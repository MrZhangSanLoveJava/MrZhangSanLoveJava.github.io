<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言基础</title>
    <url>/2025/01/16/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>和所有编程语言一样，要认识一个语言的结构得从”hello,world”开始，我们使用C语言来输出”hello,world”吧。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们初识C语言了，下面是分析。</p>
<p>**分析：**第一行是调用头文件，<code>#include</code>是C语言调用标准头文件的标准方法。<code>stdio.h</code>是标准库，调用了这个库我们才可以使用<code>printf()</code>函数</p>
<p>第二行是主函数，在C语言中可以有好多个函数，当时只能有一个<code>main</code>函数，<code>main</code>函数是程序的入口。<code>main</code>前面的是返回值类型，在好多大学中，教C语言的老师喜欢把前面的类型省略，这个叫缺省（xing），但在C语言标准里，前面的<code>int</code>是不可以去掉的。</p>
<p>第三行是函数内执行的语句，这个是一个输出函数<code>printf()</code>，它的作用是将括号里的数据输出到显示屏中，给用户查看。(具体看第一章)</p>
<p>第四行是返回值。（具体内容在函数那一章再细讲）</p>
<p>**细节：**C语言对语法要求不是那么的高，不像python一样需要严格遵循缩进，C语言需要在函数内执行的语句只需要在 <code>&#123;&#125;</code> 中即可，一行语句执行完加 <code>;</code> 即可。</p>
<p>要执行C语言的程序必须得进行编译，编译完之后才能运行，简单解释一下为什么要这么做：</p>
<p>计算机它能认识0和1这种低级语言，而我们写代码是用C语言这种高级语言来写的，但计算机不认识，必须需要一个编译器来将高级语言转换为低级语言，这样计算机就可以执行。</p>
<p>C语言编译出来的后缀为： <code>.obj</code> </p>
<p>可运行的程序的后缀为： <code>.exe</code></p>
<p><strong>这只是一个笔记，笔记主要是将重要的内容记下来，所以好多不重要的内容或者是一看就会的内容我就省略了</strong></p>
<h2 id="一、输出函数"><a href="#一、输出函数" class="headerlink" title="一、输出函数"></a>一、输出函数</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>在C语言中是没有自带的输出函数的，而是必须通过调用标准库文件才能使用输出语句，先对输入输出函数进行了解，会使你对C语言有更好的兴趣。</p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf();"></a><code>printf();</code></h3><ul>
<li>头文件：<code>stdio.h</code></li>
</ul>
<ul>
<li><p><code>printf</code>函数的功能：</p>
<p><strong>格式化输出函数</strong>，用于向标准输出设备<strong>按规定格式</strong>输出信息。 </p>
</li>
<li><p>printf函数的调用格式：</p>
<p><code>printf(&quot;格式控制字符串&quot;,输出项清单);</code></p>
<p>格式控制字符串：用于指定输出格式；由格式字符串和非格式字符串两种组成。格式字符串是以%开头的字符串。</p>
<p>输出项清单：</p>
<ul>
<li>输出项可以是常量、变量或表达式</li>
<li>要求格式字符串和各输出项在数量和类型上应该一一对应</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> m=<span class="number">123</span>,n=<span class="number">12345</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;m=%5d,n= %3d\n&quot;</span>,m,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; 变量;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>对于整形数而言，当格式控制字符规定的长度比数据本身长度还大时，则左侧补空格；若个数控制字符规定的长度比数据本身长度小时，则数据按照其本身长度进行输出。</p>
<ul>
<li><p>格式化字符串  </p>
<table>
<thead>
<tr>
<th>表示方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>以十进制形式带符号整数（正数不输出符号）</td>
</tr>
<tr>
<td>%o</td>
<td>以八进制形式输出无符号整数（默认不输出前缀0，%#o输出前缀0）</td>
</tr>
<tr>
<td>%x</td>
<td>以十六进制形式输出无符号整数（默认不输出前缀0x，%#x输出前缀0x）</td>
</tr>
<tr>
<td>%u</td>
<td>以十进制形式输出无符号整数</td>
</tr>
<tr>
<td>%f</td>
<td>以小数形式输出单、双精度实数，默认保留6位小数<br>双精度型可用%lf或%le</td>
</tr>
<tr>
<td>%e</td>
<td>以指数形式输出单、双精度实数。<strong>格式是m.ddddddexxx</strong>，默认小数精度为6，指数精度为3，不足补零（明白即可）</td>
</tr>
<tr>
<td>%g</td>
<td>以%f或%e中较短的输出单、双精度实数</td>
</tr>
<tr>
<td>%c</td>
<td>输出单个字符</td>
</tr>
<tr>
<td>%s</td>
<td>输出字符串，直到遇到\0，若<strong>字符串长度超过指定的精度则自动突破，不截断</strong></td>
</tr>
<tr>
<td>%p</td>
<td>输出变量的内存地址</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="putchar"><a href="#putchar" class="headerlink" title="putchar();"></a><code>putchar();</code></h3><h4 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h4><p>主要是用于输出字符的函数</p>
<h4 id="2-格式"><a href="#2-格式" class="headerlink" title="2.格式"></a>2.格式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> x = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//一定是字符型变量</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&quot;%c&quot;</span>, x);<span class="comment">//格式化字符串一定要%c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、输入函数"><a href="#二、输入函数" class="headerlink" title="二、输入函数"></a>二、输入函数</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf();"></a><code>scanf();</code></h3><h4 id="1-调用格式"><a href="#1-调用格式" class="headerlink" title="1.调用格式"></a>1.调用格式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//调用头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须要加取值符 <code>&amp;</code> </p>
<h4 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h4><p>将用户输入的值赋值给取值符后的变量</p>
<h3 id="getchar"><a href="#getchar" class="headerlink" title="getchar();"></a><code>getchar();</code></h3><h4 id="1-用法-1"><a href="#1-用法-1" class="headerlink" title="1.用法"></a>1.用法</h4><p>输入字符</p>
<h4 id="2-格式-1"><a href="#2-格式-1" class="headerlink" title="2.格式"></a>2.格式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    getchar(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h2><p>在C语言中有局部变量和全局变量</p>
<h3 id="1-变量的类型"><a href="#1-变量的类型" class="headerlink" title="1.变量的类型"></a>1.变量的类型</h3><h5 id="1-整型变量"><a href="#1-整型变量" class="headerlink" title="(1)整型变量"></a>(1)整型变量</h5><table>
<thead>
<tr>
<th>类型</th>
<th>储存大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td>2-4个字节</td>
<td>整型</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2字节</td>
<td>短整型</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8字节</td>
<td>长整型</td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td>2字节</td>
<td>无符号短整型</td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td>2-4字节</td>
<td>无符号整型</td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td>8字节</td>
<td>无符号长整型</td>
</tr>
</tbody></table>
<h5 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="(2)浮点型"></a>(2)浮点型</h5><table>
<thead>
<tr>
<th>类型</th>
<th>储存大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>long double</td>
<td>16字节</td>
<td>长双</td>
</tr>
</tbody></table>
<h5 id="3-字符型"><a href="#3-字符型" class="headerlink" title="(3)字符型"></a>(3)字符型</h5><table>
<thead>
<tr>
<th>类型</th>
<th>储存大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1字节</td>
<td>字符型</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1字节</td>
<td>无符号字符型</td>
</tr>
</tbody></table>
<p>说明：字符型也可以存放数字类型</p>
<h3 id="2-变量的定义"><a href="#2-变量的定义" class="headerlink" title="2.变量的定义"></a>2.变量的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">类型名 变量名 = 赋的值;</span><br><span class="line">类型名 变量名;</span><br></pre></td></tr></table></figure>

<p>两个都可以定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)变量名不能是保留字</span><br><span class="line"><span class="number">2</span>)变量名不能由数字开头</span><br><span class="line"><span class="number">3</span>)变量名只能由下划线，数字，单词组成</span><br></pre></td></tr></table></figure>



<p>注：每次定义后储存的变量一定是同种类型，负责会报错，C语言并没有字符串这个类型，如果要定义字符串需要定义字符型数组</p>
<h3 id="3-变量的转换"><a href="#3-变量的转换" class="headerlink" title="3.变量的转换"></a>3.变量的转换</h3><p>例子1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> num1 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">char</span> num2 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> num3 = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个样子是可以转的，因为 <code>char</code> 类型是1个字节，而 <code>int</code> 为4个字节是可以装的</p>
<p>例子2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">5</span>,a;</span><br><span class="line">    </span><br><span class="line">    a=<span class="number">6</span>;</span><br><span class="line">    f=a/i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,f); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果存储计算后的结果为整型，则会抛弃小数点后的数。</p>
<p>如果为浮点型，则会输出小数点后的数</p>
<h3 id="4-变量的强制转换"><a href="#4-变量的强制转换" class="headerlink" title="4.变量的强制转换"></a>4.变量的强制转换</h3><p>有些时候无法通过赋值来进行类型转换</p>
<p>所以这个时候就需要使用强制转换</p>
<h4 id="1-语法"><a href="#1-语法" class="headerlink" title="(1)语法"></a>(1)语法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(数据类型) 变量；</span><br></pre></td></tr></table></figure>

<h3 id="5-全局变量和局部变量"><a href="#5-全局变量和局部变量" class="headerlink" title="5.全局变量和局部变量"></a>5.全局变量和局部变量</h3><h4 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="(1)全局变量"></a>(1)全局变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局变量是定义在函数体外的，在函数体中没办法修改全局变量</p>
<h4 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="(2)局部变量"></a>(2)局部变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;<span class="comment">//局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、常量"><a href="#四、常量" class="headerlink" title="四、常量"></a>四、常量</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><h4 id="1-define定义"><a href="#1-define定义" class="headerlink" title="(1)define定义"></a>(1)define定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 变量名 值</span></span><br></pre></td></tr></table></figure>

<h4 id="2-const关键字"><a href="#2-const关键字" class="headerlink" title="(2)const关键字"></a>(2)<code>const</code>关键字</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> 数据类型 变量名 = 值;</span><br></pre></td></tr></table></figure>

<p><a href="#con_type"><strong>重点在存储类中</strong></a></p>
<h2 id="五、存储类"><a href="#五、存储类" class="headerlink" title="五、存储类"></a>五、存储类</h2><h3 id="1-auto"><a href="#1-auto" class="headerlink" title="1.auto"></a>1.<code>auto</code></h3><p>默认类，就是用完就释放</p>
<p>可写可不写</p>
<h3 id="2-register"><a href="#2-register" class="headerlink" title="2.register"></a>2.<code>register</code></h3><p>感觉没什么用</p>
<p>官方解释说是可以提高运算速度，但现在的CPU运算速度都很快，所以没什么用</p>
<h3 id="3-static"><a href="#3-static" class="headerlink" title="3.static"></a>3.<code>static</code></h3><p>和 <code>auto</code> 是反过来的，使用完它并不会释放</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    count();</span><br><span class="line">    count();</span><br><span class="line">    count();</span><br><span class="line">    count();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-const"><a href="#4-const" class="headerlink" title="4.const"></a>4.<code>const</code><a name="con_type"></a></h3><p>const 是将变量中的值固定，使得变量无法被修改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cconst%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E4%BF%AE%E6%94%B9%E5%80%BC.png" alt="修改失败"></p>
<p>但是在vs编辑器中是可以通过指针来修改被const修改的值的</p>
<p>如下</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cvs2019%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E6%9D%A5%E4%BF%AE%E6%94%B9%E8%A2%ABconst%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%80%BC.png" alt="vs2019可以通过指针来修改被const修饰变量中的值"></p>
<p>运行结果</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="运行结果"></p>
<p>在dev-c++中就无法使用这个办法进行修改</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cdev-c++%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%9D%A5%E4%BF%AE%E6%94%B9%E8%A2%ABconst%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%80%BC.png" alt="笔记图片\dev-c++中无法使用指针来修改被const修饰变量中的值.png"></p>
<h2 id="六、C语言编程结构"><a href="#六、C语言编程结构" class="headerlink" title="六、C语言编程结构"></a>六、C语言编程结构</h2><p>在所有编程语言中有着三种结构：顺序结构，选择结构，循环结构，循序结构</p>
<h3 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1.顺序结构"></a>1.顺序结构</h3><p>顺序结构是编程语言中最基础的一种结构，计算机不像人的思维，它得到代码后它没有办法自己行进跳转(有选择和分支除外)，它只能一条一条的执行，一条一条执行的情况就是顺序结构，如下代码</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81.png"></p>
<p>它的执行情况如下</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6这样执行的。</p>
<p>这种执行是非常简单也很基础，但没有办法做一些逻辑很强的程序，所以我们引入了选择结构。</p>
<h3 id="2-选择结构"><a href="#2-选择结构" class="headerlink" title="2.选择结构"></a>2.选择结构</h3><p>在介绍选择结构前先介绍逻辑判断语句。</p>
<h4 id="2-1-逻辑判断"><a href="#2-1-逻辑判断" class="headerlink" title="2.1 逻辑判断"></a>2.1 逻辑判断</h4><p>在C语言中0表示假，1表示真</p>
<table>
<thead>
<tr>
<th>关系符</th>
<th>a1</th>
<th>a2</th>
<th>结果(a1)  (a2)</th>
</tr>
</thead>
<tbody><tr>
<td>||  逻辑或 or</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>||</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>||</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>&amp;&amp;   逻辑与  and</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>然后还有一个逻辑是 <code>!</code> 逻辑非</p>
<table>
<thead>
<tr>
<th>a1</th>
<th>a1!</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>补充</strong>：在c语言中还有一个对于二进制的逻辑表达式</p>
<p><code>|</code> ：二进制或</p>
<p><code>&amp;</code> ：二进制与</p>
<p><code>^</code> ：二进制异或</p>
<p><code>~</code>：二进制非</p>
<h4 id="2-2-逻辑判断"><a href="#2-2-逻辑判断" class="headerlink" title="2.2 逻辑判断"></a>2.2 逻辑判断</h4><p>两个数之间判断大小，如果成立则值等于1，如果不成立则等于0。</p>
<p>但在C语言中，只能两个数之间相比，不能多个</p>
<p>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a &gt; b;</span><br></pre></td></tr></table></figure>

<p>是可以的，但下面的是绝对不可以</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a &gt; b &gt; c;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-1-三元运算符"><a href="#2-3-1-三元运算符" class="headerlink" title="2.3.1 三元运算符"></a>2.3.1 三元运算符</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> max = (a&gt;b)?a:b;</span><br></pre></td></tr></table></figure>

<p>如果a&gt;b成立，则结果为a，否则返回b</p>
<h4 id="2-3-判断语句"><a href="#2-3-判断语句" class="headerlink" title="2.3 判断语句"></a>2.3 判断语句</h4><h5 id="2-3-1-if语句"><a href="#2-3-1-if语句" class="headerlink" title="2.3.1 if语句"></a>2.3.1 if语句</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">    <span class="comment">//成立后执行花括号里的语句</span></span><br><span class="line">    执行<span class="number">1</span>;</span><br><span class="line">    执行<span class="number">2</span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-else语句"><a href="#2-3-2-else语句" class="headerlink" title="2.3.2 else语句"></a>2.3.2 else语句</h5><p>else语句是可以没有判断条件的，但必须有执行语句</p>
<h5 id="2-3-3-else-if"><a href="#2-3-3-else-if" class="headerlink" title="2.3.3 else if"></a>2.3.3 else if</h5><p>用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">    <span class="comment">//成立后执行花括号里的语句</span></span><br><span class="line">    执行<span class="number">1</span>;</span><br><span class="line">    执行<span class="number">2</span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (判断条件)&#123;</span><br><span class="line">    <span class="comment">//成立后执行花括号里的语句</span></span><br><span class="line">    执行<span class="number">1</span>;</span><br><span class="line">    执行<span class="number">2</span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-4-注意"><a href="#2-3-4-注意" class="headerlink" title="2.3.4 注意"></a>2.3.4 注意</h5><p>在if语句里可以有也可以没有else、else if语句，但必须要有if语句</p>
<h5 id="2-3-5-switch"><a href="#2-3-5-switch" class="headerlink" title="2.3.5 switch"></a>2.3.5 switch</h5><p>switch是单个判断的语句</p>
<p>语法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:语句<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>:语句<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">3</span>:语句<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">default</span> : 语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这个语句执行会一直</p>
<p>例如</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cswitch%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81.png"></p>
<p>然后输出的结果如下</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cswitch%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>它第一个条件判断成功了，但它却继续执行下面的输出代码。</p>
<p>所以我们会在后面添加一个 <code>break</code> 使它判断成功后执行玩就结束。</p>
<p>如下：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%8A%A0%E4%BA%86break%E7%9A%84switch%E8%AF%AD%E5%8F%A5.png"></p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png"></p>
<h5 id="2-3-6-switch判断范围问题"><a href="#2-3-6-switch判断范围问题" class="headerlink" title="2.3.6 switch判断范围问题"></a>2.3.6 switch判断范围问题</h5><p>在C语言中，一些时候可以用if-else来判断范围问题，有些时候也可以使用switch来判断范围问题。</p>
<p>使用switch的思路是将个个范围的数化为一个特定的数，然后使用switch语句进行判断。</p>
<p>例如：我们需要计算每个销售数段获得的提成的题目</p>
<p>我们使用if-else语句的写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你总共销售额(单位:万):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">100</span> &lt; a &amp;&amp; a &lt;=<span class="number">120</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.02</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">120</span> &lt; a &amp;&amp; a &lt;= <span class="number">140</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.05</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">140</span> &lt; a &amp;&amp; a &lt;= <span class="number">190</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.08</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">190</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有提成&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if-else的写法是非常的简单，但是，如果使用switch来改写这个if-else就有点困难，所以我们要有将范围变成具体的数的思路，然后通过数来进行判断。</p>
<p>switch改写的第一种方法：</p>
<p>我们知道，在C语言中进行的是逻辑判断，通过逻辑判断的出来的只能是或则是，所以我们可以在外部对输入的数进行逻辑判断，然后再乘以具体的1，2，3，因为如果成立则为1，不成立则为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, max;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    max = ((a &gt; <span class="number">100</span>)&amp;&amp;(a&lt;=<span class="number">120</span>)) + <span class="number">2</span>*((a&gt;<span class="number">120</span>)&amp;&amp;(a&lt;=<span class="number">140</span>)) + <span class="number">3</span>*((a&gt;<span class="number">140</span>)&amp;&amp;(a&lt;=<span class="number">190</span>)) + <span class="number">4</span>*(a&gt;<span class="number">190</span>);</span><br><span class="line">    <span class="keyword">switch</span>(max)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.02</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.05</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.08</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有提成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-循环结构"><a href="#2-4-循环结构" class="headerlink" title="2.4 循环结构"></a>2.4 循环结构</h4><p>循环结构可以让你完成一件重复的事情而不写多条代码</p>
<p>例如，我们要输出100次“hello，world”，完成这件事需要写100次printf函数和100次“hello，world”，这样子是很麻烦的，但如果有循环结构，那我们就可以很轻松的完成这个程序了。</p>
<h5 id="2-4-1-for循环"><a href="#2-4-1-for循环" class="headerlink" title="2.4.1 for循环"></a>2.4.1 for循环</h5><p>for循环是编程语言中最简单的循环了，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化值; 循环条件; 值的操作)&#123;</span><br><span class="line">    循环体<span class="number">1</span>;</span><br><span class="line">    循环体<span class="number">2</span>;</span><br><span class="line">    循环体<span class="number">3</span>;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入for循环先初始化值，然后判断循环条件，满足条件后运行循环体中的值，运行完之后执行值的操作。重复运行直到不满足循环条件为止。</p>
<p>注意：学过Java的可能会这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fot(<span class="type">int</span> i = <span class="number">0</span>; ;)</span><br></pre></td></tr></table></figure>

<p>虽然C99可以这样写，但是在C语言中并不能这样写</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-12.png"></p>
<p>这个标准只能在C++文件中这么使用</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-13.png"></p>
<h5 id="2-4-2-while循环"><a href="#2-4-2-while循环" class="headerlink" title="2.4.2 while循环"></a>2.4.2 while循环</h5><p>while循环相对于for循环要简单一点，因为只有一个判断条件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (判断条件)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入循环然后判断是否满足判断条件，如果满足则加入循环体内。</p>
<h5 id="2-4-3-do-while循环"><a href="#2-4-3-do-while循环" class="headerlink" title="2.4.3 do while循环"></a>2.4.3 do while循环</h5><p>do while循环增加了一个do语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;执行语句&#125;</span><br><span class="line"><span class="keyword">while</span>(判断条件);</span><br></pre></td></tr></table></figure>

<p>先执行do语句内，然后判断是否满足条件，如果满足则继续执行do中的语句。</p>
<p>如果不满足则跳出。</p>
<p>相比于while循环，do while是可以执行一次的。</p>
<h5 id="2-4-4-嵌套循环"><a href="#2-4-4-嵌套循环" class="headerlink" title="2.4.4 嵌套循环"></a>2.4.4 嵌套循环</h5><p>简单来说就是循环里套循环，这里借用菜鸟教程的流程图</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E8%8F%9C%E9%B8%9F%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h5 id="2-4-5-break和continue"><a href="#2-4-5-break和continue" class="headerlink" title="2.4.5 break和continue"></a>2.4.5 break和continue</h5><h6 id="break"><a href="#break" class="headerlink" title="break"></a>break</h6><p>break是直接跳出当前循环体</p>
<h6 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h6><p>continue是跳过一次</p>
<h2 id="七、数组"><a href="#七、数组" class="headerlink" title="七、数组"></a>七、数组</h2><h3 id="1-一维数组的创建和初始化"><a href="#1-一维数组的创建和初始化" class="headerlink" title="1.一维数组的创建和初始化"></a>1.一维数组的创建和初始化</h3><h4 id="1-1-数组的创建"><a href="#1-1-数组的创建" class="headerlink" title="1.1 数组的创建"></a>1.1 数组的创建</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态创建</span></span><br><span class="line">类型 变量名[数组的长度(必须是常量)];</span><br><span class="line"><span class="comment">//静态创建</span></span><br><span class="line">类型 变量名[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//不完全初始化</span></span><br><span class="line">类型 变量名[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>不完全初始化，剩下的元素默认为0</p>
<h4 id="1-2-数组的索引取值"><a href="#1-2-数组的索引取值" class="headerlink" title="1.2 数组的索引取值"></a>1.2 数组的索引取值</h4><p>下标从0开始</p>
<p>例子1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> x[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(x); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(str)/<span class="keyword">sizeof</span>(str[<span class="number">0</span>])); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-二维数组的创建和初始化"><a href="#2-二维数组的创建和初始化" class="headerlink" title="2.二维数组的创建和初始化"></a>2.二维数组的创建和初始化</h3><h4 id="2-1数组的创建"><a href="#2-1数组的创建" class="headerlink" title="2.1数组的创建"></a>2.1数组的创建</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x[][数组的长度(必须是常量)] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[数组的长度(必须是常量)][数组的长度(必须是常量)];</span><br></pre></td></tr></table></figure>

<p>二维数组必须初始化行，可以省略列</p>
<h4 id="2-2-二维数组的使用"><a href="#2-2-二维数组的使用" class="headerlink" title="2.2 二维数组的使用"></a>2.2 二维数组的使用</h4><p>一样使用索引值</p>
<h4 id="2-3-数组的地址"><a href="#2-3-数组的地址" class="headerlink" title="2.3 数组的地址"></a>2.3 数组的地址</h4><p>数组的地址一般都是第一个元素的地址值，之后的地址就是首地址加字节数</p>
<p>注意：有两种情况不是数组的首地址</p>
<p>1.sizeof(数组名) - 数组名表示整个数组，sizeof(数组名)计算的是整个数组的大小，单位是字节</p>
<p>2.&amp;数组名，数组名代表的是整个数组。&amp;数组名，取出的是整个数组的地址</p>
<h3 id="3-数组传入函数中"><a href="#3-数组传入函数中" class="headerlink" title="3.数组传入函数中"></a>3.数组传入函数中</h3><p>我们在使用数组的时候，可能会把数组放入函数中进行数据清洗，所以数组如何传入函数就需要说明一下。</p>
<h4 id="3-1-将整个函数复制到函数中使用"><a href="#3-1-将整个函数复制到函数中使用" class="headerlink" title="3.1 将整个函数复制到函数中使用"></a>3.1 将整个函数复制到函数中使用</h4><p>第一种传参的方式是将数组中的所有元素拷贝一份到函数中使用</p>
<p>写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是将数组的地址放入函数中定义的数组中，然后使用里面的元素</p>
<h4 id="3-2-将数组的地址传入函数中使用"><a href="#3-2-将数组的地址传入函数中使用" class="headerlink" title="3.2 将数组的地址传入函数中使用"></a>3.2 将数组的地址传入函数中使用</h4><p>这种方式是将数组的地址传入函数中提供，这种方式需要的内存小，推荐使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(pa + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法相对于只是把数组的地址传入到函数中使用，没有额外创建新的空间。</p>
<h4 id="3-3-数组指针来使用"><a href="#3-3-数组指针来使用" class="headerlink" title="3.3 数组指针来使用"></a>3.3 数组指针来使用</h4><p>这个需要等到C语言进阶中才会学到</p>
<h2 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h2><p>在C语言中，有一个或多个函数，我们最熟悉的main()就是一个函数。</p>
<p>函数的作用是将需要反复使用的代码包含在一起，使我们使用更方便。</p>
<h3 id="1-函数的定义"><a href="#1-函数的定义" class="headerlink" title="1.函数的定义"></a>1.函数的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_type <span class="title function_">def_name</span> <span class="params">(value1, value2,...)</span>&#123;</span><br><span class="line">    body of the function;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return_type：返回值的类型</p>
<p>def_name：函数名</p>
<p>value1：形参，如果有多个用英文逗号分开</p>
<p>body of the function：函数体，函数中执行的内容</p>
<p>value：返回值</p>
<h4 id="1-1-返回指针类型的函数"><a href="#1-1-返回指针类型的函数" class="headerlink" title="1.1 返回指针类型的函数"></a>1.1 返回指针类型的函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_type* <span class="title function_">def_name</span><span class="params">(value1, value2,...)</span>&#123;</span><br><span class="line">    body of the function;</span><br><span class="line">    <span class="keyword">return</span> value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value1：为返回的地址</p>
<h3 id="2-函数的使用"><a href="#2-函数的使用" class="headerlink" title="2.函数的使用"></a>2.函数的使用</h3><h4 id="2-1-有返回值的函数的使用"><a href="#2-1-有返回值的函数的使用" class="headerlink" title="2.1 有返回值的函数的使用"></a>2.1 有返回值的函数的使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type variable = def_name(user_value1,user_value2,...);</span><br></pre></td></tr></table></figure>

<p>type：数据类型</p>
<p>variable：变量</p>
<p>user_value1：传入的参数，如果有多个用英文逗号隔开</p>
<h4 id="2-2-无返回值的函数的使用"><a href="#2-2-无返回值的函数的使用" class="headerlink" title="2.2 无返回值的函数的使用"></a>2.2 无返回值的函数的使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def_name(user_value1,user_value2,...);</span><br></pre></td></tr></table></figure>

<p>variable：变量</p>
<p>user_value1：传入的参数，如果有多个用英文逗号隔开</p>
<h3 id="3-函数的形参和实参"><a href="#3-函数的形参和实参" class="headerlink" title="3.函数的形参和实参"></a>3.函数的形参和实参</h3><p>函数的形参可以传入变量和指针，而两种方式需要的内存是不一样的</p>
<h4 id="3-1-函数的形参传入的是变量"><a href="#3-1-函数的形参传入的是变量" class="headerlink" title="3.1 函数的形参传入的是变量"></a>3.1 函数的形参传入的是变量</h4><p>这个很容易理解，就是在调用的时候传入的是变量的形式，如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    test(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是把a和b的变量传入到函数test中，然后在test中将传入进来的a，b拷贝下来，这样的话需要更多的空间给a，b，非常的消耗空间。</p>
<h4 id="3-2-函数的形参传入的是指针"><a href="#3-2-函数的形参传入的是指针" class="headerlink" title="3.2 函数的形参传入的是指针"></a>3.2 函数的形参传入的是指针</h4><p>这个是给函数传入指针变量，如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    test(&amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是直接把地址传入到函数里，在函数里只使用传入进去的地址，这样对内存的使用比较小，推荐使用。</p>
<h3 id="4-函数的返回值"><a href="#4-函数的返回值" class="headerlink" title="4.函数的返回值"></a>4.函数的返回值</h3><p>我们在使用函数的时候，有些时候是需要返回一些特定的值的，这个时候我们就需要让函数有返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> 返回的值;</span><br></pre></td></tr></table></figure>

<p>返回的值一定要和对应的类型相同，这样是规范的写法，如果不同，只要储存的大小合适则还是能运行的。</p>
<p>返回的值也可以是指针类型的</p>
<h2 id="九、指针"><a href="#九、指针" class="headerlink" title="九、指针"></a>九、指针</h2><h3 id="1-什么是指针"><a href="#1-什么是指针" class="headerlink" title="1.什么是指针"></a>1.什么是指针</h3><p>指针是编程语言中的一个对象，是将内存的地址赋值给指针变量。</p>
<p>它的值直接指向存在电脑存储器中另一个储存单元</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指针其实是地址</span><br><span class="line">地址就是变量</span><br><span class="line">指针就是变量</span><br><span class="line">存放地址的变量</span><br></pre></td></tr></table></figure>

<ul>
<li>指针是用于存放地址的，地址是唯一表示一块地址空间的</li>
<li>指针的大小在32位平台是4个字节，在64位平台上是8个字节</li>
</ul>
<p>指针类型决定了指针进行解引用操作的时候，能够访问空间的大小</p>
<p><code>int *p</code> 能够访问4个字节</p>
<p><code>char *p</code> 能够访问1个字节</p>
<p><code>double *p</code> 能够访问8个字节</p>
<p>指针类型决定了：指针走一步走多远（指针的步长）</p>
<p><code>int *p; --&gt; 4</code></p>
<p><code>char *p; --&gt; 1 </code></p>
<p><code>double *p; --&gt; 8</code></p>
<p>总结：指针的类型决定了指针向前或向后走一步有多大（距离）</p>
<h3 id="2-指针的使用"><a href="#2-指针的使用" class="headerlink" title="2.指针的使用"></a>2.指针的使用</h3><h4 id="（1）指针的定义"><a href="#（1）指针的定义" class="headerlink" title="（1）指针的定义"></a>（1）指针的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(指针类型) *(指针名);</span><br><span class="line"><span class="comment">//变量方式</span></span><br><span class="line">(指针类型) *(指针名) = &amp;变量名;</span><br><span class="line"><span class="comment">//数组方式</span></span><br><span class="line">(指针类型) *(指针名) = 数组名;</span><br></pre></td></tr></table></figure>

<h4 id="（2）指针的赋值"><a href="#（2）指针的赋值" class="headerlink" title="（2）指针的赋值"></a>（2）指针的赋值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指针名 = &amp;变量名;</span><br></pre></td></tr></table></figure>

<h4 id="（3）指针类型"><a href="#（3）指针类型" class="headerlink" title="（3）指针类型"></a>（3）指针类型</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="type">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="type">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="type">char</span>   *ch;    <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* 访问<span class="number">4</span>个字节</span><br><span class="line"><span class="type">float</span>* 访问<span class="number">4</span>个字节</span><br><span class="line"><span class="type">char</span>* 访问<span class="number">1</span>个字节</span><br><span class="line"><span class="type">double</span>* 访问<span class="number">8</span>个字节</span><br></pre></td></tr></table></figure>

<h4 id="（4）如何使用指针"><a href="#（4）如何使用指针" class="headerlink" title="（4）如何使用指针"></a>（4）如何使用指针</h4><h3 id="3-野指针"><a href="#3-野指针" class="headerlink" title="3.野指针"></a>3.野指针</h3><p>概念：野指针就是指向的位置不可知的</p>
<h4 id="（1）导致野指针的原因"><a href="#（1）导致野指针的原因" class="headerlink" title="（1）导致野指针的原因"></a>（1）导致野指针的原因</h4><p>① 未初始化指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②指针越界访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *p = arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//当指针指向的范围超出数组arr的范围时，p就是野指针</span></span><br><span class="line">        *(p + i) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③指针指向的空间释放</p>
<h4 id="（2）如何避免野指针"><a href="#（2）如何避免野指针" class="headerlink" title="（2）如何避免野指针"></a>（2）如何避免野指针</h4><p>①指针初始化</p>
<p>②小心指针越界</p>
<p>③指针指向空间释放即用null占位</p>
<p>④指针使用之前检查有效性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// int a = 10;</span></span><br><span class="line">    <span class="comment">// int *p = &amp;a;//初始化</span></span><br><span class="line">    <span class="comment">// int *pa = NULL;//NULL - 用来初始化指针的，给指针赋值</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *pa = &amp;a;</span><br><span class="line">    *pa = <span class="number">20</span>;</span><br><span class="line">    pa = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pa != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *pa = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-指针运算"><a href="#4-指针运算" class="headerlink" title="4.指针运算"></a>4.指针运算</h3><ul>
<li>指针+-整数</li>
<li>指针-指针</li>
<li>指针的关系运算</li>
</ul>
<h4 id="指针-整数"><a href="#指针-整数" class="headerlink" title="指针+-整数"></a>指针+-整数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> *p = &amp;arr[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">        p--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针-指针"><a href="#指针-指针" class="headerlink" title="指针-指针"></a>指针-指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *start = str;</span><br><span class="line">    <span class="type">char</span> *end = str;</span><br><span class="line">    <span class="keyword">while</span> (*end != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end - start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//strlen - 求字符串长度</span></span><br><span class="line">    <span class="type">char</span> arr[] = <span class="string">&quot;bit&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = my_strlen(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针-指针可以得到这个数组的长度 - 1 </p>
<h3 id="5-指针和数组"><a href="#5-指针和数组" class="headerlink" title="5.指针和数组"></a>5.指针和数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);<span class="comment">//地址-首元素的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr);<span class="comment">//整个数组的地址</span></span><br><span class="line">    <span class="comment">//1.&amp;arr - &amp;数组名不是首元素的地址-数组名表示整个数组 - &amp;数组名 取出的是整个数组的地址</span></span><br><span class="line">    <span class="comment">//2.sizeof(arr) - sizeof(数组名) - 数组名表示的整个数组 - sizeof(数组名)计算的是整个数组的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：数组名表示的是数组首元素的地址</p>
<p><strong>注意：数组可以使用[]来修饰，但是指针使用[]来修饰</strong></p>
<h3 id="6-指针的关系运算"><a href="#6-指针的关系运算" class="headerlink" title="6.指针的关系运算"></a>6.指针的关系运算</h3><h4 id="（1）指针数组-数组指针"><a href="#（1）指针数组-数组指针" class="headerlink" title="（1）指针数组 &amp;&amp; 数组指针"></a>（1）指针数组 &amp;&amp; 数组指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指针数组 - 数组 - 存放指针的数组</span></span><br><span class="line"><span class="comment">//数组指针 - 指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b =<span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// int *pa = &amp;a;</span></span><br><span class="line">    <span class="comment">// int *pb = &amp;b;</span></span><br><span class="line">    <span class="comment">// int *pc = &amp;c;</span></span><br><span class="line">    <span class="comment">//整型数组 - 存放整型</span></span><br><span class="line">    <span class="comment">//字符数组 - 存放字符</span></span><br><span class="line">    <span class="comment">//指针数组 - 存放指针</span></span><br><span class="line">    <span class="type">int</span> *arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;<span class="comment">//指针数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-二级指针"><a href="#7-二级指针" class="headerlink" title="7.二级指针"></a>7.二级指针</h3><h4 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *pa = &amp;a;</span><br><span class="line">    <span class="type">int</span> **ppa = &amp;pa;<span class="comment">//ppa就是二级指针</span></span><br><span class="line">    <span class="comment">//int ***pppa = &amp;ppa;//pppa是三级指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）使用"><a href="#（2）使用" class="headerlink" title="（2）使用"></a>（2）使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *pa = &amp;a;</span><br><span class="line">    <span class="type">int</span> **ppa = &amp;pa;<span class="comment">//ppa就是二级指针</span></span><br><span class="line">    <span class="comment">//int ***pppa = &amp;ppa;//pppa是三级指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *ppa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, **ppa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）总结"><a href="#（3）总结" class="headerlink" title="（3）总结"></a>（3）总结</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>这句话的意思是将a的地址给p，然后*p得到的是a中的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ppa = &amp;pa;</span><br></pre></td></tr></table></figure>

<p><em>ppa存放的是pa指针中的地址，然后**ppa是</em>pa</p>
<h3 id="8-const修饰指针（一级指针）"><a href="#8-const修饰指针（一级指针）" class="headerlink" title="8.const修饰指针（一级指针）"></a>8.const修饰指针（一级指针）</h3><p>通常，我们的指针变量是可以随便使用的，但如果我们想让指针变量或者解引用的指针的内容不改变，那我们就需要使用 <code>const</code> 来修饰指针。</p>
<h4 id="8-1-const-在-左边"><a href="#8-1-const-在-左边" class="headerlink" title="8.1 const 在 * 左边"></a>8.1 const 在 * 左边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> * p;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p;</span><br></pre></td></tr></table></figure>

<p>const 在* 左边是修饰 *p的，通过这样修饰后，*p就不能再重新赋值了，*p的值是被固定了，但是指针变量p中的地址是可以重新赋值的。</p>
<h4 id="8-2-const-在-右边"><a href="#8-2-const-在-右边" class="headerlink" title="8.2 const 在 * 右边"></a>8.2 const 在 * 右边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<p>const 在* 右边是修饰 p的，通过这样修饰后，p就不能再重新赋值了，\p的值是被固定了，但是解引用*p中的值是可以重新赋值的。</p>
<h3 id="9-const修饰指针（二级指针）"><a href="#9-const修饰指针（二级指针）" class="headerlink" title="9.const修饰指针（二级指针）"></a>9.const修饰指针（二级指针）</h3><p>在二级指针中有三个位置可以加const修饰符</p>
<h4 id="9-1-在-的左边"><a href="#9-1-在-的左边" class="headerlink" title="9.1 在**的左边"></a>9.1 在**的左边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* *p;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * *p;</span><br></pre></td></tr></table></figure>

<p>const在**的左边是修饰**p的，但*p和p的值是可以改变的</p>
<h4 id="9-2-在-中间"><a href="#9-2-在-中间" class="headerlink" title="9.2 在**中间"></a>9.2 在**中间</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> *p;</span><br></pre></td></tr></table></figure>

<p>const在**的中间是修饰*p的，但**p和p的值是可以改变的</p>
<h4 id="9-3-在-的右边"><a href="#9-3-在-的右边" class="headerlink" title="9.3 在**的右边"></a>9.3 在**的右边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* *<span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<p>const在**的右边是修饰p的，但**p和*p的值是可以改变的</p>
<h4 id="9-4-通过二级指针修改被const修饰的一级指针"><a href="#9-4-通过二级指针修改被const修饰的一级指针" class="headerlink" title="9.4 通过二级指针修改被const修饰的一级指针"></a>9.4 通过二级指针修改被const修饰的一级指针</h4><p>我们回顾上面讲const修饰符中，别const修饰的变量中的值能被一级指针所修改，那如果别const修改的一级指针能否别二级指针修改呢。</p>
<p>我们来试试：</p>
<p>我们有以下的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">5</span>, n = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p = &amp;m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个语句中，const是修饰指针变量p的，所以我们无法对p变量进行修改。（如下图）</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E8%A2%ABconst%E4%BF%AE%E9%A5%B0%E7%9A%84%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88.png"></p>
<p>但是如果我们通过二级指针来间接修改呢？</p>
<p>如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">5</span>, n = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p = &amp;m;</span><br><span class="line">    <span class="type">int</span>* *pp = &amp;pm;</span><br><span class="line">    *pp = &amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>我们声明了一个二级指针，然后给这个二级指针赋值一级指针的地址，然后我们对二级指针变量重新赋n的地址值，然后输出*p里面的内容。</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%9C%A8vs%E9%87%8C%E9%80%9A%E8%BF%87%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9const%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E4%BB%A3%E7%A0%81.png"></p>
<p>然后运行的结果：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%9C%A8vs%E9%87%8C%E9%80%9A%E8%BF%87%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9const%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>我们可以看到，我们输出*p的结果已经改变，所以可以通过二级指针来修改被const修饰的一级指针的值。但是，这个方法只能在vs中才能运行成功，在dev-C++中就不能成功。如下图：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%9C%A8dev%E9%87%8C%E9%80%9A%E8%BF%87%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9const%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E4%BB%A3%E7%A0%81.png"></p>
<p>可以看到这个直接就报错了，无法通过编译。</p>
<h2 id="十、结构体"><a href="#十、结构体" class="headerlink" title="十、结构体"></a>十、结构体</h2><p>在C语言中，结构是另一种用户自定义的可用数据类型，它允许您存储不同的数据类型，结构体是属于自定义数据结构。</p>
<h3 id="1-结构体的创建"><a href="#1-结构体的创建" class="headerlink" title="1.结构体的创建"></a>1.结构体的创建</h3><h4 id="1-1-第一种方法"><a href="#1-1-第一种方法" class="headerlink" title="1.1 第一种方法"></a>1.1 第一种方法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span></span><br><span class="line">    type name;</span><br><span class="line">    type name;</span><br><span class="line">    .........</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>tag</strong> 是结构体标签</p>
<p><strong>type</strong> 数据类型</p>
<p><strong>name</strong> 类型名字</p>
<h4 id="1-2-第二种方法"><a href="#1-2-第二种方法" class="headerlink" title="1.2 第二种方法"></a>1.2 第二种方法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span></span><br><span class="line">    type name;</span><br><span class="line">    type name;</span><br><span class="line">    .........</span><br><span class="line">&#125;tags;</span><br></pre></td></tr></table></figure>

<p>结尾后的<strong>tags</strong> 是结构的变量，是全局变量，也可以多指很多结构变量。</p>
<h4 id="1-3-全局结构体和局部结构体的声明"><a href="#1-3-全局结构体和局部结构体的声明" class="headerlink" title="1.3 全局结构体和局部结构体的声明"></a>1.3 全局结构体和局部结构体的声明</h4><p>全局结构体的声明是声明在函数外，局部结构体是声明在函数内。</p>
<h3 id="2-结构体的使用"><a href="#2-结构体的使用" class="headerlink" title="2.结构体的使用"></a>2.结构体的使用</h3><h4 id="2-1-局部结构体的声明-初始化"><a href="#2-1-局部结构体的声明-初始化" class="headerlink" title="2.1 局部结构体的声明 &amp; 初始化"></a>2.1 局部结构体的声明 &amp; 初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> <span class="title">new_name</span> =</span> &#123;value1, value2, &#123;value3, value4&#125;, .....&#125;;  </span><br></pre></td></tr></table></figure>

<p><code>new_name</code> 声明的新名字</p>
<p><code>value</code> 声明的值，如果有多个值，需要使用{}括起来</p>
<p>value前面要有类型</p>
<h5 id="2-1-1-指针方法"><a href="#2-1-1-指针方法" class="headerlink" title="2.1.1 指针方法"></a>2.1.1 指针方法</h5><p>指针声明方法必须先对结构体进行声明，然后才能用指针声明</p>
<p>例一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> arr1[<span class="number">5</span>];</span><br><span class="line">        <span class="type">char</span> arr2[<span class="number">5</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span> =</span> &#123;<span class="number">1</span>, &#123;<span class="number">4</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>* <span class="title">pb</span> =</span> &amp;book;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>struct Books book &#x3D; {1, {4, 3}, {‘g’, ‘a’}}; </p>
<p>struct Books* pb &#x3D; &book; </p>
</blockquote>
<p>这个就是结构体的声明指针方法</p>
<h4 id="2-2-全局结构体全局的使用-初始化"><a href="#2-2-全局结构体全局的使用-初始化" class="headerlink" title="2.2 全局结构体全局的使用 &amp; 初始化"></a>2.2 全局结构体全局的使用 &amp; 初始化</h4><p>和局部结构体的声明和初始化一样</p>
<h3 id="3-结构体的输出"><a href="#3-结构体的输出" class="headerlink" title="3.结构体的输出"></a>3.结构体的输出</h3><h4 id="3-1-使用结构体变量的输出"><a href="#3-1-使用结构体变量的输出" class="headerlink" title="3.1 使用结构体变量的输出"></a>3.1 使用结构体变量的输出</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">结构体声明的变量 . 结构体中的值</span><br></pre></td></tr></table></figure>

<p>使用如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span>;</span></span><br><span class="line">    book.a = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, book.a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-使用指针变量的输出"><a href="#3-2-使用指针变量的输出" class="headerlink" title="3.2 使用指针变量的输出"></a>3.2 使用指针变量的输出</h4><h5 id="3-2-1-第一种方法"><a href="#3-2-1-第一种方法" class="headerlink" title="3.2.1 第一种方法"></a>3.2.1 第一种方法</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">指针变量 -&gt; 结构体中的值</span><br></pre></td></tr></table></figure>

<p>使用如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>* <span class="title">pb</span> =</span> &amp;b;</span><br><span class="line">    pb -&gt; a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, pb -&gt; a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2第二种方法"><a href="#3-2-2第二种方法" class="headerlink" title="3.2.2第二种方法"></a>3.2.2第二种方法</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(*指针变量) . 结构体中的值</span><br></pre></td></tr></table></figure>

<p>使用如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>* <span class="title">pb</span> =</span> &amp;b;</span><br><span class="line">    (*pb).a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (*pb).a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-结构体做函数的参数-结构体指针做函数的参数"><a href="#4-结构体做函数的参数-结构体指针做函数的参数" class="headerlink" title="4.结构体做函数的参数 &amp; 结构体指针做函数的参数"></a>4.结构体做函数的参数 &amp; 结构体指针做函数的参数</h3><h4 id="4-1结构体变量做参数"><a href="#4-1结构体变量做参数" class="headerlink" title="4.1结构体变量做参数"></a>4.1结构体变量做参数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Books b)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%c&quot;</span>, b.a, b.name[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span> =</span> &#123;<span class="number">5</span>, &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;&#125;;</span><br><span class="line">    Print(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2结构体指针做参数"><a href="#4-2结构体指针做参数" class="headerlink" title="4.2结构体指针做参数"></a>4.2结构体指针做参数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Books* b)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%c&quot;</span>, b-&gt;a, b-&gt;name[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span> =</span> &#123;<span class="number">5</span>, &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;&#125;;</span><br><span class="line">    Print(&amp;book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-两种定义在内存中的模式"><a href="#4-3-两种定义在内存中的模式" class="headerlink" title="4.3 两种定义在内存中的模式"></a>4.3 两种定义在内存中的模式</h4><p>4.1的方式是在函数中将变量又重新拷贝一份，占用更多的空间，而且用完就会被释放，不能修改结构体内的值；而4.2的方法是将结构体的地址放入函数里，函数操作地址，内存的占用非常的少，能直接修改函数体内的值。</p>
<h2 id="十一、debug和release方法"><a href="#十一、debug和release方法" class="headerlink" title="十一、debug和release方法"></a>十一、debug和release方法</h2><h3 id="1-debug"><a href="#1-debug" class="headerlink" title="1.debug"></a>1.debug</h3><p>debug方法是提供给程序员调试的方法。调试时会生成很多配置文件。不会做任何优化</p>
<h3 id="2-release"><a href="#2-release" class="headerlink" title="2.release"></a>2.release</h3><p>release是提供用户使用的</p>
<h2 id="十二、文件操作"><a href="#十二、文件操作" class="headerlink" title="十二、文件操作"></a>十二、文件操作</h2><p>在C语言中可以很简单的打开文件进行一些操作，这里主要是在Windows环境下使用标准输入输出库函数的对文件操作。</p>
<h3 id="1-文件打开"><a href="#1-文件打开" class="headerlink" title="1.文件打开"></a>1.文件打开</h3><p>对文件操作的基础是将文件打开，如果不打开文件就没办法对文件中的内容进行操作。</p>
<p>文件打开的方法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* <span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * __restrict__ _Filename,<span class="type">const</span> <span class="type">char</span> * __restrict__ _Mode)</span></span><br></pre></td></tr></table></figure>

<p>第一个参数是你需要打开文件的路径，这里的路径可以是绝对路径或者是相对路径。</p>
<p>第二个参数是打开文件的方式，有下面几种方式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>只读方式</td>
</tr>
<tr>
<td>w</td>
<td>写入文件，如果文件不存在会创建出一个文件，如果文件中有内容会删除里面的内容</td>
</tr>
<tr>
<td>a</td>
<td>追加模式，如果文件不存在会创建出一个文件，如果里面有数据就往后写入</td>
</tr>
<tr>
<td>r+</td>
<td>允许读写文件</td>
</tr>
<tr>
<td>w+</td>
<td>允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件</td>
</tr>
<tr>
<td>a+</td>
<td>允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody></table>
<p>例如我打开一个文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* fd = <span class="literal">NULL</span>; <span class="comment">// 创建一个FILE类型的指针</span></span><br><span class="line">fd = fopen(<span class="string">&quot;E:\\a.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码就是打开一个文件，以追加的方式进行打开的。</p>
<h3 id="2-关闭文件"><a href="#2-关闭文件" class="headerlink" title="2.关闭文件"></a>2.关闭文件</h3><p>当我们打开文件后进行操作后是需要关闭，不关闭文件会导致文件一直处于一种打开状态，所以需要关闭文件，关闭文件的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">( FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>参数是刚才打开的文件，如果关闭文件出问题，这个函数会返回<code>EOF</code>，但是基本上关闭都是会成功的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fclose(fd);</span><br></pre></td></tr></table></figure>

<h3 id="3-写入内容"><a href="#3-写入内容" class="headerlink" title="3.写入内容"></a>3.写入内容</h3><p>打开文件后可以向文件中写入内容，写入的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> c, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数是可以向文件中光标位置处写入一个字符，比如说在文件中写入一个a字符，那代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fputc(<span class="string">&#x27;a&#x27;</span>, fd);</span><br></pre></td></tr></table></figure>

<p>如果要写入字符串也是可以的，使用下面的函数就可以写入一个字符串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>比如说我要写入一个”hello”，那语法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;hello&quot;</span>, fd);</span><br></pre></td></tr></table></figure>

<h3 id="4-读取内容"><a href="#4-读取内容" class="headerlink" title="4.读取内容"></a>4.读取内容</h3><p>使用的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">( FILE * fp )</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数可以读取文件中光标后的一个字符，读取后的内容是以返回值的方式进行输出，但是输出不了中文，它返回的只能是ASCII。</p>
<p>如果想读取中文，需要使用读取字符串的函数，函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *buf, <span class="type">int</span> n, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数是可以读取字符串，返回的就是你读取的字符串。</p>
<p>第一个参数是字符串存放的位置，需要定义一个数组进行接收。</p>
<p>第二个参数是读取字符串的个数。</p>
<p>第三个参数是文件指针。</p>
<p>比如说我读取一个文件中的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE* fd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    fd = fopen(<span class="string">&quot;E:\\a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">//以r的方式打开文件</span></span><br><span class="line">    fgets(buf, <span class="number">20</span>, fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fd);</span><br><span class="line">    fd = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-设置光标位置"><a href="#5-设置光标位置" class="headerlink" title="5.设置光标位置"></a>5.设置光标位置</h3><p>上面一直提到光标，在文件中光标的位置是非常重要的，就如同我们向一个<code>txt</code>文件中写入内容是需要设置光标位置的，光标的位置是你输入字符进入的位置。</p>
<p>设置光标位置的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE * fp, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>其中最后的一个参数是需要使用宏定义的，宏定义如下：</p>
<p><code>SEEK_SET</code>：设置光标在开头位置</p>
<p><code>SEEK_CUR</code>：设置光标在指定位置</p>
<p><code>SEEK_END</code>：设置光标在最后的位置</p>
<p>最后这个设置光标在指定位置第二个参数才有效。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言进阶</title>
    <url>/2025/01/16/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="C语言进阶"><a href="#C语言进阶" class="headerlink" title="C语言进阶"></a>C语言进阶</h1><h2 id="一、数据储存"><a href="#一、数据储存" class="headerlink" title="一、数据储存"></a>一、数据储存</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h3><p>C语言中，栈区是用于存放局部变量的。</p>
<p>栈区的使用习惯是：先使用高地址，再使用低地址</p>
<h3 id="2-release和debug的区别"><a href="#2-release和debug的区别" class="headerlink" title="2.release和debug的区别"></a>2.release和debug的区别</h3><p>在基础章节里说了，它们面向的对象是不一样的，但除了面向的对象不一样外还有一些地方也是不一样的，例如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道这样的写法会导致指针越界，但这串代码在debug和release中的运行结果是不一样的。</p>
<p>在debug中的运行结果如下：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cdebug%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=" "></p>
<p>可以看到这个是一个死循环了。</p>
<p>而在release中：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Crelease%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>他运行了几次就结束了。</p>
<p>为什么会出现上面的情况呢？这就需要介绍debug和release在内存中的储存了。</p>
<h4 id="2-1-debug的内存结构"><a href="#2-1-debug的内存结构" class="headerlink" title="2.1 debug的内存结构"></a>2.1 debug的内存结构</h4><p>我们知道，在栈中先进后用，加入我们还是使用上面的代码，我们输出一下 <code>i</code> 和 <code>arr</code>的地址。</p>
<p>代码如下：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%9F%A5%E7%9C%8B%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%A3%E7%A0%81.png"></p>
<p>通过这一行代码我们可以输出在debug方式中局部变量的地址值</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cdebug%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%80%BC.png"></p>
<p>我们可以看到，在debug方式运行后，<code>arr</code>变量的地址比<code>i</code>的地址低，在内存结构中，图是这样画的：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cdebug%E5%86%85%E5%AD%98%E5%9B%BE.png" alt=" "></p>
<p><code>arr</code>只有个数，所以索引的值为0-9</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cdebug%E5%86%85%E5%AD%98%E5%9B%BE2.png"></p>
<p>从这个位置开始走，给它赋值为0，走着走着，到<code>arr</code>最后一个元素时，<code>i</code>的大小还没到12，<code>arr[i]</code>还要继续赋值，一直走到<code>i</code>地址的位置，然后将<code>i</code>又重新赋值为0</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cdebug%E5%86%85%E5%AD%98%E5%9B%BE3.png"></p>
<p>一直重复该过程，就导致了死循环。</p>
<h4 id="2-2-release的内存结构"><a href="#2-2-release的内存结构" class="headerlink" title="2.2 release的内存结构"></a>2.2 release的内存结构</h4><p>我们还是通过上面的方法来进行分析，代码如下：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%9F%A5%E7%9C%8B%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%A3%E7%A0%81.png" alt=" "></p>
<p>然后运行的结果为：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Crelease%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%80%BC.png"></p>
<p>在release中，<code>arr</code>的地址要高于<code>i</code>变量的地址，所以无论我们索引是否超过数组<code>arr</code>内元素的值，所以变量<code>i</code>就不会被重新的覆盖，就不会出生死循环。</p>
<h3 id="3-数据在内存中存储"><a href="#3-数据在内存中存储" class="headerlink" title="3.数据在内存中存储"></a>3.数据在内存中存储</h3><h4 id="3-1-数据类型"><a href="#3-1-数据类型" class="headerlink" title="3.1 数据类型"></a>3.1 数据类型</h4><h5 id="3-1-1-整型"><a href="#3-1-1-整型" class="headerlink" title="3.1.1 整型"></a>3.1.1 整型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char</span><br><span class="line">    signed char</span><br><span class="line">    unsigned char</span><br><span class="line">short</span><br><span class="line">    signed short[int]</span><br><span class="line">    unsigned short[int]</span><br><span class="line">int</span><br><span class="line">    signed int</span><br><span class="line">    unsigned int</span><br><span class="line">long </span><br><span class="line">    signed long[int]</span><br><span class="line">    unsigned long[int]</span><br></pre></td></tr></table></figure>

<h5 id="3-1-2-浮点型"><a href="#3-1-2-浮点型" class="headerlink" title="3.1.2 浮点型"></a>3.1.2 浮点型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float</span><br><span class="line">double</span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-构造类型"><a href="#3-1-3-构造类型" class="headerlink" title="3.1.3 构造类型"></a>3.1.3 构造类型</h5><p>自定义类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组类型</span><br><span class="line">结构体类型 struct</span><br><span class="line">枚举类型enum</span><br><span class="line">联合体类型union</span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-指针类型"><a href="#3-1-4-指针类型" class="headerlink" title="3.1.4 指针类型"></a>3.1.4 指针类型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* p;</span><br><span class="line">char* p;</span><br><span class="line">float* p;</span><br><span class="line">void* p;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-5-空类型"><a href="#3-1-5-空类型" class="headerlink" title="3.1.5 空类型"></a>3.1.5 空类型</h5><p><code>void</code></p>
<p>用于：函数的返回类型 void test();</p>
<p>​	   函数参数 void test(void);</p>
<p>​	   指针 void* p;</p>
<h4 id="3-2-探究整型在内存中存储模式"><a href="#3-2-探究整型在内存中存储模式" class="headerlink" title="3.2 探究整型在内存中存储模式"></a>3.2 探究整型在内存中存储模式</h4><p>在探究这个问题的时候，我们拿一个代码在演示</p>
<p>如下的代码：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F1.png"></p>
<p>然后我们调用vs2019中的调试模式，注意，调试时请一定确定是在<code>debug</code> 模式下，否则调试会失败</p>
<p>打开后</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F2.png"></p>
<p>我们找到<code>调试</code>中的<code>窗口</code>，在里面找到<code>内存</code>,然后选择一个进行查看</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F3.png"></p>
<p>进去后我们可以看到，调试器并没有定位到我们创建的变量a上</p>
<p>所以我们要通过a的地址来查找a的地址，我们找到<code>&amp;a</code>能获得a的地址，所以我们在<code>查找</code>那一行输入</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F4.png"></p>
<p>然后按回车键</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F5.png"></p>
<p>我们知道，数据在内存中都以二进制的形式存储</p>
<p>对呀整数来说，整数二进制有3种表示形式</p>
<h5 id="3-2-1-原码、补码、反码"><a href="#3-2-1-原码、补码、反码" class="headerlink" title="3.2.1 原码、补码、反码"></a>3.2.1 原码、补码、反码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原码：十进制的二进制形式就是原码</span><br><span class="line">反码：符号位不变，其他的依次取反</span><br><span class="line">补码：反码加一，就可以得到反码</span><br></pre></td></tr></table></figure>

<p><strong>注：正数的原码、补码、反码相同</strong></p>
<p><code>int</code>类型的变量在内存中占4个字节，1个字节等于8个比特，所以就有32位二进制的数，为了方便我们查看，计算机转换为十六进制的数。</p>
<p>我们知道，4位二进制数等于一位十六进制数，然后32位二进制数就应该等于8个十六进制数，所以我们要将列改成4位</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F6.png"></p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F7.png"></p>
<p>改完之后就是这样的了</p>
<h5 id="3-2-2-原码、补码、反码-续"><a href="#3-2-2-原码、补码、反码-续" class="headerlink" title="3.2.2 原码、补码、反码(续)"></a>3.2.2 原码、补码、反码(续)</h5><p>刚刚只是简单介绍了一下原码、补码、反码，还说正数的原码、补码、反码相同，那负数呢？</p>
<p>现在我们介绍一下负数的原码、补码、反码的计算</p>
<p>例如：我们有一个a的值位-10，在<code>int</code>型中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = -10</span><br></pre></td></tr></table></figure>

<p>它的原码的形式是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 1010</span><br></pre></td></tr></table></figure>

<p>然后我们把原码转换为反码后，反码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 0101</span><br></pre></td></tr></table></figure>

<p>之后我们再将反码+1就可以得到补码，补码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 0110</span><br></pre></td></tr></table></figure>

<p>之后我们再把补码转换成十六进制的形式就得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>

<p>我们把刚刚的代码改变一下</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%94%B9%E5%8F%981.png"></p>
<p>然后使用上面的方法来查看变量a中存放的数</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%94%B9%E5%8F%982.png"></p>
<p>我们可以看到，a变量中的-10存放的方式是以补码的形式存放的，所以我们就可以得出一个结论。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结论：数据在内存中是以补码的形式进行存放的</span><br></pre></td></tr></table></figure>

<p>为什么在内存中数据是以补码的形式进行存储的呢？</p>
<h5 id="3-2-3-为什么存放补码"><a href="#3-2-3-为什么存放补码" class="headerlink" title="3.2.3 为什么存放补码"></a>3.2.3 为什么存放补码</h5><p>我们知道，在CPU中只有加法器而没有减法器，我们要计算1-1其实是计算1+(-1)</p>
<p>，如果我们直接拿原码相加的话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1的原码0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-1的原码1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">结果：1000 0000 0000 0000 0000 0000 0000 0010</span><br></pre></td></tr></table></figure>

<p>上面的结果换算出来是-2，肯定是不对的，但如果我们用原码来计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1的原码0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-1的原码1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-1的补码1111 1111 1111 1111 1111 1111 1111 1110</span><br><span class="line">结果：1 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>我们发现它已经超出32位了，但是我们只能存放32位长度的数，所以33位的1要省略，所以最后的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>结果就为0。</p>
<p>补码和原码的互相转换是非常方便的，它们的电路是一样的，就比如-1的原码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>补码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>我们将补码取反再加1就能得到原码。</p>
<p>补码取反+1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>所以为什么数据在内存中存放的形式必须是补码了。</p>
<p>我们回到最上面，为什么我们自己算出来的是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>

<p>但在vs2019中的存储却是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F6 FF FF FF</span><br></pre></td></tr></table></figure>

<p>呢？</p>
<p>这个就是需要知道大端存储和小段存储了</p>
<h5 id="3-2-4-大端存储和小段存储"><a href="#3-2-4-大端存储和小段存储" class="headerlink" title="3.2.4 大端存储和小段存储"></a>3.2.4 大端存储和小段存储</h5><p>大端存储和小段存储是我们了解数据在内存中存储模式最需要了解的一个知识点</p>
<h6 id="3-2-4-1-大端和小段"><a href="#3-2-4-1-大端和小段" class="headerlink" title="3.2.4.1 大端和小段"></a>3.2.4.1 大端和小段</h6><p>在开始讲大端存储和小段存储之前，我们先了解一下数据的大端是什么，小段是什么，有微机接口原理基础的小伙伴可以跳过这一节。</p>
<p>我们先用十进制给大家说，在十进制中，数据从左到右位数越来越大，例如我们有一个数为5623，5为千位，6为百位，2为十位，3为个位，所以5就为这个数的大端，3为这个数的小段。</p>
<p>但上面的这个例子只是让大家知道大端是在左，小段是在右，在计算机内部并不是以上面那个例子来的。</p>
<p>在计算机中，数据是以二进制的形式存放的，我们这里拿两位十六进制数来举例子，如下图：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%A4%A7%E7%AB%AF%E5%B0%8F%E6%AE%B5.png"></p>
<p>（2为十六进制数等于8位二进制数）</p>
<p>在这个数中，前4位为大端，后4位为小段</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%A4%A7%E7%AB%AF%E5%B0%8F%E6%AE%B52.png"></p>
<p>这样我们就知道二进制的大端和小段的位在哪了。</p>
<h6 id="3-2-4-2-什么是大端存储"><a href="#3-2-4-2-什么是大端存储" class="headerlink" title="3.2.4.2 什么是大端存储"></a>3.2.4.2 什么是大端存储</h6><p>大端存储又可以叫<strong>大端字节序</strong></p>
<p>大端字节序是把数据的小段字节放在高地址处，把大端字节放在低位地址处。</p>
<p>举个例子：如果我们有一个数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1001 1100</span><br></pre></td></tr></table></figure>

<p>这个数据放在大端字节序中的存放方式是：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%A4%A7%E7%AB%AF%E5%AD%98%E5%82%A8.png" alt=" "></p>
<h6 id="3-2-4-3-什么是小端存储"><a href="#3-2-4-3-什么是小端存储" class="headerlink" title="3.2.4.3 什么是小端存储"></a>3.2.4.3 什么是小端存储</h6><p>小端存储又可以叫<strong>小端字节序</strong></p>
<p>小段字节序是把数据的小端字节放在低地址处，把大端字节放在高地址处。</p>
<p>例如：我们拿-10的二进制来距离</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>

<p>用大端字节存储的话就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>
<p>我们拿大端存储的那个例子来说，在小端字节序中的存放方式是：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8.png" alt=" "></p>
<h5 id="3-2-5-通过代码判断当前机器的字节序"><a href="#3-2-5-通过代码判断当前机器的字节序" class="headerlink" title="3.2.5 通过代码判断当前机器的字节序"></a>3.2.5 通过代码判断当前机器的字节序</h5><p>通过上面的内容我们了解了数据在内存中的存放形式，还有存储方式中的大端存储和小端存储，通过这些我们可以通过代码来判断，一个数的存放方式为大端还是小端了。</p>
<p><strong>补充：在调试的情况下，一般在左边的为低地址，右边为高地址</strong></p>
<p><img src="E:\C语言程序设计\C语言笔记\笔记图片\调试.png"></p>
<p>接下来我们要写代码对大端和小端进行判断了。</p>
<p>我们现在有一个<code>int</code>型变量a，它里面的值为1（这里我们拿1来举例子）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>int</code>类型的数在内存中占4个字节，也就是32位，8个十六进制数，在内存中的存放为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 01</span><br></pre></td></tr></table></figure>

<p>如果它在小端存储的话，写法应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01 00 00 00</span><br></pre></td></tr></table></figure>

<p>如果是大端存储的话，写法应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 01</span><br></pre></td></tr></table></figure>

<p>所以我们要进行判断就需要判断第一个2位十六进制数即可。</p>
<p>问题又来了，我们该如何判断第一个2位十六进制数呢？我们知道<code>char</code>类型占一个字节，也就是8位，再换就是2个十六进制数，但我们要专门指向该用什么呢？</p>
<p>没错，就是使用指针，指针是指向地址的首地址值，如果指向的第一个数是1，那就证明是小端存储，而如果第一个数是0，则证明是大端存储。</p>
<p>所以我们代码就可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*)&amp;a;</span><br><span class="line">    <span class="keyword">if</span> ((*p) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端存储&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端存储&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一定要强制转换一下类型，虽然不会报错，但还是养成规范写法吧。</p>
<h5 id="3-2-6-练习"><a href="#3-2-6-练习" class="headerlink" title="3.2.6 练习"></a>3.2.6 练习</h5><h6 id="3-2-6-1-练习1"><a href="#3-2-6-1-练习1" class="headerlink" title="3.2.6.1 练习1"></a>3.2.6.1 练习1</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> b = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d,b = %d,c=%d&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**分析：**这道题考察的是原码补码的转换，还有不同类型的位数，和整型提升</p>
<p>-1的原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>然后转换为补码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>因为a是<code>char</code>类型的，所以要阶段，留8位，所以为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111</span><br></pre></td></tr></table></figure>

<p>但是输出需要整型提升，整型提升看有无符号位，如果有符号位，补1，没符号位补0，</p>
<p><code>char</code>类型有符号位，所以我们将<code>char</code>类型的-1补位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>然后计算它的原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>所以输出-1，<code>signed char</code>类型也是一样的。</p>
<p>但<code>unsigned char</code>整型提升是提升0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 1111 1111</span><br></pre></td></tr></table></figure>

<p>因为最高位是0，是正数，原码就等于补码，所以输出为：255</p>
<h6 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h6><h6 id="1-char-是-signed-char-还是-unsigned-char"><a href="#1-char-是-signed-char-还是-unsigned-char" class="headerlink" title="1.char 是 signed char 还是 unsigned char"></a>1.<code>char</code> 是 <code>signed char</code> 还是 <code>unsigned char</code></h6><p>C语言中是没有规定的，取决于编译器</p>
<h6 id="2-int-是signed-int-还是-unsigned-int"><a href="#2-int-是signed-int-还是-unsigned-int" class="headerlink" title="2.int 是signed int 还是 unsigned int"></a>2.<code>int</code> 是<code>signed int</code> 还是 <code>unsigned int</code></h6><p><code>int</code> 就是 <code>signed int</code></p>
<p><code>short</code> 默认 <code>signed short</code></p>
<h6 id="3-2-6-2-练习2"><a href="#3-2-6-2-练习2" class="headerlink" title="3.2.6.2 练习2"></a>3.2.6.2 练习2</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">-128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a);<span class="comment">//%u输出的是无符号的十进制数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>-128的二进制数为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 1000 0000</span><br></pre></td></tr></table></figure>

<p>补码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1000 0000</span><br></pre></td></tr></table></figure>

<p>因为是 <code>char</code> 类型进行存放的，所以只保留后8位，所以保存的形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000</span><br></pre></td></tr></table></figure>

<p>到输出位时，要求的是打印一个无符号的整数，所以要整型提升，整型提升时看存放的类型，在编译器中默认存储的是 <code>signed char</code> 类型的，所以前面补1，就得：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1000 0000</span><br></pre></td></tr></table></figure>

<p>因为需要打印的无符号数，所以最高位不是符号位，答案就为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4294967168</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE-%E7%BB%83%E4%B9%A02.png"></p>
<h6 id="3-2-6-3-练习3"><a href="#3-2-6-3-练习3" class="headerlink" title="3.2.6.3 练习3"></a>3.2.6.3 练习3</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题和练习2的答案一样。</p>
<p>128在内存中的存放是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 1000 0000</span><br></pre></td></tr></table></figure>

<p>但 <code>char</code> 只能存放8位，所以是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000</span><br></pre></td></tr></table></figure>

<p>然后进行整型提升：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1000 0000</span><br></pre></td></tr></table></figure>

<p>所以答案是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4294967168</span><br></pre></td></tr></table></figure>

<h6 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h6><p>探讨char类型的取值范围</p>
<p>在char类型中可以存放8位比特位，所以在内存中可以取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char 0000 0000</span><br><span class="line">     0000 0001</span><br><span class="line">     0000 0010</span><br><span class="line">     0111 1111</span><br><span class="line">     1000 0000</span><br><span class="line">     1000 0001</span><br><span class="line">     ....</span><br><span class="line">     1111 1110</span><br><span class="line">     1111 1111</span><br></pre></td></tr></table></figure>

<p>前面0开头的都是正数，1开头的是负数，因为正数的原补码相同，所以前面存储的是0~127。</p>
<p>在负数中，我们要将补码变成原码，例如1111 1111的原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111</span><br></pre></td></tr></table></figure>

<p>然后取反加一就得原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0001</span><br></pre></td></tr></table></figure>

<p>我们转换一下这个数是不是等于-1。</p>
<p>一直这样算，1000 0001的原码是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111</span><br></pre></td></tr></table></figure>

<p>转换一下就是-127。</p>
<p>1000 0000这个数没有办法再进行计算了，它默认为-128</p>
<p>如果我们在 <code>char</code> 类型中存放128，它会默认为是-128。</p>
<h6 id="3-2-6-4-练习4"><a href="#3-2-6-4-练习4" class="headerlink" title="3.2.6.4 练习4"></a>3.2.6.4 练习4</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-20</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i + j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题非常的简单，重点就是二进制的加法，答案是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-10</span><br></pre></td></tr></table></figure>

<h6 id="3-2-6-5-练习5"><a href="#3-2-6-5-练习5" class="headerlink" title="3.2.6.5 练习5"></a>3.2.6.5 练习5</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是死循环，因为 <code>i</code> 是无符号数据，所以最小的是0。</p>
<h6 id="3-2-6-6-练习6"><a href="#3-2-6-6-练习6" class="headerlink" title="3.2.6.6 练习6"></a>3.2.6.6 练习6</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">-1</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">strlen</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong><code>char</code>类型有一个存储数据值的图：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cchar%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE.png" alt=" "></p>
<p>正常进行 <code>char</code> 类型加法的话，图应该是这样走的：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cchar%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE1.png"></p>
<p>但是我们现在是进行减法，所以这幅图要倒着计算：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5Cchar%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE2.png"></p>
<p>程序开始，整型-1-0，得到的结果为-1，-1-1，得到的结果为-2…..然后到-1-128，得到的结果为127。</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87-128-1%E7%9A%84%E7%BB%93%E6%9E%9C.png"></p>
<p>继续相减，-1 - 254 &#x3D; 1，-1 - 255 &#x3D; 0，-1 - 256 &#x3D; -1….一直重复，直到不满足条件为止，然后执行 <code>strlen()</code> ，</p>
<p>这个函数是遇见 <code>\0</code> 就结束，我们知道 <code>\0</code> 就是 <code>0</code> ，所以就128 + 127 &#x3D; 255，结果就为255。</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E7%BB%83%E4%B9%A06%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=" "></p>
<h6 id="3-2-6-7-练习7"><a href="#3-2-6-7-练习7" class="headerlink" title="3.2.6.7 练习7"></a>3.2.6.7 练习7</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**答案 **：死循环</p>
<p>**分析：**变量 <code>i</code> 的类型为 <code>unsigned char</code> ，最大值为255，当 <code>i</code> 到最大数后再加1就得0了，就变成了死循环了。</p>
<h4 id="3-3-探究浮点型在内存中存储模式"><a href="#3-3-探究浮点型在内存中存储模式" class="headerlink" title="3.3 探究浮点型在内存中存储模式"></a>3.3 探究浮点型在内存中存储模式</h4><p>在开始仔细研究浮点数在内存中的存储模式之前，我们先看下面的这一道练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">float</span>* pFloat = (<span class="type">float</span>*) &amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    </span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题很容易就会写错，大家可能觉得输出的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n的值为:9</span><br><span class="line">pFloat的值为:9.0</span><br><span class="line">n的值为:9</span><br><span class="line">pFloat的值为:9.0</span><br></pre></td></tr></table></figure>

<p>那这样就错了，我们拿到dev-c++中进行一下验证：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F.png"></p>
<p>是不是跟我们自己想的输出不一样，为什么会出现这种情况？这就要介绍一下浮点型数据在内存中存储模式了。</p>
<h5 id="3-3-1-在内存中浮点数的存储"><a href="#3-3-1-在内存中浮点数的存储" class="headerlink" title="3.3.1 在内存中浮点数的存储"></a>3.3.1 在内存中浮点数的存储</h5><p>在C语言中存储浮点数是按照IEEE 754的规则进行存储的。</p>
<p>IEEE 754规定存储浮点数的方式为：<code>S E M</code>。</p>
<ul>
<li><p>S：符号位，正数写0，负数为1.</p>
</li>
<li><p>E：指数。</p>
<p>对于指数E的情况是比较复杂的，因为一些时候指数为正数，而有些时候指数为负数，所以就找一个中间数，让指数在存储前需要加上中间数。对于8位E(也就是float数据)，中间数为127，而对于11位E(double型数据)，中间数为1023。</p>
</li>
<li><p>M：有效数字。</p>
<p>在存储时会省略小数点前的一个数，因为前面的那个数默认为1，因此可以被省略，拿出时只需要加上1即可。</p>
<p>留给M的位数：</p>
<p>float：23位</p>
<p>double：52位</p>
</li>
</ul>
<p>例如浮点数5.5f用二进制的形式转换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0101.1</span><br></pre></td></tr></table></figure>

<p>然后我们把它移动一下变为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.011 * 2^2</span><br></pre></td></tr></table></figure>

<p>s &#x3D; 0</p>
<p>M &#x3D; 1.011</p>
<p>E &#x3D; 2</p>
<p>因为是存在float中，所以E位要加127，在内存中的存储就应该为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0100 0000 1011 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>转换为十六进制为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40 B0 00 00</span><br></pre></td></tr></table></figure>

<p>我们在程序中走一下看看结果是不是一样</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C5.5f%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8.png"></p>
<p>倒着读，是不是和我们计算的一样呀。所以浮点数在内存中存储的方式也是分大小端的。</p>
<h5 id="3-3-2-从内存中读浮点数"><a href="#3-3-2-从内存中读浮点数" class="headerlink" title="3.3.2 从内存中读浮点数"></a>3.3.2 从内存中读浮点数</h5><p>从内存中读取浮点数的方法是需要具体分析的</p>
<h6 id="E不全为0或不全为1"><a href="#E不全为0或不全为1" class="headerlink" title="E不全为0或不全为1"></a>E不全为0或不全为1</h6><p>就那我们上面的5.5f举例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0100 0000 1011 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>这样子看有点复杂，我们把它写成<code>SEM</code>形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 10000001 01100000000000000000000</span><br></pre></td></tr></table></figure>

<p>我们将E减去刚才加的127，然后就得：0.011*2^2，之后我们把1加上去，就得1.011*2^2。转换一下就得101.1</p>
<h6 id="E为全0"><a href="#E为全0" class="headerlink" title="E为全0"></a>E为全0</h6><p>如果E为全0，那有效数字M前面不再加1。这样做是为表示+-0，以及接近0的数</p>
<h6 id="E为全1"><a href="#E为全1" class="headerlink" title="E为全1"></a>E为全1</h6><p>表示+-无穷大(正负有S决定)</p>
<p>我们知道浮点数在内存中的存储模式后，我们就可以分析最开始的那个题目了</p>
<h5 id="3-3-3-分析最开始的例子"><a href="#3-3-3-分析最开始的例子" class="headerlink" title="3.3.3 分析最开始的例子"></a>3.3.3 分析最开始的例子</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">float</span>* pFloat = (<span class="type">float</span>*) &amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    </span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始时有一个<code>int</code>型变量n，n中的值为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 1001</span><br></pre></td></tr></table></figure>

<p>之后<code>float*</code>获取的直接是n变量的值，它默认上面n的二进制数为浮点数的形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 00000000 00000000000000000001001</span><br><span class="line">s = 0</span><br><span class="line">E = -127</span><br><span class="line">M = 00000000000000000001001</span><br></pre></td></tr></table></figure>

<p><code>printf(&quot;n的值为:%d\n&quot;, n);</code>这个输出没什么问题，只要是<code>printf(&quot;pFloat的值为:%f\n&quot;, *pFloat);</code>的输出</p>
<p>因为它默认为浮点数的存储方式，所以要输出出来就是要把上面二进制转换为十进制数，而上面这种情况是我们<code>E为全0</code>的形式，所以M位前面不+1。</p>
<p>转换的结果就为：1.001 * 2^-127，这个数接近为0，我们又知道，<code>%f</code>只能输出小数点后6位的数，所以第二个输出就为：0.000000</p>
<p>之后我们将指针变量<code>pFloat</code>中的内容修改为9.0，9.0的二进制为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1001.0</span><br></pre></td></tr></table></figure>

<p>在内存中的存储形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 10000010 00100000000000000000000</span><br></pre></td></tr></table></figure>

<p>执行代码<code>printf(&quot;n的值为:%d\n&quot;, n);</code>，输出是以<code>%d</code>整型的输出方式，直接将上面的二进制看成整型的二进制，最高位为0，所以是正数直接输出出来，答案就为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1091567616</span><br></pre></td></tr></table></figure>

<p>和我们执行代码输出的结果一样。</p>
<p>执行代码<code>printf(&quot;pFloat的值为:%f\n&quot;, *pFloat);</code>就将浮点型的二进制转换成十进制的浮点型。</p>
<h2 id="二、指针进阶"><a href="#二、指针进阶" class="headerlink" title="二、指针进阶"></a>二、指针进阶</h2><p>之前我们学了基础的指针，现在我们要对指针进行更深入的讲解。</p>
<p>我们知道</p>
<ul>
<li>指针就是个变量，用于存放地址的变量。</li>
<li>指针的大小是固定的4&#x2F;8个字节(32位&#x2F;64位)</li>
</ul>
<p>这些是比较基础的概念，我们讲指针进阶先从字符指针开始讲</p>
<h3 id="1-字符指针"><a href="#1-字符指针" class="headerlink" title="1.字符指针"></a>1.字符指针</h3><p>我们知道，在C语言中我们可以通过数组的方式来存储字符和字符串，但其实指针也可以存储字符串的。</p>
<p>例如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>* p = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个字符型指针<code>p</code>，但我们知道指针变量最高只能存放8个字节，但我们给<code>p</code> 赋值的变量有12个字节(最后的<code>\0</code>)，指针应该是存不下的，那为什么我们说指针可以存放字符串呢？</p>
<blockquote>
<p>是因为指针并不是存放这个字符串，而是存放字符串的首元素地址</p>
</blockquote>
<p>我们可以验证一下这个说法，我们将<code>*p</code>进行输出，如果输出的结果为<code>h</code>，则指针就是存放字符串的首元素地址。</p>
<p>我们在dev-c++中将代码写好</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88.png"></p>
<p>然后运行：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-2.png"></p>
<p>看，结果是不是和我们猜想的一样</p>
<blockquote>
<p>字符指针存放的其实是字符串的首元素值</p>
</blockquote>
<p>可能有些同学会说是不是和数组一样的存放方式呀？</p>
<p>其实是不一样的，在数组中存放的是整个字符串，但是指针存放不了整个字符串，所以只能存放首元素的地址。</p>
<p>还有一点就是指针储存的字符串是不能修改里面的值的</p>
<p>例如：我们将首元素的地址中的元素修改</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-3.png"></p>
<p>运行的结果：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-4.png" alt=" "></p>
<p>可以看出，我们使用指针方式是不能修改字符串中的字符的。</p>
<h4 id="1-1-面试题"><a href="#1-1-面试题" class="headerlink" title="1.1 面试题"></a>1.1 面试题</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* str3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* str4 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str1 == str2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 == str2&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 != str2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str3 == str4)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一道题会输出什么结果呢？</p>
<p>我们知道，数组是单独开辟一个空间来存放内容，但指针是使用的是共用的地址</p>
<p>我们从内存的角度进行分析，在内存中变量是存放在栈中</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-5.png"></p>
<p>我们创建了一个 <code>str1</code> 的数组，在栈中的存放：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-6.png" alt=" "></p>
<p>然后在里面存放的值为”hello,world”， <code>str1</code> 指向就为：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-7.png" alt=" "></p>
<p>之后我们又创建了一个变量 <code>str2</code> ，给它的值也为”hello,world”，但在数组变量中就算是相同的值也会重新开辟空间来存放</p>
<p>存放情况：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-8.png"></p>
<p>所以在数组变量中，我们在不同的数值中存放相同的值，它们的地址指向绝对不可能是相同的。</p>
<p>之后我们创建了一个 <code>char</code> 型的指针 <code>str3</code> ，创建完后在内存中会创建一个字符串”hello,world”</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-9.png" alt=" "></p>
<p>然后指针 <code>str3</code> 就会指向创建出来的字符串的首元素地址</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-10.png"></p>
<p>之后又创建了一个 <code>char</code> 型的指针 <code>str4</code> ，这个指针指向的也是字符串”hello,world”，内存中已经存在字符串”hello,world”，所以就不需要再重新创建，指针 <code>str4</code> 直接指向创建出来的字符串”hello,world”了</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-11.png"></p>
<p>这两个指针都指向的是同一个字符串的首元素地址，所以它们的地址相同。</p>
<h3 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2.指针数组"></a>2.指针数组</h3><p>在前面我们知道，指针数组就是存放指针的数组，它的使用方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* arr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>上面的代码是一个数组中可以存放2个 <code>int</code> 型的指针变量。</p>
<p>使用的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="type">int</span>* arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;</span><br><span class="line">    <span class="comment">//输出内容</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个用法基本上没什么人使用。</p>
<p>一般指针数组的使用是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">5</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> c[<span class="number">5</span>] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* arr[<span class="number">3</span>] = &#123;a, b, c&#125;;</span><br><span class="line">    <span class="comment">//输出内容</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr[i] + j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将多个数组的地址存入一个数组中，方便使用。</p>
<p>上面那个代码的输出其实也可以写成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr[i][j]));</span><br></pre></td></tr></table></figure>

<p>使用解引用 <code>[]</code> 意思也是和+j一样的，只不过写法不一样。</p>
<p>在进阶内容中我们重点不是指针数组，指针数组在基础部分已经讲完了，现在的重点是我们在基础没有讲的一个知识，就是数组指针。</p>
<h3 id="3-数组指针"><a href="#3-数组指针" class="headerlink" title="3.数组指针"></a>3.数组指针</h3><p>我们前面学习了整型指针，浮点数正整，字符型指针，这些都是指针，数组指针也是一个指针</p>
<p>整型指针就是操作整型的指针，数组指针就是操作数组的指针。</p>
<h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><p>我们前面学过，数组名就是首元素的地址，我们 <code>&amp;数组名</code> 得到的是整个数组的地址，我们可以使用 <code>&amp;数组名</code> 来获取数组的地址然后存入指针中。</p>
<p>但这个数组指针如何定义？</p>
<p>数组指针的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> (*pa)[<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<p>怎么理解呢？</p>
<p>我们一步一步来</p>
<p>首先我们先写 <code>&amp;arr</code> ，这个获取的是 <code>arr</code> 的地址值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;arr;</span><br></pre></td></tr></table></figure>

<p>我们取了地址后需要一个指针来存放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*pa = &amp;arr;</span><br></pre></td></tr></table></figure>

<p>指针<code>pa</code>是需要有类型的，<code>pa</code>的类型是数组，而在C语言中要表示数组类型是用<code>type [number]</code>来表示的，所以我们可以按照这样来进行写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pa [<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<p>但是我们看，如果这样写，计算机会先将</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pa[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>结合在一起，然后就变成了指针数组，但我们 <code>*pa</code> 是在一起的，所以我们需要用括号将 <code>*pa</code></p>
<p>结合在一起</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*pa) [<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<p><strong>注：解引用<code>[]</code>中的值是该数组中的长度，要定义哪一个数组的指针，里面的值就为该数组的长度</strong></p>
<h4 id="3-2-指针数组和数组名"><a href="#3-2-指针数组和数组名" class="headerlink" title="3.2 指针数组和数组名"></a>3.2 指针数组和数组名</h4><p>在定义中说到，数组名就是首元素的地址，指针数组获取数组的地址是整个数组的地址，我们可以通过下面的程序来说明</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-14.png"></p>
<p>数组名和指针数组的地址都相同，那我们为什么还有指针数组这个东西呢？</p>
<p>我们用数组进行移位+1，得到的就是下一个元素的值</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-15.png"></p>
<p>我们使用一下数组指针进行一下位移看看会发生什么</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-16.png"></p>
<p>我们发现，通过数组指针+1后它直接就跳过20个字节，也就是一个数组</p>
<p>我们可以总结</p>
<blockquote>
<p>数组指针前进是跳过这个数组</p>
</blockquote>
<p>数组名就是首元素地址，但是有两个例外：</p>
<blockquote>
<p><code>sizeof</code>后的数组名代表的是整个数组，单位是字节</p>
<p>&amp;数组名表示的是整个数组，取出的是整个数组的地址</p>
</blockquote>
<h4 id="3-3-数组指针的使用"><a href="#3-3-数组指针的使用" class="headerlink" title="3.3 数组指针的使用"></a>3.3 数组指针的使用</h4><h5 id="3-3-1-一维数组中的使用"><a href="#3-3-1-一维数组中的使用" class="headerlink" title="3.3.1 一维数组中的使用"></a>3.3.1 一维数组中的使用</h5><p>数组指针<code>pa</code>中的地址是整个数组的地址，<code>*pa</code>就为数组本身</p>
<p>例如我们有一个数组名，我们需要使用数组指针将它全部打印出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*pa)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*pa)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>*pa</code>+<code>i</code>得出下一个位置的地址出来，然后再进行解引用输出出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*pa)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *((*pa) + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个的输出是一样的</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-17.png"></p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-18.png"></p>
<p>我们也可以把输出的功能放在函数中使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *((*pa) + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    print1(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在函数中的形参中定义的是数组指针，输出的结果和上面的结果一样</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-21.png"></p>
<p>但是一维数组基本上用不到数组指针，只有在二维数组中才能很好的使用</p>
<h5 id="3-3-2-二维数组中的使用"><a href="#3-3-2-二维数组中的使用" class="headerlink" title="3.3.2 二维数组中的使用"></a>3.3.2 二维数组中的使用</h5><p>一般使用二维数组的时候我们都是通过下面的代码来实现的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line">    print(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们使用一下数组指针的方式来输出一下二维数组中的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*(pa + i)) + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line">    print(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*(pa + i))[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line">    print(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组的数组名表示的是首元素的地址，二维数组首元素的地址是第一行，就比如我们上面的那个例子中的数组</p>
<p>二维数组的首元素的地址就是</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-19.png"></p>
<p>所以我们的数组指针其实指向的是二维数组中的第一行，如果我们用这一行的地址加1就直接跳过第一行的所有元素，然后到第二行</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-20.png"></p>
<p>所以我们的数组指针的正确指向其实是该数组每一行的长度。</p>
<p>输出的解释参考一维数组的输出即可，重点是二维数组的定义和指针到底指向的是哪一个地址。</p>
<h5 id="3-3-3-使用函数输出数组传入加-该怎么用"><a href="#3-3-3-使用函数输出数组传入加-该怎么用" class="headerlink" title="3.3.3 使用函数输出数组传入加&amp;该怎么用"></a>3.3.3 使用函数输出数组传入加<code>&amp;</code>该怎么用</h5><p>数组传入函数是传的地址值，我们可以在函数中使用指针或者数组来接受，一般都不使用 <code>&amp;</code> 取址符来获取数组的地址，但如果你偏要使用 <code>&amp;数组名</code> 那函数中该怎么写呢？</p>
<h6 id="3-3-3-1-一维数组中"><a href="#3-3-3-1-一维数组中" class="headerlink" title="3.3.3.1 一维数组中"></a>3.3.3.1 一维数组中</h6><p>如果是一维数组的话，传的数组参数必须加上 <code>&amp;</code></p>
<p>看下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">(<span class="type">int</span> (*pa) [<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*pa)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    print3(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还是用数组指针进行接受，在上面代码中数组指针 <code>pa</code> 接受的是整个数组的地址，我们没有办法对它进行+1的操作，操作后就会跳过整个数组。</p>
<p>在上面说到， <code>pa</code> 是数组地址， <code>*pa</code> 就是整个数组，所以我们可以直接通过<code>数组名[索引]</code> 来转换成指针的形式 <code>(*pa)[索引值]</code></p>
<p>当然我们也可以用下面的输出办法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">(<span class="type">int</span> (*pa) [<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *((*pa) + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    print3(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个原理也和上面的差不多，就是把 <code>[]</code> 转换为+了。</p>
<h6 id="3-3-3-2-二维数组中"><a href="#3-3-3-2-二维数组中" class="headerlink" title="3.3.3.2 二维数组中"></a>3.3.3.2 二维数组中</h6><p>在传二维数组的参数时我们一般都不添加 <code>&amp;</code> 符号</p>
<p>如果传入函数中我们传 <code>&amp;数组名</code> 那函数的形参该如何写呢？</p>
<p>用我们之前的那个函数的形参可以吗</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-22.png"></p>
<p>很显然这个方法是不行的</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-23.png"></p>
<p>我们可以通过上面学到的知识来说明这个问题</p>
<p>讲数组指针操作二维数组中说过，它获取的是二维数组的地址，二维数组的地址就是第一行的地址，我们其实是在对二维数组的行进行操作，也指定了操作的行的长度</p>
<p>而如果直接 <code>&amp;arr</code> ，其实是将整个二维数组的地址传到这个函数中，我们要对整个二维数组进行操作就需要定义数组指针的长度，因为是二维数组，所以是需要有两个长度的。所以我们定义就需要这样定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">3</span>][<span class="number">5</span>])</span></span><br></pre></td></tr></table></figure>

<p>这样才是对整个二维数组的操作的方式。</p>
<p>我们现在知道函数的形参如何定义的了，那该如何对整个二维数组进行操作呢？</p>
<p>其实也和一维数组的操作差不多</p>
<p>第一种方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">3</span>][<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*pa)[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    print2(&amp;arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们传入的是整个二维数组的地址，所以 <code>*pa</code> 直接就是二维数组 <code>arr</code> </p>
<p>我们可以通过 <code>*pa[][]</code> 来获取值</p>
<p>这个办法是很简单的，但还有一个办法，有点复杂，需要仔细想想</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">3</span>][<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*((*pa) + i) + j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    print2(&amp;arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个办法我们在3.3.2中说过，只不过那种直接加得到的就是该元素的值，而我们这里得到的其实是地址，所以还需要使用<code>*</code>来转义一下 ，才能得到值。</p>
<h5 id="3-3-4-分析几个例子"><a href="#3-3-4-分析几个例子" class="headerlink" title="3.3.4 分析几个例子"></a>3.3.4 分析几个例子</h5><p>我们先看下面的几个定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> parr1[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* parr2[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> (*parr3)[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> (*parr4[<span class="number">10</span>])[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>parr1很简单这就是数组</p>
</li>
<li><p>parr2也容易理解，是一个指针数组</p>
</li>
<li><p>parr3我们也学过，是一个数组指针</p>
</li>
<li><p>parr4有点复杂，我们之前没有见过。</p>
<p>我们可以一个一个的分析，看到<code>(*)</code>的就可以理解为一个数组指针，然后<code>parr4[10]</code>就是一个数组，这就是一个存储数组指针的数组，该数组存放的长度为10，每个数组指针能指向一个数组，然后指向的数组的长度是5</p>
</li>
</ul>
<h3 id="4-数组参数、指针参数"><a href="#4-数组参数、指针参数" class="headerlink" title="4.数组参数、指针参数"></a>4.数组参数、指针参数</h3><h4 id="4-1-一维数组传参"><a href="#4-1-一维数组传参" class="headerlink" title="4.1 一维数组传参"></a>4.1 一维数组传参</h4><p>在一维数组中，传参有几种方法是可以的</p>
<h5 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h5><p>形参是数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h5><p>形参是指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h5><p>形参是数组指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(&amp;arr, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h5><p>形参是指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* arr[<span class="number">20</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第五种"><a href="#第五种" class="headerlink" title="第五种"></a>第五种</h5><p>形参是二级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* *ppa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-二维数组传输"><a href="#4-2-二维数组传输" class="headerlink" title="4.2 二维数组传输"></a>4.2 二维数组传输</h4><h5 id="第一种-1"><a href="#第一种-1" class="headerlink" title="第一种"></a>第一种</h5><p>形参是二维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[][<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test(arr, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二种-1"><a href="#第二种-1" class="headerlink" title="第二种"></a>第二种</h5><p>形参是数组指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test1(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; left; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ((*pa) + i)[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不能写的"><a href="#不能写的" class="headerlink" title="不能写的"></a>不能写的</h5><p>形参为一级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* arr)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参为二级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> **pa, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test1(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> **pa, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参为指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span>* pa[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test1(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span>* pa[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参为二维数组，但第二个 <code>[]</code> 中的数值省略</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[<span class="number">3</span>][])</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一定要看好传入的是什么类型的，要用相同的类型去接收</strong></p>
<h4 id="4-3-一级指针传参"><a href="#4-3-一级指针传参" class="headerlink" title="4.3 一级指针传参"></a>4.3 一级指针传参</h4><p>我们写一个程序的时候，一般是先写main函数里的东西，如果要传参数给函数也是规定好函数的形参是是什么形式的</p>
<p>例如我们下面写好了一个main函数，我们也规定函数test2中的形参为一个指针和一个整数来接受</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* p = arr;</span><br><span class="line">    test2(p, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们的函数的写法就如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(pa + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果我们有一个写好的函数，我们需要使用，能给这个函数传什么值进去呢？</p>
<p>例如下面的这个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span>* pa)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看，我们有一个函数，形参是一个指针，我们需要给这个函数传参数，只能选择传地址。</p>
<p>主函数main中有一个 <code>char</code> 类型的变量a</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要把这个值传入函数中其实有两种写法</p>
<p>第一种直接就是把a的地址传入函数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    print(&amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种写法就是用一个指针来接收a的地址，然后再传入函数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="type">char</span>* pa = &amp;a;</span><br><span class="line">    print(pa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式都要明白，传一级指针用什么接收，形参为一级指针该传什么值我们需要明白。</p>
<h4 id="4-4-二级指针传参"><a href="#4-4-二级指针传参" class="headerlink" title="4.4 二级指针传参"></a>4.4 二级指针传参</h4><p>当有一个二级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* pa = &amp;a;</span><br><span class="line">    <span class="type">int</span>** ppa = &amp;pa;</span><br><span class="line">    print(ppa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要将这个二级指针传给一个函数中使用，函数的形参的写法可以是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>** ppa)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, **ppa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那反过来，如果这个函数写好了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>** ppa)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**ppa)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该传什么值呢？有两种办法</p>
<p>第一种：</p>
<p>我们直接将定义的一级指针的地址传进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* pa = &amp;a;</span><br><span class="line">    print(&amp;pa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式是定义二级指针，然后把二级指针传进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* pa = &amp;a;</span><br><span class="line">    <span class="type">int</span>** ppa = &amp;pa;</span><br><span class="line">    print(ppa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种方式是把指针数组传进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    print(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组中是存放一级指针，所以可以使用二级指针的方式来接收，但尽量不要使用该方法，有可能会出现野指针的情况。</p>
<p>内容不是很难，重点是要将这些方法记住，并且能熟练的使用。</p>
<h3 id="5-函数指针"><a href="#5-函数指针" class="headerlink" title="5.函数指针"></a>5.函数指针</h3><p>在C语言中，所有的数据都有它的地址，整型变量、数组等都有地址，在函数中，函数也是有地址的，比如我们创建一个函数来输出它的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;Add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-24.png"></p>
<p>所以函数是有地址的，只要有地址就可以使用指针来进行接收</p>
<h4 id="5-1-函数指针的定义"><a href="#5-1-函数指针的定义" class="headerlink" title="5.1 函数指针的定义"></a>5.1 函数指针的定义</h4><p>可以结合数组指针的定义来互相推</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数返回值类型 (*指针名)(形参类型) = &amp;函数名</span><br></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初学的时候，可能会写成下面这个样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *<span class="title function_">pa</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> = &amp;Add;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个写法是错误的，因为 <code>*</code> 的结合优先级低，会让 <code>pa(int x, int y)</code> 先进行结合，然后再和 <code>*</code> 结合。</p>
<h4 id="5-2-函数指针的使用"><a href="#5-2-函数指针的使用" class="headerlink" title="5.2 函数指针的使用"></a>5.2 函数指针的使用</h4><p>定义就是为了使用，定义好之后该如何进行使用，是需要知道的重点。</p>
<p>从上面定义知道， <code>pa</code> 是函数 <code>Add</code> 的地址，在前面如果加上 <code>*</code> 就直接是函数了，所以可以这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> sum = (*pa)(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-25.png"></p>
<p>答案是没有问题的。</p>
<h4 id="5-3-探究函数的地址"><a href="#5-3-探究函数的地址" class="headerlink" title="5.3 探究函数的地址"></a>5.3 探究函数的地址</h4><p>在数组前面说过输出数组的地址可以用 <code>&amp;数组名</code> ，也可以直接使用 <code>数组名</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-26.png"></p>
<p>带入函数中，<code>&amp;函数名</code> 是函数的地址，那直接输出 <code>函数名</code> 得到的是不是函数的地址呢？</p>
<p>测试一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;Add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, Add);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-27.png"></p>
<p>通过上面的运行结果，可以发现，使用 <code>&amp;函数名</code> 和 <code>函数名</code> 的输出结果是一样的，所以可以总结为</p>
<blockquote>
<p>函数名是函数的地址</p>
</blockquote>
<p>在使用的时候是直接通过</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数名();</span><br></pre></td></tr></table></figure>

<p>进行调用的</p>
<p>可以尝试直接使用指针名来调用函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> sum = pa(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-28.png"></p>
<p>可以看出，直接用指针名也可以调用函数，所以可以总结</p>
<blockquote>
<p>可以使用函数指针直接调用函数</p>
<p>但不能使用数组指针直接调用数组</p>
</blockquote>
<p>当然，将函数的地址传给函数指针的时候也可以不添加 <code>&amp;</code> 就可以获得函数的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = Add;</span><br><span class="line">    <span class="type">int</span> x = pa(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-33.png"></p>
<h4 id="5-4-阅读代码"><a href="#5-4-阅读代码" class="headerlink" title="5.4 阅读代码"></a>5.4 阅读代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*(<span class="type">void</span> (*)())<span class="number">0</span>)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>出处：C陷阱和缺陷</p>
</blockquote>
<p>这段代码得一步一步分析，<code>void (*)()</code> 是一个函数指针类型，它将 <code>0</code> 强制类型转换成一个函数指针的地址</p>
<p>然后对其解引用 <code>*(void (*)()0)</code> 后进行了调用</p>
<p><code>(*(void (*)()0))()</code> 。</p>
<p>也就是调用了地址为0处的函数，它的返回值为0，无形参。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (* signal(<span class="type">int</span>, <span class="type">void</span>(*)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数其实就是指针函数套一个指针函数</p>
<p>先看 <code>signal(int, void(*)(int))</code> 这是一个函数，第一个参数是 <code>int</code> 第二个参数是指向返回值为 <code>void</code> 形参为 <code>int</code> 的函数。</p>
<p>而这个函数它的返回值为一个函数指针。这个函数指针是指向返回值为 <code>void</code> ，形参为 <code>int</code> 的函数。</p>
<p>简化一下这个代码就能能看懂了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*) (<span class="type">int</span>) signal(<span class="type">int</span>, <span class="type">void</span> (*)(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>这个函数的返回类型是一个函数指针类型，但是这种写法在C语言中是不能支持的，如果一个函数的返回类型是函数指针类型，那它的写法只能是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (* (signal(<span class="type">int</span>, <span class="type">void</span> (*)(<span class="type">int</span>)))) (<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-29.png"></p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-30.png"></p>
<p>如果真的要简化其实也是可以的，可以使用 <code>typedef</code> 对类型重命名</p>
<p>在讲用 <code>typedef</code> 简化前，先把前面漏的东西补充一下</p>
<h5 id="5-4-1-typedef"><a href="#5-4-1-typedef" class="headerlink" title="5.4.1 typedef"></a>5.4.1 <code>typedef</code></h5><p><code>typedef</code> 的作用就是对类型进行重新命名</p>
<p>比如要将 <code>unsigned int</code> 类型名字变成 <code>ui</code> 来使用，就需要在程序中这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line">    ui i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行的结果</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-31.png"></p>
<p>如果你要将一个函数指针重新命名使用下面的代码是不行的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span> <span class="type">pfun_t</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-32.png"></p>
<blockquote>
<p>这个和5.4中的不能简化的那个一样</p>
</blockquote>
<p>如果要给函数指针重新命名只能写成下面的样子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* <span class="type">pfun_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写成这样就不会出现问题了</p>
<p>现在就可以进行简化了，将函数指针类型重新命名，然后再使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* <span class="type">pfun_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">pfun_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> (*)(<span class="type">int</span>))</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看是不是更好的就明白这个代码的意思了。</p>
<h3 id="6-函数指针数组"><a href="#6-函数指针数组" class="headerlink" title="6.函数指针数组"></a>6.函数指针数组</h3><p>之前学过指针数组，指针数组就是存放指针的数组</p>
<p>例如需要有一个数组来存放5个整型指针，那代码可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* pa[<span class="number">5</span>]; </span><br></pre></td></tr></table></figure>

<p>那函数指针数组不就是存放函数指针的一个数组吗，按照上面的写法改一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*)() pa[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>但是从上面知道，不能这样写的，虽然 <code>int(*)()</code> 是函数指针类型，但是不能放在前面，数组名放在后面，而是要把数组名和 <code>*</code> 放在一起</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* pa[<span class="number">5</span>])();</span><br></pre></td></tr></table></figure>

<h4 id="6-1-使用例子"><a href="#6-1-使用例子" class="headerlink" title="6.1 使用例子"></a>6.1 使用例子</h4><p>例如有两个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这两个函数的返回值类型和形参类型都一样，可以直接使用一个函数指针数组将它存放在里面</p>
<p>main函数就可以这么写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;Add, Sub&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接写的是函数的名字，因为在5.3中讲到，函数名就是函数的地址，所以这直接可以将函数名存储在函数指针中。</p>
<p>也可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pA)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> (*pS)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Sub;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;pA, pS&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-函数指针数组的使用"><a href="#6-2-函数指针数组的使用" class="headerlink" title="6.2 函数指针数组的使用"></a>6.2 函数指针数组的使用</h4><p>和查找数组中元素的方法一样，通过数组的索引来查找，只不过这里得到的是函数的地址，但前面说过，函数名就是函数地址，可以直接通过函数地址来调函数</p>
<p>还是用上面那个例子，已经将函数指针存放在函数指针数组中后，进行调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pA)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> (*pS)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Sub;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;pA, pS&#125;;</span><br><span class="line">    <span class="type">int</span> x = pa[<span class="number">0</span>](<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-34.png"></p>
<p>知道函数指针数组的使用后，就可以找一个项目来练习了。</p>
<h4 id="6-3-计数器项目"><a href="#6-3-计数器项目" class="headerlink" title="6.3 计数器项目"></a>6.3 计数器项目</h4><p>需要写一个程序，这个程序能做整型的加减乘除。</p>
<p>在没有学会函数指针数组前，写的程序应该是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">switch</span>(input)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Add(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Sub(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Mul(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:	</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Div(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这个程序可以执行，但是有很多地方有冗余(rong yu)，重复得太多是不好的，可以使用函数指针数组来代替，因为这些函数都是同样的返回类型和同样的形参，所以可以使用函数指针数组来替代</p>
<p>替代之后的程序就为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;Add, Sub, Mul, Div&#125;;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> arr_size = <span class="keyword">sizeof</span>(pa) / <span class="keyword">sizeof</span>(pa[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">if</span> (input &lt; (arr_size - <span class="number">1</span>) &amp;&amp; input != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">            res = (pa[input - <span class="number">1</span>])(num1, num2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;res = %d\n&quot;</span>, res);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(input &gt; (arr_size - <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉上面的代码比之前的代码要简单且没造成冗余，这个使用了函数指针数组，通过函数指针数组存放函数地址，然后再通过函数指针数组的索引调用函数，这样就不用一直用 <code>switch</code> 和 <code>case</code> 进行反复判断，而且在后面需要增加新功能时也能很好的添加。</p>
<p>这种方法用专业的说法就是：转义表</p>
<blockquote>
<p>在《C和指针》中提到</p>
</blockquote>
<h4 id="6-4-取函数指针数组的地址"><a href="#6-4-取函数指针数组的地址" class="headerlink" title="6.4 取函数指针数组的地址"></a>6.4 取函数指针数组的地址</h4><p>之前学数组的时候知道，数组名就是数组地址，只要是地址就可以用指针来接收</p>
<p>比如说有一个整型变量 <code>a</code> ，可以使用一个整型指针来进行接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* pa = &amp;a;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向【整型】的指针</p>
</blockquote>
<p>比如说现在有一个数组，需要获得这个数组的地址，可以使用数组指针来进行接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> (*pa)[<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向【数组】的指针</p>
</blockquote>
<p>再比如说有一个指针数组，需要获取指针数组的地址，可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* arr[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* (*pa)[<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向【整型指针的数组】的指针</p>
</blockquote>
<p>那现在有一个函数指针，取它的地址值，用函数指针数组来接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (* pa[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) = &amp;pa</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向函数指针的数组</p>
</blockquote>
<p>那现在需要将函数指针数组的地址取出来，用一个指针来接收地址，那这个类型该如何写呢？</p>
<p>现在一步一步进行分析</p>
<p>有一个函数指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* pa[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>取这个数组的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;pa;</span><br></pre></td></tr></table></figure>

<p>用一个指针进行接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*ppa = &amp;pa;</span><br></pre></td></tr></table></figure>

<p>但这个类型应该为函数指针的数组，所以类型应该为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* [<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>如果直接把指针名加到后面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* [<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) (*ppa);</span><br></pre></td></tr></table></figure>

<p>是不可以的，可以参考5.4，所以应该写为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* (*ppa)[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) = &amp;pa;</span><br></pre></td></tr></table></figure>

<p><strong>本节内容了解即可</strong></p>
<h3 id="7-回调函数"><a href="#7-回调函数" class="headerlink" title="7.回调函数"></a>7.回调函数</h3><h4 id="7-1-什么是回调函数"><a href="#7-1-什么是回调函数" class="headerlink" title="7.1 什么是回调函数"></a>7.1 什么是回调函数</h4><p>回调函数可以理解为函数的形参是函数指针，并且在函数中调用函数指针。</p>
<p>例如有一个a函数，需要它在b函数中使用</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-35.png"></p>
<p>它的传送就是这个样子。</p>
<h4 id="7-2-计算器-回调函数"><a href="#7-2-计算器-回调函数" class="headerlink" title="7.2 计算器(回调函数)"></a>7.2 计算器(回调函数)</h4><p>继续使用6.3的计数器的例子，这里使用的是没有进行优化的版本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">switch</span>(input)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Add(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Sub(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Mul(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:	</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Div(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有用函数指针数值进行优化的例子中有好多地方冗余，其实可以把冗余的部分放在一个函数中，使用的时候直接调用函数即可。</p>
<p>但在每一行都调了不同的函数，所以就需要使用回调函数在重新定义的函数中调用</p>
<p>优化后的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Cope</span><span class="params">(<span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>))</span>&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">    <span class="keyword">return</span> pa(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">switch</span>(input)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                res = Cope(&amp;Add);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                res = Cope(&amp;Sub);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                res = Cope(&amp;Mul);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:	</span><br><span class="line">                res = Cope(&amp;Div);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-快速排序函数"><a href="#8-快速排序函数" class="headerlink" title="8.快速排序函数"></a>8.快速排序函数</h3><p>在讲数值的时候讲到了一个冒泡排序的算法，但这种方法只能对整型数组进行排序，无法对其他类型进行排序，所以要介绍一种可以对任意类型进行排序的函数 <code>qsort</code></p>
<h4 id="8-1-qsort-的结构"><a href="#8-1-qsort-的结构" class="headerlink" title="8.1 qsort 的结构"></a>8.1 <code>qsort</code> 的结构</h4><p>在学习一个函数时，需要了解这个函数的形参和返回值。</p>
<p>可以通过 <code>cplusplus</code> 网站来查找这个函数的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span> <span class="params">(<span class="type">void</span>* base, <span class="type">size_t</span> num, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span>*,<span class="type">const</span> <span class="type">void</span>*))</span>;</span><br></pre></td></tr></table></figure>

<p>上面的就是 <code>qsort</code> 函数的形参，现在一步一步分析，等后面就可以自己仿照写一个 <code>qsort</code> 函数了。</p>
<p>首先看第一个形参 <code>base</code>，是一个无类型的指针，因为函数一开始的设计者考虑到使用者可能会使用其他类型的值，所以直接就使用无类型的指针来接收。而这个接收的是需要排序的数组&#x2F;结构体的地址</p>
<p>再看第二个形参 <code>num</code>，这个参数的功能是接收数组的长度的，之前在写冒泡排序的时候也有这一个参数。</p>
<p>第三个形参 <code>size</code>，这个函数的第一个形参接收的是一个无类型的指针，不是指定形式的指针，没办法通过+1来查找下一个数，所以需要用户提交一下这个数组类型的大小。</p>
<p>最后一个形参是一个函数指针，指向的函数的返回值为 <code>int</code>，两个形参都为无符号的指针。这个是需要用户自己写一个函数然后传进去，这个函数的功能主要是提供一个判断数，用这个判断数来决定是用升序还是降序，而返回的值要么大于1(&gt;1)，要么等于1(&#x3D;1)，要么小于1(&lt;1)。</p>
<p>上面的内容可以会容易迷糊，所以举个使用例子</p>
<h4 id="8-2-qsort-的使用-数组"><a href="#8-2-qsort-的使用-数组" class="headerlink" title="8.2 qsort 的使用(数组)"></a>8.2 <code>qsort</code> 的使用(数组)</h4><p>先拿一个<code>int</code>型的数组来进行一下排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中调用一下 <code>qsort</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    qsort();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就需要传函数的参数了，第一个参数是一个指针，所以需要把数组名传入，第二个是数组的长度，所以需要使用 <code>sizeof</code> 来计算，并传进去，第三个参数是类型的大小，也可以用 <code>sizeof</code> 来计算，所以前3个参数可以这么写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最难写的是第四个参数，需要使用者自己写一个判断函数，在官方文档中的写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">int</span>*)pa) - *((<span class="type">int</span>*)pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下，因为无类型的指针没有办法取得对应位置的值，所以需要强制类型转换一下，把类型转换成数组的类型进行计算，计算完后需要取到返回值，得到返回值后就可以进行排序了。</p>
<p>完善一下写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">int</span>*)pa) - *((<span class="type">int</span>*)pb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在dev++中演示一下运行的结果</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-36.png"></p>
<p>如果这个函数只能对整型或者浮点型进行排序的话，就没有必要花时间来说了。</p>
<p>现在来对字符数组进行一下排序</p>
<h4 id="8-3-qsort-的使用-字符数组"><a href="#8-3-qsort-的使用-字符数组" class="headerlink" title="8.3 qsort 的使用(字符数组)"></a>8.3 <code>qsort</code> 的使用(字符数组)</h4><p>在C语言中，存放字符其实是存放该字符的ASCII码，所以字符也是可以比较大小的，还是按照上面的写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">char</span>*)pa - *(<span class="type">char</span>*)pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[] = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), i;</span><br><span class="line">    qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-37.png"></p>
<p>现在来测试一下结构体中的数组的排序</p>
<h4 id="8-4-qsort-的使用-结构体"><a href="#8-4-qsort-的使用-结构体" class="headerlink" title="8.4 qsort 的使用(结构体)"></a>8.4 <code>qsort</code> 的使用(结构体)</h4><p>结构体中的数组的排列和上面的一样，先创建出一个记录学生消息的结构体 <code>Stu</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>name</code> 用于存放学生的名字</p>
<p><code>age</code> 用来存放年龄</p>
<p>之后写主函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&#x27;b&#x27;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>&#125;&#125;;<span class="comment">//1</span></span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);<span class="comment">//2</span></span><br><span class="line">    qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %d\n&quot;</span>, stu[i].name, stu[i].age);<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个语句是创建一个结构体类型的数组 <code>stu</code> 并赋值</p>
<p>第二条语句是获取结构体数组的长度。</p>
<p>第三条语句就是调用一下 <code>qsort</code> 函数来进行排序，其中 <code>cmp</code> 函数的内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa)-&gt;age - ((<span class="keyword">struct</span> Stu*)pb)-&gt;age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为传入的是结构体，所以要按照结构体的写法来进行书写，需要对年龄进行排序，就调用 <code>age</code> ，如果需要对名字进行排序就调用  <code>name</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa)-&gt;name - ((<span class="keyword">struct</span> Stu*)pb)-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到上面，第四条语句是将结果打印出来，方便观察数据是否被修改。</p>
<p>上面的名字只是一个字符，如果按照真实的情况下，名字是一个字符串，如果要对字符串名字进行排序，那该如何写呢？</p>
<h4 id="8-5-qsort-的使用-结构体更改"><a href="#8-5-qsort-的使用-结构体更改" class="headerlink" title="8.5 qsort 的使用(结构体更改)"></a>8.5 <code>qsort</code> 的使用(结构体更改)</h4><p>现在需要结构体中的 <code>name</code> 存放字符串，所以要对结构体进行一下修改，只需要把它变成一个数组即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要介绍一个比较字符串大小的一个函数 <code>strcmp</code></p>
<h5 id="8-5-1-strcmp"><a href="#8-5-1-strcmp" class="headerlink" title="8.5.1 strcmp"></a>8.5.1 <code>strcmp</code></h5><p>比较字符的内核就是比较它们之间的ASCII码值，而比较字符串的办法也是一样的，只不过比较繁琐，不适合在开发中花时间写，所以C语言的工程师很贴心的写好了比较字符串的函数，用户可以直接使用</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-68.png"></p>
<p>继续回到上面，现在已经学会了 <code>strcmp</code> 函数后，可以使用三种办法来解决上面的问题</p>
<h5 id="8-5-2-第一种办法"><a href="#8-5-2-第一种办法" class="headerlink" title="8.5.2 第一种办法"></a>8.5.2 第一种办法</h5><p>第一种办法就是直接调用 <code>strcmp</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(((<span class="keyword">struct</span> Stu*)pa)-&gt;name, ((<span class="keyword">struct</span> Stu*)pb) -&gt; name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&quot;aike&quot;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&quot;js&quot;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&quot;sjd&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);</span><br><span class="line">    qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, stu[i].name, stu[i].age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>strcmp</code> 的返回值是1，-1，0，所以直接就可以返回。</p>
<h5 id="8-5-3-第二种方法"><a href="#8-5-3-第二种方法" class="headerlink" title="8.5.3 第二种方法"></a>8.5.3 第二种方法</h5><p>直接使用 <code>-</code> 来获得</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa)-&gt;name - ((<span class="keyword">struct</span> Stu*)pb)-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&quot;aike&quot;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&quot;js&quot;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&quot;sjd&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);</span><br><span class="line">    qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, stu[i].name, stu[i].age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法也可以得到排序的结果。</p>
<h5 id="8-5-4-第三种方法"><a href="#8-5-4-第三种方法" class="headerlink" title="8.5.4 第三种方法"></a>8.5.4 第三种方法</h5><p>这种方法特别不推荐，这种方法主要是让自己写一个 <code>strcmp</code> 函数来使用，觉得麻烦的可以直接跳过</p>
<p><code>strcmp</code> 主要是对字符串进行比较，传入的值主要是字符型的数组，所以自己写的 <code>my_strcmp</code> 的形参为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_strcmp(<span class="type">const</span> <span class="type">char</span>* pa, <span class="type">const</span> <span class="type">char</span>* pb)</span><br></pre></td></tr></table></figure>

<p>在测试 <code>strcmp</code> 函数的时候，它的返回值只有3种情况，并且都是 <code>int</code> 型的，所以返回值的类型就应该为 <code>int</code> ，再完善一下写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa, <span class="type">const</span> <span class="type">char</span>* pb)</span></span><br></pre></td></tr></table></figure>

<p>现在要对函数内部功能开始书写</p>
<p>要模仿前先要确定一下 <code>strcmp</code> 如何判断哪一条字符串大，判断字符串的大小其实就是单个字符的比较，如果 <code>str1</code> 中有一个位置上的字符比 <code>str2</code> 同位置的字符大，则返回1，如果等于返回0。</p>
<p>还有一点就是需要找到最大的字符串来比较，如果 <code>str1</code> 终止了但 <code>str2</code> 还有字符，就会出现问题，所以需要在函数中添加一下判断长度的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, num_a = <span class="number">0</span>, num_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pa + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_a = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pb + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_b = i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这串代码很容易理解，它的本质就是遍历数组，把数组的长度获取，可以便于使用</p>
<p>有了长度之后就可以对数组进行遍历比值了，比较的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= ((num_a &gt; num_b)?num_a:num_b); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*(pa + i) &gt; *(pb + i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*(pa + i) &lt; *(pb + i))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>for</code> 循环中使用了一下三元运算符来判断最大的长度，这样可以有效的避免短的数组没有长度而结束判断了</p>
<p>在 <code>for</code> 循环中有两个判断条件，一个是大于一个是小于，如果在字符串中找到一个值如果大或者小就直接结束函数。</p>
<p>如果都相等就在外面结束函数。</p>
<p>全部代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa, <span class="type">const</span> <span class="type">char</span>* pb)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, num_a = <span class="number">0</span>, num_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pa + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_a = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pb + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_b = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= ((num_a &gt; num_b)?num_a:num_b); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*(pa + i) &gt; *(pb + i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*(pa + i) &lt; *(pb + i))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>strcmp</code> 和我们写的 <code>my_strcmp</code> 进行一下比较<br><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-69.png"></p>
<p>结果一样的，自己写的 <code>my_strcmp</code> 成功了，然后把这个带进去就能得到第三种方法了</p>
<h4 id="8-6-my-qsort"><a href="#8-6-my-qsort" class="headerlink" title="8.6 my_qsort"></a>8.6 <code>my_qsort</code></h4><p>这一节从 <code>qsort</code> 函数来分析并写出一个 <code>my_qsort</code> 函数</p>
<p>回顾学过的排序算法，就只有冒泡好用，所以这里使用冒泡排序作为 <code>my_qsort</code> 的排序方法。</p>
<p>知道使用什么方法进行排序后，要确定函数的形参如何书写。第一个形参可以作为需要比较的内容的指针，但不确定传入的是什么类型的数组的地址，所以可以用 <code>void</code> 类型来接收。</p>
<p>然后再传入数组的长度和步长还有判断数即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span>(*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span></span><br></pre></td></tr></table></figure>

<p>函数的形参写好了</p>
<blockquote>
<p>加上 <code>const</code> 是为了不改变变量的值</p>
</blockquote>
<p>现在需要的是完成函数内部的功能，用冒泡排序的办法就要设计2个循环变量，一个是计循环的次数的，另一个是索引位数，所以内部写法就为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span>(*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内容的结构就完成了，现在要加上判断条件，通过判断数来决定，这里写的是 <code>&gt;0</code> ，你自己写也可以写成 <code>&lt;0</code> ，只不过用户写的判断函数就会改动一下。</p>
<p>如果把第j个元素和第j+1个元素带入到判断函数中，如果 <code>&gt;0</code> 就进行交换，否则就不进行什么操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span>(*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp((<span class="type">char</span>*)p + j * width, (<span class="type">char</span>*)p + (j+<span class="number">1</span>)*width))&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要把判断数带入用户写的判断函数中，因为不知道是什么类型的数，无法用加来查找下一个元素，所以这里就需要让数变成一个字节长度小的类型来进行加运算</p>
<p>这里现在了 <code>char</code> ，因为一个 <code>char</code> 类型只有一个字节长度，用 <code>char</code> 类型加上1再乘类型长度，这样就可以找到下一个元素的位置</p>
<p>进入循环后就要进行交换，交换代码放在一个函数 <code>Spack</code> 中，和之前冒泡一样的写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Spack</span><span class="params">(<span class="type">char</span>* pa, <span class="type">char</span>* pb, <span class="type">int</span> width)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; width - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp = *(pa + i);</span><br><span class="line">        *(pa + i) = *(pb + i);</span><br><span class="line">        *(pb + i) = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在前面把 <code>void</code> 类型的全部强制类型转换成 <code>char</code> 了，传入交换函数的类型也为 <code>char</code> 类型的，加1只能移动1位，如果是 <code>int</code> 类型的，加1只能移动一位，但它有4个位，所以这使用循环长度，然后把所有位都交换。</p>
<p>完善一下函数的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Spack</span><span class="params">(<span class="type">char</span>* pa, <span class="type">char</span>* pb, <span class="type">int</span> width)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; width; i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp = *(pa + i);</span><br><span class="line">        *(pa + i) = *(pb + i);</span><br><span class="line">        *(pb + i) = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp((<span class="type">char</span>*)p + j * width, (<span class="type">char</span>*)p + (j+<span class="number">1</span>) * width) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                Spack(((<span class="type">char</span>*)p + j * width), ((<span class="type">char</span>*)p + (j+<span class="number">1</span>) * width), width);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在对函数进行一下调试，用 <code>int</code> 型的数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)pa - *(<span class="type">int</span>*)pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    my_qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-70.png"></p>
<p>测试一下结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa) -&gt; age - ((<span class="keyword">struct</span> Stu*)pb) -&gt; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&quot;zdw&quot;</span>, <span class="number">18</span>&#125;, &#123;<span class="string">&quot;djs&quot;</span>, <span class="number">54</span>&#125;, &#123;<span class="string">&quot;sdx&quot;</span>, <span class="number">14</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    my_qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, stu[i].age, stu[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-71.png"></p>
<p>试试用名字进行排序</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%5C1-72.png"></p>
<h3 id="9-指针和数组的练习题"><a href="#9-指针和数组的练习题" class="headerlink" title="9.指针和数组的练习题"></a>9.指针和数组的练习题</h3><h4 id="9-1-一维数组"><a href="#9-1-一维数组" class="headerlink" title="9.1 一维数组"></a>9.1 一维数组</h4><h5 id="9-1-1-第一题"><a href="#9-1-1-第一题" class="headerlink" title="9.1.1 第一题"></a>9.1.1 第一题</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br></pre></td></tr></table></figure>

<p>在程序中执行的结果</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-1.png"></p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-2.png"></p>
<p>**分析：**第一个 <code>sizeof(a)</code> 语句是输出整个数组的长度，该数组是一个长度为4的数组，每个元素的大小为4为，所以整个数组的长度就为16</p>
<p><code>sizeof(a + 0) </code> 输出的是8，在学数组的时候知道，数组的首元素是该数组的地址，现在使用地址+1，就是获取地址的长度，在32位机中，地址长为4，64位中，地址长度为8.</p>
<p><code>sizeof(*a)</code> 这个就是地址的解引用，数组的地址为首元素的地址，所以这里计算的是数组第一个元素的长度，就为4。</p>
<p><code>sizeof(a + 1)</code> 和上面的a+0一个道理</p>
<p><code>sizeof(a[1])</code> 这个就是去索引位置</p>
<h5 id="9-1-2-第二题"><a href="#9-1-2-第二题" class="headerlink" title="9.1.2 第二题"></a>9.1.2 第二题</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br></pre></td></tr></table></figure>

<p>在电脑上执行一下</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-3.png"></p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-4.png"></p>
<p><strong>分析：</strong> <code>sizeof(&amp;a)</code> 获得的是数组地址的大小，在之前学过，&amp;数组名获得的是整个数组的地址，所以这里输出的是8（在64位）</p>
<p><code>sizeof(*&amp;a)</code> 先是取数组整个的地址，然后再用 <code>*</code> 解引用，得到的就是数组第一个元素，然后再输出长度，得到的就是4</p>
<p>其他的都是一样的道理，得到的就是地址的大小</p>
<h4 id="9-2-字符数组"><a href="#9-2-字符数组" class="headerlink" title="9.2 字符数组"></a>9.2 字符数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr + <span class="number">0</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>] + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-5.png"></p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-6.png"></p>
<h4 id="9-3-字符串数组"><a href="#9-3-字符串数组" class="headerlink" title="9.3 字符串数组"></a>9.3 字符串数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr + <span class="number">0</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>] + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-7.png"></p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-8.png" alt="1-8"></p>
<h4 id="9-4-字符指针"><a href="#9-4-字符指针" class="headerlink" title="9.4 字符指针"></a>9.4 字符指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p = <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p[<span class="number">0</span>] + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-9.png"></p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-10.png" alt="1-10"></p>
<h4 id="9-5-二维数组"><a href="#9-5-二维数组" class="headerlink" title="9.5 二维数组"></a>9.5 二维数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(a[<span class="number">0</span>] + <span class="number">1</span>)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(a + <span class="number">1</span>)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(&amp;a[<span class="number">0</span>] + <span class="number">1</span>)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">3</span>]));</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-11.png"></p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0%5C1-12.png" alt="1-12"></p>
<h3 id="10、指针练习题"><a href="#10、指针练习题" class="headerlink" title="10、指针练习题"></a>10、指针练习题</h3><h4 id="10-1-一维数组"><a href="#10-1-一维数组" class="headerlink" title="10.1 一维数组"></a>10.1 一维数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)(&amp;a + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h4 id="10-2-结构体"><a href="#10-2-结构体" class="headerlink" title="10.2 结构体"></a>10.2 结构体</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span>* pcNumber;</span><br><span class="line">    <span class="type">short</span> sDate;</span><br><span class="line">    <span class="type">char</span> cha[<span class="number">2</span>];</span><br><span class="line">    <span class="type">short</span> sBa[<span class="number">4</span>];</span><br><span class="line">&#125;* p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">0x1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)p + <span class="number">0x1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>*)p + <span class="number">0x1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//设p中存放的地址为0x10000</span></span><br></pre></td></tr></table></figure>

<p>这道题考察的是指针的运算方法，先看这个结构体的大小为20个字节，指针p是结构体的指针。</p>
<p>第一步先将 <code>p + 0x1</code>，也就是让指针p跳过一个结构体，跳过20个字节，所以输出的地址就为 <code>0x10014</code></p>
<p>第二步将结构体指针p强制类型转换为 <code>unsigned long</code> 类型，现在指针p变成了整型p，整型+1，而地址不会改变</p>
<p>第三步将结构体指针p强制类型转换为无符号的整型指针类型，用无符号整型指针+1跳过的就是整个整型指针的长度，而整型指针的长度为4个字节，所以输出的地址为0x10004。</p>
<h4 id="10-3-二维数组"><a href="#10-3-二维数组" class="headerlink" title="10.3 二维数组"></a>10.3 二维数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123;(<span class="number">0</span>,<span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>,<span class="number">5</span>)&#125;;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题考察的是逗号表达式，真正存放在这二维数组中的格式为：<code>&#123;&#123;1,3&#125;,&#123;5,0&#125;,&#123;0,0&#125;&#125;</code></p>
<h4 id="10-4-复杂模式"><a href="#10-4-复杂模式" class="headerlink" title="10.4 复杂模式"></a>10.4 复杂模式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> (*p) [<span class="number">4</span>];</span><br><span class="line">    p = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %d\n&quot;</span>, &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>], &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题考察的是指针互相-和数组指针指向的关系。</p>
<h2 id="三、字符串函数和内存函数"><a href="#三、字符串函数和内存函数" class="headerlink" title="三、字符串函数和内存函数"></a>三、字符串函数和内存函数</h2><h3 id="1-模拟实现字符串函数"><a href="#1-模拟实现字符串函数" class="headerlink" title="1.模拟实现字符串函数"></a>1.模拟实现字符串函数</h3><h4 id="1-1-strlen"><a href="#1-1-strlen" class="headerlink" title="1.1 strlen"></a>1.1 strlen</h4><p>对于查看字符串长度的函数有3中模拟的写法</p>
<h5 id="第一种-2"><a href="#第一种-2" class="headerlink" title="第一种"></a>第一种</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    assert(pa != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(*pa != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        pa++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二种-2"><a href="#第二种-2" class="headerlink" title="第二种"></a>第二种</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa)</span>&#123;</span><br><span class="line">    assert(pa != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (*pa != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + my_strlen(pa + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-内存函数"><a href="#2-内存函数" class="headerlink" title="2.内存函数"></a>2.内存函数</h3><p>其实内存函数就是对数组的拷贝，属于深拷贝的范畴，之前已经讲过深拷贝了，这里就不多说了。</p>
<h2 id="四、结构体提高"><a href="#四、结构体提高" class="headerlink" title="四、结构体提高"></a>四、结构体提高</h2><p>在之前的学习了一下结构体的基本使用，这一节主要是学习一下结构体更多的用法</p>
<h3 id="1-结构体中的数组赋值"><a href="#1-结构体中的数组赋值" class="headerlink" title="1.结构体中的数组赋值"></a>1.结构体中的数组赋值</h3><p>先看下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">60</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在一个结构体中存放着一个字符型数组，现在要对它进行赋值只能使用初始化值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span> =</span> &#123;<span class="string">&quot;tom&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果要单独对结构体中的数组进行赋值，使用 <code>=</code> 是会报错的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    p1.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这里需要使用到字符拷贝函数 <code>strcpy</code> ，在使用的时候一定要引头文件 <code>string.h</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">60</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以单独修改结构体中的数组内的元素。</p>
<h3 id="2-结构体中的深浅拷贝"><a href="#2-结构体中的深浅拷贝" class="headerlink" title="2.结构体中的深浅拷贝"></a>2.结构体中的深浅拷贝</h3><h4 id="2-1-堆区操作函数"><a href="#2-1-堆区操作函数" class="headerlink" title="2.1 堆区操作函数"></a>2.1 堆区操作函数</h4><p>在学习之前，先了解一下在C语言中将数据存放在堆区的几个函数</p>
<h5 id="2-1-1-malloc"><a href="#2-1-1-malloc" class="headerlink" title="2.1.1 malloc"></a>2.1.1 malloc</h5><p>这个函数是属于 <code>stdlib.h</code> 头文件的函数，函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态的开辟一块size大小的空间，并返回该内存的地址，如果出现错误则会返回NULL。</p>
<h5 id="2-1-2-calloc"><a href="#2-1-2-calloc" class="headerlink" title="2.1.2 calloc"></a>2.1.2 calloc</h5><p>该函数所属的头文件也是 <code>stdlib.h</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> n, <span class="type">unsigned</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态分配n个长度为size的内存空间，并返回开辟空间的首地址，如果发生错误，则返回NULL。</p>
<h5 id="2-1-3-free"><a href="#2-1-3-free" class="headerlink" title="2.1.3 free"></a>2.1.3 free</h5><p>该函数也是属于 <code>stdlib.h</code> 头文件中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数是将指针ptr指向的内存释放出来。</p>
<h4 id="2-2-结构体的浅拷贝"><a href="#2-2-结构体的浅拷贝" class="headerlink" title="2.2 结构体的浅拷贝"></a>2.2 结构体的浅拷贝</h4><p>比如下面的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">60</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span> =</span> &#123;<span class="string">&quot;tom&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span> =</span> &#123;<span class="string">&quot;alax&quot;</span>, <span class="number">19</span>&#125;;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\n&quot;</span>, p1.name, p1.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\n&quot;</span>, p2.name, p2.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种是将p2中的内容逐字逐句的拷贝到p1中</p>
<p>而如果将结构体中的name开辟到堆区，然后再使用 <code>=</code> 进行拷贝，然后使用完再将堆区的内容释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>;</span></span><br><span class="line">    p1.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p1.name)*<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    p1.age = <span class="number">18</span>;</span><br><span class="line">    p2.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2.name)*<span class="number">120</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p2.name, <span class="string">&quot;alax&quot;</span>);</span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    <span class="keyword">if</span> (p1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1.name);</span><br><span class="line">        p1.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p2.name);</span><br><span class="line">        p2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码会导致程序崩溃，为什么会导致整个情况，原因就是深拷贝和浅拷贝的问题</p>
<h4 id="2-3-结构体的深拷贝"><a href="#2-3-结构体的深拷贝" class="headerlink" title="2.3 结构体的深拷贝"></a>2.3 结构体的深拷贝</h4><p>在上一节讲到了直接使用 <code>=</code> 将p1中的内容浅拷贝到p2中，这种是结构体中的内容存放到栈区才能使用这种拷贝方法，但如果是在堆区的内容使用浅拷贝就会导致报错</p>
<p>拿上面的代码来说：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>;</span></span><br><span class="line">    p1.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p1.name)*<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    p1.age = <span class="number">18</span>;</span><br><span class="line">    p2.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2.name)*<span class="number">120</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p2.name, <span class="string">&quot;alax&quot;</span>);</span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    <span class="keyword">if</span> (p1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1.name);</span><br><span class="line">        p1.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p2.name);</span><br><span class="line">        p2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先分配出 <code>sizeof(p1.name)*60</code> 的空间到堆区，执行完语句之后会返回出该堆区的地址，然后将返回的地址放在 <code>p1.name</code> 中，p2也是，只不过存放的是 <code>sizeof(p2.name)*120</code> 大小的堆空间中。</p>
<p>接下来执行 <code>p1 = p2</code> ，是将p2中的内容逐条放入p1中，这里也包括开辟的堆区空间，后面就进入释放堆区内存了，因为p1中的name存放的是p2中name存储的地址，在释放时p1先释放了那块区域，p2后面又释放了那块区域的地址，导致重复释放了。</p>
<p>为了解决这个问题，就需要使用到深拷贝的方法了，这种方法就是先将p1中的name中存放的地址释放，然后再开辟一块空间，将p2 name中存放的值放到那块新开辟的空间，然后把那块空间的地址存放到p1.name中，这样就可以避免重复释放的问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deep_copy</span><span class="params">(<span class="keyword">struct</span> Person* p1, <span class="keyword">struct</span> Person* p2)</span>&#123;</span><br><span class="line">    <span class="comment">//深拷贝函数</span></span><br><span class="line">    <span class="keyword">if</span> (p1-&gt;name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1-&gt;name); <span class="comment">//先释放原来p1中堆区地址</span></span><br><span class="line">        p1-&gt;name = <span class="literal">NULL</span>; <span class="comment">//避免空指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    p1-&gt;name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2-&gt;name)*<span class="number">120</span>);<span class="comment">//重新开辟空间</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1-&gt;name, p2-&gt;name);</span><br><span class="line">    p1-&gt;age = p2-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>;</span></span><br><span class="line">    p1.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p1.name)*<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    p1.age = <span class="number">18</span>;</span><br><span class="line">    p2.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2.name)*<span class="number">120</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p2.name, <span class="string">&quot;alax&quot;</span>);</span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    deep_copy(&amp;p1, &amp;p2);</span><br><span class="line">    <span class="keyword">if</span> (p1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1.name);</span><br><span class="line">        p1.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p2.name);</span><br><span class="line">        p2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码运行后就会达到指定的效果且不会崩。</p>
<h2 id="五、结构体和共用体"><a href="#五、结构体和共用体" class="headerlink" title="五、结构体和共用体"></a>五、结构体和共用体</h2><h3 id="1-结构体的嵌套"><a href="#1-结构体的嵌套" class="headerlink" title="1.结构体的嵌套"></a>1.结构体的嵌套</h3><p>这里是对结构体的一个补充，在一个结构体中又有一个结构体，这个就叫做结构体的嵌套。</p>
<p>比如说有一个物品它是由零件1、零件2、零件3、零件4组成，但在零件4中又包含着小零件1、小零件2、小零件3，用代码表示出来为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> short_part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_3[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">goods</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_3[<span class="number">10</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> <span class="title">p4</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化值的写法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> short_part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_3[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">goods</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_3[<span class="number">10</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> <span class="title">p4</span>;</span></span><br><span class="line">&#125; g = &#123; <span class="string">&quot;luosi&quot;</span>, <span class="string">&quot;jigai&quot;</span>, <span class="string">&quot;suiji&quot;</span>, &#123;<span class="string">&quot;xiao&quot;</span>, <span class="string">&quot;da&quot;</span>, <span class="string">&quot;op&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>如果要给 <code>part_4</code> 中的内容重新赋值是不可以的，只能使用字符串函数 <code>strcpy</code> 但是这个在不同的编译器上可以执行操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">part_4</span> &#123;</span><br><span class="line">    <span class="type">char</span> short_part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_3[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">goods</span> &#123;</span><br><span class="line">    <span class="type">char</span> part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_3[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">part_4</span> p4;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">goods</span> g = &#123; <span class="string">&quot;luosi&quot;</span>, <span class="string">&quot;jigai&quot;</span>, <span class="string">&quot;suiji&quot;</span>, &#123;<span class="string">&quot;xiao&quot;</span>, <span class="string">&quot;da&quot;</span>, <span class="string">&quot;op&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(g.part_1, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, g.part_1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><p>在之前学数组的时候知道，在定义数组时需要先固定好数组的长度，这样会面临着一个问题就是如果该数组定义的长度不够存储的数据长度，会导致多出来的内容无法存储。如果存储的数据少于数组的长度，就会导致内存浪费。</p>
<p>这个时候就可以使用链表来解决这些问题。</p>
<h4 id="2-1-链表概述"><a href="#2-1-链表概述" class="headerlink" title="2.1 链表概述"></a>2.1 链表概述</h4><p>链表的本质是结构体，它里面包含一个尾指针来指向下一块链表的内容，还包含一块区域来存储内容。</p>
<p>简单的链表示意图：</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E9%93%BE%E8%A1%A8%5C%E9%93%BE%E8%A1%A8%E6%A6%82%E8%BF%B0%E7%A4%BA%E6%84%8F%E5%9B%BE1.png"></p>
<p>就像是一堆小朋友手拉着手一样，第一个就是老师做指向。</p>
<p>下面简单创建一个班级的链表，而这个链表的每个节点是学生</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> cName[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span><span class="comment">//用于指向下一个节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>链表就不用担心长度会超范围了。</p>
<h4 id="2-2-静态链表"><a href="#2-2-静态链表" class="headerlink" title="2.2 静态链表"></a>2.2 静态链表</h4><p>静态链表和上面的一样，每个节点后跟着下一个节点的地址，而这个节点的地址需要手动去添加，最后一个节点的地址为NULL是为了避免空指针的产生。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s5</span> =</span> &#123;<span class="number">10</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s4</span> =</span> &#123; <span class="number">20</span>, &amp;s5 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s3</span> =</span> &#123; <span class="number">30</span>, &amp;s4 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s2</span> =</span> &#123; <span class="number">40</span>, &amp;s3 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span> =</span> &#123; <span class="number">50</span>, &amp;s2 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是实现了静态的链表，但拿到第一个节点的地址就能得到整个链表了，如何将静态链表输出出来，就是需要靠另外一个指针来辅助输出出来</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s5</span> =</span> &#123;<span class="number">10</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s4</span> =</span> &#123; <span class="number">20</span>, &amp;s5 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s3</span> =</span> &#123; <span class="number">30</span>, &amp;s4 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s2</span> =</span> &#123; <span class="number">40</span>, &amp;s3 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span> =</span> &#123; <span class="number">50</span>, &amp;s2 &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pCount</span> =</span> &amp;s1;</span><br><span class="line">    <span class="keyword">while</span> (pCount != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pCount-&gt;iNumber);</span><br><span class="line">        pCount = pCount-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现先创建一个指针用于存储第一条节点的地址，在每次变量完之后该指针又指向下一条节点的地址，直到最后一个节点，最后一个节点没有任何指向，所以地址为 <code>NULL</code> ，这样就实现了静态指针的输出。</p>
<h4 id="2-3-动态链表"><a href="#2-3-动态链表" class="headerlink" title="2.3 动态链表"></a>2.3 动态链表</h4><p>动态链表并不是像静态链表一样，每次添加元素就是用声明的方式，非常的麻烦，而动态链表是每次存入数据时使用语句开辟空间，再将数据存放链表中</p>
<p>这里先了解一下分配内存空间的三个函数</p>
<p>1.malloc</p>
<p>这个函数是属于 <code>stdlib.h</code> 头文件的函数，函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态的开辟一块size大小的空间，并返回该内存的地址，如果出现错误则会返回NULL。</p>
<p>2.calloc</p>
<p>该函数所属的头文件也是 <code>stdlib.h</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> n, <span class="type">unsigned</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态分配n个长度为size的内存空间，并返回开辟空间的首地址，如果发生错误，则返回NULL。</p>
<p>3.free</p>
<p>该函数也是属于 <code>stdlib.h</code> 头文件中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数是将指针ptr指向的内存释放出来。</p>
<p>如何创建动态的链表，其实和前面静态链表的一样，在一个链表中有节点，节点中一部分是存放数据的，另一部分是存放下一个节点的地址，创建动态链表也是依靠的是这个，而和静态不同的是，动态链表是在函数中动态分配一块内存给下一个节点，而不是我们使用声明静态的分配内存</p>
<p>动态链表的写法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student* <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNew</span>, *<span class="title">pEnd</span>;</span></span><br><span class="line">    pNew = pEnd = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Place input number\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    <span class="keyword">while</span> (pNew-&gt;iNumber != <span class="number">-1</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">            pHead = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">            pEnd-&gt;pNext = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Place input number\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Student</code> 是每个节点的结构</p>
<p>而 <code>Create</code> 为创建动态节点，首先需要创建出一个头链，头链固定不动，如果后面的节点要增加和删除只需要改变它前面一个节点中指向下一个节点的地址即可。</p>
<p>这里创建了两个指针，分别是 <code>pNew</code> 和 <code>pEnd</code> </p>
<p><code>pNew</code> 是创建出内存的指针，当每次在链表中增加一个节点时， <code>pNew</code> 就是为了接受到这一个新节点的地址。</p>
<p><code>pEnd</code> 是指向增加的节点，避免每次添加节点后又重新遍历一遍链表元素后再在最后添加，所以每一次增加都会用 <code>pEnd</code> 来记录最后一个节点的地址。</p>
<p>输出链表的方法和静态输出的方法一致</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">p</span> =</span> create();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;iNumber);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-1-链表练习1"><a href="#2-3-1-链表练习1" class="headerlink" title="2.3.1 链表练习1"></a>2.3.1 链表练习1</h5><p>新建一个班级类，每一个学生作为一个节点，每个节点的内容有学生名字和学号。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> cName[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">struct</span> Student* <span class="title function_">Create</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pEnd</span>, *<span class="title">pNew</span>;</span></span><br><span class="line">    pEnd = pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Place input name and number\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;(pNew-&gt;cName));</span><br><span class="line">    <span class="keyword">while</span> (pNew-&gt;iNumber != <span class="number">-1</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            pNew-&gt;pNext = pHead;</span><br><span class="line">            pHead = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">            pEnd-&gt;pNext = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Place input name and number\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;(pNew-&gt;cName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Student* ph)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (ph != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, ph-&gt;iNumber, ph-&gt;cName);</span><br><span class="line">        ph = ph-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">ph</span> =</span> Create();</span><br><span class="line">    Print(ph);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-增加节点"><a href="#2-4-增加节点" class="headerlink" title="2.4 增加节点"></a>2.4 增加节点</h4><p>节点的增加其实是将该节点前的指针的地址指向该节点，并让该节点的指针指向原来是一个节点的地址给它重新赋值过去即可。</p>
<h5 id="2-4-1-在头节点增加"><a href="#2-4-1-在头节点增加" class="headerlink" title="2.4.1 在头节点增加"></a>2.4.1 在头节点增加</h5><p>在头节点增加节点是一种非常简单的方法传入的参数就只需要传入一个头节点即可。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student* <span class="title function_">insert</span><span class="params">(<span class="keyword">struct</span> Student* pHead)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNew</span>;</span></span><br><span class="line">    pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    pNew-&gt;pNext = pHead;</span><br><span class="line">    pHead = pNew;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>进阶</tag>
      </tags>
  </entry>
</search>
