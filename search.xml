<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>00在linux环境下搭建stm32开发环境</title>
    <url>/2025/01/17/802f7a7d62e1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我在那天终于说服自己将系统换成了linux系统了，当换成了linux系统后我发现，keil5这个软件实在是太香了，在linux系统下面没有keil5软件，当然我可以选择使用cubeIDE,但是我写stm32都是使用的是标准库进行编写的，要我再去学HAL库实在是太麻烦了。</p>
<p>然后我研究了一个星期后终于搞定这个环境了，所以我准备写一片文章来从头开始搭建stm32的环境，因为我又把ubuntu换成了kubuntu了，所以可以重头开始搭建了。</p>
<h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><h2 id="1-arm-none-eabi-gcc"><a href="#1-arm-none-eabi-gcc" class="headerlink" title="1.arm-none-eabi-gcc"></a>1.arm-none-eabi-gcc</h2><p>这个工具是我们需要使用的编译工具，就和我们在linux中编译C语言程序一样，需要使用一个编译工具，这个工具可以编译arm芯片对应的机器码并生成<code>hex</code>文件，所以我们首先要安装一下这个工具。</p>
<p>在官网中下载适合系统的压缩包：<a href="https://developer.arm.com/downloads/-/gnu-rm">arm-none-eabi-gcc</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ed715bb624b7f119ec6020fb8798850d.png" alt="1.png"></p>
<p>我这选择的是这个安装包，然后等待下载。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/810b51fa659f38271ca717cc015c2920.png" alt="2.png"></p>
<p>下载完成后就看到有这个压缩包，我们先解压一下这个压缩包：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -jxvf gcc-arm-none-eabi-10.3-2021.10-x86_64-linux.tar.bz2</span><br></pre></td></tr></table></figure>

<p>解压出来的文件名字太长了，我们需要给它改个名字并且放在根目录下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> gcc-arm-none-eabi-10.3-2021.10 ~/gcc-arm-none-eabi</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/91fa3df7291b9357f402a392b0b7429a.png" alt="3.png"></p>
<p>然后将这个文件中的<code>bin</code>目录添加到环境变量中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>在最后一行添加：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/lavender_edgar/gcc-arm-none-eabi/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/f69050b82bf26308f01a5d7f73111530.png" alt="4.png"></p>
<p>我这用的是zsh终端，你们如果用bash终端的话是使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>然后使用下面的命令重启一下即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>如果是bash的就使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>在终端中敲入<code>arm</code>后按下tab键就可以看到有很多的补全，这就代表着安装成功了</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f1aecb460834c1106482580eb80f1c1e.png" alt="5.png"></p>
<h2 id="2-openocd"><a href="#2-openocd" class="headerlink" title="2.openocd"></a>2.openocd</h2><p>这个工具可以将hex文件通过下载器下载到单片机中，这个工具支持很多的下载工具。</p>
<p>首先先在官网上下载这个工具：<a href="https://sourceforge.net/projects/openocd/">openocd</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9a156608555b2f36a9132ab1ed40efc1.png" alt="6.png"></p>
<p>下载完成后进行解压：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -jxvf openocd-0.12.0.tar.bz2</span><br></pre></td></tr></table></figure>

<p>然后还是一样的移动改名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> openocd-0.12.0 ~/openocd</span><br></pre></td></tr></table></figure>

<p>在开始之前我们需要做几个步骤，首先安装<code>libtool</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install libtool-bin</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/671e44e4ab09609cc182ebf8c14e905e.png" alt="7.png"></p>
<p>然后安装一下<code>HIDAPI</code>库，这个是<code>CMSIS</code>需要的库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libhidapi-dev</span><br></pre></td></tr></table></figure>

<p>将<code>openocd/contrib</code>中的<code>60-openocd.rules</code>复制一份到<code>/etc/udev/rules.d/</code>中，如果不进行这个操作可能下载不进去，在复制时记得加上<code>sudo</code>。</p>
<p>之后安装一下<code>libusb++-dev</code>即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libusb++-dev</span><br></pre></td></tr></table></figure>

<p>然后我们进入到刚才解压的目录中，执行下面的命令生成<code>makefile</code>文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./configure </span><br></pre></td></tr></table></figure>

<p>如果出现下面的错误代表着你没有安装make</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/31373852073d248757270016e8e60ccd.png" alt="8.png"></p>
<p>执行<code>sudo apt install make</code>就可以了，安装完成后继续执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./configure </span><br></pre></td></tr></table></figure>

<p>然后就能生成<code>makefile</code>文件</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0c9e77061891cfc8d333591dcdaa4cd1.png" alt="10.png"></p>
<p>然后我们使用下面命令进行编译</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> make</span><br></pre></td></tr></table></figure>

<p>然后再执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<p>这样我们就安装好了<code>openocd</code>了，我们可以在<code>/usr/local/share/openocd/scripts/target</code>看到芯片配置文件</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e5dbdf3f6486d31062ad6852ec26d136.png" alt="11.png"></p>
<p>在<code>/usr/local/share/openocd/scripts/interface</code>可以看到下载器配置文件</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e5dd68430bcb2fb9413e466b00133b48.png" alt="12.png"></p>
<p>但还没有结束，因为刚才我们执行<code>sudo ./configure</code>时出现了一个表</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2e2bd9c7d119aa3604f3dc1ad23a5ebe.png" alt="13.png"></p>
<p>可以看到只有两个适合的，我们需要添加一下<code>stlink</code>，这样才能支持，所以我们需要执行一下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./configure --enable-stlink</span><br></pre></td></tr></table></figure>

<p>我在执行的时候出现了这样一个问题</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1e16ea086129f2863d3bf355ac8f2d02.png" alt="14.png"></p>
<p>这是因为少了一个<code>pkg-config</code>，如果你也没有就需要使用下面的代码进行下载</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install pkg-config</span><br></pre></td></tr></table></figure>

<p>然后在进行生成就会发现在<code>stlink</code>后是ok了</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/70581ca48f30e5cfe2a443b4968277d5.png" alt="15.png"></p>
<p>然后再进行<code>make</code>和<code>make install</code>就可以了。</p>
<h1 id="三、创建stm32标准库工程"><a href="#三、创建stm32标准库工程" class="headerlink" title="三、创建stm32标准库工程"></a>三、创建stm32标准库工程</h1><h2 id="1-创建工程目录"><a href="#1-创建工程目录" class="headerlink" title="1.创建工程目录"></a>1.创建工程目录</h2><p>当环境安装完成后我们就可以创建stm32标准库的工程文件了，其实创建和在keil5中是一样的，只不过有些文件需要进行一下改变。</p>
<p>首先到官网下载标准库文件：<a href="https://www.st.com/zh/embedded-software/stm32-standard-peripheral-libraries.html">标准库</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2ab4960f54e28e718bf115800666197b.png" alt="16.png"></p>
<p>然后创建一个文件夹用来存放项目文件，然后就可以开始移动了，这里可以直接使用图形化界面来进行移动要简单一点，这里我的项目格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── doc</span><br><span class="line">├── lib</span><br><span class="line">│   ├── CMSIS</span><br><span class="line">│   │   ├── core_cm3.c</span><br><span class="line">│   │   ├── core_cm3.h</span><br><span class="line">│   │   ├── startup</span><br><span class="line">│   │   │   ├── startup_stm32f10x_cl.s</span><br><span class="line">│   │   │   ├── startup_stm32f10x_hd.s</span><br><span class="line">│   │   │   ├── startup_stm32f10x_hd_vl.s</span><br><span class="line">│   │   │   ├── startup_stm32f10x_ld.s</span><br><span class="line">│   │   │   ├── startup_stm32f10x_ld_vl.s</span><br><span class="line">│   │   │   ├── startup_stm32f10x_md.s</span><br><span class="line">│   │   │   ├── startup_stm32f10x_md_vl.s</span><br><span class="line">│   │   │   └── startup_stm32f10x_xl.s</span><br><span class="line">│   │   ├── stm32f10x.h</span><br><span class="line">│   │   ├── system_stm32f10x.c</span><br><span class="line">│   │   └── system_stm32f10x.h</span><br><span class="line">│   └── FWlib</span><br><span class="line">│       ├── inc</span><br><span class="line">│       │   ├── misc.h</span><br><span class="line">│       │   ├── stm32f10x_adc.h</span><br><span class="line">│       │   ├── stm32f10x_bkp.h</span><br><span class="line">│       │   ├── stm32f10x_can.h</span><br><span class="line">│       │   ├── stm32f10x_cec.h</span><br><span class="line">│       │   ├── stm32f10x_crc.h</span><br><span class="line">│       │   ├── stm32f10x_dac.h</span><br><span class="line">│       │   ├── stm32f10x_dbgmcu.h</span><br><span class="line">│       │   ├── stm32f10x_dma.h</span><br><span class="line">│       │   ├── stm32f10x_exti.h</span><br><span class="line">│       │   ├── stm32f10x_flash.h</span><br><span class="line">│       │   ├── stm32f10x_fsmc.h</span><br><span class="line">│       │   ├── stm32f10x_gpio.h</span><br><span class="line">│       │   ├── stm32f10x_i2c.h</span><br><span class="line">│       │   ├── stm32f10x_iwdg.h</span><br><span class="line">│       │   ├── stm32f10x_pwr.h</span><br><span class="line">│       │   ├── stm32f10x_rcc.h</span><br><span class="line">│       │   ├── stm32f10x_rtc.h</span><br><span class="line">│       │   ├── stm32f10x_sdio.h</span><br><span class="line">│       │   ├── stm32f10x_spi.h</span><br><span class="line">│       │   ├── stm32f10x_tim.h</span><br><span class="line">│       │   ├── stm32f10x_usart.h</span><br><span class="line">│       │   └── stm32f10x_wwdg.h</span><br><span class="line">│       └── src</span><br><span class="line">│           ├── misc.c</span><br><span class="line">│           ├── stm32f10x_adc.c</span><br><span class="line">│           ├── stm32f10x_bkp.c</span><br><span class="line">│           ├── stm32f10x_can.c</span><br><span class="line">│           ├── stm32f10x_cec.c</span><br><span class="line">│           ├── stm32f10x_crc.c</span><br><span class="line">│           ├── stm32f10x_dac.c</span><br><span class="line">│           ├── stm32f10x_dbgmcu.c</span><br><span class="line">│           ├── stm32f10x_dma.c</span><br><span class="line">│           ├── stm32f10x_exti.c</span><br><span class="line">│           ├── stm32f10x_flash.c</span><br><span class="line">│           ├── stm32f10x_fsmc.c</span><br><span class="line">│           ├── stm32f10x_gpio.c</span><br><span class="line">│           ├── stm32f10x_i2c.c</span><br><span class="line">│           ├── stm32f10x_iwdg.c</span><br><span class="line">│           ├── stm32f10x_pwr.c</span><br><span class="line">│           ├── stm32f10x_rcc.c</span><br><span class="line">│           ├── stm32f10x_rtc.c</span><br><span class="line">│           ├── stm32f10x_sdio.c</span><br><span class="line">│           ├── stm32f10x_spi.c</span><br><span class="line">│           ├── stm32f10x_tim.c</span><br><span class="line">│           ├── stm32f10x_usart.c</span><br><span class="line">│           └── stm32f10x_wwdg.c</span><br><span class="line">├── makefile</span><br><span class="line">├── stm32_flash.ld</span><br><span class="line">└── user</span><br><span class="line">    ├── main.c</span><br><span class="line">    ├── stm32f10x_conf.h</span><br><span class="line">    ├── stm32f10x_it.c</span><br><span class="line">    └── stm32f10x_it.h</span><br></pre></td></tr></table></figure>

<p>其中最主要的文件是启动文件，这个启动文件是在这个路径中进行查找：<code>STM32F10x_StdPeriph_Lib_V3.6.0/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO</code>，你可以把他们全部拷贝，也可以只用一个。</p>
<p>当然一个一个的移动实在是太麻烦了，所以我写了一个sh脚本，大家可以一键移动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你是使用bash可以在上面改为!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span>=$(<span class="built_in">sudo</span> find /home/ -name <span class="string">&#x27;STM32F10x_StdPeriph_Lib_V3.6.0&#x27;</span>)</span><br><span class="line">name=test1         <span class="comment"># 这个修改为你的工程名字</span></span><br><span class="line">start_name=startup_stm32f10x_hd.s    <span class="comment"># 修改这个移动对应的启动文件，如果要移动全部文件可以写为*.s</span></span><br><span class="line"></span><br><span class="line">file_lib=(./<span class="variable">$name</span>/lib ./<span class="variable">$name</span>/lib/CMSIS ./<span class="variable">$name</span>/lib/FWlib ./<span class="variable">$name</span>/lib/CMSIS/startup)</span><br><span class="line"></span><br><span class="line">file_user=(./<span class="variable">$name</span>/user)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$local</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> ./<span class="variable">$name</span> ./<span class="variable">$name</span>/doc</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;file_lib&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;file_user&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line"><span class="built_in">touch</span> ./<span class="variable">$name</span>/makefile</span><br><span class="line"><span class="built_in">touch</span> ./<span class="variable">$name</span>/user/main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$local</span>/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/TrueSTUDIO/<span class="variable">$start_name</span> ./<span class="variable">$name</span>/lib/CMSIS/startup</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$local</span>/Libraries/CMSIS/CM3/DeviceSupport/ST/STM32F10x/*.(c|h) ./<span class="variable">$name</span>/lib/CMSIS/</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$local</span>/Libraries/CMSIS/CM3/CoreSupport/* ./<span class="variable">$name</span>/lib/CMSIS/</span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$local</span>/Libraries/STM32F10x_StdPeriph_Driver/inc ./<span class="variable">$name</span>/lib/FWlib</span><br><span class="line"><span class="built_in">cp</span> -r <span class="variable">$local</span>/Libraries/STM32F10x_StdPeriph_Driver/src ./<span class="variable">$name</span>/lib/FWlib</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$local</span>/Project/STM32F10x_StdPeriph_Template/stm32f10x_conf.h ./<span class="variable">$name</span>/user</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$local</span>/Project/STM32F10x_StdPeriph_Template/stm32f10x_it.h ./<span class="variable">$name</span>/user</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$local</span>/Project/STM32F10x_StdPeriph_Template/stm32f10x_it.c ./<span class="variable">$name</span>/user</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$local</span>/Project/STM32F10x_StdPeriph_Template/TrueSTUDIO/STM3210E-EVAL_XL/stm32_flash.ld ./<span class="variable">$name</span>/</span><br></pre></td></tr></table></figure>

<p>我很久没有写shell了，这个脚本不是很完美，大家可以感根据自己的想法进行改写。</p>
<h2 id="2-修改stm32-flash-ld文件"><a href="#2-修改stm32-flash-ld文件" class="headerlink" title="2.修改stm32_flash.ld文件"></a>2.修改stm32_flash.ld文件</h2><p>我之前在这踩了很多次坑，所以这里需要非常的注意，我们这使用的<code>stm32_flash.ld</code>文件是移植<code>STM32F103ZG</code>芯片的，因为这个<code>ld</code>文件和<code>c8t6</code>的文件差不多，所以我们选择这个作为我们的链接脚本，但并不是移植完就可以使用的，我们还需要给它修改一下。</p>
<p>这个是原始的链接文件：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8c2e79d2845ce7a3c0089756cf8bcd6b.png" alt="17.png"></p>
<p>我们需要修改的内容其实就是在最前面就可以了。</p>
<p>首先我们要将<code>_estack = 0x20018000;</code>修改为<code>_estack = ORIGIN(RAM) + LENGTH(RAM);</code>，然后将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLASH (rx)      : ORIGIN = 0x08000000, LENGTH = 1M</span><br><span class="line">RAM (xrw)       : ORIGIN = 0x20000000, LENGTH = 96K</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLASH (rx)      : ORIGIN = 0x08000000, LENGTH = 64K</span><br><span class="line">RAM (xrw)       : ORIGIN = 0x20000000, LENGTH = 20K</span><br></pre></td></tr></table></figure>

<p>然后就可以了，修改完成的内容如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b962a1b5800e787eafce6448a3738653.png" alt="18.png"></p>
<p>修改完成后我们就可以开始写makefile文件了。</p>
<h2 id="3-写makefile文件"><a href="#3-写makefile文件" class="headerlink" title="3.写makefile文件"></a>3.写makefile文件</h2><p>上面的脚本执行完后会生成一个makefile文件，我们直接用<code>vim</code>进行写入就可以了，脚本我是参考了很多文章写出来的，这里就不讲解了，直接用我写好的就可以了：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET=test	<span class="comment"># 这里是项目名，改就可以</span></span><br><span class="line">CC=arm-none-eabi-gcc</span><br><span class="line">OBJCOPY=arm-none-eabi-objcopy</span><br><span class="line">RM=rm -f</span><br><span class="line">CORE=3</span><br><span class="line">CPUFLAGS=-mthumb -mcpu=cortex-m<span class="variable">$(CORE)</span></span><br><span class="line">INCFLAGS=-I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/lib/CMSIS -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/lib/FWlib/inc -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/user</span><br><span class="line">LDFLAGS = -T stm32_flash.ld -Wl,-cref,-u,Reset_Handler -Wl,-Map=<span class="variable">$(TARGET)</span>.map -Wl,--gc-sections -Wl,--defsym=malloc_getpagesize_P=0x80 -Wl,--start-group -lc -lm -Wl,--end-group</span><br><span class="line">CFLAGS=<span class="variable">$(INCFLAGS)</span> -D STM32F10X_HD -D USE_STDPERIPH_DRIVER -Wall -g</span><br><span class="line">START_SRC=<span class="variable">$(<span class="built_in">shell</span> find ./ -name &#x27;startup_stm32f10x_hd.s&#x27;)</span></span><br><span class="line">START_OBJ=$(START_SRC:%.s=%.o)</span><br><span class="line">C_SRC=<span class="variable">$(<span class="built_in">shell</span> find ./ -name &#x27;*.c&#x27;)</span></span><br><span class="line">C_OBJ=$(C_SRC:%.c=%.o)</span><br><span class="line">INTERRFACE_CFG=/usr/local/share/openocd/scripts/interface/stlink-v2.cfg      <span class="comment"># 这里就是下载器的配置文件，可以在前面提到的文件夹中找到对应下载器的配置文件</span></span><br><span class="line">TARGET_CFG=/usr/local/share/openocd/scripts/target/stm32f1x.cfg </span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(START_OBJ)</span> <span class="variable">$(C_SRC)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$^</span> <span class="variable">$(CPUFLAGS)</span> <span class="variable">$(LDFLAGS)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$(TARGET)</span>.elf</span><br><span class="line">	<span class="variable">$(OBJCOPY)</span> <span class="variable">$(TARGET)</span>.elf <span class="variable">$(TARGET)</span>.bin</span><br><span class="line">	<span class="variable">$(OBJCOPY)</span> <span class="variable">$(TARGET)</span>.elf -Oihex <span class="variable">$(TARGET)</span>.hex</span><br><span class="line"><span class="variable">$(START_OBJ)</span>:<span class="variable">$(START_SRC)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$^</span> <span class="variable">$(CPUFLAGS)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(C_OBJ)</span>:%.o:%.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$^</span> <span class="variable">$(CPUFLAGS)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(<span class="built_in">shell</span> find ./ -name &#x27;*.o&#x27;)</span> <span class="variable">$(TARGET)</span>.*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个是一键下载，如果不是stlink下载器可以改对应的变量</span></span><br><span class="line"><span class="section">download:</span></span><br><span class="line">	openocd -f <span class="variable">$(INTERRFACE_CFG)</span> -f <span class="variable">$(TARGET_CFG)</span> -c init -c halt -c <span class="string">&quot;flash write_image erase <span class="variable">$(PWD)</span>/<span class="variable">$(TARGET)</span>.bin&quot;</span> -c reset -c shutdown</span><br></pre></td></tr></table></figure>

<h2 id="4-修改core-cm3-c"><a href="#4-修改core-cm3-c" class="headerlink" title="4.修改core_cm3.c"></a>4.修改core_cm3.c</h2><p>这个文件是需要进行修改一下的，如果你不进行修改就会报错</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1c467dbe84138240dc6484b290ffe399.png" alt="19.png"></p>
<p>这个错误需要你打开<code>core_cm3.c</code>文件，然后在第736行和753行的<code>=r</code>中添加一个<code>&amp;</code>，这样就不会报错了</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/525906bd485c1f96c068a3b3863c7170.png" alt="20.png"></p>
<h2 id="5-写main函数并下载到板子上"><a href="#5-写main函数并下载到板子上" class="headerlink" title="5.写main函数并下载到板子上"></a>5.写main函数并下载到板子上</h2><p>这一步大家应该都会吧，这里我写的main函数是点亮PB0的LED灯来进行测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		GPIO_WriteBit(GPIOB, GPIO_Pin_0, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行<code>make</code>，当编译完成后就可以执行<code>make downlocal</code>进行下载了。</p>
<p>编译的效果图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/739ef1beeb0091e410cc10dd8b8c9920.png" alt="21.png"></p>
<p>下载的效果图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f940dc3cc006d247ba784d32ad08c5ea.png" alt="22.png"></p>
<p>实物的效果：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7bf6549a8c53b32c78367f4ed00f8ab4.jpeg" alt="23.jpg"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>使用linux对stm32的开发的环境搭建就讲完了，如果大家有其他错误出现可以发在评论区，我这随时可以回答的，大家也可以关注一下我的csdn、博客园和我自己的论坛，链接放在下面了</p>
<p><a href="https://blog.lavenderedgar.asia/">Lavender Edgar的博客</a><br><a href="https://www.cnblogs.com/Lavender-edgar">博客园</a><br><a href="https://blog.csdn.net/zagzag001?type=blog">CSDN</a></p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>01使用调试工具</title>
    <url>/2025/01/17/e5d40c6790d6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前写了一篇关于在linux下搭建stm32标准库的文章后，有一些小伙伴们还是出现了一些奇奇怪怪的错误，这一篇文章就是给大家介绍一下如何调试来找到错误。</p>
<h1 id="一、用openocd打开单片机"><a href="#一、用openocd打开单片机" class="headerlink" title="一、用openocd打开单片机"></a>一、用openocd打开单片机</h1><p>我们上一节说烧录的时候是使用的是一键烧录，其实没有一键烧录还是比较复杂的，首先先执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openocd -f /usr/local/share/openocd/scripts/interface/stlink-v2.cfg -f /usr/local/share/openocd/scripts/target/stm32f1x.cfg</span><br></pre></td></tr></table></figure>

<p>然后就会将stlink给打开，这里我们可以修改一下，修改为jlink什么的都可以的，思路都是一样的，然后运行后就会显示下面的界面：</p>
<p><img src="https://img2.imgtp.com/2024/03/27/osYtkNHN.png" alt="1.png"></p>
<p>诶？怎么会出现这种情况呢？</p>
<p>噢，原来我没连接stlink,把它连接后就正常了：</p>
<p><img src="https://img2.imgtp.com/2024/03/27/zQjTR421.png" alt="2.png"></p>
<p>把这个内容拿下了看看：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Open On-Chip Debugger 0.12.0</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">For bug reports, <span class="built_in">read</span></span><br><span class="line">        http://openocd.org/doc/doxygen/bugs.html</span><br><span class="line">WARNING: interface/stlink-v2.cfg is deprecated, please switch to interface/stlink.cfg</span><br><span class="line">Info : auto-selecting first available session transport <span class="string">&quot;hla_swd&quot;</span>. To override use <span class="string">&#x27;transport select &lt;transport&gt;&#x27;</span>.</span><br><span class="line">Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD</span><br><span class="line">Info : Listening on port 6666 <span class="keyword">for</span> tcl connections</span><br><span class="line">Info : Listening on port 4444 <span class="keyword">for</span> telnet connections</span><br><span class="line">Info : clock speed 1000 kHz</span><br><span class="line">Info : STLINK V2J43S7 (API v2) VID:PID 0483:3748</span><br><span class="line">Info : Target voltage: 3.279414</span><br><span class="line">Info : [stm32f1x.cpu] Cortex-M3 r1p1 processor detected</span><br><span class="line">Info : [stm32f1x.cpu] target has 6 breakpoints, 4 watchpoints</span><br><span class="line">Info : starting gdb server <span class="keyword">for</span> stm32f1x.cpu on 3333</span><br><span class="line">Info : Listening on port 3333 <span class="keyword">for</span> gdb connections</span><br></pre></td></tr></table></figure>

<p>可以看到执行后开放了3个端口，分别是<code>4444</code>、<code>6666</code>、<code>3333</code>，4444这个端口我们可以将编译好的<code>.hex</code>文件烧录进单片机中，3333这个端口可以启用gdb调试功能。</p>
<h1 id="二、利用4444端口向单片机写入hex文件"><a href="#二、利用4444端口向单片机写入hex文件" class="headerlink" title="二、利用4444端口向单片机写入hex文件"></a>二、利用4444端口向单片机写入hex文件</h1><p>当我们打开4444端口后我们需要再打开一个终端，然后在终端中输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">telnet localhost 4444</span><br></pre></td></tr></table></figure>

<p>然后就可以连接4444端口了</p>
<p><img src="https://img2.imgtp.com/2024/03/27/eB4ZfOZe.png" alt="3.png"></p>
<p>然后输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">program test.hex</span><br></pre></td></tr></table></figure>

<p>将test.hex文件烧录进单片机中，烧录完成后还需要执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">reset</span><br></pre></td></tr></table></figure>

<p>进行重启，这样烧录的hex文件才能运行。</p>
<h1 id="三、利用3333端口和gdb进行调试"><a href="#三、利用3333端口和gdb进行调试" class="headerlink" title="三、利用3333端口和gdb进行调试"></a>三、利用3333端口和gdb进行调试</h1><p>在学linuxC的小伙伴们应该知道，在<code>gcc</code>中有一个<code>gdb</code>调试工具，但这个工具只能调试linux平台下的程序，不能调试arm平台的程序，所以我们需要使用我们上一篇文章讲过的<code>arm-none-eabi</code>工具包中的<code>arm-none-eabi-gdb</code>调试工具，利用这个工具我们可以调试我们写好的单片机程序。</p>
<p>首先还是一样的，使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openocd -f /usr/local/share/openocd/scripts/interface/stlink-v2.cfg -f /usr/local/share/openocd/scripts/target/stm32f1x.cfg</span><br></pre></td></tr></table></figure>

<p>打开我们的下载器，然后打开一个新的终端，在里面运行<code>arm-none-eabi-gdb</code>，如果出现了和我一样的错误：</p>
<p><img src="https://img2.imgtp.com/2024/03/27/mDQmasu1.png" alt="4.png"></p>
<p>可以运行一下下面的两条命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install lib32ncurses5-dev</span><br><span class="line"><span class="built_in">sudo</span> apt install libncurses5</span><br></pre></td></tr></table></figure>

<p>如果还是不行，可以去百度一下，因为我这个执行完成后就可以运行了。</p>
<p>如果你可以运行，那先退出刚才运行的<code>gdb</code>，我们还需要在<code>gdb</code>后跟东西。</p>
<p>然后我们在刚打开的终端中输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openLed arm-none-eabi-gdb test.elf</span><br></pre></td></tr></table></figure>

<p>运行后就会出现下面的界面</p>
<p><img src="https://img2.imgtp.com/2024/03/27/GaxjdVNd.png" alt="5.png"></p>
<p>这样就代表着已经进入elf文件的调试页面了，但是这个时候你还不能调试，因为你只是选择了这个文件，还没有平台可以让这个代码去运行，所以我们需要让gdb连接一下我们单片机的调试端口，输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">target remote localhost:3333</span><br></pre></td></tr></table></figure>

<p>这样就可以连接到单片机了，如果没有打断点，它会到当前执行的代码，一直执行</p>
<p><img src="https://img2.imgtp.com/2024/03/27/6PsBqEmo.png" alt="6.png"></p>
<p>我们可以输入n让它单步执行：</p>
<p><img src="https://img2.imgtp.com/2024/03/27/6JhT9Dwy.png" alt="7.png"></p>
<p>也可以用<code>b</code>来打一个断点，<code>b 行号</code>，这样就可以打断点了。</p>
<h1 id="四、之前我出的问题"><a href="#四、之前我出的问题" class="headerlink" title="四、之前我出的问题"></a>四、之前我出的问题</h1><p>我在使用linux对单片机开发前出过一个问题，后面还是这位大佬给我了一下思路</p>
<p><img src="https://img2.imgtp.com/2024/03/27/STKZ5xfo.png" alt="8.png"></p>
<p>然后我就用他们的电脑写了个简单的代码后写入到单片机中，结果发现还是没办法运行，我就知道是因为单片机出问题了，后面我又重新拿了一个再试了一下发现没有任何问题，我在这分享一下我之前的调试过程。</p>
<p>这用的是之前说的gdb调试，将写好的内容写入进单片机后我发现LED灯没有亮，然后我就启动了一下调试功能，一看</p>
<p><img src="https://img2.imgtp.com/2024/03/27/Ku0ebpc6.png" alt="9.png"></p>
<p>一直卡在<code>HardFault_Handler</code>中断中，我就去百度了一下，原来是因为硬件故障，我以为是我的启动文件出问题了，然后去百度了很多文章去找标准库的<code>ld</code>文件，看了许久也没有解决。</p>
<p>然后我又试了一下cublemx来进行生成一个<code>hal</code>库的程序，然后也不行，我就往各个方面的去考虑，后面还是做了半天也是不行，最后得出结论，这个单片机坏了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当然这个文章还是写得不是很完整，因为我只遇到了这种问题，如果你们有什么问题可以问问我，但我不一定能解决，大家可以加一下我们的讨论群：247294351，当然也不一定能解决。</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>02 IO口的操作</title>
    <url>/2025/01/17/1889a077401c/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前已经介绍了环境的搭建和调试的方法，这一篇文章我们就开始介绍一下如何对外设进行操作，这一节我会结合多种外设的操作来将所有方式的操作介绍给大家，并手把手介绍如何使用一个小显示屏OLED,这对我们后面的操作有很大的帮助。</p>
<h1 id="一、IO的概念"><a href="#一、IO的概念" class="headerlink" title="一、IO的概念"></a>一、IO的概念</h1><h2 id="1-IO接口"><a href="#1-IO接口" class="headerlink" title="1.IO接口"></a>1.IO接口</h2><p>IO接口是能让CPU和外设能够进行信息交换的逻辑电路，在stm32中，IO接口是已经集成进单片机中了，我们不需要自己搭建一个IO接口电路，可以直接就使用其中的IO接口了。</p>
<h2 id="2-IO端口"><a href="#2-IO端口" class="headerlink" title="2.IO端口"></a>2.IO端口</h2><p>IO端口是CPU可以直接访问的一些寄存器，这些寄存器可以控制外设的状态和传输一些信息。</p>
<p>我们对IO设备进行操作时其实就是对IO端口进行一些操作，只不过在stm32中，这个设备更加的高级，这个设备被称为GPIO,接下来我们就是对这些GPIO口进行操作，以达到我们控制外设的目的。</p>
<h1 id="二、CPU和外设进行数据传输的方法"><a href="#二、CPU和外设进行数据传输的方法" class="headerlink" title="二、CPU和外设进行数据传输的方法"></a>二、CPU和外设进行数据传输的方法</h1><p>这里总共有4种方法，在这一节中我都会涉及到，只不过中断和DMA我会简单的介绍，先会用，后面还会详细的介绍一下对应的内部结构。</p>
<h2 id="1-程序控制方式"><a href="#1-程序控制方式" class="headerlink" title="1.程序控制方式"></a>1.程序控制方式</h2><p>这个是由程序直接进行控制，这里有两种方法，一种是无条件，另一种是查询方式。</p>
<h3 id="1-1-无条件"><a href="#1-1-无条件" class="headerlink" title="1.1 无条件"></a>1.1 无条件</h3><p>无条件传输方式是默认外设已经是处于就绪状态，就比如我们对LED灯进行操作，就可以直接使用无条件方式，因为它已经处于就绪状态，不会有忙状态，所以可以直接进行数据的传输。</p>
<p>这种方法的特点就是程序简单，但缺点就是没办法对特别复杂的电路进行操作。</p>
<h3 id="1-2-查询方式"><a href="#1-2-查询方式" class="headerlink" title="1.2 查询方式"></a>1.2 查询方式</h3><p>查询方式是在我们要进行数据传输之前，先查看一下外设的状态或者是条件是否满足，如果就绪或者是条件满足则开始进行数据的传输，否则就就绪查询。比如我们通过按键对外设进行控制，或者有些外设在给它传递信号后他会返回一个应答信号或者是其他的信号，当它发送后我们才能继续操作就可以使用这种方法。</p>
<p>这种方法的优点就是可以根据条件来控制外设的状态，缺点就是实时性差。</p>
<h2 id="2-中断方式"><a href="#2-中断方式" class="headerlink" title="2.中断方式"></a>2.中断方式</h2><p>如果外设准备好时，会主动发送一个信号过来，我们通过程序将这个信号设定为中断出发，当接受到这个信号后，CPU会停止当前执行的代码，转去执行对应设定好的中断服务程序。</p>
<p>这种方法的优点就是实时性好，速度快，但是代码比较难写。</p>
<p>我们可以使用中断的方法来代替查询方法，这样可以提高CPU的实时性和速度，但是就是代码比较复杂，但速度是最主要的，不要太在意复杂性。</p>
<h2 id="3-DMA方式"><a href="#3-DMA方式" class="headerlink" title="3.DMA方式"></a>3.DMA方式</h2><p>这种方法又称为直接数据传送方法，之前外设和内存进行数据交换的时候，需要先经过CPU,然后才可以进行数据交换，但是DMA就是直接跳过这个过程，不经过CPU,直接就让外设和内存进行数据交换，这种方法又一个DMA控制器（DMAC）进行控制。</p>
<p>这种方法的优点是速度快，适合大量数据的交换，缺点就是需要依赖硬件环境。</p>
<p>上面介绍了一下传送数据的方式，接下来我们就把每一个的方法详细介绍一下。</p>
<h1 id="一、方法介绍和代码编写"><a href="#一、方法介绍和代码编写" class="headerlink" title="一、方法介绍和代码编写"></a>一、方法介绍和代码编写</h1><p>这里需要先介绍一下stm32的GPIO口和对应的引脚。</p>
<h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1.前置知识"></a>1.前置知识</h2><p>在STM32中将IO端口分为了多个GPIO口，每个GPIO口又有多个引脚，这些我们可以直接通过C语言进行控制。</p>
<p>我们使用的stm32f103c8t6有GPIOA到GPIOC这总共3个GPIO口，而每个GPIO口中又有16个引脚，我们可以对这每个引脚进行操作。</p>
<h2 id="2-程序方式"><a href="#2-程序方式" class="headerlink" title="2.程序方式"></a>2.程序方式</h2><h3 id="1-1-无条件方式"><a href="#1-1-无条件方式" class="headerlink" title="1.1 无条件方式"></a>1.1 无条件方式</h3><p>无条件方式是在学单片机操作中首先会给大家介绍的一种方法，这种方法很简单，操作起来也很容易。</p>
<p>用无条件方法对GPIO操作我们可以简单分为一下这几步：</p>
<p>1.打开对应的GPIO口</p>
<p>2.初始化对应的GPIO引脚</p>
<p>3.对GPIO引脚进行操作</p>
<h4 id="1-1-1-打开对应的GPIO口"><a href="#1-1-1-打开对应的GPIO口" class="headerlink" title="1.1.1 打开对应的GPIO口"></a>1.1.1 打开对应的GPIO口</h4><p>首先在操作之前我们需要开启对应操作的GPIO引脚的时钟，使用的函数是<code>RCC_APB2PeriphClockCmd()</code>这个函数可以开启你要使用的GPIO口的时钟，当开启时钟后我们可以对其中的引脚进行操作。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(u32 RCC_APB2Periph, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个成熟是选择对应的APB2，我们可以选择的APB2的值如下：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RCC_APB2Periph_AFIO</td>
<td>功能复用I&#x2F;O时钟</td>
</tr>
<tr>
<td>RCC_APB2Periph_GPIOA</td>
<td>GPIOA时钟</td>
</tr>
<tr>
<td>RCC_APB2Periph_GPIOB</td>
<td>GPIOB时钟</td>
</tr>
<tr>
<td>RCC_APB2Periph_GPIOC</td>
<td>GPIOC时钟</td>
</tr>
<tr>
<td>RCC_APB2Periph_GPIOD</td>
<td>GPIOD时钟</td>
</tr>
<tr>
<td>RCC_APB2Periph_GPIOE</td>
<td>GPIOE时钟</td>
</tr>
<tr>
<td>RCC_APB2Periph_ADC1</td>
<td>ADC1的时钟</td>
</tr>
<tr>
<td>RCC_APB2Periph_ADC2</td>
<td>ADC2的时钟</td>
</tr>
<tr>
<td>RCC_APB2Periph_TIM1</td>
<td>TIM1的时钟</td>
</tr>
<tr>
<td>RCC_APB2Periph_SPI1</td>
<td>SPI1的时钟</td>
</tr>
<tr>
<td>RCC_APB2Periph_USART1</td>
<td>USART1的时钟</td>
</tr>
<tr>
<td>RCC_APB2Periph_ALL</td>
<td>开启全部的APB2的时钟</td>
</tr>
</tbody></table>
<p>这里先介绍一下APB2的一些内容，后面会用到APB1还会给大家介绍一下。</p>
<p>第二个参数就是使能或者失能，可以填写使能<code>ENABLE</code>或者失能<code>DISABLE</code>。</p>
<p>例如我们在GPIOB口中的PB0引脚上接了一个LED灯，我们的初始化就可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br></pre></td></tr></table></figure>

<p>这样我们就可以打开对应的GPIO口的时钟了，就可以继续对GPIO口中的引脚进行操作了。</p>
<p>这里需要注意一下，这个打开时钟的操作是必须的，如果你没有对其打开，那会导致引脚没办法使用，时钟这个东西就是CPU的心脏，如果没有心脏，那它就shi了。</p>
<h4 id="1-1-2-初始化对应的GPIO引脚"><a href="#1-1-2-初始化对应的GPIO引脚" class="headerlink" title="1.1.2 初始化对应的GPIO引脚"></a>1.1.2 初始化对应的GPIO引脚</h4><p>当打开时钟后我们就可以对其中的引脚进行操作了。引脚是在GPIO口中的，必须得上一步初始化后我们对引脚初始化才有用。</p>
<p>这里对对应的引脚进行初始化需要用到一个结构体，然后将写好的结构体传递到函数中进行初始化，我们使用的结构体类型为：<code>GPIO_InitTypeDef</code>，我们需要先利用它来创建一个结构体变量，然后对这个变量进行初始化即可。</p>
<p>这个结构体的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    u16 GPIO_Pin;</span><br><span class="line">    GPIOSpeed_TypeDef GPIO_Speed;</span><br><span class="line">    GPIOMode_TypeDef GPIO_Mode;</span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p><code>GPIO_Pin</code>是需要填写的对应GPIO引脚</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GPIO_Pin_None</td>
<td>没有引脚被选中</td>
</tr>
<tr>
<td>GPIO_Pin_x</td>
<td>选中GPIOx引脚</td>
</tr>
<tr>
<td>GPIO_Pin_All</td>
<td>全部选中</td>
</tr>
</tbody></table>
<p><code>GPIO_Speed</code>是设置引脚的速率</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GPIO_Speed_2MHz</td>
<td>最高输出速率2MHz</td>
</tr>
<tr>
<td>GPIO_Speed_10MHz</td>
<td>最高输出速率10MHz</td>
</tr>
<tr>
<td>GPIO_Speed_50MHz</td>
<td>最高输出速率10MHz</td>
</tr>
</tbody></table>
<p><code>GPIO_Mode</code>是设置引脚的工作模式</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GPIO_Mode_Out_PP</td>
<td>推挽输出</td>
</tr>
<tr>
<td>GPIO_Mode_Out_OD</td>
<td>开漏输出</td>
</tr>
<tr>
<td>GPIO_Mode_AF_PP</td>
<td>复用开漏输出</td>
</tr>
<tr>
<td>GPIO_Mode_AF_OD</td>
<td>复用推挽输出</td>
</tr>
<tr>
<td>GPIO_Mode_AIN</td>
<td>模拟输入</td>
</tr>
<tr>
<td>GPIO_Mode_IN_FLOATING</td>
<td>浮空输入</td>
</tr>
<tr>
<td>GPIO_Mode_IPU</td>
<td>上拉输入</td>
</tr>
<tr>
<td>GPIO_Mode_IPD</td>
<td>下拉输入</td>
</tr>
</tbody></table>
<p>这个还是比较复杂，所以我这给大家一个一个的介绍一下：</p>
<h5 id="1-1-2-1-推挽输出"><a href="#1-1-2-1-推挽输出" class="headerlink" title="1.1.2.1 推挽输出"></a>1.1.2.1 推挽输出</h5><p>这个可以理解为输出的就是最大电压和0电压，效率高。高电平就是5V，低电平就是0V。</p>
<h5 id="1-1-2-2-开漏输出"><a href="#1-1-2-2-开漏输出" class="headerlink" title="1.1.2.2 开漏输出"></a>1.1.2.2 开漏输出</h5><p>这个高电平不是很高，如果要让其输出高电平则需要外接一个上拉电阻，但它对电流的吸收很强，这种模式一般对那种需要复用的引脚使用，用来接收电平信息。</p>
<h5 id="1-1-2-3-浮空输入"><a href="#1-1-2-3-浮空输入" class="headerlink" title="1.1.2.3 浮空输入"></a>1.1.2.3 浮空输入</h5><p>没有上拉和下拉电阻的输入，默认为一种中间态，一点浮动都会被接收到。</p>
<h5 id="1-1-2-4-上拉输入"><a href="#1-1-2-4-上拉输入" class="headerlink" title="1.1.2.4 上拉输入"></a>1.1.2.4 上拉输入</h5><p>在输入内部增加了一个上拉电阻，在没有电平来的情况下，这个引脚默认的电平是高电平，一般用这种方式来接受下降沿的电平信息。</p>
<h5 id="1-1-2-5-下拉输入"><a href="#1-1-2-5-下拉输入" class="headerlink" title="1.1.2.5 下拉输入"></a>1.1.2.5 下拉输入</h5><p>在输入的内部增加了一个下拉电阻，在没有电平进入的情况下，这个引脚默认的电平是低电平，一般用这种方式来接受上升沿的电平信息。</p>
<h5 id="1-1-2-6-模拟输入"><a href="#1-1-2-6-模拟输入" class="headerlink" title="1.1.2.6 模拟输入"></a>1.1.2.6 模拟输入</h5><p>一般用直接引脚来输入模拟信号后进行数模转换，后面在数模转换的时候会使用到这个引脚。</p>
<p>其实这些方式慢慢使用都能记得住的，我们知道了初始化结构体后我们就可以创建一个初始化结构体并为其配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br></pre></td></tr></table></figure>

<p>如果要对多个引脚进行初始化的话，我们可以使用逻辑与运算符，将多个引脚连接在一起，比如我要初始化0,1,5,7引脚，那么代码可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br></pre></td></tr></table></figure>

<p>当这样配置好后我们需要使用到<code>GPIO_Init()</code>函数将GPIO口和GPIO引脚进行初始化，函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是GPIO口的名称，第二个参数是刚才初始化的GPIO引脚的结构体地址。</p>
<p>我们将刚才设置好的内容拿来初始化吧：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<p>这样就可以完成对GPIO口和对应的引脚进行初始化了。</p>
<p>如果要对多个不同模式的引脚初始化，我们可以在写好一个初始化结构体后调用一下初始化函数，例如PA5是推挽输出，PC3是上拉输入，那我们的初始化代码可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_Init(GPIOC, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>


<h4 id="1-1-3-对其中的GPIO引脚进行操作"><a href="#1-1-3-对其中的GPIO引脚进行操作" class="headerlink" title="1.1.3 对其中的GPIO引脚进行操作"></a>1.1.3 对其中的GPIO引脚进行操作</h4><p>这里就可以对其引脚进行操作了，一般操作就是输入或者是输出，这个操作需要看上面初始化的模式是什么，如果是输出，那只能输出，如果是输入，那只能输入。</p>
<p>这里有一个特殊的，就是开漏输出，这个模式也可以使用输入的函数来读取外部的引脚电平。</p>
<h5 id="1-1-3-1-GPIO-SetBits"><a href="#1-1-3-1-GPIO-SetBits" class="headerlink" title="1.1.3.1 GPIO_SetBits"></a>1.1.3.1 GPIO_SetBits</h5><p>这个函数可以将对应的引脚置为1。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是对应的GPIO口，第二个是GPIO引脚。例如我要对PB6置1,代码可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_6);</span><br></pre></td></tr></table></figure>

<p>这里注明一下，在单片机开发中，有一个类型规范，这个规范是在标准库中是定义好的，我们可以直接拿来使用，比如上面的<code>u16</code>就是对应着<code>unsigned short</code>无符号的短整形，其他的可以类推。</p>
<h5 id="1-1-3-2-GPIO-ResetBits"><a href="#1-1-3-2-GPIO-ResetBits" class="headerlink" title="1.1.3.2 GPIO_ResetBits"></a>1.1.3.2 GPIO_ResetBits</h5><p>这个函数可以将对应的引脚置为0.</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-3-3-GPIO-Write"><a href="#1-1-3-3-GPIO-Write" class="headerlink" title="1.1.3.3 GPIO_Write"></a>1.1.3.3 GPIO_Write</h5><p>这个引脚是对GPIO口的所有引脚进行操作。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, u16 PortVal)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是GPIO口，第二个参数是这个GPIO口的所有引脚的状态，例如我们要让GPIOA的PA7引脚为高电平，其他引脚为低电平，那么代码可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_Write(GPIOA, <span class="number">0x0080</span>);    <span class="comment">// 0000 0000 1000 0000</span></span><br></pre></td></tr></table></figure>

<h5 id="1-1-3-4-GPIO-WriteBit"><a href="#1-1-3-4-GPIO-WriteBit" class="headerlink" title="1.1.3.4 GPIO_WriteBit"></a>1.1.3.4 GPIO_WriteBit</h5><p>这个函数是对特定位进行操作。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是GPIO口，第二个参数是对应的引脚，第三个是设置的电平，这有两个参数可以填写，高电平<code>Bit_SET</code>和低电平<code>Bit_RESET</code>，当然，如果你记不住，你也可以直接用0和1来代替。</p>
<p>比如我们要对PB0变成高电平，那么代码可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_WriteBits(GPIOB, GPIO_Pin_0, Bit_SET);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">GPIO_WriteBits(GPIOB, GPIO_Pin_0, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>上面两种都是可以的写法。</p>
<p>上面的都是输出的函数，现在我们利用这个来做一个LED流水灯，首先先用面包版搭建一个电路</p>
<p><img src="https://img2.imgtp.com/2024/04/22/FVMRHGK6.jpg" alt="1.jpg"></p>
<p>流水灯的引脚挨着连着单片机的PA口的0到7引脚，然后对其进行初始化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stm32f10x.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时函数，使用的是SysTick定时器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> time)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp;</span><br><span class="line">	SysTick -&gt; LOAD = <span class="number">9000</span> * time;</span><br><span class="line">	SysTick -&gt; CTRL = <span class="number">0x01</span>;</span><br><span class="line">	SysTick -&gt; VAL = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		temp = SysTick -&gt; CTRL;</span><br><span class="line">	&#125;<span class="keyword">while</span>((temp &amp; <span class="number">0x01</span>) &amp;&amp; (!(temp &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>))));</span><br><span class="line">	SysTick -&gt; CTRL = <span class="number">0</span>;</span><br><span class="line">	SysTick -&gt; VAL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">0x0001</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		value = <span class="number">0x0001</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">			GPIO_Write(GPIOA, ~value);</span><br><span class="line">			value &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">			delay(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是直接使用<code>GPIO_Write()</code>函数对GPIOA口进行操作，这种方式很简单，如果直接用<code>GPIO_WriteBit()</code>，就很麻烦，大家可以试试。</p>
<h2 id="3-查询方式"><a href="#3-查询方式" class="headerlink" title="3.查询方式"></a>3.查询方式</h2><p>这种方式需要查询外设的状态后才能开始接下来的工作，使用查询方式的大概步骤如下：</p>
<p>1.设置输入模式</p>
<p>2.判断是否满足条件</p>
<p>3.满足条件传输数据</p>
<p>4.不满足继续查询</p>
<h3 id="3-1-设置输入模式"><a href="#3-1-设置输入模式" class="headerlink" title="3.1 设置输入模式"></a>3.1 设置输入模式</h3><p>和之前设置输出一样，使用初始化函数即可初始化，这里可以选择上拉输入、输出模式和浮空输入，当然也可以设置成开漏输出。</p>
<p>这个选择需要根据外设的电路来决定，就拿按键来举例，假如按钮的另一边的接地，当按下按键后，单片机的引脚就会受到地电平，如果设置成下拉输入，那单片机的接口默认是低电平，按下后还是接受到低电平，这样就没有区别，所以就不能设置成下拉输入。</p>
<p>如果设置成浮空输入，那只要有一点变化就会发生电平变化，不稳定也不确定，所以一般在严格规范下最好不要使用，自己玩可以。</p>
<p>如果设置成上拉输入，在默认情况下引脚的电平是高电平，当外设输入低电平时就会发生电平的变化，所以就能选择出选择的模式。</p>
<p>根据外设可以确定好输入的模式后就可以进行初始化。</p>
<h3 id="3-2-判断条件"><a href="#3-2-判断条件" class="headerlink" title="3.2 判断条件"></a>3.2 判断条件</h3><p>这里使用到判断和输入函数，所以这里给大家介绍一下全部的输入模式。</p>
<h4 id="3-2-1-GPIO-ReadInputDataBit"><a href="#3-2-1-GPIO-ReadInputDataBit" class="headerlink" title="3.2.1 GPIO_ReadInputDataBit"></a>3.2.1 GPIO_ReadInputDataBit</h4><p>这个函数是读取指定引脚的电平。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u8 <span class="title function_">GPIO_ReadInitputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-GPIO-ReadInputData"><a href="#3-2-2-GPIO-ReadInputData" class="headerlink" title="3.2.2 GPIO_ReadInputData"></a>3.2.2 GPIO_ReadInputData</h4><p>读取指定GPIO口的电平值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u16 <span class="title function_">GPIO_ReadInputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-GPIO-ReadOutputDataBit"><a href="#3-2-3-GPIO-ReadOutputDataBit" class="headerlink" title="3.2.3 GPIO_ReadOutputDataBit"></a>3.2.3 GPIO_ReadOutputDataBit</h4><p>读取指定引脚输出的电平值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u8 <span class="title function_">GPIO_ReadOutputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-GPIO-ReadOutputData"><a href="#3-2-4-GPIO-ReadOutputData" class="headerlink" title="3.2.4 GPIO_ReadOutputData"></a>3.2.4 GPIO_ReadOutputData</h4><p>读取指定GPIO口的输出的电平值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u16 <span class="title function_">GPIO_ReadOutputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br></pre></td></tr></table></figure>

<p>学习完输入函数后我们可以利用一下输入函数来做一个查询方式的流水灯。当按键按下时，流水灯启动，没按下时就停止。</p>
<p>这里假如只有一个按键接到PB0上，按下按钮后接受到低电平，我们的判断代码就可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)&#123;&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == Bit_RESET)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-执行内容"><a href="#3-3-执行内容" class="headerlink" title="3.3 执行内容"></a>3.3 执行内容</h3><p>我们在写好的判断语句内部写上我们需要执行的代码即可完成查询方式的数据交换。</p>
<p>完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> time)</span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> temp;</span><br><span class="line">        SysTick -&gt; LOAD = <span class="number">9000</span> * time;</span><br><span class="line">        SysTick -&gt; CTRL = <span class="number">0x01</span>;</span><br><span class="line">        SysTick -&gt; VAL = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">                temp = SysTick -&gt; CTRL;</span><br><span class="line">        &#125;<span class="keyword">while</span>((temp &amp; <span class="number">0x01</span>) &amp;&amp; (!(temp &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>))));</span><br><span class="line">        SysTick -&gt; CTRL = <span class="number">0</span>;</span><br><span class="line">        SysTick -&gt; VAL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> value = <span class="number">0x0001</span>;</span><br><span class="line">        u8 i;</span><br><span class="line"></span><br><span class="line">        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line">        GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">        GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">        GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">        GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">        GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">        GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">        GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)&#123;</span><br><span class="line">                        value = <span class="number">0x0001</span>;</span><br><span class="line">                        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">                                GPIO_Write(GPIOA, ~value);</span><br><span class="line">                                value &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                                delay(<span class="number">1000</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当按键按下后，流水灯会开始启动，执行完一次后就会结束，我们可以感觉这个代码再来改写一下，当按下按钮后流水灯启动直到再次按下按钮后结束流水灯。</p>
<p>改写后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> time)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp;</span><br><span class="line">	SysTick -&gt; LOAD = <span class="number">9000</span> * time;</span><br><span class="line">	SysTick -&gt; CTRL = <span class="number">0x01</span>;</span><br><span class="line">	SysTick -&gt; VAL = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">			temp = SysTick -&gt; CTRL;</span><br><span class="line">	&#125;<span class="keyword">while</span>((temp &amp; <span class="number">0x01</span>) &amp;&amp; (!(temp &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>))));</span><br><span class="line">	SysTick -&gt; CTRL = <span class="number">0</span>;</span><br><span class="line">	SysTick -&gt; VAL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> value = <span class="number">0x0001</span>;</span><br><span class="line">	u8 i, flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)&#123;</span><br><span class="line">			delay(<span class="number">100</span>);    <span class="comment">// 消抖</span></span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">				value = <span class="number">0x0001</span>;</span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">					GPIO_Write(GPIOA, ~value);</span><br><span class="line">					value &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">					delay(<span class="number">1000</span>);</span><br><span class="line">					<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)&#123;</span><br><span class="line">						flag = <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (flag)&#123;</span><br><span class="line">					delay(<span class="number">100</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以实现改功能了。</p>
<p>在上面的代码中出现了个消抖，因为按键在按下的过程中是会有抖动的，我们需要消除这个抖动让接受的数据唯一，并且要错过按下后电平还是原来的电平时又进入到循环中的问题。</p>
<p>上面的只是用延时函数简单的消除了一下，可以在延时完成后加上一个循环来保证该电平又恢复到原来的状态。</p>
<h2 id="4-中断方式"><a href="#4-中断方式" class="headerlink" title="4.中断方式"></a>4.中断方式</h2><p>这种方式的原理不会在这一篇文章中说明，等后面会专门出一篇文章来介绍一下原理和复杂应用后面再说，先简单的介绍一下。</p>
<p>中断设置方式很简单</p>
<p>1.初始化引脚</p>
<p>2.初始化中断EXTI</p>
<p>3.设置NVIC的参数</p>
<p>4.重写中断服务程序</p>
<h3 id="4-1-初始化引脚"><a href="#4-1-初始化引脚" class="headerlink" title="4.1 初始化引脚"></a>4.1 初始化引脚</h3><p>这里初始化引脚和前面的一样，也是设置为输入模式，但设置完成后需要将初始化的引脚绑定到EXTI外部中断上，这里使用的函数是<code>GPIO_EXTILineConfig()</code>。</p>
<p>函数的原型是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EXTILineConfig</span><span class="params">(u8 GPIO_PortSource, u8 GPIO_PinSource)</span>;</span><br></pre></td></tr></table></figure>

<p>将指定引脚映射到EXTI上，然后我们就可以初始化EXTI外部中断了。</p>
<p>第二个参数并不是直接填写引脚号，这个是需要填写通道值，总共有0到15可以选择，这0到15需要感觉选择的引脚号了决定，因为32单片机的中断是将GPIO的引脚号一致的接入到一个通道中，比如通道0接的是PA0到PE0中的所有0号引脚，然后以此类推。</p>
<p>比如我们要将GPIOB口的PB4引脚打开EXTI中断，那么映射函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_EXTILineConfig(GPIOB, GPIO_PinSource4);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-初始化外部中断"><a href="#4-2-初始化外部中断" class="headerlink" title="4.2 初始化外部中断"></a>4.2 初始化外部中断</h3><p>这里需要使用到EXTI的结构体进行初始化，该结构体类型为:<code>EXTI_InitTypeDef</code>，原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	u32 EXTI_Line;</span><br><span class="line">	EXTIMode_TypeDef EXTI_Mode;</span><br><span class="line">	EXTIrigger_TypeDef EXTI_Trigger;</span><br><span class="line">	FunctionalState EXTI_LineCmd;</span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>EXTI_Line</code>是选择中断线路，总共有18根外部中断线，这个可以根据自己的安排来安排对应的线路，对应的中断服务入口地址是不同的。</p>
<p>第二个参数<code>EXTI_Mode</code>是选择上面选择的线路模式。有两个选项可以填写：</p>
<p><code>EXTI_Mode_Event</code>：设置EXTI线路为事件请求。</p>
<p><code>EXTI_Mode_Interrupt</code>：设置EXTI线路为中断请求。</p>
<p>第三个参数是设置线路的触发边沿，有三个可选的参数：</p>
<p><code>EXTI_Trigger_Falling</code>：设置输入线路为下降沿触发。</p>
<p><code>EXTI_Trigger_Rising</code>：设置输入线路为上升沿触发。</p>
<p><code>EXTI_Trigger_Rising_Falling</code>：设置输入线路为上升沿和下降沿触发。</p>
<p>第四个参数是选中的线路是否开启，有两个参数，一个是使能<code>ENABLE</code>另一个是失能<code>DISABLE</code>。</p>
<p>当设置完成后我们可以用<code>EXTI_Init()</code>函数将刚才初始化的结构体传入进去进行初始化。</p>
<h3 id="4-3-设置NVIC"><a href="#4-3-设置NVIC" class="headerlink" title="4.3 设置NVIC"></a>4.3 设置NVIC</h3><p>NVIC是一个中断优先级判断的一个逻辑电路，我们可以为我们前面设置的中断设置一下中断的优先级，优先级后面会详细的说明，这里只简单的介绍一下如何初始化。</p>
<p>设置NVIC也是需要使用到一个结构体来进行初始化，这个结构体类型为：<code>NVIC_InitTypeDef</code>，结构体原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	u8 NVIC_IRQChannel;</span><br><span class="line">	u8 NVIC_IRQChannelPreemptionPrior;</span><br><span class="line">	u8 NviC_IRQChannelSubPriority;</span><br><span class="line">	FunctionalState NVIC_IRQChannelCmd;</span><br><span class="line">&#125;NVIC_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>第一个参数是选择指定的IRQ通道，这里简单介绍一下我们要用的外部中断线的中断通道：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>EXTI0_IRQn</td>
<td>外部中断线0中断</td>
</tr>
<tr>
<td>EXTI1_IRQn</td>
<td>外部中断线1中断</td>
</tr>
<tr>
<td>EXTI2_IRQn</td>
<td>外部中断线2中断</td>
</tr>
<tr>
<td>EXTI3_IRQn</td>
<td>外部中断线3中断</td>
</tr>
<tr>
<td>EXTI4_IRQn</td>
<td>外部中断线4中断</td>
</tr>
<tr>
<td>EXTI9_5_IRQn</td>
<td>外部中断线5～9中断</td>
</tr>
<tr>
<td>EXTI15_10_IRQn</td>
<td>外部中断线10～15中断</td>
</tr>
</tbody></table>
<p>第二个参数是设置IRQ通道的抢占优先级，抢占优先级就是当在执行这个中断的时候，由来了一个中断，那这个新来的中断是否会干扰当前执行的中断就得看这个抢占优先级，指定的优先级数值越低，优先级越高，这里填写数值就可以了。</p>
<p>第三个参数是优先级，也是填写数值即可，优先级是确定当同一时刻都接受到中断源时，谁先执行就按照这个优先级来确定。</p>
<p>第四个参数是使能或者失能，也就是<code>ENABLE</code>和<code>DISABLE</code>。</p>
<p>当填写好这个初始化结构体后我们调用<code>NVIC_Init()</code>函数将填写好的结构体传入进去即可。</p>
<h3 id="4-4-重写中断服务函数"><a href="#4-4-重写中断服务函数" class="headerlink" title="4.4 重写中断服务函数"></a>4.4 重写中断服务函数</h3><p>这个中断服务函数可以在<code>startup_stm32f10x_hd.s</code>文件中查看，其中这个就是中断服务函数的列表：</p>
<p><img src="https://img2.imgtp.com/2024/04/23/MeUv2KW4.png" alt="2.png"></p>
<p>比如说我们这设置好外部中断通道0中断，那么我们要重写<code>EXTI0_IRQHandler</code>函数，重写方法很简单，我们先定义一下这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然后在内部先判断一下是不是该通道的线路触发，因为我们可以让一个通道选择多条线，所以需要有一个判断，当确实是这个线路后我们清除一下该通道的标志位然后就可以开始我们的工作了。</p>
<p>判断和清理的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line0) == SET)&#123;    <span class="comment">// 判断线路0是否触发</span></span><br><span class="line">		EXTI_ClearFlag(EXTI_Line0);     <span class="comment">// 清理线路0的标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，如果只有一个线路，那就可以不用判断，如果你嫌麻烦。</p>
<p>知道了中断的设置后我们可以写出对应的代码了，完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_EXTI_Init</span><span class="params">()</span>&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);    <span class="comment">// 开启中断的时钟</span></span><br><span class="line">	<span class="comment">// 中断初始化函数</span></span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);     <span class="comment">// 设置外部线路</span></span><br><span class="line">	</span><br><span class="line">	EXTI_InitStruct.EXTI_Line = EXTI_Line0;</span><br><span class="line">	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;    <span class="comment">// 下降沿触发</span></span><br><span class="line">	EXTI_InitStruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStruct);</span><br><span class="line"></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);      <span class="comment">// NVIC优先级分组</span></span><br><span class="line">	</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = EXTI0_IRQn;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">2</span>;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> time)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp;</span><br><span class="line">	SysTick -&gt; LOAD = <span class="number">9000</span> * time;</span><br><span class="line">	SysTick -&gt; CTRL = <span class="number">0x01</span>;</span><br><span class="line">	SysTick -&gt; VAL = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">			temp = SysTick -&gt; CTRL;</span><br><span class="line">	&#125;<span class="keyword">while</span>((temp &amp; <span class="number">0x01</span>) &amp;&amp; (!(temp &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>))));</span><br><span class="line">	SysTick -&gt; CTRL = <span class="number">0</span>;</span><br><span class="line">	SysTick -&gt; VAL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line0) == SET)&#123;</span><br><span class="line">		EXTI_ClearFlag(EXTI_Line0);</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	u32 value;</span><br><span class="line">	u8 i;</span><br><span class="line"></span><br><span class="line">	MX_EXTI_Init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag)&#123;</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">			value = <span class="number">0x0001</span>;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">				<span class="comment">// GPIO_WriteBit(GPIOA, GPIO_Pin_0, 1);</span></span><br><span class="line">				GPIO_Write(GPIOA, ~value);</span><br><span class="line">				value &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">				delay(<span class="number">1000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-DMA方式"><a href="#5-DMA方式" class="headerlink" title="5.DMA方式"></a>5.DMA方式</h2><p>DMA方式只适合大量数据的交换，这里不给大家介绍，等后面介绍一下存储芯片会使用到这种方式的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章是学会单片机的起始，后面的内容都会围绕着这些东西来进行操作，像什么点灯、控制OLED屏幕或者大屏幕、操作传感器、控制通讯模块等等等等都是和IO口的操作脱离不了关系的，学完这个后后面会很容易的掌握单片机的很多操作，我们只要勤加练习就可以学会单片机，单片机其实很简单。</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>05 详细的中断讲解</title>
    <url>/2025/01/17/80a02853c189/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>又鸽了几天的文章，最近在做一个手表项目，这个项目用到了很多知识，特别是中断的知识特别的多，所以这一篇文章来讲讲外部中断，等下一章说一下内部中断。</p>
<h1 id="一、什么是中断"><a href="#一、什么是中断" class="headerlink" title="一、什么是中断"></a>一、什么是中断</h1><p>例如你现在在搞一个项目，然后突然看到你自己写的便条，上面写着今天该写文章了，然后你就会停下手中的项目，转去写文章，当文章写完后又继续的做项目，这个过程就是一个中断。</p>
<p>也就是说中断就是一个打断当前执行的任务，转去执行另外一个任务，当这个任务执行完成后就会返回执行被打断的任务。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240728210911470-416681044.png" alt="img"></p>
<p>上面就是中断执行的一个逻辑。</p>
<h1 id="二、如何使用中断"><a href="#二、如何使用中断" class="headerlink" title="二、如何使用中断"></a>二、如何使用中断</h1><p>上面我们简单的了解了一下中断，大概了解了中断是需要外部信号的，但是光有外部信号进来也不行，我们还需要配置内部，就比如上面举的例子，你看到了便条，但是你忘记这件事了，是不是就会忽略掉那个便条，stm32也是一样，你设置了外部的信号，但是你没设置stm32内部，让它知道这个信号是中断，这样是没用的，所以我们要对stm32进行配置。</p>
<p>在配置之前首先要了解stm32处理中断的硬件环境，这样我们才知道如何配置。</p>
<h2 id="1-stm32中断结构"><a href="#1-stm32中断结构" class="headerlink" title="1.stm32中断结构"></a>1.stm32中断结构</h2><p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240728211945019-542550085.png" alt="img"></p>
<p>因为我们这里讲的是外部中断，在stm32中控制外部中断的是EXTI控制器，所以这里有GPIO口，GPIO口经过<code>AFIO</code>引脚选择器后选择出引脚转到<code>EXTI</code>检测器后会到<code>NVIC</code>中进行排队触发，如果前面有正在执行的中断，<code>NVIC</code>会根据这个中断的抢占优先级来进行强占，如果没有正常排队；如果同时有两个中断同时触发，会根据它们之间的响应优先级来进行排队响应。</p>
<h3 id="1-1-AFIO中断引脚选择"><a href="#1-1-AFIO中断引脚选择" class="headerlink" title="1.1 AFIO中断引脚选择"></a>1.1 AFIO中断引脚选择</h3><p>这个连接这GPIO口的所有引脚，进入了这个器件后，这个器件会将同一个号码的引脚分为一个引脚，比如说PA1、PB1、PC1….分为一个引脚，其他的引脚也是这样的分类，我们配置引脚为中断接受引脚后，AFIO会将这个引脚设置为对应的名字，然后将这个引脚发送给EXTI进行检测和控制，这里可以看到上图有一个16，代表的是只能接受16个引脚。</p>
<h3 id="1-2-EXTI边缘检测"><a href="#1-2-EXTI边缘检测" class="headerlink" title="1.2 EXTI边缘检测"></a>1.2 EXTI边缘检测</h3><p>当配置好后，就可以将配置的引脚设置进EXTI中进行配置模式，配置好后进入NVIC进行配置抢占优先级和响应优先级。</p>
<h3 id="1-3-NVIC优先级配置"><a href="#1-3-NVIC优先级配置" class="headerlink" title="1.3 NVIC优先级配置"></a>1.3 NVIC优先级配置</h3><p>到NVIC中就开始配置优先级，当优先级配置好后，NVIC就会让配置好的这个中断进行执行。</p>
<p>这样就是一个中断的执行过程，下面就是介绍一下配置了。</p>
<h2 id="2-配置stm32的中断"><a href="#2-配置stm32的中断" class="headerlink" title="2.配置stm32的中断"></a>2.配置stm32的中断</h2><p>了解了上面的那些元器件，接下来就是代码的配置实现了。</p>
<h3 id="1-打开时钟"><a href="#1-打开时钟" class="headerlink" title="1.打开时钟"></a>1.打开时钟</h3><p>我们在做32的时候要，无论是做什么都需要打开对应的时钟，打开后才能正常的使用。</p>
<p>在上面的硬件介绍中我们了解到，需要打开GPIO的时钟、AFIO的时钟。</p>
<p>为什么不打开EXTI和NVIC的时钟呢？因为EXTI是和GPIO在一起的，当打开了GPIO的时钟，EXTI的时钟就打开了，而NVIC是在内核中的，这个时钟是在单片机启动有时钟时就可以直接使用，所以不用再麻烦的打开时钟进行操作。</p>
<p>AFIO的时钟是属于APB2中的，所以打开时钟的代码也很简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB2PriphClockCmd(RCC_APB2Periph_GPIOx, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br></pre></td></tr></table></figure>

<p>其中<code>RCC_APB2Periph_GPIOx</code>是你要开启的GPIO口的时钟，这里就不具体举例子了。</p>
<h3 id="2-配置GPIO口"><a href="#2-配置GPIO口" class="headerlink" title="2.配置GPIO口"></a>2.配置GPIO口</h3><p>打开时钟后就可以配置GPIO口了，一般我们使用GPIO口来接受中断信号，所以需要配置GPIO口，配置的方法之前在将IO口的操作时已经讲了，主要是GPIO口该是什么模式来进行接受呢？</p>
<p>其实和输入一样，如果这个按钮是接地，那这个就设置为上拉输入，如果是接电源，那就下拉输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;   <span class="comment">// 这里默认为接地</span></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_x;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOx, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<h3 id="3-配置AFIO控制"><a href="#3-配置AFIO控制" class="headerlink" title="3.配置AFIO控制"></a>3.配置AFIO控制</h3><p>配置完成后我们接下来<code>AFIO</code>控制，了解过<code>AFIO</code>的都知道，<code>AFIO</code>是GPIO重映像的一个部件，在32中有一些引脚有一个重映像功能，如果我们需要使用到这个重映像的话就需要使用<code>AFIO</code>进行重映像配置。</p>
<p>在这也是，其实你可以理解为将接受中断信号的引脚重映像为中断引脚，配置的方法很简单，只需要使用下面的一个语句就可以了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOx, GPIO_PinSourcex);</span><br></pre></td></tr></table></figure>

<p>其中<code>GPIO_PortSourceGPIOx</code>是GPIO组，如果要设置为GPIOB的，那这里就写<code>GPIO_PortSourceGPIOB</code>。</p>
<p><code>GPIO_PinSourcex</code>是GPIO口中需要配置的引脚，比如说是12引脚，那这里就填写<code>GPIO_PinSource12</code>。</p>
<h3 id="4-配置EXTI功能"><a href="#4-配置EXTI功能" class="headerlink" title="4.配置EXTI功能"></a>4.配置EXTI功能</h3><p>配置完成AFIO后现在就要来配置EXTI中断控制器了，配置方法其实和GPIO口的配置一样，首先创建一个结构体，然后配置结构体中的内容，然后交给初始化函数就可以了，配置代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXTI_InitTypeDef EXTI_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;   <span class="comment">// 设置中断模式</span></span><br><span class="line">EXTI_InitStruct.EXTI_LineCmd = ENABLE;    <span class="comment">// 使能中断通道</span></span><br><span class="line">EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;     <span class="comment">// 触发模式</span></span><br><span class="line">EXTI_InitStruct.EXTI_Line = EXTI_Linex;   <span class="comment">// 设置通道</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStruct);</span><br></pre></td></tr></table></figure>

<p>其中<code>EXTI_Linex</code>是设置通道，比如上面设置12引脚为中断模式，那这里就填写<code>EXTI_Line12</code>即可。</p>
<h3 id="5-配置NVIC"><a href="#5-配置NVIC" class="headerlink" title="5.配置NVIC"></a>5.配置NVIC</h3><p>现在需要配置个NVIC就可以将stm32的中断配置完成了，配置NVIC的步骤也是和配置GPIO一样，但是在设置之前需要给NVIC一个分组，这个分组的作用是设置抢占优先级和响应优先级的范围，每个组的抢占和响应可选的值不一样，下面是分组对应的优先级的范围：</p>
<table>
<thead>
<tr>
<th>组名</th>
<th>抢占优先级</th>
<th>响应优先级</th>
</tr>
</thead>
<tbody><tr>
<td>NVIC_PriorityGroup_0</td>
<td>0~4</td>
<td>0</td>
</tr>
<tr>
<td>NVIC_PriorityGroup_1</td>
<td>0~3</td>
<td>0~1</td>
</tr>
<tr>
<td>NVIC_PriorityGroup_2</td>
<td>0~2</td>
<td>0~2</td>
</tr>
<tr>
<td>NVIC_PriorityGroup_3</td>
<td>0~1</td>
<td>0~3</td>
</tr>
<tr>
<td>NVIC_PriorityGroup_4</td>
<td>0</td>
<td>0~4</td>
</tr>
</tbody></table>
<p>配置的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br></pre></td></tr></table></figure>

<p>这里设置是组二，这个设置NVIC的组只有设置的第一次有用，如果你在其他再次调用了这个函数，组配置的不一样那也不会进行更改，相当于只要执行了一次这个函数就再也修改不了了，设置完成后就可以开始配置NVIC了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NVIC_InitStruct.NVIC_IRQChannel = EXTI15_10_IRQn;    <span class="comment">// 选择启用的IRQ通道</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;   <span class="comment">// 设置抢占优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">2</span>;          <span class="comment">// 设置响应优先级</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br></pre></td></tr></table></figure>

<p>这里需要注意一下，这里的抢占和响应的优先级如果超过了配置的组中的优先级，那会出问题，不要超过即可。</p>
<p>这里<code>EXTI15_10_IRQn</code>是设置启用的通道，前面配置的通道需要在这变为IRQ通道，这里可以在源码中进行查看对应的通道，比如说我配置的是2引脚，那么这里写<code>EXTI2_IRQn</code>。</p>
<p>这里就写完配置中断的代码了，全部的代码如下：</p>
<h3 id="6-配置完整代码"><a href="#6-配置完整代码" class="headerlink" title="6.配置完整代码"></a>6.配置完整代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启时钟</span></span><br><span class="line">RCC_APB2PriphClockCmd(RCC_APB2Periph_GPIOx, ENABLE);    <span class="comment">// 这里需要对应的GPIO口</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置GPIO口</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;   <span class="comment">// 这里默认为接地</span></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_x;    <span class="comment">// 这里需要写响应的引脚</span></span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOx, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置AFIO</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOx, GPIO_PinSourcex);    <span class="comment">// 这里需要写具体的GPIO口和引脚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置EXTI</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;   <span class="comment">// 设置中断模式</span></span><br><span class="line">EXTI_InitStruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">EXTI_InitStruct.EXTI_Line = EXTI_Linex;   <span class="comment">// 这里需要写具体的通道</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置NVIC组</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_x);  <span class="comment">// 这里要写具体的组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置NVIC</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel = EXTI15_10_IRQn;    <span class="comment">// 选择启用的IRQ通道</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;   <span class="comment">// 设置抢占优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">2</span>;          <span class="comment">// 设置响应优先级</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br></pre></td></tr></table></figure>

<p>配置完成中断后，stm32知道要执行中断了，但是中断的内容却没有，就比如你现在看到字条了，你知道要写文章了，已经停止做项目的操作了，但是你不知道该写什么文章，所以我们现在要做的就是告诉32，你触发了这个中断后要进行什么操作。</p>
<p>这一步就叫做写中断服务函数，让它接收到这个中断后能转去执行对应的函数和内容。</p>
<h2 id="3-书写中断服务函数"><a href="#3-书写中断服务函数" class="headerlink" title="3.书写中断服务函数"></a>3.书写中断服务函数</h2><p>这里中断服务函数的函数名不是想叫什么就可以叫什么的，而是在启动文件中已经标注好了的，我们只需要给它拿下来就可以了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240728223052312-2071434475.png" alt="img"></p>
<p>这里可以看到很多，我们找在NVIC配置好的那个IRQ通道的名称的就可以了，比如是<code>EXTI2_IRQn</code>，那这里我们要的是<code>EXTI2_IRQHandler</code>，一样的道理，这里就以这个<code>EXTI2_IRQHandler</code>举例子，那我们开始写函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样中断函数就写好了，现在就是需要在里面填写内容了，内容一般是自己来规定的，但是有一些内容需要写好，首先是判断中断标志位，要判断一下是不是这个引脚触发的，函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXTI_GetITStatus(EXTI_Linex);</span><br></pre></td></tr></table></figure>

<p><code>EXTI_Linex</code>是设置的通道，然后这个函数的返回值是<code>SET</code>和<code>RESET</code>，当触发时返回<code>SET</code>，没触发时返回<code>RESET</code>。</p>
<p>然后就是清除中断标志位，要手动进行一次复位，使得下一次能够正常的进行触发，函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXTI_ClearITPendingBit(EXTI_Linex);</span><br></pre></td></tr></table></figure>

<p>我们在中断服务函数中就先写好这样的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Linex) == SET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 你自己的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ===========</span></span><br><span class="line">        EXTI_ClearITPendingBit(EXTI_Linex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断服务函数可以写在任意的位置，不需要在main函数中进行调用，这个中断函数的调用又系统来进行。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在中断函数中尽量不要执行一些耗费大量时间的内容，我一般是使用变量来进行控制，控制变量然后在main函数中判断这个变量的值，然后才执行相应的操作，一般我用中断来进行按键的控制，因为这个效率比较高，但是抖动问题还是比较严重的，可以用做其他的地方。</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>03 OLED显示屏实现</title>
    <url>/2025/01/17/ebc592be8231/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一章主要是上一节没有讲完的项目的一个编写，上一章我们说道单片机的输入和输出，包括四种单片机与外设之间的数据交换使用到的方式，这一章就利用前面说到的这几种方式来编写一个OLED显示屏的驱动。</p>
<h1 id="一、软件模拟IIC协议"><a href="#一、软件模拟IIC协议" class="headerlink" title="一、软件模拟IIC协议"></a>一、软件模拟IIC协议</h1><p>这使用的OLED屏幕是用的4引脚IIC协议的，在编写相关代码之前我们需要先了解一下什么是IIC协议，在单片机中，IIC通常指的是Inter-Integrated Circuit，也称为I2C（Inter-Integrated Circuit）总线，它是一种用于在集成电路之间进行通信的串行通信协议。</p>
<p>I2C总线由飞利浦公司（现在的恩智浦半导体公司）开发，用于在数字集成电路之间进行通信。它通常用于连接微控制器和外部设备，如传感器、存储器、扩展模块等。</p>
<p>I2C总线使用两根线进行通信：串行数据线（SDA）和串行时钟线（SCL）。通过这两根线，多个设备可以在同一总线上进行通信。每个设备都有一个唯一的地址，因此可以通过地址来选择要通信的特定设备。</p>
<p>I2C总线采用主从结构，主设备负责发起通信并控制总线，而从设备则响应主设备的命令。这种通信协议简单而灵活，适用于连接多种类型的设备。</p>
<p>简单来说IIC协议就是一种串行通讯协议，我们只需要对两根数据线进行操作就可以了，在32中有对应的IIC的函数库，我们可以直接调用来实现，但是那个内容我安排在后面了，我们实现先学习上一节用输入和输出来进行模拟的方式，学习完后我们才可以用一些传感器来观察效果并实现更高级的内容。</p>
<h2 id="1-开启IIC协议"><a href="#1-开启IIC协议" class="headerlink" title="1.开启IIC协议"></a>1.开启IIC协议</h2><p>我们在使用IIC协议之前需要发送一个开始信号的，这个开始信号的时序图如下：</p>
<p><img src="https://img2.imgtp.com/2024/04/25/qTEXkBCk.png" alt="3.png"></p>
<p>可以看到左边是起始条件，我们要开启IIC协议必须得先发送其实条件，这里的代码很容易就可以编写，这里我用了一下宏定义和位操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    GPIO_SetBits(GPIO, SDA);</span><br><span class="line">    GPIO_SetBits(GPIO, SCL);</span><br><span class="line">    GPIO_ResetBits(GPIO, SDA);</span><br><span class="line">    GPIO_ResetBits(GPIO, SCL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数就可以让IIC协议开始，当开始后我们就可以参数数据和一些命令了。</p>
<h2 id="2-结束IIC协议"><a href="#2-结束IIC协议" class="headerlink" title="2.结束IIC协议"></a>2.结束IIC协议</h2><p>当一条IIC协议传输完成后需要发送一条协议结束信号，这个信号的写法也很简单，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    GPIO_ResetBits(GPIO, SDA);</span><br><span class="line">    GPIO_SetBits(GPIO, SCL);</span><br><span class="line">    GPIO_SetBits(GPIO, SDA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以结束上一次的IIC数据传输。</p>
<h2 id="3-传输数据"><a href="#3-传输数据" class="headerlink" title="3.传输数据"></a>3.传输数据</h2><p>这个的时序图也可以参考上面的时序图</p>
<p><img src="https://img2.imgtp.com/2024/04/25/qTEXkBCk.png" alt="3.png"></p>
<p>看中间的位置，这个位置就是传输一位数据时的时序图，那么我们就可以根据这个图写出传输一个字节的数据了，这里需要注意一下，我们传输一条字节数据时是需要先传递高位数据，在<code>SCL</code>从高电平到低电平的时候才会将数据传递过去，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_WriteBit</span><span class="params">(u8 byte)</span>&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (byte &amp; <span class="number">0x80</span>)&#123;</span><br><span class="line">            GPIO_SetBits(GPIO, SDA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            GPIO_ResetBits(GPIO, SDA);</span><br><span class="line">        &#125;</span><br><span class="line">        byte &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        GPIO_SetBits(GPIO, SCL);</span><br><span class="line">        GPIO_ResetBits(GPIO, SCL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳过一个ACK信号</span></span><br><span class="line">    GPIO_SetBits(GPIO, SCL);</span><br><span class="line">    GPIO_ResetBits(GPIO, SCL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是向IIC传递一个字节数据的函数，最后这里写了一个跳过ACK响应，这个ACK响应是什么呢？</p>
<p>我们可以看这个时序图：</p>
<p><img src="https://img2.imgtp.com/2024/04/25/qOQWvGZv.jpg" alt="3.jpg"></p>
<p>可以看到WORD数据后有一个ACK信号，这个ACK信号是响应信号，就是当我们数据传递到IIC设备后，它如果接受到数据后就会发送一个接受信号，这个就是接受信号，我们不需要这个信号，所以直接忽略即可。</p>
<p>好了，模拟IIC的操作就是这些了，下面我们就介绍一下OLED的操作了。</p>
<h1 id="二、OLED的操作"><a href="#二、OLED的操作" class="headerlink" title="二、OLED的操作"></a>二、OLED的操作</h1><h2 id="1-传输数据的准备"><a href="#1-传输数据的准备" class="headerlink" title="1.传输数据的准备"></a>1.传输数据的准备</h2><p>在用IIC协议向OLED传输数据前需要做的操作有下面这几步，我们只有操作好了才能正确的传输命令或者数据：</p>
<p>1.开启IIC协议</p>
<p>2.向OLED传入从地址</p>
<p>3.传输是写入的是命令还是数据</p>
<p>4.开始传输数据</p>
<p>5.结束IIC协议</p>
<p>在传输数据或者命令之前要先向OLED传入它的地址，相当于一个片选，当选中了才可以进行操作，每个OLED的地址都是固定的，都是为<code>0x78</code>，如果要更改需要联系厂家</p>
<p><img src="https://img2.imgtp.com/2024/04/25/mXMAgWXU.png" alt="4.png"></p>
<p>这个就是时序图，在右边的<code>SSD1306 Slave Address</code>就是它的地址，我们就将这个先传入即可，在下面的写入命令会有这个代码。</p>
<p>然后就是传入是数据还是命令，在<code>words</code>这个数据块中可以告诉你该如何传入，第一个<code>Co</code>不用管，默认0皆可，然后第二个是选择命令还是数据，1是数据，0是命令，所以就可以得到下面的内容，当我们要写命令的时候，传入完地址后再传入<code>0x00</code>。如果要写数据得到的时候，要传入<code>0x40</code>。</p>
<h2 id="2-写入命令"><a href="#2-写入命令" class="headerlink" title="2.写入命令"></a>2.写入命令</h2><p>知道了上面的过程后我们就可以写写入命令的函数了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_command</span><span class="params">(u8 cmd)</span>&#123;</span><br><span class="line">    IIC_Start();        <span class="comment">// 开启IIC协议</span></span><br><span class="line">    IIC_Write(<span class="number">0x78</span>);    <span class="comment">// 传入地址</span></span><br><span class="line">    IIC_Write(<span class="number">0x00</span>);    <span class="comment">// 传入0x00代表要传入命令</span></span><br><span class="line">    IIC_Write(cmd);     <span class="comment">// 传入命令</span></span><br><span class="line">    IIC_Stop();         <span class="comment">// 结束IIC协议</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了一次写入命令。</p>
<h2 id="3-写入数据"><a href="#3-写入数据" class="headerlink" title="3.写入数据"></a>3.写入数据</h2><p>写入数据的函数和上面的函数一样，只不过就是传入地址后传入的内容不同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_data</span><span class="params">(u8 data)</span>&#123;</span><br><span class="line">    IIC_Start();</span><br><span class="line">    IIC_Write(<span class="number">0x78</span>);</span><br><span class="line">    IIC_Write(<span class="number">0x40</span>);</span><br><span class="line">    IIC_Write(data);</span><br><span class="line">    IIC_Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以完成一次数据的传送。</p>
<p>这些基础功能讲完了，后面的操作是需要结合命令列表来进行操作了。</p>
<h2 id="4-初始化函数"><a href="#4-初始化函数" class="headerlink" title="4.初始化函数"></a>4.初始化函数</h2><p>首先我们要操作需要先进行初始化，这里初始化的功能不会全部说明，大家如果有问题可以查一下OLED的数据手册即可。</p>
<p>初始化传入的命令步骤如下：</p>
<ol>
<li><p>关闭显示屏</p>
</li>
<li><p>设置显示时钟分频比&#x2F;振荡器频率</p>
</li>
<li><p>设置多路复用率</p>
</li>
<li><p>显示开始行</p>
</li>
<li><p>设置左右方向</p>
</li>
<li><p>设置上下方向</p>
</li>
<li><p>设置COM引脚硬件配置</p>
</li>
<li><p>设置对比度</p>
</li>
<li><p>设置预充电周期</p>
</li>
<li><p>设置VCOMH取消选择级别</p>
</li>
<li><p>设置整个显示打开&#x2F;关闭</p>
</li>
<li><p>设置正常&#x2F;倒转显示</p>
</li>
<li><p>设置充电泵</p>
</li>
<li><p>开启显示</p>
</li>
</ol>
<p>这个内容需要查看手册来慢慢写，我这里就不一个一个介绍了，我这写好了，你们可以直接复制和粘贴</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CMD 0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA 0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOSESHOW 0xAE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETCLS 0xD5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RATE    0xA8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET  0xD3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> START   0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFTRIG 0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPDOWN  0xC8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HARD    0xDA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RATION  0x81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  CYCLE  0xD9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VCOM    0xDB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWUP  0xA4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEN     0x8D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWOK  0xAF</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">()</span>&#123;</span><br><span class="line">    write_command(CLOSESHOW);</span><br><span class="line">    write_command(SETCLS);</span><br><span class="line">    write_command(<span class="number">0x80</span>);</span><br><span class="line">    write_command(RATE);</span><br><span class="line">    write_command(<span class="number">0x3F</span>);</span><br><span class="line">    write_command(OFFSET);</span><br><span class="line">    write_command(<span class="number">0x00</span>);</span><br><span class="line">    write_command(START);</span><br><span class="line">    write_command(LEFTRIG);</span><br><span class="line">    write_command(UPDOWN);</span><br><span class="line">    write_command(HARD);</span><br><span class="line">    write_command(<span class="number">0x12</span>);</span><br><span class="line">    write_command(RATION);</span><br><span class="line">    write_command(<span class="number">0xCF</span>);</span><br><span class="line">    write_command(CYCLE);</span><br><span class="line">    write_command(<span class="number">0xF1</span>);</span><br><span class="line">    write_command(VCOM);</span><br><span class="line">    write_command(<span class="number">0x30</span>);</span><br><span class="line">    write_command(SHOWUP);</span><br><span class="line">    write_command(<span class="number">0xA6</span>);</span><br><span class="line">    write_command(BEN);</span><br><span class="line">    write_command(<span class="number">0x14</span>);</span><br><span class="line">    write_command(SHOWOK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-设置光标"><a href="#5-设置光标" class="headerlink" title="5.设置光标"></a>5.设置光标</h2><p>在屏幕中有一个光标，只不过我们在初始化的时候就把这个光标给隐藏了，但是你要有这个概念，设置光标也是需要使用命令来进行操作，这里也需要参考一下命令手册，但是，我这已经写好了，直接用就可以了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_currsor</span><span class="params">(u8 row, u8 col)</span>&#123;</span><br><span class="line">    write_command(<span class="number">0xB0</span> |row);</span><br><span class="line">    write_command(<span class="number">0x10</span> | ((col &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>));</span><br><span class="line">    write_command(<span class="number">0x00</span> | (col &amp; <span class="number">0x0F</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>row</code>就是光标所在的行，<code>col</code>是光标所在的列。</p>
<h2 id="6-显示字符"><a href="#6-显示字符" class="headerlink" title="6.显示字符"></a>6.显示字符</h2><p>要让OLED显示字符需要使用到取摸3工具取出来，因为我们显示其实就是让那些液晶块亮，哪些不亮，所以需要取摸，这里我没找到Linux下的取摸工具，等后面我有时间后我写一个，然后下面是我之前取好的ASCII后32个字符对应的字摸，大家可以直接拿来用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> ASCII1[][<span class="number">16</span>] = &#123;</span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;!&quot;,0*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x02</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;&quot;&quot;,1*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="number">0x78</span>,<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="number">0x78</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x3F</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x3F</span>,<span class="number">0x04</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;#&quot;,2*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0xFC</span>,<span class="number">0x08</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x21</span>,<span class="number">0x1E</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;$&quot;,3*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x31</span>,<span class="number">0x0C</span>,<span class="number">0x03</span>,<span class="number">0x1E</span>,<span class="number">0x21</span>,<span class="number">0x1E</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;%&quot;,4*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1E</span>,<span class="number">0x21</span>,<span class="number">0x23</span>,<span class="number">0x2C</span>,<span class="number">0x19</span>,<span class="number">0x27</span>,<span class="number">0x21</span>,<span class="number">0x10</span>&#125;,<span class="comment">/*&quot;&amp;&quot;,5*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x12</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;&#x27;&quot;,6*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x18</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;(&quot;,7*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x18</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;)&quot;,8*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0xF0</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x0F</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;*&quot;,9*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x0F</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>&#125;,<span class="comment">/*&quot;+&quot;,10*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x90</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;,&quot;,11*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;-&quot;,12*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;.&quot;,13*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x38</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x60</span>,<span class="number">0x18</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;/&quot;,14*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;0&quot;,0*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;1&quot;,1*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x28</span>,<span class="number">0x24</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;2&quot;,2*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;3&quot;,3*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x30</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x06</span>,<span class="number">0x05</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x3F</span>,<span class="number">0x24</span>,<span class="number">0x24</span>&#125;,<span class="comment">/*&quot;4&quot;,4*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x19</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;5&quot;,5*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x90</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;6&quot;,6*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x68</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3E</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;7&quot;,7*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1C</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;8&quot;,8*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x12</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x11</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;9&quot;,9*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;:&quot;,0*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;;&quot;,1*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;&lt;&quot;,2*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;=&quot;,3*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;&gt;&quot;,4*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x48</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x37</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;?&quot;,5*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0xC8</span>,<span class="number">0x28</span>,<span class="number">0xE8</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x27</span>,<span class="number">0x28</span>,<span class="number">0x2F</span>,<span class="number">0x28</span>,<span class="number">0x17</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;@&quot;,6*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x38</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3C</span>,<span class="number">0x23</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x27</span>,<span class="number">0x38</span>,<span class="number">0x20</span>&#125;,<span class="comment">/*&quot;A&quot;,0*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;B&quot;,1*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;C&quot;,2*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;D&quot;,3*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0xE8</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x23</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;E&quot;,4*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0xE8</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;F&quot;,5*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x22</span>,<span class="number">0x1E</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;G&quot;,6*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">/*&quot;H&quot;,7*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;I&quot;,8*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;J&quot;,9*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0xC0</span>,<span class="number">0x28</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x01</span>,<span class="number">0x26</span>,<span class="number">0x38</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;K&quot;,10*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;L&quot;,11*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x01</span>,<span class="number">0x3E</span>,<span class="number">0x01</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;M&quot;,12*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x30</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;N&quot;,13*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;O&quot;,14*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;P&quot;,15*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x28</span>,<span class="number">0x28</span>,<span class="number">0x30</span>,<span class="number">0x50</span>,<span class="number">0x4F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;Q&quot;,16*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0x20</span>&#125;,<span class="comment">/*&quot;R&quot;,17*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x38</span>,<span class="number">0x20</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;S&quot;,18*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;T&quot;,19*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;U&quot;,20*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0x78</span>,<span class="number">0x88</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x38</span>,<span class="number">0x0E</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;V&quot;,21*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x3E</span>,<span class="number">0x01</span>,<span class="number">0x3E</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;W&quot;,22*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0x18</span>,<span class="number">0x68</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x68</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x30</span>,<span class="number">0x2C</span>,<span class="number">0x03</span>,<span class="number">0x03</span>,<span class="number">0x2C</span>,<span class="number">0x30</span>,<span class="number">0x20</span>&#125;,<span class="comment">/*&quot;X&quot;,23*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0xC8</span>,<span class="number">0x00</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;Y&quot;,24*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x38</span>,<span class="number">0x26</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;Z&quot;,25*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;[&quot;,0*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x38</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x38</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;\&quot;,1*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;]&quot;,2*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;^&quot;,3*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>&#125;,<span class="comment">/*&quot;_&quot;,4*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;`&quot;,5*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x19</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x12</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;a&quot;,0*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x10</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;b&quot;,1*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;c&quot;,2*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">/*&quot;d&quot;,3*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x17</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;e&quot;,4*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0xE0</span>,<span class="number">0x90</span>,<span class="number">0x90</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;f&quot;,5*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x6B</span>,<span class="number">0x94</span>,<span class="number">0x94</span>,<span class="number">0x94</span>,<span class="number">0x93</span>,<span class="number">0x60</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;g&quot;,6*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x10</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">/*&quot;h&quot;,7*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;i&quot;,8*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;j&quot;,9*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x10</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x24</span>,<span class="number">0x06</span>,<span class="number">0x29</span>,<span class="number">0x30</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;k&quot;,10*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;l&quot;,11*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>&#125;,<span class="comment">/*&quot;m&quot;,12*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">/*&quot;n&quot;,13*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;o&quot;,14*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0xFF</span>,<span class="number">0x91</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;p&quot;,15*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x91</span>,<span class="number">0xFF</span>,<span class="number">0x80</span>&#125;,<span class="comment">/*&quot;q&quot;,16*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;r&quot;,17*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x19</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;s&quot;,18*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0xE0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;t&quot;,19*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">/*&quot;u&quot;,20*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0x0C</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;v&quot;,21*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x01</span>,<span class="number">0x0E</span>,<span class="number">0x30</span>,<span class="number">0x0C</span>,<span class="number">0x07</span>,<span class="number">0x38</span>,<span class="number">0x06</span>,<span class="number">0x01</span>&#125;,<span class="comment">/*&quot;w&quot;,22*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x31</span>,<span class="number">0x0E</span>,<span class="number">0x2E</span>,<span class="number">0x31</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;x&quot;,23*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x81</span>,<span class="number">0x86</span>,<span class="number">0x78</span>,<span class="number">0x18</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;y&quot;,24*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x2C</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;z&quot;,25*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> number1[][<span class="number">16</span>] = &#123;</span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;0&quot;,0*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;1&quot;,1*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x28</span>,<span class="number">0x24</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;2&quot;,2*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;3&quot;,3*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x30</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x06</span>,<span class="number">0x05</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x3F</span>,<span class="number">0x24</span>,<span class="number">0x24</span>&#125;,<span class="comment">/*&quot;4&quot;,4*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x19</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;5&quot;,5*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x90</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;6&quot;,6*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x68</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3E</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;7&quot;,7*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1C</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;8&quot;,8*/</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x12</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x11</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;9&quot;,9*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后根据这个字摸，我们可以显示字符了，这里写一个显示字符的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">show_char</span><span class="params">(u8 row, u8 col, u8 charr)</span>&#123;</span><br><span class="line">    u8 i;     <span class="comment">// 遍历变量</span></span><br><span class="line">    set_currsor(row, col + <span class="number">8</span>);    <span class="comment">// 设置显示位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        IIC_Write(ASCII1[charr - <span class="number">32</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    set_currsor(row + <span class="number">1</span>, col + <span class="number">8</span>);  <span class="comment">// 设置下一行显示的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        IIC_Write(ASCII1[charr - <span class="number">32</span>][i + <span class="number">8</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字摸的长度是16位，而我们显示的这个ASCII是8*8大小的，我们在第一次设置光标的时候要加上8是为了错过前面的一个字符，然后在显示字符的时候选择的是逐列式。</p>
<p>也就是先将第一个字节的字摸先显示，然后转到下一列再显示第二个字摸，依次下去，这样如果只有一半，也就是只有4*8,还需要转到下一行补上那4行才可以变成8*8。</p>
<p>在写这个函数的时候，我发现了一个好玩的，我这如果让列不跳过一个字符，而是跳过一位，那这个字符就会扭动，虽然没有什么用，但是感觉很有趣，代码如下，大家可以来试试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扭动字符显示</span></span><br><span class="line"><span class="comment">// 只能显示一个，显示多个就不流畅了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_Twistchar</span><span class="params">(u8 row, u8 col, u8 word)</span>&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    set_currsor(row, col * <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        write_data(ASCII1[word - <span class="number">32</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    set_currsor(row + <span class="number">1</span>, col * <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        write_data(ASCII1[word - <span class="number">32</span>][i + <span class="number">8</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面这些可以删掉，然后在主函数调用的时候调用两遍，要一样的字符</span></span><br><span class="line">    delay_us(<span class="number">5</span>); </span><br><span class="line">    set_currsor(row, col * <span class="number">8</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        write_data(ASCII1[word - <span class="number">32</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    set_currsor(row + <span class="number">1</span>, col * <span class="number">8</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        write_data(ASCII1[word - <span class="number">32</span>][i + <span class="number">8</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-显示字符串"><a href="#7-显示字符串" class="headerlink" title="7.显示字符串"></a>7.显示字符串</h2><p>这个就得看大家对于串操作的熟练程度了，就是用到对字符串的操作，但是呢，这个需要考虑到换行，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">show_string</span><span class="params">(u8 row, u8 col, u8* str)</span>&#123;</span><br><span class="line">    u8 i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++, j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">16</span>)&#123;</span><br><span class="line">            row += <span class="number">1</span>;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        show_char(row, col + j, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我用一个变量作为判断条件，因为一行有128个像素点，我们显示8*8的字符，那一行只能显示16个8*8的字符，所以当j变量到了16个字符，我们就让行换一行，列清零，这样就可以实现换行操作了。</p>
<h2 id="8-清屏"><a href="#8-清屏" class="headerlink" title="8.清屏"></a>8.清屏</h2><p>这个操作很简单，就是将每一行和每一列的所有像素点全部变为0x00就可以了，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">    u8 i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        set_currsor(i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)&#123;</span><br><span class="line">            write_data(<span class="number">0x00</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-显示汉字"><a href="#9-显示汉字" class="headerlink" title="9.显示汉字"></a>9.显示汉字</h2><p>这个也是需要使用取摸得到，然后每个汉字是16*16的点阵，我们只需要显示即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 现实汉字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_hz</span><span class="params">(u8 row, u8 col, u8 len)</span>&#123;</span><br><span class="line">    u8 i, j, x, y;</span><br><span class="line">    y = row;</span><br><span class="line">    x = col;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len * <span class="number">2</span>; j += <span class="number">2</span>, y+= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((x + y) * <span class="number">8</span> &gt;= <span class="number">128</span>)&#123;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">            row = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_currsor(row, (x + y) * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">            write_data(hz[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        set_currsor(row + <span class="number">1</span>, (x + y) * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">            write_data(hz[j + <span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个也是可以自动换行的，但在使用前需要将字摸放入到<code>hz</code>这个数组中，这个数组的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> hz[][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0x20</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0xFE</span>,<span class="number">0x23</span>,<span class="number">0x22</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x20</span>,<span class="number">0x22</span>,<span class="number">0x2C</span>,<span class="number">0xA0</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x48</span>,<span class="number">0x84</span>,<span class="number">0x7F</span>,<span class="number">0x02</span>,<span class="number">0x41</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x13</span>,<span class="number">0x0C</span>,<span class="number">0x14</span>,<span class="number">0x22</span>,<span class="number">0x41</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;我&quot;,0*/</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0xF8</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0xFC</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;们&quot;,1*/</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="number">0x20</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0xA4</span>,<span class="number">0x7F</span>,<span class="number">0x24</span>,<span class="number">0x34</span>,<span class="number">0x28</span>,<span class="number">0x26</span>,<span class="number">0x20</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0x22</span>,<span class="number">0xDA</span>,<span class="number">0x06</span>,<span class="number">0x00</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0xFF</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0x49</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x07</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;都&quot;,2*/</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x84</span>,<span class="number">0xE4</span>,<span class="number">0x3C</span>,<span class="number">0x27</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0xE4</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x09</span>,<span class="number">0x09</span>,<span class="number">0x09</span>,<span class="number">0x09</span>,<span class="number">0x49</span>,<span class="number">0x89</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;有&quot;,3*/</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;一&quot;,4*/</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x04</span>,<span class="number">0xC3</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;个&quot;,5*/</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="number">0x40</span>,<span class="number">0x44</span>,<span class="number">0x24</span>,<span class="number">0x14</span>,<span class="number">0x7F</span>,<span class="number">0x94</span>,<span class="number">0x24</span>,<span class="number">0x00</span>,<span class="number">0x24</span>,<span class="number">0x14</span>,<span class="number">0x7F</span>,<span class="number">0x14</span>,<span class="number">0x24</span>,<span class="number">0x44</span>,<span class="number">0x40</span>,<span class="number">0x00</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x88</span>,<span class="number">0x84</span>,<span class="number">0x42</span>,<span class="number">0x45</span>,<span class="number">0x29</span>,<span class="number">0x11</span>,<span class="number">0x11</span>,<span class="number">0x09</span>,<span class="number">0x05</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;梦&quot;,6*/</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x68</span>,<span class="number">0xFF</span>,<span class="number">0x48</span>,<span class="number">0x88</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x52</span>,<span class="number">0x52</span>,<span class="number">0x52</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x40</span>,<span class="number">0x31</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3B</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x44</span>,<span class="number">0x5B</span>,<span class="number">0x42</span>,<span class="number">0x42</span>,<span class="number">0x72</span>,<span class="number">0x03</span>,<span class="number">0x08</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;想&quot;,7*/</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x68</span>,<span class="number">0xFF</span>,<span class="number">0x48</span>,<span class="number">0x88</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x52</span>,<span class="number">0x52</span>,<span class="number">0x52</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x40</span>,<span class="number">0x31</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3B</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x44</span>,<span class="number">0x5B</span>,<span class="number">0x42</span>,<span class="number">0x42</span>,<span class="number">0x72</span>,<span class="number">0x03</span>,<span class="number">0x08</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">/*&quot;想&quot;,7*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里面有一些测试的汉字，大家可以测试一下。</p>
<h2 id="10-显示图片"><a href="#10-显示图片" class="headerlink" title="10.显示图片"></a>10.显示图片</h2><p>显示图片的代码我没有写，其实和显示字符和汉字一样，然后用取摸工具取出，然后看一下行有多少，列有多少，然后显示即可，这里我后面写完后会放入<code>gitee</code>上的，<code>github</code>的话因为我最近资金不足，所以没工具，懂得都懂。</p>
<h2 id="11-显示动图"><a href="#11-显示动图" class="headerlink" title="11.显示动图"></a>11.显示动图</h2><p>这个其实和GIF的原理一样，图片上覆盖图片，这样就会让图片动起来。</p>
<h1 id="三、完整代码"><a href="#三、完整代码" class="headerlink" title="三、完整代码"></a>三、完整代码</h1><p>我这个项目是分文件编写的，分为<code>oled.c</code>函数原型，<code>oled.h</code>函数声明和头文件引入，<code>oledfont.h</code>这个是字符库，<code>sys.c</code>是延时函数和系统操作,<code>gpio.h</code>是gpio口的初始化函数的声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gpio.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_GPIOInit</span><span class="params">()</span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = CLK;</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIO, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = SDA;</span><br><span class="line">    GPIO_Init(GPIO, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gpio.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __GPIO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GPIO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLK GPIO_Pin_8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDA GPIO_Pin_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_GPIOInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// oled.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C协议开始</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">()</span>&#123;</span><br><span class="line">    GPIO_SetBits(GPIO, SDA);</span><br><span class="line">    GPIO_SetBits(GPIO, CLK);</span><br><span class="line">    GPIO_ResetBits(GPIO, SDA);</span><br><span class="line">    GPIO_ResetBits(GPIO, CLK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IIC协议结束</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">()</span>&#123;</span><br><span class="line">    GPIO_ResetBits(GPIO, SDA);</span><br><span class="line">    GPIO_SetBits(GPIO, CLK);</span><br><span class="line">    GPIO_SetBits(GPIO, SDA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过IIC写入数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Write</span><span class="params">(u8 data)</span>&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (data &amp; <span class="number">0x80</span>)&#123;</span><br><span class="line">            GPIO_SetBits(GPIO, SDA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            GPIO_ResetBits(GPIO, SDA);</span><br><span class="line">        &#125;</span><br><span class="line">        GPIO_SetBits(GPIO, CLK);</span><br><span class="line">        GPIO_ResetBits(GPIOB, CLK);</span><br><span class="line">        data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// GPIO_ResetBits(GPIO, CLK);</span></span><br><span class="line">        <span class="comment">// GPIO_SetBits(GPIO, CLK);</span></span><br><span class="line">    &#125;</span><br><span class="line">    GPIO_SetBits(GPIO, CLK);</span><br><span class="line">    GPIO_ResetBits(GPIO, CLK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入命令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_command</span><span class="params">(u8 cmd)</span>&#123;</span><br><span class="line">    IIC_Start();</span><br><span class="line">    IIC_Write(ADDR);</span><br><span class="line">    IIC_Write(<span class="number">0x00</span>);</span><br><span class="line">    IIC_Write(cmd);</span><br><span class="line">    IIC_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_data</span><span class="params">(u8 data)</span>&#123;</span><br><span class="line">    IIC_Start();</span><br><span class="line">    IIC_Write(ADDR);</span><br><span class="line">    IIC_Write(<span class="number">0x40</span>);</span><br><span class="line">    IIC_Write(data);</span><br><span class="line">    IIC_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置光标</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_currsor</span><span class="params">(u8 row, u8 col)</span>&#123;</span><br><span class="line">    write_command(<span class="number">0xB0</span> |row);</span><br><span class="line">    write_command(<span class="number">0x10</span> | ((col &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>));</span><br><span class="line">    write_command(<span class="number">0x00</span> | (col &amp; <span class="number">0x0F</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扭动字符显示</span></span><br><span class="line"><span class="comment">// 只能显示一个，显示多个就不流畅了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_Twistchar</span><span class="params">(u8 row, u8 col, u8 word)</span>&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    set_currsor(row, col * <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        write_data(ASCII1[word - <span class="number">32</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    set_currsor(row + <span class="number">1</span>, col * <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        write_data(ASCII1[word - <span class="number">32</span>][i + <span class="number">8</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">    set_currsor(row, col * <span class="number">8</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        write_data(ASCII1[word - <span class="number">32</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    set_currsor(row + <span class="number">1</span>, col * <span class="number">8</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        write_data(ASCII1[word - <span class="number">32</span>][i + <span class="number">8</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示一个字符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_char</span><span class="params">(u8 row, u8 col, u8 word)</span>&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    set_currsor(row * <span class="number">2</span>, col * <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        write_data(ASCII1[word - <span class="number">32</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    set_currsor(row * <span class="number">2</span> + <span class="number">1</span>, col * <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        write_data(ASCII1[word - <span class="number">32</span>][i + <span class="number">8</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_string</span><span class="params">(u8 row, u8 col, u8* str)</span>&#123;</span><br><span class="line">    u8 i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++, j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">16</span>)&#123;</span><br><span class="line">            row += <span class="number">1</span>;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        show_char(row, col + j, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现实汉字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_hz</span><span class="params">(u8 row, u8 col, u8 len)</span>&#123;</span><br><span class="line">    u8 i, j, x, y;</span><br><span class="line">    y = row;</span><br><span class="line">    x = col;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len * <span class="number">2</span>; j += <span class="number">2</span>, y+= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// x = (x + j) * 8;</span></span><br><span class="line">        <span class="keyword">if</span> ((x + y) * <span class="number">8</span> &gt;= <span class="number">128</span>)&#123;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">            row = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_currsor(row, (x + y) * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">            write_data(hz[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        set_currsor(row + <span class="number">1</span>, (x + y) * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">            write_data(hz[j + <span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清屏</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">    u8 i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        set_currsor(i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)&#123;</span><br><span class="line">            write_data(<span class="number">0x00</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">()</span>&#123;</span><br><span class="line">    u32 i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++);</span><br><span class="line">    &#125;</span><br><span class="line">    write_command(CLOSESHOW);</span><br><span class="line">    write_command(SETCLS);</span><br><span class="line">    write_command(<span class="number">0x80</span>);</span><br><span class="line">    write_command(RATE);</span><br><span class="line">    write_command(<span class="number">0x3F</span>);</span><br><span class="line">    write_command(OFFSET);</span><br><span class="line">    write_command(<span class="number">0x00</span>);</span><br><span class="line">    write_command(START);</span><br><span class="line">    write_command(LEFTRIG);</span><br><span class="line">    write_command(UPDOWN);</span><br><span class="line">    write_command(HARD);</span><br><span class="line">    write_command(<span class="number">0x12</span>);</span><br><span class="line">    write_command(RATION);</span><br><span class="line">    write_command(<span class="number">0xCF</span>);</span><br><span class="line">    write_command(CYCLE);</span><br><span class="line">    write_command(<span class="number">0xF1</span>);</span><br><span class="line">    write_command(VCOM);</span><br><span class="line">    write_command(<span class="number">0x30</span>);</span><br><span class="line">    write_command(SHOWUP);</span><br><span class="line">    write_command(<span class="number">0xA6</span>);</span><br><span class="line">    write_command(BEN);</span><br><span class="line">    write_command(<span class="number">0x14</span>);</span><br><span class="line">    write_command(SHOWOK);</span><br><span class="line">    clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// oled.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oledfont.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDR 0x78</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD 0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA 0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOSESHOW 0xAE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETCLS 0xD5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RATE    0xA8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET  0xD3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> START   0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFTRIG 0xA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPDOWN  0xC8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HARD    0xDA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RATION  0x81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  CYCLE  0xD9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VCOM    0xDB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWUP  0xA4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEN     0x8D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWOK  0xAF</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_char</span><span class="params">(u8 row, u8 col, u8 word)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_currsor</span><span class="params">(u8 row, u8 col)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_Twistchar</span><span class="params">(u8 row, u8 col, u8 word)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_string</span><span class="params">(u8 row, u8 col, u8* str)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_hz</span><span class="params">(u8 row, u8 col, u8 len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sys.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(u32 time)</span>&#123;</span><br><span class="line">    u32 temp;</span><br><span class="line">    SysTick -&gt; LOAD = <span class="number">9</span> * time;</span><br><span class="line">    SysTick -&gt; CTRL = <span class="number">0x01</span>;</span><br><span class="line">    SysTick -&gt; VAL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        temp = SysTick -&gt; CTRL;</span><br><span class="line">    &#125;<span class="keyword">while</span>((temp &amp; <span class="number">0x01</span>) &amp;&amp; (!(temp &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>))));</span><br><span class="line">    SysTick -&gt; CTRL = <span class="number">0</span>;</span><br><span class="line">    SysTick -&gt; VAL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sys.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SYS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(u32 time)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学会了这个显示屏如何显示后后面我们可以对传感器进行操作了，到时候传感器接收到的数据就可以直接显示在OLED上，这样就能很好的观察其中的变化了。</p>
<p>下一章准备介绍一下显示屏的一些操作，比如显示进度条，显示动图或者其他内容。</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>06 定时器和PWM（1）</title>
    <url>/2025/01/17/4dff7e1a6b94/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面介绍了一下外部中断，这一节主要介绍一下内部定时器和PWM，这两个知识还是比较重要的。</p>
<h1 id="一、定时器"><a href="#一、定时器" class="headerlink" title="一、定时器"></a>一、定时器</h1><h2 id="1-什么是定时器"><a href="#1-什么是定时器" class="headerlink" title="1.什么是定时器"></a>1.什么是定时器</h2><p>定时器其实和计数器一样，我们通过设置一个值，当计数器运行一个计数寄存器向上加1或者向下减1达到这个值后，会发送一个事件，以此运行即可。</p>
<p>这个就是定时器。</p>
<h2 id="2-在stm32中的定时器"><a href="#2-在stm32中的定时器" class="headerlink" title="2.在stm32中的定时器"></a>2.在stm32中的定时器</h2><p>在stm32中定时器是以TIMx来命名的，在stm32中有三类定时器，分别是基本定时器、通用定时器和高级定时器。</p>
<h3 id="2-1-基本定时器"><a href="#2-1-基本定时器" class="headerlink" title="2.1 基本定时器"></a>2.1 基本定时器</h3><p>基本定时器的编号为<code>TIM6</code>和<code>TIM7</code>，它们是属于<code>APB1</code>总线中的外设。</p>
<p>它们的功能有：定时中断、主模式触发DAC。</p>
<p>基本定时器属于最基本的定时器，在stm32f103中没有基本定时器。</p>
<h3 id="2-2-通用定时器"><a href="#2-2-通用定时器" class="headerlink" title="2.2 通用定时器"></a>2.2 通用定时器</h3><p>通用定时器的编号为<code>TIM2</code>、<code>TIM3</code>、<code>TIM4</code>、<code>TIM5</code>，它们是属于<code>APB1</code>总线中的外设。</p>
<p>通用定时器有基本定时器的全部功能，并且在此功能上还添加了内外时钟源选择、输入捕获、输出比较、编码器接口和主从模式等功能。</p>
<p>我们使用通用定时器可以做PWM的输出和捕获。</p>
<h3 id="2-3-高级定时器"><a href="#2-3-高级定时器" class="headerlink" title="2.3 高级定时器"></a>2.3 高级定时器</h3><p>高级定时器的编号为<code>TIM1</code>和<code>TIM8</code>，它们是属于<code>APB2</code>总线中的外设。</p>
<p>高级定时器有通用定时器的全部功能，并且增加了重复计数器、死区生成、互补输出、刹车输入等功能。</p>
<p>其中死区生成、互补输出、刹车输入是针对与三项无刷电机的功能。</p>
<p>在stm32f103c8t6中有一个高级定时器和三个通用定时器，编号分别是<code>TIM1</code>、<code>TIM2</code>、<code>TIM3</code>和<code>TIM4</code>。</p>
<p>接下来我们来了解一下定时器的内部结构。</p>
<h2 id="3-定时器的内部结构"><a href="#3-定时器的内部结构" class="headerlink" title="3.定时器的内部结构"></a>3.定时器的内部结构</h2><p>这里的图我借用了江科大的图</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240731111559043-328370503.png" alt="img"></p>
<p>我们可以设置定时器是使用内部时钟还是外部时钟，也可以捕获外部的PWM信号，然后选择模式是内部模式还是外部模式或者是编码器模式，通过选择模式后进入到时基单元，时基单元主要是用来运行定时器的，预分频器是将输入的时钟再次进行分频，然后根据这个再次分好的频率来运行计数器<code>CNT</code>，当计数器达到自动重装器中的值后会发出一个信号给中断输出控制，中断输出控制发送中断信号给<code>NVIC</code>，这样就可以完成一次定时器中断了。</p>
<p>对于在运行过程中，我们通过代码修改自动重装值<code>ARR</code>中的值时，stm32有两种模式，一种是无预装时许，另一种是有预装时许。</p>
<h3 id="3-1-无预装时许"><a href="#3-1-无预装时许" class="headerlink" title="3.1 无预装时许"></a>3.1 无预装时许</h3><p>无预装时许的意思是，你在某一个时刻修改<code>ARR</code>中的值后，当前计数器比较到当前值后就会立马响应信号，就比如下图：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240731114837880-1114930503.png" alt="img"></p>
<p>原来的计数值是FF，当修改为36后，计数器寄存器达到36后就会发送一个信号出来。</p>
<h3 id="3-2-有预装时许"><a href="#3-2-有预装时许" class="headerlink" title="3.2 有预装时许"></a>3.2 有预装时许</h3><p>有预装时许和无预装时许的区别在与有预装时许有一个影子寄存器，当你在计时的过程中修改<code>ARR</code>的值，这个<code>ARR</code>的值不会立刻响应，而是要等当前的<code>ARR</code>值响应后下一次计数才可以响应：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240731115206151-1655877682.png" alt="img"></p>
<p>可以看到，当修改值后，影子寄存器中的值是不会改变，只有<code>ARR</code>中的值改变，当当前计时完成后，产生更新事件后，才会使用修改后的值。</p>
<h2 id="4-开始写代码"><a href="#4-开始写代码" class="headerlink" title="4.开始写代码"></a>4.开始写代码</h2><p>我们已经了解了定时器的内部结构后我们就知道了如何写好这个代码。</p>
<p>逻辑其实就是，打开TIM的时钟，设置TIM使用内部时钟，配置TIM，打开NVIC中断，书写中断处理函数即可。</p>
<p>那下面就一步一步的进行实现。</p>
<h3 id="4-1-打开TIM时钟"><a href="#4-1-打开TIM时钟" class="headerlink" title="4.1 打开TIM时钟"></a>4.1 打开TIM时钟</h3><p>这一步很简单，只需要先确定TIM的编号，然后打开对应的<code>APB</code>总线即可，这里我选择的是通用定时器<code>TIM2</code>，<code>TIM2</code>是在<code>APB1</code>总线上的，所以代码就使用开启<code>APB1</code>的函数即可开启：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB2Periph_TIM2, ENABLE);</span><br></pre></td></tr></table></figure>

<p>再比如我开启高级定时器<code>TIM1</code>，那高级定时器对应的是<code>APB2</code>总线，那这里的开启时钟代码就是使用<code>APB2</code>的函数即可开启：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);</span><br></pre></td></tr></table></figure>

<p>这样就开启了定时器的时钟。</p>
<h3 id="4-2-选择定时器的时钟"><a href="#4-2-选择定时器的时钟" class="headerlink" title="4.2 选择定时器的时钟"></a>4.2 选择定时器的时钟</h3><p>这里在之前内部结构可以了解到，我们可以选择外部时钟输入或者是内部时钟，配置内部时钟使用的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_InternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br></pre></td></tr></table></figure>

<p>在<code>TIMx</code>这填写对应的定时器编号，比如说这<code>TIM2</code>使用内部时钟作为输入，那就填写为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_InternalClockConfig(TIM2);</span><br></pre></td></tr></table></figure>

<p>这样就可以让<code>TIM2</code>使用内部<code>RCC</code>时钟了。</p>
<p>配置外部时钟输入的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity, <span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数是通过设置ETR外部时钟模式2来作为时钟的输入，这里的传输比较多。</p>
<p>第一个参数是定时器的编号，第二个参数<code>TIM_ExtTRGPrescaler</code>是外部时钟预分频器，这个参数可以填写下面的这些参数：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>TIM_ExtTRGPSC_OFF</td>
<td>不分频</td>
</tr>
<tr>
<td>TIM_ExtTRGPSC_DIV2</td>
<td>2分频</td>
</tr>
<tr>
<td>TIM_ExtTRGPSC_DIV4</td>
<td>4分频</td>
</tr>
<tr>
<td>TIM_ExtTRGPSC_DIV8</td>
<td>8分频</td>
</tr>
</tbody></table>
<p>第三个参数<code>TIM_ExtTRGPolarity</code>是外部触发极性，可以填写下面这些参数：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>TIM_ExtTRGPolarity_Inverted</td>
<td>低电平有效</td>
</tr>
<tr>
<td>TIM_ExtTRGPolarity_NonInverted</td>
<td>高电平有效</td>
</tr>
</tbody></table>
<p>第四个参数<code>ExtTRGFilter</code>是外部触发器过滤器，这个东西是设置一个值，这个值要在0x00到0x0F之间才可以。过滤器就是在一个f频率中采样N个点，如果N个点的电平一致，那就代表有效，这个函数就是设置f和N的。</p>
<p>这里使用的是内部时钟，所以这里使用<code>TIM_InternalClockConfig</code>来进行配置，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_InternalClockConfig(TIM2);</span><br></pre></td></tr></table></figure>

<p>这样就可以使用内部<code>RCC</code>时钟了。</p>
<h3 id="4-3-配置定时器"><a href="#4-3-配置定时器" class="headerlink" title="4.3 配置定时器"></a>4.3 配置定时器</h3><p>这个配置方法很简单，和配置GPIO口一样，创建结构体然后配置里面的内容，最后初始化一下即可，这样就配置好TIM定时器了，使用的结构体是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> TIM_Prescaler;         <span class="comment">/*!&lt; 指定用于除以 TIM 时钟的预分频器值。</span></span><br><span class="line"><span class="comment">  此参数可以是介于 0x0000 和 0xFFFF 之间的数字 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_CounterMode;       <span class="comment">/*!&lt; 指定计数器模式。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Counter_Mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_Period;            <span class="comment">/*!&lt; 指定要加载到活动状态的周期值</span></span><br><span class="line"><span class="comment">  在下一次更新事件中自动重新加载寄存器。</span></span><br><span class="line"><span class="comment">  此参数必须是介于 0x0000 和 0xFFFF 之间的数字。  */</span> </span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_ClockDivision;     <span class="comment">/*!&lt; 指定时钟划分。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Clock_Division_CKD */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> TIM_RepetitionCounter;  <span class="comment">/*!&lt; 这个参数是设置重复计数器的值，这个值填写0x00到0xFF之间的值，只有TIM1和TIM8配置该参数才有用 */</span></span><br><span class="line">&#125; TIM_TimeBaseInitTypeDef;</span><br></pre></td></tr></table></figure>

<p>可以看到这个结构体中有一个<code>TIM_RepetitionCounter</code>参数只有高级定时器才能使用，所以我们可以不配置，给个0即可，也可以使用<code>TIM_TimeBaseStructInit</code>函数对结构体一个默认值。</p>
<p>这里就介绍一下这两种写法，第一种全部配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">TIM_TimeBaseInitStruct.TIM_Prescaler = <span class="number">7200</span> - <span class="number">1</span>;   <span class="comment">// 预分频</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_Period = <span class="number">1000</span> - <span class="number">1</span>； <span class="comment">// arr自动重装器</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;      <span class="comment">// 向上计数</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;      <span class="comment">// 分频系数，这里是不分频</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_RepetitionCounter = <span class="number">0</span>; <span class="comment">// 这个是重复寄存器，因为只有高级的才有，所以这里填0</span></span><br><span class="line">TIM_BaseInit(TIM2, &amp;TIM_TimeBaseInitStruct);</span><br></pre></td></tr></table></figure>

<p>这样就可以配置TIM了，第二种方法，实现给这个结构体一个初始值，然后再配置需要用到的一些参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">TIM_TimeBaseStructInit(&amp;TIM_TimeBaseInitStruct);</span><br><span class="line">TIM_TimeBaseInitStruct.TIM_Prescaler = <span class="number">7200</span> - <span class="number">1</span>;   <span class="comment">// 预分频</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_Period = <span class="number">1000</span> - <span class="number">1</span>； <span class="comment">// arr自动重装器</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;      <span class="comment">// 向上计数</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;      <span class="comment">// 分频系数，这里是不分频</span></span><br><span class="line">TIM_BaseInit(&amp;TIM_TimeBaseInitStruct);</span><br></pre></td></tr></table></figure>

<p>这样就可以配置好了，其实还是比较简单的。</p>
<h3 id="4-4-打开TIM中断"><a href="#4-4-打开TIM中断" class="headerlink" title="4.4 打开TIM中断"></a>4.4 打开TIM中断</h3><p>这个使用<code>TIM_ITConfig()</code>函数进行打开即可，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<p><code>TIMx</code>是TIM的编号。</p>
<p><code>TIM_IT</code>是填写触发模式，这里大家可以去标准库中进行查看。</p>
<p><code>NewState</code>这个是填写使能<code>ENABLE</code>或者失能<code>DISABLE</code>的。</p>
<p>这里我要配置TIM2定时器，更新事件，那么代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);</span><br></pre></td></tr></table></figure>

<p>这样就可以使能定时器中断了。</p>
<h3 id="4-5-配置NVIC"><a href="#4-5-配置NVIC" class="headerlink" title="4.5 配置NVIC"></a>4.5 配置NVIC</h3><p>这个就很简单了，直接上代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel = TIM2_IRQn;   <span class="comment">// 这里注意是定时器的通道，可以在标准库中查询</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br></pre></td></tr></table></figure>

<h3 id="4-6-启动TIM时钟"><a href="#4-6-启动TIM时钟" class="headerlink" title="4.6 启动TIM时钟"></a>4.6 启动TIM时钟</h3><p>这里需要使用<code>TIM_Cmd()</code>进行使能才可以让定时器运行，这里的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_Cmd(TIM2, ENABLE);</span><br></pre></td></tr></table></figure>

<p>这样就可以启动时钟开始定时了。</p>
<h3 id="4-7-书写中断服务函数"><a href="#4-7-书写中断服务函数" class="headerlink" title="4.7 书写中断服务函数"></a>4.7 书写中断服务函数</h3><p>这个地方的中断服务函数需要到启动文件中去找，我这使用的是<code>TIM2</code>，所以中断服务函数是：<code>TIM2_IRQHandler</code>，然后写里面的内容即可，这里的话不是清除外部中断标志位和判断外部中断标志位了，而是清除定时器的中断标志位和判断定时器中断的标志位。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)  <span class="comment">// 这里类型是更新中断</span></span><br><span class="line">    &#123;</span><br><span class="line">        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);   <span class="comment">// 清除中断标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样内部定时器中断和实现就写完了，接下来来介绍一下如何计算定时的时间。</p>
<h2 id="5-定时时间的计算"><a href="#5-定时时间的计算" class="headerlink" title="5.定时时间的计算"></a>5.定时时间的计算</h2><p>这个是讲公式了，我们前面了解到一个内部时钟，这个是CLK，预分频器是PSC，重装寄存器是RCC，那定时频率的公式为：P_CLK &#x3D; CLK &#x2F; (PSC + 1) &#x2F; (RCC + 1)。</p>
<p>根据这个公式就可以计算出来计时时间了，比如说我们要实现1s的定时，那PSC我们可以给7200 - 1，RCC可以给10000 - 1，这样就是1s发生一次中断。</p>
<p>当然你也可以给PSC 10000 - 1，RCC给7200 - 1。</p>
<p>这些都是可以的，这个是自己经过计算可以得到的。</p>
<h1 id="二、外部时钟模式定时器"><a href="#二、外部时钟模式定时器" class="headerlink" title="二、外部时钟模式定时器"></a>二、外部时钟模式定时器</h1><p>上面介绍了使用<code>RCC</code>作为时钟的定时器，这里介绍一下用外部的时钟作为定时器的方式。</p>
<p>其实内部的思想是一样的，在时钟选择那不用<code>TIM_InternalClockConfig()</code>函数进行设置，而是使用<code>TIM_ETRClockMode2Config()</code>函数进行设置即可，上面详细解释了这个函数的原型和参数，这里就不再介绍了，然后配置个GPIO口，因为需要外部输入，外部输入需要使用到GPIO口，所以要进行配置，手册上对于作为时钟输入的GPIO口配置为浮空输入，这里也用浮空输入，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB2Periph_TIM2, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOx, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置GPIO口</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;   <span class="comment">// 浮空输入</span></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_x;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOx, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置TIM时钟</span></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">TIM_TimeBaseInitStruct.TIM_Prescaler = <span class="number">7200</span> - <span class="number">1</span>;   <span class="comment">// 预分频</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_Period = <span class="number">1000</span> - <span class="number">1</span>； <span class="comment">// arr自动重装器</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;      <span class="comment">// 向上计数</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;      <span class="comment">// 分频系数，这里是不分频</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_RepetitionCounter = <span class="number">0</span>; <span class="comment">// 这个是重复寄存器，因为只有高级的才有，所以这里填0</span></span><br><span class="line">TIM_BaseInit(TIM2, &amp;TIM_TimeBaseInitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用外部时钟</span></span><br><span class="line">TIM_ETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_Inverted, <span class="number">0x03</span>);   <span class="comment">// 无分频，低电平为有效输入，过滤器为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能TIM中断</span></span><br><span class="line">TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置NVIC</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能TIM</span></span><br><span class="line">TIM_Cmd(TIM2, ENABLE);</span><br></pre></td></tr></table></figure>

<p>然后就是书写中断服务函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)  <span class="comment">// 这里类型是更新中断</span></span><br><span class="line">    &#123;</span><br><span class="line">        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);   <span class="comment">// 清除中断标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断服务函数的位置不固定。</p>
<h1 id="三、PWM"><a href="#三、PWM" class="headerlink" title="三、PWM"></a>三、PWM</h1><p>终于到PWM脉冲调制控制了，这个功能的实现其实也是基于定时器的，这个功能用来控制电机的。</p>
<p>PWM有三个关键参数，一个是占空比，一个是分辨率，另一个是频率。</p>
<p>占空比是在一个时钟内，高电平的时间和一个时钟时间的比值。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240731145853440-1506660610.png" alt="img"></p>
<p>Ts是一个时钟的时间，Ton是高电平的时间。这个就是占空比。</p>
<p>分辨率是占空比的变化步距。</p>
<p>频率是Ts时钟时间的倒数。</p>
<h2 id="1-PWM工作过程"><a href="#1-PWM工作过程" class="headerlink" title="1.PWM工作过程"></a>1.PWM工作过程</h2><p>在PWM中有着定时器的重装寄存器ARR，还增加了一个捕获&#x2F;比较寄存器<code>CCR</code>，这个<code>CCR</code>的作用是，当计数器到达这个<code>CCR</code>设定的值后就会发生一个电平的翻转，例如下图：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240731150352588-103987578.png" alt="img"></p>
<p>黄色的线代表着<code>ARR</code>中的值，红色的线代表<code>CCR</code>中的值，可以看到当计数器到<code>CCR</code>那时，电平就发生了变化，当到达<code>ARR</code>后就会变回来，以此工作下去。</p>
<h2 id="2-PWM内部结构"><a href="#2-PWM内部结构" class="headerlink" title="2.PWM内部结构"></a>2.PWM内部结构</h2><p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240731150905333-2121755911.png" alt="img"></p>
<p>可以看到这个内部结构，<code>CRR</code>就是对计数器中的值进行一个比较，当比较成功就会根据设置好的模式来进行输出，其实还是比较简单的，设置方法也是先设置TIM，然后配置GPIO口，最后配置PWM的模式就可以了，过程比较简单，前面见过的TIM设置这里就不再重复了。</p>
<p>因为PWM是通用定时器和高级定时器的一个功能，所以不需要额外开启时钟，直接开启对应的定时器的时钟即可。</p>
<p>主要要注意，基本定时器是没有PWM功能的。</p>
<h3 id="2-1-配置GPIO口"><a href="#2-1-配置GPIO口" class="headerlink" title="2.1 配置GPIO口"></a>2.1 配置GPIO口</h3><p>这里需要使用到GPIO口来作为一个PWM的输出，翻看手册，可以看到</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240731151403977-1619864766.png" alt="img"></p>
<p>对于输出比较通道，GPIO口的配置是使用推挽复用输出<code>GPIO_Mode_AF_PP</code>，所以这里就明白了，配置方法很简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;   <span class="comment">// 复用推挽输出</span></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_x;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOx, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-配置PWM"><a href="#2-2-配置PWM" class="headerlink" title="2.2 配置PWM"></a>2.2 配置PWM</h3><p>上面有一步是配置TIM，那个之前就已经说了的，配置的内容一样，所以就直接省略，这里直接上PWM配置，使用到的函数比较多，其实我们这使用的是定时器的输出比较功能，而在输出比较功能中就有一个功能是PWM功能。</p>
<p>这里的输出比较有这么几个模式，这里还是借用江科大的图：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240731152155454-1787089970.png" alt="img"></p>
<p>这里可以看到有这些功能，解释也比较清楚，所以这里就不介绍了。</p>
<p>这里配置PWM也是使用一个结构体来进行配置，结构体的类型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> TIM_OCMode;        <span class="comment">/*!&lt; 指定 TIM 模式。</span></span><br><span class="line"><span class="comment">  此参数可以是 TIM 模式@ref TIM_Output_Compare_and_PWM_modesSpecifies的值。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Output_Compare_and_PWM_modes */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_OutputState;   <span class="comment">/*!&lt; 指定 TIM 输出比较状态。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Output_Compare_state */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_OutputNState;  <span class="comment">/*!&lt; 指定 TIM 互补输出比较状态。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Output_Compare_N_state</span></span><br><span class="line"><span class="comment">  @note 此参数仅对 TIM1 和 TIM8 有效。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_Pulse;         <span class="comment">/*!&lt; 指定要加载到捕获比较寄存器中的脉冲值。</span></span><br><span class="line"><span class="comment">  此参数可以是介于 0x0000 和 0xFFFF 之间的数字 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_OCPolarity;    <span class="comment">/*!&lt; 指定输出极性。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Output_Compare_Polarity */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_OCNPolarity;   <span class="comment">/*!&lt; 指定互补输出极性。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Output_Compare_N_Polarity</span></span><br><span class="line"><span class="comment">  @note 此参数仅对 TIM1 和 TIM8 有效。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_OCIdleState;   <span class="comment">/*!&lt; 指定空闲状态期间的 TIM 输出比较引脚状态。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Output_Compare_Idle_State</span></span><br><span class="line"><span class="comment">  @note 此参数仅对 TIM1 和 TIM8 有效。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_OCNIdleState;  <span class="comment">/*!&lt; 指定空闲状态期间的 TIM 输出比较引脚状态。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Output_Compare_N_Idle_State</span></span><br><span class="line"><span class="comment">  @note 此参数仅对 TIM1 和 TIM8 有效。 */</span></span><br><span class="line">&#125; TIM_OCInitTypeDef;</span><br></pre></td></tr></table></figure>

<p>这里的话有一些可以不用配置，表明着仅对 TIM1 和 TIM8 有效的可以省略，这里可以使用<code>TIM_OCStructInit</code>函数对创建好的结构体进行一个初始化，避免初始化时因为参数没有配置导致出现错误。</p>
<p>首先创建一个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_OCInitTypeDef TIM_OCInitStruct = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>然后使用<code>TIM_OCStructInit</code>进行初始化配置:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_OCStructInit(&amp;TIM_OCInitStruct);</span><br></pre></td></tr></table></figure>

<p>初始化完成后就可以开始对结构体中的成员开始配置了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;  <span class="comment">// 这个是配置模式，这里配置的模式是PWM1</span></span><br><span class="line">TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_ENABLE;    <span class="comment">// 这里配置的是输出使能如果不使能就输出不了</span></span><br><span class="line">TIM_OCInitStruct.TIM_Pulse = <span class="number">0x20</span>;  <span class="comment">// 这里是设置脉冲值，这个具体的内容后面再详细讲解</span></span><br><span class="line">TIM_OCInitStruct.TIM_OCPolarity = TIM_OCPolarity_High;         <span class="comment">// 这里是设置输出极性，比如说没达到CCR时，就输出这个电平，当达到后就会翻转</span></span><br></pre></td></tr></table></figure>

<p>这样就配置好了结构体了，下面就需要进行初始化，在初始化的时候需要选择对应的输出比较函数，在c8t6中有4个输出比较通道可以进行设置，并不是每个通道都可以初始化相应的定时器，这个需要在看GPIO引脚的默认复用功能是哪一个通道，然后再选择相应的通道，这四个函数为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240731160909597-366055006.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240731160922043-862972203.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202407/3083010-20240731160930913-14232135.png" alt="img"></p>
<p>比如说上面还是使用的是TIM2定时器，并且是使用PA3作为PWM的输出，那么这里的初始化通道就得选择4通道，初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_OC4Init(TIM2, &amp;TIM_OCInitStruct);</span><br></pre></td></tr></table></figure>

<p>这样就可以配置好TIM2_CH4了。</p>
<h3 id="2-3-使能输出比较通道"><a href="#2-3-使能输出比较通道" class="headerlink" title="2.3 使能输出比较通道"></a>2.3 使能输出比较通道</h3><p>这个使用一个函数就可以进行使能了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Enable);</span><br></pre></td></tr></table></figure>

<p>当然这也是有4个函数的，这4的函数要对应对应的通道来选择，不能乱选择。</p>
<h3 id="2-4-使能定时器"><a href="#2-4-使能定时器" class="headerlink" title="2.4 使能定时器"></a>2.4 使能定时器</h3><p>设置完成后我们就可以加定时器进行设置了，设置的函数和前面的一样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_Cmd(TIM2, ENABLE);</span><br></pre></td></tr></table></figure>

<h3 id="2-5-计算出占空比"><a href="#2-5-计算出占空比" class="headerlink" title="2.5 计算出占空比"></a>2.5 计算出占空比</h3><p>这样PWM就设置完成了，现在然后我们就可以了解一下占空比的计算方法了，我们之前设置了PSC预分频器和重装寄存器ARR，这个可以算出运行一次需要多少时间，那我们用设置的CCR捕获&#x2F;比较寄存器来除以（ARR+1）了。</p>
<p>比如说在1s的定时器中输出0.5s的高电平和0.5s的低电平，那PSC设置为7200 - 1，ARR设置为10000 - 1，CCR设置为5000 - 1即可实现。</p>
<h1 id="四、LED呼吸灯"><a href="#四、LED呼吸灯" class="headerlink" title="四、LED呼吸灯"></a>四、LED呼吸灯</h1><p>这个项目太经典了，每个教程在讲PWM的时候都会讲一个呼吸灯的项目，这里也一样，跟随潮流，我也写一个。</p>
<p>其实这个项目很简单，就是不断的调整PWM的占空比就可以实现了。</p>
<p>初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建初始化结构体变量</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    TIM_OCInitTypeDef TIM_OCInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置GPIO引脚</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置TIM定时器</span></span><br><span class="line">    TIM_TimeBaseStructInit(&amp;TIM_TimeBaseInitStruct);</span><br><span class="line">    </span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="comment">// 时钟分频</span></span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;       <span class="comment">// 计算模式</span></span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;           <span class="comment">//自动重装值</span></span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_Prescaler = <span class="number">720</span> - <span class="number">1</span>;        <span class="comment">// 预分频</span></span><br><span class="line">    TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStruct);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置PWM</span></span><br><span class="line">    TIM_OCStructInit(&amp;TIM_OCInitStruct);</span><br><span class="line">    TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;     <span class="comment">// 输出使能</span></span><br><span class="line">    TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;       <span class="comment">// PWM模式1</span></span><br><span class="line">    TIM_OCInitStruct.TIM_Pulse = <span class="number">0</span>;              <span class="comment">// CCR值</span></span><br><span class="line">    TIM_OCInitStruct.TIM_OCPolarity = TIM_OCPolarity_Low;    <span class="comment">// 有效输出</span></span><br><span class="line">    TIM_OC4Init(TIM2, &amp;TIM_OCInitStruct);</span><br><span class="line">    TIM_OC4PreloadConfig(TIM2, TIM_OCPreload_Enable);</span><br><span class="line">    TIM_Cmd(TIM2, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后主函数的实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int16_t</span> i = <span class="number">0</span>;</span><br><span class="line">    PWM_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TIM_SetCompare4(TIM2, i);</span><br><span class="line">            delay_ms(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">100</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            TIM_SetCompare4(TIM2, i);</span><br><span class="line">            delay_ms(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TIM定时器中断和PWM的基础功能还是比较简单的，大家可以多使用一下就可以慢慢的熟悉了。</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>07 输入捕获和编码器接口</title>
    <url>/2025/01/17/67157ff102f4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面介绍了定时器和输出比较，这一节主要介绍一下输入捕获测量输入频率和PWM占空比，然后介绍一下编码器接口。</p>
<h1 id="一、输入捕获"><a href="#一、输入捕获" class="headerlink" title="一、输入捕获"></a>一、输入捕获</h1><h2 id="1-什么是输入捕获"><a href="#1-什么是输入捕获" class="headerlink" title="1.什么是输入捕获"></a>1.什么是输入捕获</h2><p>当输入的引脚有指定电平跳变时，会将计数器CNT中的值保存在CCR中，这个就称为输入捕获。</p>
<h2 id="2-输入捕获测频率"><a href="#2-输入捕获测频率" class="headerlink" title="2.输入捕获测频率"></a>2.输入捕获测频率</h2><p>我们可以通过获取输入的值来测量频率，这里有两个计算的方法：</p>
<h3 id="2-1-测频法"><a href="#2-1-测频法" class="headerlink" title="2.1 测频法"></a>2.1 测频法</h3><p>在一个闸门时间T内，对上升沿进行计数，得到计数值N，频率就为&#x3D;N&#x2F;T。</p>
<h3 id="2-2-测周法"><a href="#2-2-测周法" class="headerlink" title="2.2 测周法"></a>2.2 测周法</h3><p>在一个标准的频率fc下，对上升沿进行计数，得到计数值N，频率就为：fc &#x2F; N。</p>
<h2 id="3-输入捕获的内部结构"><a href="#3-输入捕获的内部结构" class="headerlink" title="3.输入捕获的内部结构"></a>3.输入捕获的内部结构</h2><p>接下来了解一下输入捕获的内部结构，只有了解了内部结构，我们写代码才会很轻松，下图就是输入捕获的内部结构：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240802102446874-1786397910.png" alt="img"></p>
<p>可以看到，从GPIO口输入电平，然后通过输入捕获单元，检测到触发电平，如果是设定的电平就会将CNT中的值保存到CCR中，然后通过配置从模式来将CNT中的值清0。</p>
<p>了解了这个结构后我们大概就知道如何配置输入捕获了。</p>
<p>首先配置外部输入，即GPIO口，然后配置定时器，因为输入捕获是定时器的一个工作模式，然后配置从模式，使用从模式的Reset来清空计数器CNT，这样就是配置好输入捕获了。</p>
<p>我们可以通过读取CCR中的值来计算频率。</p>
<h2 id="4-软件实现"><a href="#4-软件实现" class="headerlink" title="4.软件实现"></a>4.软件实现</h2><p>前面了解了硬件结构后，我们就可以使用软件来一一实现了，首先要打开时钟，时钟是stm32中最重要的一个部件，如果不打开时钟，就算配置了也没办法运行。</p>
<h3 id="4-1-打开时钟"><a href="#4-1-打开时钟" class="headerlink" title="4.1 打开时钟"></a>4.1 打开时钟</h3><p>这里我们从上面的硬件分析可以得到，其实就是只用开启两个时钟，一个是GPIO的时钟，另一个就是TIM的时钟，输入捕获这个功能是在TIM中的，所以打开了TIM的时钟，输入捕获和输出比较也就打开了。</p>
<p>所以这里的代码就比较简单，我这里使用TIM3作为输入捕获的定时器，那么打开的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-配置GPIO口"><a href="#4-2-配置GPIO口" class="headerlink" title="4.2 配置GPIO口"></a>4.2 配置GPIO口</h3><p>GPIO口做为一个外部信号的输入口，所以要为其设置输入模式，那选择什么模式最好呢？这里可以翻看一下手册：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240802103502500-1392002671.png" alt="img"></p>
<p>可以看到GPIO配置为浮空输入，但是其实这里也可以配置为上拉输入，浮空输入就是能很好的捕捉电平的变化，但是没有上拉或者下拉导致不是很稳定，这里因为都是一个电平的跳变，就算是使用上拉，当输入的是高电平后会跳变为低电平，然后再变成高电平，所以这里可以选上拉或者下拉。</p>
<p>如果你不清楚这个跳变到底是什么，你可以选择浮空输入，这样获得的要好一点。</p>
<p>这里就是正常的配置GPIO口即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;   <span class="comment">// 这里使用上拉输入</span></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<p>这里是使用的是TIM3的通道1。</p>
<h3 id="4-3-配置TIM"><a href="#4-3-配置TIM" class="headerlink" title="4.3 配置TIM"></a>4.3 配置TIM</h3><p>现在需要配置一下TIM了，在配置GPIO那配置的是TIM3的通道1，所以这要配置一下TIM3。</p>
<p>如果你选择的是TIM2，那上面要配置TIM2对应的引脚。</p>
<p>这里的配置方法和之前配置定时器那一样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM3);    <span class="comment">// 使用内部时钟</span></span><br><span class="line">    </span><br><span class="line">TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;       <span class="comment">// 不分频</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;     <span class="comment">// 向上计数</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;     <span class="comment">// 这里需要注意</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;      <span class="comment">// 频率</span></span><br><span class="line">TIM_TimeBaseInitStruct.TIM_RepetitionCounter = <span class="number">0</span>;       <span class="comment">// 重复计数器，高级定时器才有的功能</span></span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStruct);</span><br></pre></td></tr></table></figure>

<p>这里的自动重装寄存器是填了一个最大值，是因为这里的输入捕获是用CNT对变化电平进行计数，而CNT中的值和自动重装寄存器ARR中的值一致时，就会使得计数器清0然后发送一个信号，如果这里到了ARR中的值后，还有变化的电平，是不是就会被舍弃。</p>
<p>所以这里为了防止这个问题，我们将ARR中的值设置成最大值，防止出现到了自动重装值时还有变化，所以用个最大的值，防止溢出。</p>
<h3 id="4-4-配置输入捕获"><a href="#4-4-配置输入捕获" class="headerlink" title="4.4 配置输入捕获"></a>4.4 配置输入捕获</h3><p>这个也是使用一个结构体来进行配置的，结构体类型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_Channel;      <span class="comment">/*!&lt; 指定 TIM 通道。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Channel */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_ICPolarity;   <span class="comment">/*!&lt; 指定输入信号的有效边沿。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Input_Capture_Polarity */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_ICSelection;  <span class="comment">/*!&lt; 指定输入。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Input_Capture_Selection */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_ICPrescaler;  <span class="comment">/*!&lt; 指定输入捕获预分频器。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref TIM_Input_Capture_Prescaler */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> TIM_ICFilter;     <span class="comment">/*!&lt; 指定输入捕获筛选器。</span></span><br><span class="line"><span class="comment">  此参数可以是介于 0x0 和 0xF 之间的数字 */</span></span><br><span class="line">&#125; TIM_ICInitTypeDef;</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>TIM_Channel</code>是选择通道，这个是通过之前说的引脚来进行设定的：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240802110117493-1469706630.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240802110137440-1592808447.png" alt="img"></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240802110144469-1344710896.png" alt="img"></p>
<p>前面比如是设置了TIM3_CH1，那这里就填写<code>TIM_Channel_1</code>。</p>
<p>第二个参数<code>TIM_ICPolarity</code>，这个参数是选择有效信号的，可以选择<code>TIM_ICPolarity_Rising</code>高电平触发，<code>TIM_ICPolarity_Falling</code>低电平触发。</p>
<p>第三个参数<code>TIM_ICSelection</code>，指定输入，有信号直连<code>TIM_ICSelection_DirectTI</code>和交叉<code>TIM_ICSelection_IndirectTI</code>。这个需要拿个图来看看：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240802111017688-560210779.png" alt="img"></p>
<p>从这可以看到，我们通过选择<code>TI1FP1</code>它可以连到两个输入通道，一个是连到输入通道1，另一个连到通道2，直接配置到输入通道1的就叫做直连模式，如果连到输入通道2就叫做交叉模式。</p>
<p>第四个参数<code>TIM_ICPrescaler</code>就是分配器。</p>
<p>第五个参数<code>TIM_ICFilter</code>这个参数是选择过滤器的分辨率。</p>
<p>了解了结构体后我们就可以配置一下结构体中的内容了，这里我直接使用定时器通道1和输入通道1，所以模式就是直连：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_ICInitStruct.TIM_Channel = TIM_Channel_1;</span><br><span class="line">TIM_ICInitStruct.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">TIM_ICInitStruct.TIM_ICPolarity = TIM_ICPolarity_Rising;      <span class="comment">// 有效电平高电平</span></span><br><span class="line">TIM_ICInitStruct.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">TIM_ICInitStruct.TIM_ICSelection = TIM_ICSelection_DirectTI;     <span class="comment">// 直连</span></span><br><span class="line">TIM_ICInit(TIM3, &amp;TIM_ICInitStruct);</span><br></pre></td></tr></table></figure>

<p>这里再举一个例子，我这还是定时器通道1，输入通道变成了通道2，那这就选择交叉模式，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_ICInitStruct.TIM_Channel = TIM_Channel_1;</span><br><span class="line">TIM_ICInitStruct.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">TIM_ICInitStruct.TIM_ICPolarity = TIM_ICPolarity_Rising;      <span class="comment">// 有效电平高电平</span></span><br><span class="line">TIM_ICInitStruct.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">TIM_ICInitStruct.TIM_ICSelection = TIM_ICSelection_IndirectTI;     <span class="comment">// 交叉</span></span><br><span class="line">TIM_ICInit(TIM3, &amp;TIM_ICInitStruct);</span><br></pre></td></tr></table></figure>

<p>这样就可以通过读取输入通道2中的CCR值来获取有效电平的次数了。</p>
<p>我们可以通过这个来计算PWM的频率和PWM的占空比，一个输入通道来获取PWM频率，另一个通道获取PWM的占空比。</p>
<p>一个通道两个设置的方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_ICInitStruct.TIM_Channel = TIM_Channel_1;</span><br><span class="line">TIM_ICInitStruct.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">TIM_ICInitStruct.TIM_ICPolarity = TIM_ICPolarity_Rising;      <span class="comment">// 有效电平高电平</span></span><br><span class="line">TIM_ICInitStruct.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">TIM_ICInitStruct.TIM_ICSelection = TIM_ICSelection_DirectTI;     <span class="comment">// 直连</span></span><br><span class="line">TIM_ICInit(TIM3, &amp;TIM_ICInitStruct);</span><br><span class="line"></span><br><span class="line">TIM_ICInitStruct.TIM_Channel = TIM_Channel_1;</span><br><span class="line">TIM_ICInitStruct.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">TIM_ICInitStruct.TIM_ICPolarity = TIM_ICPolarity_Falling;      <span class="comment">// 有效电平低电平</span></span><br><span class="line">TIM_ICInitStruct.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">TIM_ICInitStruct.TIM_ICSelection = TIM_ICSelection_IndirectTI;     <span class="comment">// 交叉</span></span><br><span class="line">TIM_ICInit(TIM3, &amp;TIM_ICInitStruct);</span><br></pre></td></tr></table></figure>

<p>一个通道分别有直连和交叉，然后一个是高电平有效，一个是低电平有效。</p>
<h3 id="4-5-配置从模式"><a href="#4-5-配置从模式" class="headerlink" title="4.5 配置从模式"></a>4.5 配置从模式</h3><p>我们在前面知道，需要配置个从模式让从模式去执行<code>Reset</code>操作来讲CNT中的值清0，这里只需要使用俩个函数就可以实现，首先是第一个<code>TIM_SelectInputTrigger</code>，这个函数是选择触发器源，在这个图中：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240802112328175-731723048.png" alt="img"></p>
<p>可以看到在边缘检测电路后有四个信号，分别是是<code>TI1FP1</code>、<code>TI2FP2</code>、<code>TI3FP3</code>、<code>TI4FP4</code>，这几个信号可以触发从模式，我们先用这个定时器的输入通道后，然后通过<code>TIM_SelectSlaveMode</code>函数来设置从模式。</p>
<p>比如说我们上面设置的是TIM3定时器，而且是使用的是TIM3_CH1，那这的设置函数就为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);</span><br><span class="line">TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);</span><br></pre></td></tr></table></figure>

<p>再比如说，这里是TIM2的CH2，那设置函数为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_SelectInputTrigger(TIM2, TIM_TS_TI2FP2);</span><br><span class="line">TIM_SelectSlaveMode(TIM2, TIM_SlaveMode_Reset);</span><br></pre></td></tr></table></figure>

<p>这里的信号<code>TIxFPx</code>和定时器是什么无关，只和通道有关。stm32f103c8t6只能配置4个输入捕获，所以这里的x是从1到4。</p>
<h3 id="4-6-使能定时器"><a href="#4-6-使能定时器" class="headerlink" title="4.6 使能定时器"></a>4.6 使能定时器</h3><p>这个就不详细说了，就是使用<code>TIM_Cmd()</code>函数就可以使能了，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_Cmd(TIMx, ENABLE);</span><br></pre></td></tr></table></figure>

<h2 id="5-输入捕获测频率和占空比"><a href="#5-输入捕获测频率和占空比" class="headerlink" title="5.输入捕获测频率和占空比"></a>5.输入捕获测频率和占空比</h2><p>上面介绍了代码的实现，这里来介绍一下，如果使用输入捕获来获取PWM频率和PWM占空比。</p>
<p>这个的代码实现比较简单，就是设置为输入捕获模式，然后写两个转换函数即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    TIM_ICInitTypeDef TIM_ICInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_7;  <span class="comment">// 这里使用的是TIM3_CH2</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">    </span><br><span class="line">    TIM_InternalClockConfig(TIM3);</span><br><span class="line">    </span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;</span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;</span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStruct);</span><br><span class="line">    </span><br><span class="line">    TIM_ICInitStruct.TIM_Channel = TIM_Channel_2;       <span class="comment">// 直连模式要选择通道2</span></span><br><span class="line">    TIM_ICInitStruct.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">    TIM_ICInitStruct.TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">    TIM_ICInitStruct.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">    TIM_ICInitStruct.TIM_ICSelection = TIM_ICSelection_DirectTI;        <span class="comment">// 直连模式</span></span><br><span class="line">    TIM_ICInit(TIM3, &amp;TIM_ICInitStruct);</span><br><span class="line">    </span><br><span class="line">    TIM_ICInitStruct.TIM_Channel = TIM_Channel_1;          <span class="comment">// 交叉模式要选择通道1</span></span><br><span class="line">    TIM_ICInitStruct.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">    TIM_ICInitStruct.TIM_ICPolarity = TIM_ICPolarity_Falling;   <span class="comment">// 这里需要和上面设置的有效电平分割开，要不然会出现运行不了的问题，我试过，必须要分开，要不然测试不了。</span></span><br><span class="line">    TIM_ICInitStruct.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">    TIM_ICInitStruct.TIM_ICSelection = TIM_ICSelection_IndirectTI;      <span class="comment">// 交叉模式</span></span><br><span class="line">    TIM_ICInit(TIM3, &amp;TIM_ICInitStruct);</span><br><span class="line">    </span><br><span class="line">    TIM_SelectInputTrigger(TIM3, TIM_TS_TI2FP2);</span><br><span class="line">    TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);</span><br><span class="line">    </span><br><span class="line">    TIM_Cmd(TIM3, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_Get_Freq</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 转换为频率</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000000</span> / (TIM_GetCapture2(TIM3) + <span class="number">1</span>);      <span class="comment">// 用输入捕获设置的频率除以标准时钟72MHz后得到1000000，然后用这个频率除以获取的N即可得到频率。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_Get_Pulse</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 转换为占空比</span></span><br><span class="line">    <span class="keyword">return</span> ((TIM_GetCapture1(TIM3) + <span class="number">1</span>) * <span class="number">100</span>) / IC_Get_Freq();      <span class="comment">// 这个算法是在PWM占空比那说过的。这里不重复</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就可以获取得到PWM的频率和占空比了。</p>
<h1 id="二、编码器接口"><a href="#二、编码器接口" class="headerlink" title="二、编码器接口"></a>二、编码器接口</h1><h2 id="1-什么是编码器接口"><a href="#1-什么是编码器接口" class="headerlink" title="1.什么是编码器接口"></a>1.什么是编码器接口</h2><p>编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减。</p>
<p>下图是一个正交编码器的图：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240802114916183-1439848519.png" alt="img"></p>
<p>可以看到，编码器的这个波形，A项和B项的波形是相差90度的，所以这两个波形在一起就可以分正和反了。</p>
<h2 id="2-编码器接口的硬件结构"><a href="#2-编码器接口的硬件结构" class="headerlink" title="2.编码器接口的硬件结构"></a>2.编码器接口的硬件结构</h2><p>我们可以用前面学过的输入捕获或者是中断来实现编码器的实现，但是，在stm32f103c8t6中设置了一个编码器接口，我们可以直接使用硬件来实现编码器的测试。</p>
<p>硬件结构如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240802115650098-1214663844.png" alt="img"></p>
<p>可以看到非常的简单，只需要在前面的基础上增加个编译器接口的配置即可。</p>
<p>使用的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_EncoderInterfaceConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_EncoderMode,<span class="type">uint16_t</span> TIM_IC1Polarity, <span class="type">uint16_t</span> TIM_IC2Polarity)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数就可以设置编码器接口了，首先设置GPIO口，因为我们的这个编码器是需要两个输入的，所以需要设置两个引脚作为输入引脚，然后配置定时器，配置为定时器后需要配置输入捕获，之后就使用上面的函数进行配置编码器接口。</p>
<p>第一个参数<code>TIMx</code>是定时器的编号。</p>
<p>第二个参数<code>TIM_EncoderMode</code>是使用模式，可以选下面这几个模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>TIM_EncoderMode_TI1</td>
<td>使用TI1FP1作为编码器设置</td>
</tr>
<tr>
<td>TIM_EncoderMode_TI2</td>
<td>使用TI2FP2作为编码器设置</td>
</tr>
<tr>
<td>TIM_EncoderMode_TI12</td>
<td>使用TI1FP1和TI2FP2作为编码器设置</td>
</tr>
</tbody></table>
<p>第三个参数<code>TIM_IC1Polarity</code>是选择TI1FP1是正项还是反向，第四个参数<code>TIM_IC2Polarity</code>和第三个参数一样，是选择TI2FP2。</p>
<p>当两个都选择正向或者是反向时，就如下图的时许一样：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240802142621636-481778235.png" alt="img"></p>
<p>当TI1有上升电平，TI2还是低电平时，计数器就会自增，当TI2有上升电平，TI1是高电平时，计数器也会自增。</p>
<p>当TI1FP1或者TI2FP2有一个是反项时就会变成下面的时许：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240802142853582-1255617354.png" alt="img"></p>
<p>在正向时TI1有上升电平，TI2还是低电平时，计数器就会自增，但反向后就是变成自减了。</p>
<p>也就是说当正向的自增转到反向后就会变成自减。</p>
<h2 id="3-软件实现"><a href="#3-软件实现" class="headerlink" title="3.软件实现"></a>3.软件实现</h2><p>硬件结构讲完成后，就可以用代码来对其中的功能进行一个实现了。</p>
<h3 id="3-1-时钟开启"><a href="#3-1-时钟开启" class="headerlink" title="3.1 时钟开启"></a>3.1 时钟开启</h3><p>这里的开启时钟也就只需要开启GPIO的时钟和定时器的时钟，因为编码器接口也是定时器的一个附加功能，所以只用开启GPIO和定时器的时钟即可，不需要额外的时钟开启。</p>
<h3 id="3-2-GPIO口配置"><a href="#3-2-GPIO口配置" class="headerlink" title="3.2 GPIO口配置"></a>3.2 GPIO口配置</h3><p>这里还是需要配置GPIO口，因为需要外部的编码器的输入，这里选择的引脚和定时器的输入捕获和输出比较一样，需要查看引脚的复用功能是不是在TIM定时器的通道上，如果不在那就不能使用。</p>
<p>这里选择的是定时器3的通道1和通道2，对应的引脚是PA6和PA7。</p>
<p>配置代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-配置定时器"><a href="#3-3-配置定时器" class="headerlink" title="3.3 配置定时器"></a>3.3 配置定时器</h3><p>配置的方法也是和上面一样，打开TIM3定时器，然后配置一系列操作，但这里需要改变一下，预分频器PSC这里就不需要分频，只需要填写1-1即可，1就是不分频，这里是又编码器接口硬件来进行操作即可，然后自动重装寄存器ARR只需要配置最大即可，也不需要TIM指定使用内部时钟，这个时钟也是由编码器接口来提供的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseTypeDef TIM_TimeBaseStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">TIM_TimeBaseStruct.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseStruct.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseStruct.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;</span><br><span class="line">TIM_TimeBaseStruct.TIM_Prescaler = <span class="number">1</span> - <span class="number">1</span>;</span><br><span class="line">TIM_TimeBaseStruct.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStruct);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-配置输入捕获"><a href="#3-4-配置输入捕获" class="headerlink" title="3.4 配置输入捕获"></a>3.4 配置输入捕获</h3><p>这里需要注意一下，有些东西在这配置时不需要配置，只需要配置两个参数即可，需要配置的有通道<code>TIM_Channel</code>和过滤器的分辨率<code>TIM_ICFilter</code>然后其他的不需要配置。</p>
<p>所以这里需要使用一个函数来为结构体赋一个默认值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_ICInitTypeDef TIM_ICInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">TIM_ICStructInit(&amp;TIM_ICInitStruct);</span><br><span class="line"></span><br><span class="line">TIM_ICInitStruct.TIM_Channel = TIM_Channel_1;</span><br><span class="line">TIM_ICInitStruct.TIM_ICFilter = <span class="number">0x0F</span>;</span><br><span class="line">TIM_Init(TIM3, &amp;TIM_ICInitStruct);</span><br><span class="line"></span><br><span class="line">TIM_ICInitStruct.TIM_Channel = TIM_Channel_2;</span><br><span class="line">TIM_ICInitStruct.TIM_ICFilter = <span class="number">0x0F</span>;</span><br><span class="line">TIM_Init(TIM3, &amp;TIM_ICInitStruct);</span><br></pre></td></tr></table></figure>

<p>这里可能会比较好奇为什么那些都不配置，比如说预分频器和有效电平和反向，这是因为在配置编码器接口那就已经配置好了的，不需要我们再进行配置，编码器接口会为这个输入捕获一个时钟，所以就不需要分频了，然后反向也是，也是那一个函数就可以配置好了的。</p>
<h3 id="3-5配置编码器接口"><a href="#3-5配置编码器接口" class="headerlink" title="3.5配置编码器接口"></a>3.5配置编码器接口</h3><p>这里就使用上面介绍的那个函数即可配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);</span><br></pre></td></tr></table></figure>

<p>这里我都设置的是不反向，是为了方便。</p>
<h3 id="3-6-使能定时器"><a href="#3-6-使能定时器" class="headerlink" title="3.6 使能定时器"></a>3.6 使能定时器</h3><p>最后使能一下定时器就可以了，使能方法之前介绍了很多遍，这里就不再拉出代码了，下面完整代码中有。</p>
<h3 id="3-7-完整代码"><a href="#3-7-完整代码" class="headerlink" title="3.7 完整代码"></a>3.7 完整代码</h3><p>这里为了方便，我把完整代码贴出来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    TIM_ICInitTypeDef TIM_ICInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">    </span><br><span class="line">    TIM_TimeBaseStruct.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseStruct.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseStruct.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;</span><br><span class="line">    TIM_TimeBaseStruct.TIM_Prescaler = <span class="number">1</span> - <span class="number">1</span>;</span><br><span class="line">    TIM_TimeBaseStruct.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStruct);</span><br><span class="line">    </span><br><span class="line">    TIM_ICInitStruct.TIM_Channel = TIM_Channel_1;</span><br><span class="line">    TIM_ICInitStruct.TIM_ICFilter = <span class="number">0x0F</span>;</span><br><span class="line">    TIM_ICInit(TIM3, &amp;TIM_ICInitStruct);</span><br><span class="line">    </span><br><span class="line">    TIM_ICInitStruct.TIM_Channel = TIM_Channel_2;</span><br><span class="line">    TIM_ICInitStruct.TIM_ICFilter = <span class="number">0x0F</span>;</span><br><span class="line">    TIM_ICInit(TIM3, &amp;TIM_ICInitStruct);</span><br><span class="line">    </span><br><span class="line">    TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);</span><br><span class="line">    </span><br><span class="line">    TIM_Cmd(TIM3, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通用定时器的相关操作就介绍完成了，后面有机会的话给大家介绍一下高级定时器，高级定时器可以操作三项无刷电机，等后面有时间我做一个无人机会使用到高级定时器。</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>08 ADC模数转换</title>
    <url>/2025/01/17/769e4c55fdc1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一节终于到模数转换了，我在做那个项目的时候忘记如何配置模数转换器了，所以这一章是在我学完后并且在项目中实现后写的文章，这里我会结合项目来介绍如何用adc采集外部模拟量后转换为数字量和用stm32内部的温度传感器通过adc采集后显示出来。</p>
<h1 id="一、什么是ADC"><a href="#一、什么是ADC" class="headerlink" title="一、什么是ADC"></a>一、什么是ADC</h1><p>ADC又叫做模数转换，即模拟量转换为数字量，什么是模拟量什么是数字量呢？</p>
<p>模拟量就是一种没有规律的量，比如说声音，声音就是一个模拟量。</p>
<p>数字量是用数字表达的一个量，就像上上节输出比较那说的PWM波就是一个数字量。</p>
<p>而ADC这个设备就是将这些模拟量转换为用数字表达的数字量。</p>
<h1 id="二、stm中的ADC"><a href="#二、stm中的ADC" class="headerlink" title="二、stm中的ADC"></a>二、stm中的ADC</h1><p>在stm32f103中，有3个ADC，这3个都是12位分辨率逐次逼近型的ADC，每个ADC都有很多个通道，下图是stm32f103ADC资源：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240807160126872-1557009759.png" alt="img"></p>
<p>可以看到ADC1有18个通道，包括16个外部ADC采集和两个内部ADC，而ADC2和ADC3都是外部ADC采集通道。</p>
<h1 id="三、adc内部结构"><a href="#三、adc内部结构" class="headerlink" title="三、adc内部结构"></a>三、adc内部结构</h1><p>我们要写代码还是需要先了解一下adc其中的内部结构，这样写代码才好写，下图就是adc的内部结构：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240807160348899-2123484267.png" alt="img"></p>
<p>可以看到有一个AD转换器，我们需要配置它才可以进行AD转换，从左到右可以看到，是由输入到一个选择器中来进行选择输入的通道到AD转换器中的，这里可以选择GPIO口和内部的温度和参考电压。</p>
<p>选择通道后就进去到AD转换器中，在AD转换器中有两个组来存放需要转换的AD信息，分别是规则组和注入组，这里是可以在配置AD转换器那配置使用哪个组的。</p>
<p>在配置AD转换器中还需要配置一个触发控制和RCC，触发控制选择的可多了，我们可以使用软件直接触发，也可以使用定时器来进行触发。</p>
<p>而RCC这里就需要注意了，ADC虽然是接到APB2的，但是在进入APB2后还要经过一个分频，因为ADC的时钟最大不能超过12MHz，如果超过了ADC的运行就是超频运行，对于ADC的伤害还是比较大的。</p>
<p>然后AD转换器会将注入组或者规则组中转换后的数据发送个AD数据寄存器中，在AD寄存器中我们就可以把转换的数据读取出来了。</p>
<p>这个就是adc的内部结构，了解了这个adc的内部结构后我们就可以写代码了。</p>
<h1 id="四、adc代码实现"><a href="#四、adc代码实现" class="headerlink" title="四、adc代码实现"></a>四、adc代码实现</h1><p>上面了解了adc的内部结构后我们知道adc的使用步骤，首先是如果使用外部输入，就需要配置外部输入端口，然后打开ADC的时钟，并且配置ADC的分频，然后就可以配置ADC，配置完成后将要转换的数据塞到注入组或者是规则组中进行转换，最后从AD数据寄存器中进行读取转换后的结构即可。</p>
<h2 id="1-配置外部引脚"><a href="#1-配置外部引脚" class="headerlink" title="1.配置外部引脚"></a>1.配置外部引脚</h2><p>这里是对于外部模拟信号输入，只有从外部读取模拟需要才需要配置外部引脚，如果是直接使用内部来读取温度值，这一步就可以直接省略。</p>
<p>首先配置外部引脚还是一样的，需要打开时钟：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOx, ENABLE);</span><br></pre></td></tr></table></figure>

<p>打开时钟后就可以配置GPIO和引脚了，这里的引脚的模式是需要注意一下的，我们这里不能选择什么上拉下拉什么什么的了，而是要选择模拟输入<code>GPIO_Mode_AIN</code>。</p>
<p>我之前的代码为什么读取不了ADC的值，就是因为我这设置成浮空输入了，浮空、上拉、下拉输入都是输入的是数字量，而我们这里需要让它输入个模拟量来进行转换，所以这里一定要注意。</p>
<p>那么代码就如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;    <span class="comment">// 这里是模拟输入</span></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_x;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOx, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<p>这样GPIO口就配置完成了。</p>
<h2 id="2-打开ADC的时钟和分频"><a href="#2-打开ADC的时钟和分频" class="headerlink" title="2.打开ADC的时钟和分频"></a>2.打开ADC的时钟和分频</h2><p>首先要使用ADC也要打开时钟，ADC是在APB2总线下的器件，所以打开时钟使用的函数也是<code>RCC_APB2PeriphClockCmd</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADCx, ENABLE);</span><br></pre></td></tr></table></figure>

<p>这里ADCx是具体哪个ADC设备，比如ADC1那这里就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br></pre></td></tr></table></figure>

<p>当这个时钟打开后，ADC的时钟频率就为72MHz，而上面我们提到，ADC的最大时钟频率为12MHz，这里如果直接使用就超频了，所以我们需要进行一下分频，分频使用的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_ADCCLKConfig</span><span class="params">(<span class="type">uint32_t</span> RCC_PCLK2)</span>;</span><br></pre></td></tr></table></figure>

<p>这里的参数可以选择下面这几个：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>RCC_PCLK2_Div2</td>
<td>ADC clock &#x3D; PCLK2&#x2F;2 2分频</td>
</tr>
<tr>
<td>RCC_PCLK2_Div4</td>
<td>ADC clock &#x3D; PCLK2&#x2F;4 4分频</td>
</tr>
<tr>
<td>RCC_PCLK2_Div6</td>
<td>ADC clock &#x3D; PCLK2&#x2F;6 6分频</td>
</tr>
<tr>
<td>RCC_PCLK2_Div8</td>
<td>ADC clock &#x3D; PCLK2&#x2F;8 8分频</td>
</tr>
</tbody></table>
<p>这里的PCLK2就是APB2总线的频率，这里经过分频我们的PCLK2就是72MHz，我们要得到12MHz只能进行6分频，当然也可以选择8分频，那adc的频率就是9MHz。</p>
<p>所以代码就如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br></pre></td></tr></table></figure>

<h2 id="3-配置ADC"><a href="#3-配置ADC" class="headerlink" title="3.配置ADC"></a>3.配置ADC</h2><p>设置完时钟后就可以开始配置ADC了，配置ADC的方式和配置GPIO一样，创建个结构体，然后用Init函数进行初始化，这样就可以了。</p>
<p>首先创建一个结构体，结构体的类型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> ADC_Mode;                      <span class="comment">/*!&lt; 将ADC配置为在独立或双模式下运行。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref ADC_mode */</span></span><br><span class="line"></span><br><span class="line">  FunctionalState ADC_ScanConvMode;       <span class="comment">/*!&lt; 指定是否在以下位置执行转换</span></span><br><span class="line"><span class="comment">  扫描（多通道）或单通道（单通道）模式。</span></span><br><span class="line"><span class="comment">  此参数可以设置为 ENABLE 或 DISABLE */</span></span><br><span class="line"></span><br><span class="line">  FunctionalState ADC_ContinuousConvMode; <span class="comment">/*!&lt; 指定是否在以下位置执行转换</span></span><br><span class="line"><span class="comment">  连续或单一模式。</span></span><br><span class="line"><span class="comment">  此参数可以设置为 ENABLE 或 DISABLE。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> ADC_ExternalTrigConv;          <span class="comment">/*!&lt; 定义用于启动常规通道的模数转换的外部触发器。此参数</span></span><br><span class="line"><span class="comment">  的值可以是 @ref ADC_external_trigger_sources_for_regular_channels_conversion */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> ADC_DataAlign;                 <span class="comment">/*!&lt; 指定ADC数据对齐是左对齐还是右对齐。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref ADC_data_align*/</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> ADC_NbrOfChannel;               <span class="comment">/*!&lt; 指定要转换的ADC通道数</span></span><br><span class="line"><span class="comment">  将音序器用于常规频道组。</span></span><br><span class="line"><span class="comment">  此参数的范围必须介于 1 到 16 之间。 */</span></span><br><span class="line">&#125;ADC_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>ADC_Mode</code>，这个是选择adc的运行模式的，单模式是只有一个ADC运行，而双模式是两个ADC一起运行。</p>
<p>第二个参数<code>ADC_ScanConvMode</code>是决定这个组中可以有多少个转换的adc信息，这里如果是<code>DISABLE</code>，就是非扫描模式，只能放一个ADC数据进行转换，如果是<code>ENABLE</code>就是扫描模式，可以放多个ADC数据</p>
<p>第三个参数<code>ADC_ContinuousConvMode</code>是选择单通道还是扫描模式，当是单次扫描，就每次需要我们手动的将ADC中的数据手动的拿出来，而扫描模式的话就是在转换完成后自动的将数据放在寄存器中。</p>
<p>第四个参数<code>ADC_ExternalTrigConv</code>可以选择触发方式，有软件触发，TIM触发等等。</p>
<p>第五个参数<code>ADC_DataAlign</code>是选择对其模式，如果需要直接读取后就能使用的数据，那这里就选择右对齐。</p>
<p>第六个参数<code>ADC_NbrOfChannel</code>是指定要转换的ADC通道的个数。</p>
<p>这里我就选择单一模式非扫描模式，并且是软件触发，右对齐，只有一个通道需要转换，那代码就可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;           <span class="comment">// 单一模式</span></span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;        <span class="comment">// 右对齐</span></span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;     <span class="comment">// 软件触发</span></span><br><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;            <span class="comment">// 单独模式</span></span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = <span class="number">1</span>;</span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = DISABLE;</span><br></pre></td></tr></table></figure>

<p>然后初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_Init(ADC1, &amp;ADC_InitStruct);</span><br></pre></td></tr></table></figure>

<p>初始化完成后就使能ADC：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_Cmd(ADC1, ENABLE);</span><br></pre></td></tr></table></figure>

<h2 id="4-校准ADC"><a href="#4-校准ADC" class="headerlink" title="4.校准ADC"></a>4.校准ADC</h2><p>为了使ADC采集的数据是精准的，这里就需要让ADC进行一下校准，校准只需要使用函数来控制ADC进行校准就可以了，校准的过程主要是先将校准位清除，然后再为校准位置1即可。</p>
<p>这里使用的代码就这四个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ResetCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;    <span class="comment">// 将校准位复位</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetResetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;     <span class="comment">// 判断校准位是否复位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_StartCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;     <span class="comment">// 将校准位置位</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;      <span class="comment">// 判断校准位是否置位</span></span><br></pre></td></tr></table></figure>

<p>代码就可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_ResetCalibration(ADC1);     <span class="comment">// 将校准位复位</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);         <span class="comment">// 判断校准位是否复位</span></span><br><span class="line">ADC_StartCalibration(ADC1);     <span class="comment">// 将校准位置位</span></span><br><span class="line"><span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == RESET);      <span class="comment">// 判断校准位是否置位</span></span><br></pre></td></tr></table></figure>

<p>这里主要是判断一个寄存器的位是否被置位和复位。</p>
<h2 id="5-触发ADC转换"><a href="#5-触发ADC转换" class="headerlink" title="5.触发ADC转换"></a>5.触发ADC转换</h2><p>校准完成后就可以配置需要转换的ADC到AD转换器中，然后用软件触发进行转换后读取即可，这里的代码也是比较简单的，首先将要转换的ADC通道放到规则组中，使用的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_RegularChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>ADCx</code>是ADC的设备号，第二个参数<code>ADC_Channel</code>是ADC的通道号，第三个<code>Rank</code>是这个转换的在这个组中是第几个，第四个<code>ADC_SampleTime</code>是采样时间，采样时间越长，精度越高。</p>
<p>这里我就将通道0塞进去：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_239Cycles5);</span><br></pre></td></tr></table></figure>

<p>这里的采样时间用的是239.5，比较长，为了精度。</p>
<p>然后将需要转换的通道塞入组中后就可以使用软件进行软件触发转换了，使用的函数为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_SoftwareStartConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span><br></pre></td></tr></table></figure>

<p>直接上代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br></pre></td></tr></table></figure>

<p>这样就可以使用软件触发来进行转换了，如果知道是否转换完成呢？</p>
<p>其实在转换完成时，adc会产生一个EOF标志，我们可以判断这个标志来知道adc是否转换完成了，我们使用<code>ADC_GetFlagStatus</code>来判断这个标志：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);</span><br></pre></td></tr></table></figure>

<p>当产生这个信号后，这个循环就会跳出，我们就可以从AD数据寄存器中读取转换值了，读取方式也是很简单，使用<code>ADC_GetConversionValue</code>函数就可以读取了，当值取出后，ADC会自动将EOF标志清空，为下一次转换做准备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> ADC_GetConversionValue(ADC1);</span><br></pre></td></tr></table></figure>

<h1 id="五、读取电压值"><a href="#五、读取电压值" class="headerlink" title="五、读取电压值"></a>五、读取电压值</h1><p>这个需要来配合这电路图来进行分析了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240807170545439-550640096.png" alt="img"></p>
<p>这里可以看到有两个电阻，比如我这VBIN输入的是3.3，那ADC读取到的值就为VBIN&#x2F;20*10。这样就很明白读取到的值和转换公式了，直接上代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_InitTypeDef ADC_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;       <span class="comment">// 模拟输入</span></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = ADC;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(ADC_GPIO, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置ADC时钟*/</span></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;           <span class="comment">// 单一模式</span></span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;        <span class="comment">// 右对齐</span></span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;     <span class="comment">// 软件触发</span></span><br><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;            <span class="comment">// 单独模式</span></span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = <span class="number">1</span>;</span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = DISABLE;</span><br><span class="line"></span><br><span class="line">ADC_Init(ADC1, &amp;ADC_InitStruct);</span><br><span class="line">ADC_Cmd(ADC1, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ADC校准</span></span><br><span class="line">ADC_ResetCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == RESET);</span><br></pre></td></tr></table></figure>

<p>上面的是初始化代码，下面的是读取代码加转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> ave = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="type">float</span> v = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ADC规则组通道配置</span></span><br><span class="line">    ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_239Cycles5);</span><br><span class="line">    ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line">    <span class="keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);</span><br><span class="line">    ave = ADC_GetConversionValue(ADC1);</span><br><span class="line">    Delay_Ms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">v = (ave / <span class="number">50.0</span>) * <span class="number">3.3</span> / <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">return</span> ave * <span class="number">20.0</span> / <span class="number">10.0</span>;</span><br></pre></td></tr></table></figure>

<p>这里我采集了50次后取平均值，这样采集的数据要准确有点，测试到的电压如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240807171234748-2076890587.jpg" alt="img"></p>
<h1 id="六、读取内部温度"><a href="#六、读取内部温度" class="headerlink" title="六、读取内部温度"></a>六、读取内部温度</h1><p>在介绍ADC通道的时候介绍到了，内部温度测试的是在ADC1中的通道16，这种内部设置的不需要配置外部GPIO口，直接可以通过配置ADC即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_InitTypeDef ADC_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置ADC时钟*/</span></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;           <span class="comment">// 单一模式</span></span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;        <span class="comment">// 右对齐</span></span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;     <span class="comment">// 软件触发</span></span><br><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;            <span class="comment">// 单独模式</span></span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = <span class="number">1</span>;</span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = DISABLE;</span><br><span class="line"></span><br><span class="line">ADC_Init(ADC1, &amp;ADC_InitStruct);</span><br><span class="line">ADC_Cmd(ADC1, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ADC校准</span></span><br><span class="line">ADC_ResetCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == RESET);</span><br></pre></td></tr></table></figure>

<p>配置的代码和前面的一样，主要是塞入组的时候要塞入通道16：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> ave = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ADC规则组通道配置</span></span><br><span class="line">    ADC_RegularChannelConfig(ADC1, ADC_Channel_16, <span class="number">1</span>, ADC_SampleTime_239Cycles5);</span><br><span class="line">    ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line">    <span class="keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);</span><br><span class="line">    ave = ADC_GetConversionValue(ADC1);</span><br><span class="line">    Delay_Ms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以得到温度了，我看其它大佬写的文章需要进行一个转换，但是我感觉都不需要进行转换就可以得到真实的温度，可能不行，后面我会进行验证的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于ADC的介绍就先介绍到这了，后面会结合DMA进行多通道的AD转换，这里先只介绍了最简单的，对于我现在的项目够用，追求速度的话我后面再改为DMA。</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>09 DMA配合ADC多通道</title>
    <url>/2025/01/17/f9c6962d2c72/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面介绍了ADC数模转换，得到了内部的温度值和外部电压值，我感觉这样太消耗CPU的资源了，所以我准备用DMA来帮我从AD的数据寄存器中拿出数据出来，就不用再去读取AD的数据寄存器了。</p>
<h1 id="一、什么是DMA"><a href="#一、什么是DMA" class="headerlink" title="一、什么是DMA"></a>一、什么是DMA</h1><p>DMA叫做直接存储器存取，就不需要我们CPU通过软件将外部寄存器或者内部的存储器的数据读取到一个地方，而是由DMA控制器来进行操作，这种方法只需要让CPU为DMA配置好一些基本的配置后，当DMA接收到对应的信号就会自动的执行，省去了CPU进行这种毫无意义的操作。</p>
<p>一般使用DMA都是在大量数据处理和ADC多通道操作的地方，而我们这暂时只用到ADC，所以重点还是对于ADC多通道的DMA设置。</p>
<h1 id="二、DMA介绍"><a href="#二、DMA介绍" class="headerlink" title="二、DMA介绍"></a>二、DMA介绍</h1><h2 id="1-stm32的DMA"><a href="#1-stm32的DMA" class="headerlink" title="1.stm32的DMA"></a>1.stm32的DMA</h2><p>在stm32f103c8t6中有2个DMA外设，分别是DMA1和DMA2，这两个DMA是连接在<code>AHB</code>高速外部总线上的，所以我们要使用DMA开启的时钟要开启<code>AHB</code>，而不是<code>APB</code>了。</p>
<p>这两个DMA中又分别有着许多通道，在DMA1中有7个通道，在DMA2中有5个通道，我们使用DMA进行转运就是使用的是这些通道。</p>
<p>如果我们是对外设和存储器进行转运就需要找到这个外设所对应的通道是哪一个了，下图就是这个的介绍。</p>
<p>下图是DMA1通道连接的外设：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240808211140049-962440252.png" alt="img"></p>
<p>下面是DMA2通道连接的外设：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240808211226965-1102066633.png" alt="img"></p>
<p>可以看到要让DMA转运外设的内容需要看这个DMA的通道是不是连接到该外设，如果没有连接，你进行配置是没办法触发的，所以要对应着来进行配置。</p>
<h2 id="2-DMA的内部结构"><a href="#2-DMA的内部结构" class="headerlink" title="2.DMA的内部结构"></a>2.DMA的内部结构</h2><p>这里还是借用人家的图，因为我画的不是很清晰，人家的还是很清晰：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240808211437368-184154653.png" alt="img"></p>
<p>这里可以看到有两个东西，一个是外设寄存器，外设寄存器主要是外部的设备，另一个是存储器，是在内部的，这个其实可以抽象成一个是A另一个是B，就是这个样子：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240808211620579-1992848281.png" alt="img"></p>
<p>我们可以设置从A到B或者从B到A这个方向的，然后在A端和B端都可以设置三个东西，分别是起始地址、数据宽度、地址是否自增。</p>
<p>起始地址就是你需要转运的数据或者需要存储的空间它的地址是在哪里，在学指针的时候肯定说过，地址是一个变量在计算机中的实际位置，我们对这个地址所对应的空间赋值，那这个变量就得到这个值了。</p>
<p>然后数据宽度是指你这个需要传输的数据是什么类型的，是int还是char还是short，就是确定一个类型。</p>
<p>地址自增就是你给的这个地址，当一个数据传输过去了，它的地址会不会增加，可以自增也可以不自增。</p>
<p>再往下看，看到一个传输计数器，这个的功能是限制DMA传输的次数，当这个次数自减为0就结束这一次的数据传输，每次传输一个数据时这个寄存器中的值就会减一。</p>
<p>旁边的自动重装寄存器只有在硬件模式中可以用，当这个传输计数器为0后，自动重装寄存器就会把值再给传输计数器，这样就是一个循环执行，所以被称为硬件模式。</p>
<p>当然有硬件模式也就有软件模式，而软件模式是没有用这个自动重装寄存器的，因为软件模式是有软件进行控制的，当传输完成后软件会自动的对传输计数器进行赋值，然后再继续运行。</p>
<p>然后就是硬件选择和软件选择了，这里是由M2M进行控制的，硬件选择对应的就是上面的硬件模式，而软件选择对应的就是软件模式，这里就是使用M2M进行控制。</p>
<h1 id="三、代码的编写"><a href="#三、代码的编写" class="headerlink" title="三、代码的编写"></a>三、代码的编写</h1><p>上面了解了内部结构后，我们就可以来进行软件编写了，这里分为两种，一个是数据转运，另一个是ADC多通道转运。</p>
<h2 id="1-数据转运"><a href="#1-数据转运" class="headerlink" title="1.数据转运"></a>1.数据转运</h2><p>实现来讲解一下数据转运，可能后面我需要DMA为我转运陀螺仪的信息，然后这里先介绍一下。</p>
<h3 id="1-1-开启时钟"><a href="#1-1-开启时钟" class="headerlink" title="1.1 开启时钟"></a>1.1 开启时钟</h3><p>在使用stm32外设第一步都是要开启时钟，只有把时钟开启后下面的操作才会有意义。</p>
<p>上面提到了，DMA是挂载到AHB总线上的，所以我们要操作<code>RCC_AHBPeriphClockCmd()</code>函数才可以打开<code>AHB</code>总线上的外设，这里的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1);</span><br></pre></td></tr></table></figure>

<p>这里打开的是DMA1，也可以打开DMA2，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2);</span><br></pre></td></tr></table></figure>

<p>这里主要是取决于你使用的是那个DMA设备。</p>
<h3 id="1-2-配置DMA结构体"><a href="#1-2-配置DMA结构体" class="headerlink" title="1.2 配置DMA结构体"></a>1.2 配置DMA结构体</h3><p>DMA的配置和配置GPIO一样，首先是创建结构体，然后对结构体中的内容进行赋值，配置DMA的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> DMA_PeripheralBaseAddr; <span class="comment">/*!&lt; 指定 DMAy Channelx 的外设基址。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DMA_MemoryBaseAddr;     <span class="comment">/*!&lt; 指定 DMAy Channelx 的内存基址。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DMA_DIR;                <span class="comment">/*!&lt; 指定外围设备是源还是目标。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref DMA_data_transfer_direction */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DMA_BufferSize;         <span class="comment">/*!&lt; 指定指定通道的缓冲区大小（以数据单位为单位）。</span></span><br><span class="line"><span class="comment">  数据单元等于 DMA_PeripheralDataSize 中设置的配置</span></span><br><span class="line"><span class="comment">  或根据转移方向DMA_MemoryDataSize成员。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DMA_PeripheralInc;      <span class="comment">/*!&lt; 指定外设地址寄存器是否递增。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref DMA_peripheral_incremented_mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DMA_MemoryInc;          <span class="comment">/*!&lt; 指定内存地址寄存器是否递增。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref DMA_memory_incremented_mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DMA_PeripheralDataSize; <span class="comment">/*!&lt; 指定外围设备数据宽度。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref DMA_peripheral_data_size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DMA_MemoryDataSize;     <span class="comment">/*!&lt; 指定内存数据宽度。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref DMA_memory_data_size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DMA_Mode;               <span class="comment">/*!&lt; 指定 DMAy Channelx 的操作模式。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref DMA_circular_normal_mode。</span></span><br><span class="line"><span class="comment">  @note：如果内存到内存，则无法使用循环缓冲模式。</span></span><br><span class="line"><span class="comment">  在选定的通道上配置数据传输 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DMA_Priority;           <span class="comment">/*!&lt; 指定 DMAy Channelx 的软件优先级。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref DMA_priority_level */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> DMA_M2M;                <span class="comment">/*!&lt; 指定是否将 DMAy Channelx 用于内存到内存的传输。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref DMA_memory_to_memory */</span></span><br><span class="line">&#125;DMA_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>DMA_PeripheralBaseAddr</code>是指定A端的地址。</p>
<p>第二个参数<code>DMA_MemoryBaseAddr</code>是指定B端的地址。</p>
<p>第三个参数<code>DMA_DIR</code>是指定传输方向，可以选下面这几个传输：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>DMA_DIR_PeripheralDST</td>
<td>B到A</td>
</tr>
<tr>
<td>DMA_DIR_PeripheralSRC</td>
<td>A到B</td>
</tr>
</tbody></table>
<p>第四个参数<code>DMA_BufferSize</code>就是设置传输寄存器的，比如我这要传输10个数据，那这要填写10，也就是运行10次传输。</p>
<p>第五个参数<code>DMA_PeripheralInc</code>是指A端的地址是否自增，如果这里填写自增，那传输一次，A端的地址就自增1，以此类推。</p>
<p>第六个参数<code>DMA_MemoryInc</code>是指B端的地址是否自增，如果这里填写自增，那传输一次，B端的地址就自增1，以此类推。</p>
<p>第七个参数<code>DMA_PeripheralDataSize</code>是指A端要传输的数据是什么类型的，可以选择字节8位、半字16位、字32位。</p>
<p>第八个参数<code>DMA_MemoryDataSize</code>是指B端要传输的数据是什么类型的，可以选择字节8位、半字16位、字32位。</p>
<p>第九个参数<code>DMA_Mode</code>是指是什么模式的，可以选择下面这两个参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>DMA_Mode_Circular</td>
<td>循环模式，只有在硬件触发才可以选择</td>
</tr>
<tr>
<td>DMA_Mode_Normal</td>
<td>正常模式，没有自动重装寄存器</td>
</tr>
</tbody></table>
<p>第十个参数<code>DMA_Priority</code>是选择传输的优先级的。</p>
<p>第十一个参数<code>DMA_M2M</code>用来指定传输的方式，下面是参数介绍：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>DMA_M2M_Enable</td>
<td>存储器到存储器</td>
</tr>
<tr>
<td>DMA_M2M_Disable</td>
<td>外设到存储器</td>
</tr>
</tbody></table>
<p>其实就是选择是软件模式还是硬件模式，如果选择<code>DMA_M2M_Disable</code>就是硬件模式，如果选择<code>DMA_M2M_Enable</code>就是软件模式。</p>
<p>这样我们就可以写一个初始化的代码了，这里是要数据的转运，而这个数据是在代码中定义的变量，在代码中定义的变量其实存放在存储器中的，所以这里是存储器到存储器，那么初始化代码就是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DMA_InitTypeDef DMA_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;arr_A;                     <span class="comment">// A端地址   arr_A是一个长为10的字节数组，这里是把arr_A的地址存放进去</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;         <span class="comment">// A端数据长度  读取的是字节也就是8位</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Enable;                    <span class="comment">// A端地址是否自增     这里的数据寄存器需要自增地址</span></span><br><span class="line"></span><br><span class="line">DMA_InitStruct.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)&amp;arr_B;                    <span class="comment">// B端地址   从A端转移过来的数据存放位置的地址，这里是arr_B的地址，arr_B是一个长为10的字节数组</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;              <span class="comment">// B端数据长度  读取的是字节也就是8位</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;                              <span class="comment">// B端地址是否自增  这里需要地址进行自增</span></span><br><span class="line"></span><br><span class="line">DMA_InitStruct.DMA_BufferSize = <span class="number">10</span>;                                               <span class="comment">// 传输计数器的值</span></span><br><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Normal;                                     <span class="comment">// 模式选择，这里选择正常模式</span></span><br><span class="line">DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC;                                  <span class="comment">// 传输方向，A作为源端B作为目标端</span></span><br><span class="line">DMA_InitStruct.DMA_M2M = DMA_M2M_Enable;                                        <span class="comment">// 传输是存储器到存储器还是外设到存储器</span></span><br><span class="line">DMA_InitStruct.DMA_Priority = DMA_Priority_Medium;                               <span class="comment">// DMA转换的转换优先级</span></span><br><span class="line"></span><br><span class="line">DMA_Init(DMA1_Channel1, &amp;DMA_InitStruct);</span><br></pre></td></tr></table></figure>

<p>这样就初始化完成了，有很多地方大家需要注意一下，在填写A端和B端的字节的时候要区分前面的名称，我在写DMA转换ADC数据的时候就把B端的字节搞错了，我写成<code>DMA_PeripheralDataSize_HalfWord</code>而这里得填写<code>DMA_MemoryDataSize_HalfWord</code>，就因为这里的数据填写错误，导致读取的值不对。</p>
<h3 id="1-3-开始转换"><a href="#1-3-开始转换" class="headerlink" title="1.3 开始转换"></a>1.3 开始转换</h3><p>到这里大家可能就像直接使用<code>DMA_Cmd</code>进行使能后运行DMA了，但是这里我们设置的是正常模式，当一次转换后计数器中的值就为0了，再进行转换是转换不了的，所以我们要用软件手动的为计数器中添加值。</p>
<p>当添加值后就可以继续运行了，那这里是不是可以直接用<code>DMA_SetCurrDataCounter</code>函数进行设置值呢？</p>
<p>是不行的，stm32中规定，要软件为计数器中添加值之前是需要将DMA失能的，在失能后才能修改计数器中的值，所以这里我们要将DMA进行失能，然后修改后使能，这样DMA才可以继续运行，所以这里的运行代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DMA_Cmd(DMA1_Channel1, DISABLE);     <span class="comment">// 失能DMA1的通道1</span></span><br><span class="line">DMA_SetCurrDataCounter(<span class="number">10</span>);     <span class="comment">// 修改计数器的值</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1, ENABLE);      <span class="comment">// 使能DMA1的通道1</span></span><br></pre></td></tr></table></figure>

<p>这个运行函数可以写一个函数进行封装，当要进行转换的时候进行一次调用即可。</p>
<p>当然这样还不是很完善，我们让它运行后怎么知道运行完成了，我们好查看数据呢？</p>
<p>这里当传输完成后会置一个标志位，我们可以通过这个标志位来进行判断是否转换完成，这里的标志位有点多，每个通道都有一个对应的标志位，而且在每个过程中都有一个标志位的产生，这里就将过程中的标志位写出来，然后DMA编号和通道就用x和y表示：</p>
<table>
<thead>
<tr>
<th>标志位</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>DMAx_FLAG_GLy</td>
<td>DMA全局标志位</td>
</tr>
<tr>
<td>DMAx_FLAG_TCy</td>
<td>传输完成标志位</td>
</tr>
<tr>
<td>DMAx_FLAG_HTy</td>
<td>传输过半标志位</td>
</tr>
<tr>
<td>DMAx_FLAG_TEy</td>
<td>传输错误标志位</td>
</tr>
</tbody></table>
<p>然后用<code>DMA_GetFlagStatus</code>函数判断这个标志位是否产生，当产生后就可以读取数据了，然后再手动清除一下这个标志位，使用<code>DMA_ClearFlag</code>函数即可清除，该进后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DMA_Cmd(DMA1_Channel1, DISABLE);     <span class="comment">// 失能DMA1的通道1</span></span><br><span class="line">DMA_SetCurrDataCounter(<span class="number">10</span>);     <span class="comment">// 修改计数器的值</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1, ENABLE);      <span class="comment">// 使能DMA1的通道1</span></span><br><span class="line"><span class="keyword">while</span> (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);     <span class="comment">// 手动清除标志位</span></span><br></pre></td></tr></table></figure>

<p>这样的代码就比较完整了，然后传输完成后就访问<code>arr_B</code>即可，就是数组的引用了，这个都比较简单。</p>
<h2 id="2-ADC单通道转换"><a href="#2-ADC单通道转换" class="headerlink" title="2.ADC单通道转换"></a>2.ADC单通道转换</h2><p>在ADC中也是一样的道理，首先配置ADC然后GPIO空，然后配置DMA即可。</p>
<h3 id="2-1-开启时钟"><a href="#2-1-开启时钟" class="headerlink" title="2.1 开启时钟"></a>2.1 开启时钟</h3><p>首先这开启时钟，这里就把全部的时钟都进行打开，分别打开GPIO口、ADC和DMA的时钟，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);      <span class="comment">// 开启GPIOA的时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Perph_ADC1, ENABLE);      <span class="comment">// 开启ADC1的时钟</span></span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);      <span class="comment">// 开启DMA的时钟</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-配置GPIO和ADC"><a href="#2-2-配置GPIO和ADC" class="headerlink" title="2.2 配置GPIO和ADC"></a>2.2 配置GPIO和ADC</h3><p>这里是前面讲过的，所以这里直接就上代码即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_InitTypeDef ADC_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;       <span class="comment">// 模拟输入</span></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置ADC时钟*/</span></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;                                  <span class="comment">// 不连续转换</span></span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;                              <span class="comment">// 右对齐</span></span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;                 <span class="comment">// 软件触发</span></span><br><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;                                  <span class="comment">// 单独模式</span></span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = <span class="number">1</span>;                                             <span class="comment">// 通道数     </span></span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = DISABLE;                                        <span class="comment">// 不连续扫描</span></span><br><span class="line"></span><br><span class="line">ADC_Init(ADC1, &amp;ADC_InitStruct);</span><br></pre></td></tr></table></figure>

<p>上面的配置是单通道，不连续转换的ADC。</p>
<h3 id="2-3-配置DMA"><a href="#2-3-配置DMA" class="headerlink" title="2.3 配置DMA"></a>2.3 配置DMA</h3><p>接下来就是要配置DMA了，在这ADC是外设，所以在配置DMA的模式就要选择外设到存储器了，模式的话因为上面是软件触发非连续模式，这里因为选择了外设到存储器，所以需要注意一下哪一个DMA中的通道是连接到ADC1上，这边查看了一下是在DMA1中的通道1是连接到ADC1上的，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DMA_InitTypeDef DMA_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;                     <span class="comment">// A端地址   ADC数据寄存器的地址</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;         <span class="comment">// A端数据长度  读取的是半字也就是16位</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;                    <span class="comment">// A端地址是否自增     这里的数据寄存器不需要自增地址</span></span><br><span class="line"></span><br><span class="line">DMA_InitStruct.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)&amp;adc_read_value;                    <span class="comment">// B端地址   用一个数组来存放ADC读取的结果</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;              <span class="comment">// B端数据长度  读取的是半字也就是16位</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;                              <span class="comment">// B端地址是否自增  这里需要地址进行自增</span></span><br><span class="line"></span><br><span class="line">DMA_InitStruct.DMA_BufferSize = <span class="number">1</span>;                                               <span class="comment">// 传输计数器的值</span></span><br><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Normal;                                     <span class="comment">// 模式选择，这里选择正常模式</span></span><br><span class="line">DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC;                                  <span class="comment">// 传输方向，A到B</span></span><br><span class="line">DMA_InitStruct.DMA_M2M = DMA_M2M_Disable;                                        <span class="comment">// 传输是外设到存储器</span></span><br><span class="line">DMA_InitStruct.DMA_Priority = DMA_Priority_Medium;                               <span class="comment">// DMA转换的转换优先级</span></span><br><span class="line">DMA_Init(DMA1_Channel1, &amp;DMA_InitStruct);</span><br></pre></td></tr></table></figure>

<p>这里因为选择了<code>DMA_Mode_Normal</code>正常模式，所以没有自动重装寄存器，所以在每次需要使DMA运行的时候就要调用一下<code>DMA_SetCurrDataCounter</code>为其重装值，这样DMA才可以再次运行。</p>
<h3 id="2-4-使能ADC"><a href="#2-4-使能ADC" class="headerlink" title="2.4 使能ADC"></a>2.4 使能ADC</h3><p>配置完成后就可以使能ADC来和DMA了，然后再调用ADC的DMA使能，让DMA接收到ADC转换完成信号后开始转移数据。</p>
<p>这里先用<code>ADC_Cmd</code>对ADC进行使能，然后用<code>ADC_DMACmd</code>对ADC触发的DMA进行使能，然后使能或者失能DMA，这里一般是配置完成后先不启用DMA，等后面专门写一个DMA运行函数配置好计数器中的值后再使能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_Cmd(ADC1, ENABLE);     <span class="comment">// 使能ADC1</span></span><br><span class="line">ADC_DMACmd(ADC1, ENABLE);  <span class="comment">// 使能ADC1的DMA</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1, DISABLE);  <span class="comment">// 先失能</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-DMA转移函数"><a href="#2-5-DMA转移函数" class="headerlink" title="2.5 DMA转移函数"></a>2.5 DMA转移函数</h3><p>这里就单独将DMA的运行拿出来，因为正常模式也就是软件模式下，DMA在进行一次转移后（计数器中的值为0）不会自动为计数器进行赋值的，需要软件手动的为计数器进行赋值。</p>
<p>并且这里的ADC是使用单独模式并且不是循环模式，需要软件进行触发才能进行一次ADC转换。</p>
<p>所以这要把这一步单独拿出来，这样使用DMA就很方便，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_239Cycles5);     <span class="comment">// 添加需要采集的ADC到组中</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1, DISABLE);</span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1, <span class="number">1</span>);    <span class="comment">// 为计数器重装值</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1, ENABLE);    <span class="comment">// 使能DMA</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1, ENABLE);    <span class="comment">// 软件触发ADC转换</span></span><br><span class="line"><span class="keyword">while</span> (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);     <span class="comment">// 手动清除标志位</span></span><br></pre></td></tr></table></figure>

<p>这里当ADC转换完成后我们不用程序来进行读取，而是由DMA来进行读取，当转换完成后ADC会发送一个信号给DMA，这个是需要在上面使能ADC的DMA才可以让DMA接收这个信号的</p>
<h2 id="3-ADC多通道转换"><a href="#3-ADC多通道转换" class="headerlink" title="3.ADC多通道转换"></a>3.ADC多通道转换</h2><p>其实上面了解了单通道后，这里可以在此基础上进行改写，改写的方法也是很简单的，只不过就是在<code>ADC_InitStruct.ADC_ContinuousConvMode</code>中给连续转换，然后在<code>ADC_InitStruct.ADC_NbrOfChannel</code>填写要转换的通道数，最后改一下DMA的计数器的值即可，完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);      <span class="comment">// 开启GPIOA的时钟</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Perph_ADC1, ENABLE);      <span class="comment">// 开启ADC1的时钟</span></span><br><span class="line">  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);      <span class="comment">// 开启DMA的时钟</span></span><br><span class="line"></span><br><span class="line">  ADC_InitTypeDef ADC_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  DMA_InitTypeDef DMA_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;       <span class="comment">// 模拟输入</span></span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*设置ADC时钟*/</span></span><br><span class="line">  RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line">  ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;                                  <span class="comment">// 连续转换</span></span><br><span class="line">  ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;                              <span class="comment">// 右对齐</span></span><br><span class="line">  ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;                 <span class="comment">// 软件触发</span></span><br><span class="line">  ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;                                  <span class="comment">// 单独模式</span></span><br><span class="line">  ADC_InitStruct.ADC_NbrOfChannel = <span class="number">2</span>;                                             <span class="comment">// 通道数     </span></span><br><span class="line">  ADC_InitStruct.ADC_ScanConvMode = DISABLE;                                        <span class="comment">// 不连续扫描</span></span><br><span class="line"></span><br><span class="line">  ADC_Init(ADC1, &amp;ADC_InitStruct);</span><br><span class="line">  </span><br><span class="line">  DMA_InitStruct.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;                     <span class="comment">// A端地址   ADC数据寄存器的地址</span></span><br><span class="line">  DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;         <span class="comment">// A端数据长度  读取的是半字也就是16位</span></span><br><span class="line">  DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;                    <span class="comment">// A端地址是否自增     这里的数据寄存器不需要自增地址</span></span><br><span class="line"></span><br><span class="line">  DMA_InitStruct.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)&amp;adc_read_value;                    <span class="comment">// B端地址   用一个数组来存放ADC读取的结果</span></span><br><span class="line">  DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;              <span class="comment">// B端数据长度  读取的是半字也就是16位</span></span><br><span class="line">  DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;                              <span class="comment">// B端地址是否自增  这里需要地址进行自增</span></span><br><span class="line"></span><br><span class="line">  DMA_InitStruct.DMA_BufferSize = <span class="number">2</span>;                                               <span class="comment">// 传输计数器的值</span></span><br><span class="line">  DMA_InitStruct.DMA_Mode = DMA_Mode_Normal;                                     <span class="comment">// 模式选择，这里选择正常模式</span></span><br><span class="line">  DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC;                                  <span class="comment">// 传输方向，A到B</span></span><br><span class="line">  DMA_InitStruct.DMA_M2M = DMA_M2M_Disable;                                        <span class="comment">// 传输是外设到存储器</span></span><br><span class="line">  DMA_InitStruct.DMA_Priority = DMA_Priority_Medium;                               <span class="comment">// DMA转换的转换优先级</span></span><br><span class="line">  DMA_Init(DMA1_Channel1, &amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line">  ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_239Cycles5);     <span class="comment">// 添加需要采集的ADC到组中</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1, ADC_Channel_1, <span class="number">2</span>, ADC_SampleTime_239Cycles5);     <span class="comment">// 添加需要采集的ADC到组中</span></span><br><span class="line"></span><br><span class="line">  ADC_Cmd(ADC1, ENABLE);     <span class="comment">// 使能ADC1</span></span><br><span class="line">  ADC_DMACmd(ADC1, ENABLE);  <span class="comment">// 使能ADC1的DMA</span></span><br><span class="line">  DMA_Cmd(DMA1_Channel1, DISABLE);  <span class="comment">// 先失能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Start_DMA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  DMA_Cmd(DMA1_Channel1, DISABLE);</span><br><span class="line">  DMA_SetCurrDataCounter(DMA1_Channel1, <span class="number">2</span>);    <span class="comment">// 为计数器重装值</span></span><br><span class="line">  DMA_Cmd(DMA1_Channel1, ENABLE);    <span class="comment">// 使能DMA</span></span><br><span class="line">  ADC_SoftwareStartConvCmd(ADC1, ENABLE);    <span class="comment">// 软件触发ADC转换</span></span><br><span class="line">  <span class="keyword">while</span> (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">  DMA_ClearFlag(DMA1_FLAG_TC1);     <span class="comment">// 手动清除标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用初始化完成后需要进行ADC转换并且使用DMA转移就可以调用上面的<code>Start_DMA</code>函数进行。</p>
<h2 id="4-ADC连续转换"><a href="#4-ADC连续转换" class="headerlink" title="4.ADC连续转换"></a>4.ADC连续转换</h2><p>上面的代码有点不智能，需要软件进行一次触发才能进行一次ADC转换并且还需要手动的为DMA计数器手动赋值，多多少少还是有软件控制的，而这里介绍一下，全过程都由硬件执行。</p>
<p>实现的方法很简单，让ADC配置为连续扫描模式，然后DMA配置为循环模式，然后配置完成后直接使能DMA并且来一次软件触发ADC，这样就可以让ADC连续的转换并且DMA不需要手动赋值就可以一直转换了。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);      <span class="comment">// 开启GPIOA的时钟</span></span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Perph_ADC1, ENABLE);      <span class="comment">// 开启ADC1的时钟</span></span><br><span class="line">  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);      <span class="comment">// 开启DMA的时钟</span></span><br><span class="line"></span><br><span class="line">  ADC_InitTypeDef ADC_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  DMA_InitTypeDef DMA_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;       <span class="comment">// 模拟输入</span></span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*设置ADC时钟*/</span></span><br><span class="line">  RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line">  ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;                                  <span class="comment">// 连续转换</span></span><br><span class="line">  ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;                              <span class="comment">// 右对齐</span></span><br><span class="line">  ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;                 <span class="comment">// 软件触发</span></span><br><span class="line">  ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;                                  <span class="comment">// 单独模式</span></span><br><span class="line">  ADC_InitStruct.ADC_NbrOfChannel = <span class="number">2</span>;                                             <span class="comment">// 通道数     </span></span><br><span class="line">  ADC_InitStruct.ADC_ScanConvMode = ENABLE;                                        <span class="comment">// 连续扫描</span></span><br><span class="line"></span><br><span class="line">  ADC_Init(ADC1, &amp;ADC_InitStruct);</span><br><span class="line">  </span><br><span class="line">  DMA_InitStruct.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;                     <span class="comment">// A端地址   ADC数据寄存器的地址</span></span><br><span class="line">  DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;         <span class="comment">// A端数据长度  读取的是半字也就是16位</span></span><br><span class="line">  DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;                    <span class="comment">// A端地址是否自增     这里的数据寄存器不需要自增地址</span></span><br><span class="line"></span><br><span class="line">  DMA_InitStruct.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)&amp;adc_read_value;                    <span class="comment">// B端地址   用一个数组来存放ADC读取的结果</span></span><br><span class="line">  DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;              <span class="comment">// B端数据长度  读取的是半字也就是16位</span></span><br><span class="line">  DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;                              <span class="comment">// B端地址是否自增  这里需要地址进行自增</span></span><br><span class="line"></span><br><span class="line">  DMA_InitStruct.DMA_BufferSize = <span class="number">2</span>;                                               <span class="comment">// 传输计数器的值</span></span><br><span class="line">  DMA_InitStruct.DMA_Mode = DMA_Mode_Circular;                                     <span class="comment">// 模式选择，这里选择正常模式</span></span><br><span class="line">  DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC;                                  <span class="comment">// 传输方向，A到B</span></span><br><span class="line">  DMA_InitStruct.DMA_M2M = DMA_M2M_Disable;                                        <span class="comment">// 传输是外设到存储器</span></span><br><span class="line">  DMA_InitStruct.DMA_Priority = DMA_Priority_Medium;                               <span class="comment">// DMA转换的转换优先级</span></span><br><span class="line">  DMA_Init(DMA1_Channel1, &amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line">  ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_239Cycles5);     <span class="comment">// 添加需要采集的ADC到组中</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1, ADC_Channel_1, <span class="number">2</span>, ADC_SampleTime_239Cycles5);     <span class="comment">// 添加需要采集的ADC到组中</span></span><br><span class="line"></span><br><span class="line">  ADC_Cmd(ADC1, ENABLE);     <span class="comment">// 使能ADC1</span></span><br><span class="line">  ADC_DMACmd(ADC1, ENABLE);  <span class="comment">// 使能ADC1的DMA</span></span><br><span class="line">  DMA_Cmd(DMA1_Channel1, ENABLE);  <span class="comment">// 使能DMA</span></span><br><span class="line">  ADC_SoftwareStartConvCmd(ADC1, ENABLE);    <span class="comment">// 软件触发ADC转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以让ADC连续转换多通道的ADC通道，并且可以让DMA自动进行数据转运不用再手动为其赋值，一直运行。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用DMA可以大量节约CPU的资源，对于大量的数据传递会消耗CPU大量的时间，在转移过程中就没办法执行其他功能，所以DMA对于大量数据转运有着很大的帮助，并且节约了大量的时间。</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>11 IIC通讯协议</title>
    <url>/2025/01/17/33a6745a9cf3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>IIC协议在前面03 OLED显示屏中初略的介绍了一下IIC协议，并且使用软件模拟IIC协议来和OLED显示屏进行通讯，但是之前的那一章主要是介绍如何写入数据到从设备中，没有介绍如何从从设备那接收发送过来的数据，并且还有硬件实现IIC也没有说，这一节就讲读取和硬件IIC来统一说明。</p>
<h1 id="一、IIC介绍"><a href="#一、IIC介绍" class="headerlink" title="一、IIC介绍"></a>一、IIC介绍</h1><p>IIC、SPI、USART等都属于通讯协议，是由飞利浦公司开发的一款同步半双工、一主一从、一主多从或多主多从的通讯协议，它有两条线组成，一根是SCL时钟线，另一根是SDA数据线。</p>
<p>SCL主要是提供一个时钟，只能由主设备来控制，主设备和从设备根据这一根时钟线来进行同步的数据传输。</p>
<h2 id="1-IIC的时序"><a href="#1-IIC的时序" class="headerlink" title="1.IIC的时序"></a>1.IIC的时序</h2><p>这里介绍一下IIC的时序，在前面讲OLED显示屏的时候是讲过该IIC的时序的，这里再介绍一下IIC的时序。</p>
<p>首先是开始和结束时序：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240819143451302-1471677611.png" alt="img"></p>
<p>在IIC中，要开始进行IIC协议的通讯前需要发送一个开始信号，这个开始信号在<code>START</code>框中，当开始信号进行后就可以开始传送数据了，当传输完成后就需要发送一个结束信号来结束当前的IIC协议，这个信号在<code>STOP</code>中。</p>
<p>然后是发送数据时序：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240819143837747-585854846.png" alt="img"></p>
<p>可以看到，当SCL时钟为低电平的时候SDA的数据开始切换，当SCL上升沿的时候稳定，并将数据发送出去。</p>
<p>之后是读取数据时序：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240819144001999-878170256.png" alt="img"></p>
<p>和发送数据时一样，只不过就是在高电平时不是发送数据了，而是读取数据，SCL在低电平时，从机改变SDA的电平，当SCL上升沿时SDA稳定然后开始读取从机的数据。</p>
<p>最后就是读取ACK和发送ACK的时序：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240819144249031-599212755.png" alt="img"></p>
<p>这个就是读取和发送ack的时序，其实就是上面的读取和发送时序，很简单的。</p>
<h2 id="2-使用IIC对从机寄存器的写操作流程"><a href="#2-使用IIC对从机寄存器的写操作流程" class="headerlink" title="2.使用IIC对从机寄存器的写操作流程"></a>2.使用IIC对从机寄存器的写操作流程</h2><p>这个操作流程是：</p>
<ol>
<li>发送IIC开始信号</li>
<li>发送从机写地址</li>
<li>接收从机发送的ack信号</li>
<li>发送需要操作的寄存器地址</li>
<li>接收从机发送的ack信号</li>
<li>发送需要写入的数据</li>
<li>接收从机发送的ack信号</li>
<li>发送IIC结束信号</li>
</ol>
<p>这样就是一个发送数据到从机的过程。</p>
<h2 id="3-使用IIC对从机寄存器的读操作流程"><a href="#3-使用IIC对从机寄存器的读操作流程" class="headerlink" title="3.使用IIC对从机寄存器的读操作流程"></a>3.使用IIC对从机寄存器的读操作流程</h2><p>这个操作流程是：</p>
<ol>
<li>发送IIC开始信号</li>
<li>发送从机写地址</li>
<li>接收从机发送的ack信号</li>
<li>发送需要读的寄存器地址</li>
<li>接收从机发送的ack信号</li>
<li>再次发送IIC开始信号</li>
<li>发送从机读地址</li>
<li>读取SDA线上的数据</li>
<li>发送NACK结束读取</li>
<li>发送结束信号</li>
</ol>
<p>这样就完成了主机读取从机的数据操作。</p>
<p>需要注意这里接收完成后发送NACK是接收一个字节的数据才发送，当发送完NACK给从机后，从机会将SDA信号线拉高，也就是将SDA的控制权交给主机。</p>
<p>如果从机的这个寄存器中的数据有多个字节，那需要在第一次接收8位数据后发送一个ACK响应，当从机接收到后会继续发送数据。</p>
<h1 id="二、软件实现IIC协议"><a href="#二、软件实现IIC协议" class="headerlink" title="二、软件实现IIC协议"></a>二、软件实现IIC协议</h1><h2 id="1-GPIO口配置"><a href="#1-GPIO口配置" class="headerlink" title="1.GPIO口配置"></a>1.GPIO口配置</h2><p>这里用软件实现IIC协议推荐使用开漏输出，然后从机的引脚需要接上一个上拉电阻，为了防止在一条IIC总线上大家都进行推挽输出导致电流的灌制。</p>
<p>配置的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">RCC_APB2PeriphClockCmd(MPU6050_GPIO_RCC, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = MPU6050_IIC_SCL | MPU6050_IIC_SDA;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(MPU6050_GPIO, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<p>这里直接用我写好的代码了，我把IIC引脚全部使用宏定义替换了，这样后面移植的时候好进行更改。</p>
<h2 id="2-IIC开始信号"><a href="#2-IIC开始信号" class="headerlink" title="2.IIC开始信号"></a>2.IIC开始信号</h2><p>这里可以看一下上面的图：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240819143451302-1471677611.png" alt="img"></p>
<p>在开始时，SDA是高电平，然后被拉低，而SCL是高电平，当SDA拉低后SCL才被拉低，所以代码可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IIC_MPU6050_SCL_Set(<span class="number">1</span>);</span><br><span class="line">IIC_MPU6050_SDA_Set(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">IIC_MPU6050_SDA_Set(<span class="number">0</span>);</span><br><span class="line">IIC_MPU6050_SCL_Set(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这里我做了一个封装，把SDA和SCL的操作封装到一个函数中，其实本质上的操作就是<code>GPIO_WriteBit()</code>函数进行操作，这里就懒一下了。</p>
<h2 id="3-IIC结束信号"><a href="#3-IIC结束信号" class="headerlink" title="3.IIC结束信号"></a>3.IIC结束信号</h2><p>这里就需要写一下结束信号，参考上面的图，可以看到SDA信号线一开始是低电平，然后被拉为高电平，而SCL信号线一直都是高电平，所以代码就可以这样写，先让SDA为低电平，SCL为高电平，最后拉高SDA即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IIC_MPU6050_SDA_Set(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">IIC_MPU6050_SCL_Set(<span class="number">1</span>);</span><br><span class="line">IIC_MPU6050_SDA_Set(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这样就完成了结束信号的编写。</p>
<h2 id="4-发送数据"><a href="#4-发送数据" class="headerlink" title="4.发送数据"></a>4.发送数据</h2><p>这里可以看一下上面的时序：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240819143837747-585854846.png" alt="img"></p>
<p>这里是在SCL为低电平的时候更改SDA的电平，当SCL被拉高后就会将SDA上的数据发送到从机中，所以这里的代码可以这样写，先将数据给SDA，然后拉高SCL信号线，这样就会将数据发送给从机了，然后再把SCL信号线拉低更改SDA上的数据。</p>
<p>也可以先拉低SCL的电平，但因为前面在开始信号的时候SCL的电平就是为低电平了，所以一开始可以不用将SCL拉低：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    IIC_MPU6050_SDA_Set(bit &amp; (<span class="number">0x80</span> &gt;&gt; i));</span><br><span class="line">    </span><br><span class="line">    IIC_MPU6050_SCL_Set(<span class="number">1</span>);</span><br><span class="line">    IIC_MPU6050_SCL_Set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IIC_MPU6050_SDA_Set(bit &amp; (<span class="number">0x80</span> &gt;&gt; i));</span><br><span class="line">    </span><br><span class="line">IIC_MPU6050_SCL_Set(<span class="number">1</span>);</span><br><span class="line">IIC_MPU6050_SCL_Set(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>是发送一位数据的操作，重复8次就是发送一个字节的数据了。</p>
<h2 id="5-接收数据"><a href="#5-接收数据" class="headerlink" title="5.接收数据"></a>5.接收数据</h2><p>这里看一下时序：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240819144001999-878170256.png" alt="img"></p>
<p>可以看到，也是在SCL为高电平的时候读出数据，所以代码可以这样写，先将SDA信号线释放，直接给高电平即可，然后当SCL拉高后读取SDA信号线上的数据，再将SDA拉低为下一次读取做准备：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> i, bit = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">IIC_MPU6050_SDA_Set(<span class="number">1</span>);       <span class="comment">// 释放SDA信号线</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    IIC_MPU6050_SCL_Set(<span class="number">1</span>);</span><br><span class="line">    bit |= IIC_MPU6050_SDA_Read();</span><br><span class="line">    IIC_MPU6050_SCL_Set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-接收ACK响应"><a href="#6-接收ACK响应" class="headerlink" title="6.接收ACK响应"></a>6.接收ACK响应</h2><p>这里就不多说了，直接就使用接收数据的那个逻辑即可，这里是一条数据，所以只需要执行一次即可，就不用使用循环了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> ack = <span class="number">0</span>;</span><br><span class="line">IIC_MPU6050_SDA_Set(<span class="number">1</span>);       <span class="comment">// 释放SDA信号线</span></span><br><span class="line">IIC_MPU6050_SCL_Set(<span class="number">1</span>);</span><br><span class="line">ack = IIC_MPU6050_SDA_Read();</span><br><span class="line">IIC_MPU6050_SCL_Set(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="7-发送ACK和NACK响应"><a href="#7-发送ACK和NACK响应" class="headerlink" title="7.发送ACK和NACK响应"></a>7.发送ACK和NACK响应</h2><p>这个东西很简单，其实就是发送一个位即可，主要是ACK和NACK是怎么发送而已。</p>
<p>在前面接收从机发送的ACK信号可以判断是否接收的为0，如果为0就是接收成功了，所以我们知道了，ACK信号其实就是0，而NACK就是ACK信号的取反，也就是1。</p>
<p>这样不就清楚了吧，当发送0时就是发送ACK，当发送1时就是发送NACK。</p>
<p>发送ACK代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IIC_MPU6050_SDA_Set(<span class="number">0</span>);</span><br><span class="line">IIC_MPU6050_SCL_Set(<span class="number">1</span>);</span><br><span class="line">IIC_MPU6050_SCL_Set(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>发送NACK代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IIC_MPU6050_SDA_Set(<span class="number">1</span>);</span><br><span class="line">IIC_MPU6050_SCL_Set(<span class="number">1</span>);</span><br><span class="line">IIC_MPU6050_SCL_Set(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>代码一样，也就是发送的SDA不一样而已。</p>
<p>IIC协议的基础代码就写完了，后面就开始使用写好的这些封装来进行寄存器的操作了。</p>
<h2 id="8-对寄存器进行写处理"><a href="#8-对寄存器进行写处理" class="headerlink" title="8.对寄存器进行写处理"></a>8.对寄存器进行写处理</h2><p>这里可以看一下上面写的那个写操作：</p>
<ol>
<li>发送IIC开始信号</li>
<li>发送从机写地址</li>
<li>接收从机发送的ack信号</li>
<li>发送需要操作的寄存器地址</li>
<li>接收从机发送的ack信号</li>
<li>发送需要写入的数据</li>
<li>接收从机发送的ack信号</li>
<li>发送IIC结束信号</li>
</ol>
<p>现在来把它转换为代码的写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteByte</span><span class="params">(<span class="type">uint8_t</span> cmd, <span class="type">uint8_t</span> date)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 开始IIC协议</span></span><br><span class="line">    IIC_MPU6050_Start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入从机的写地址</span></span><br><span class="line">    IIC_MPU6050_WritBit(MPU6050_ADDR);</span><br><span class="line">    <span class="comment">// 等待从机发送的ACK</span></span><br><span class="line">    IIC_MPU6050_ReadACK();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写需要写入的从机寄存器地址</span></span><br><span class="line">    IIC_MPU6050_WritBit(cmd);</span><br><span class="line">    <span class="comment">// 等待从机发送的ACK</span></span><br><span class="line">    IIC_MPU6050_ReadACK();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向从机寄存器地址中写入数据</span></span><br><span class="line">    IIC_MPU6050_WritBit(date);</span><br><span class="line">    <span class="comment">// 等待从机发送的ACK</span></span><br><span class="line">    IIC_MPU6050_ReadACK();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束IIC协议</span></span><br><span class="line">    IIC_MPU6050_Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以对从机的寄存器中写入一些数据了。</p>
<h2 id="9-对寄存器进行读处理"><a href="#9-对寄存器进行读处理" class="headerlink" title="9.对寄存器进行读处理"></a>9.对寄存器进行读处理</h2><p>这里还是看前面说的那个过程：</p>
<ol>
<li>发送IIC开始信号</li>
<li>发送从机写地址</li>
<li>接收从机发送的ack信号</li>
<li>发送需要读的寄存器地址</li>
<li>接收从机发送的ack信号</li>
<li>再次发送IIC开始信号</li>
<li>发送从机读地址</li>
<li>读取SDA线上的数据</li>
<li>发送NACK结束读取</li>
<li>发送结束信号</li>
</ol>
<p>现在来进行实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadByte</span><span class="params">(<span class="type">uint8_t</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> byte = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    IIC_MPU6050_Start();    <span class="comment">// 开启IIC</span></span><br><span class="line">    </span><br><span class="line">    IIC_MPU6050_WritBit(MPU6050_ADDR);    <span class="comment">// 写入从机的写地址</span></span><br><span class="line">    IIC_MPU6050_ReadACK();</span><br><span class="line">    </span><br><span class="line">    IIC_MPU6050_WritBit(cmd);      <span class="comment">// 写入需要读取的寄存器地址</span></span><br><span class="line">    IIC_MPU6050_ReadACK();</span><br><span class="line">    </span><br><span class="line">    IIC_MPU6050_Start();        <span class="comment">// 再次开启IIC协议</span></span><br><span class="line">    </span><br><span class="line">    IIC_MPU6050_WritBit(MPU6050_ADDR | <span class="number">0x01</span>);       <span class="comment">// 写入从机读地址</span></span><br><span class="line">    IIC_MPU6050_ReadACK();</span><br><span class="line">    </span><br><span class="line">    byte = IIC_MPU6050_ReadBit();       <span class="comment">// 接收读取的数据</span></span><br><span class="line">    IIC_MPU6050_SendNACK();          <span class="comment">// 发送NACK结束接收</span></span><br><span class="line">    </span><br><span class="line">    IIC_MPU6050_Stop();         <span class="comment">// 结束IIC协议</span></span><br><span class="line">    <span class="keyword">return</span> byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样模拟的IIC协议就写完了，大家可以使用MPU6050陀螺仪模块来进行测试，但我这手表上的陀螺仪忘记画上拉电阻了，导致读取不了数据，所以就不展示了。</p>
<h1 id="三、硬件实现IIC协议"><a href="#三、硬件实现IIC协议" class="headerlink" title="三、硬件实现IIC协议"></a>三、硬件实现IIC协议</h1><p>使用硬件可以节约CPU的使用率，让其可以只控制IIC控制器完成IIC协议的通讯。</p>
<p>当时在stm32f103中只有2个IIC通讯引脚，硬件资源还是蛮少的，但是IIC可以一主多从，其实也是够用的。</p>
<p>这里主要介绍一下硬件IIC产生的事件，使用硬件IIC会根据不同的时段产生一些信号，我们可以通过判断这些信号来进行相应的处理。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240819154030548-915768335.png" alt="img"></p>
<p>上图的硬件IIC主机发送数据的序列图，可以看到有两个，这个不用了解，一般的IIC通讯的设备都是7位地址的，我没见过10位的，所以这里只讲7位的。</p>
<p>当发送IIC开始信号后会产生一个<code>EV5</code>的事件，当发送完地址和响应后会产生一个<code>EV6</code>和<code>EV8_1</code>的事件，这里只需要判断一下<code>EV6</code>即可，而<code>EV8_1</code>不需要进行判断，因为在刚开始肯定都是空的。</p>
<p>然后就开始发送数据到移位寄存器中，这个时候会产生一个信号<code>EV8</code>，当数据从移位寄存器中到数据寄存器中后这个事件就会清除。</p>
<p>最后不想发送数据后，就可以等待<code>EV8_2</code>，当移位寄存器和数据寄存器都清空了就可以发送停止位了。</p>
<p>发送的还是比较简单，接下来看一下接收的：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240819154755654-2071608050.png" alt="img"></p>
<p>可以看到一下子复杂起来了，这里还是看7位的，这里是直接列出二次开启后的事件产生了，第二次产生也是产生一个<code>EV5</code>事件，然后接收从机读地址，还是一个<code>EV6</code>信号，然后到DR数据寄存器中读取数据后就会讲<code>EV7</code>进行清空。</p>
<p>这里需要注意一下，如果只读一个字节数据，那这里需要先进行结束后再去读取DR寄存器中的值，因为在接收一次后会存放到DR寄存器中，然后继续读，所以要先发送停止后再读取并发送NACK信号。</p>
<p>这样就能明白其中的意义了，就可以来写代码了。</p>
<h2 id="1-初始化GPIO口"><a href="#1-初始化GPIO口" class="headerlink" title="1.初始化GPIO口"></a>1.初始化GPIO口</h2><p>这里需要注意一下，因为硬件IIC是GPIO口的一个复用功能，所以要使用复用开漏输出，我在写的时候就遇到这个问题，一直读取不了数据，并且开启<code>AFIO</code>的时钟，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(MPU6050_GPIO_RCC, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = MPU6050_IIC_SCL | MPU6050_IIC_SDA;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(MPU6050_GPIO, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<p>这样就配置好GPIO口了。</p>
<h2 id="2-配置IIC的时钟"><a href="#2-配置IIC的时钟" class="headerlink" title="2.配置IIC的时钟"></a>2.配置IIC的时钟</h2><p>使用一个外设最重要的就是开启对应的时钟，IIC的时钟是在APB1总线下的，所以要通过APB1来进行开启：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);</span><br></pre></td></tr></table></figure>

<h2 id="3-配置IIC"><a href="#3-配置IIC" class="headerlink" title="3.配置IIC"></a>3.配置IIC</h2><p>这里也是使用结构体的方式进行IIC的配置，使用的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> I2C_ClockSpeed;          <span class="comment">/*!&lt; 指定时钟频率。</span></span><br><span class="line"><span class="comment">  此参数必须设置为低于 400kHz 的值 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> I2C_Mode;                <span class="comment">/*!&lt; 指定 I2C 模式。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref I2C_mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> I2C_DutyCycle;           <span class="comment">/*!&lt; 指定 I2C 快速模式占空比。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref I2C_duty_cycle_in_fast_mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> I2C_OwnAddress1;         <span class="comment">/*!&lt; 指定第一个设备自己的地址。</span></span><br><span class="line"><span class="comment">  此参数可以是 7 位或 10 位地址。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> I2C_Ack;                 <span class="comment">/*!&lt; 启用或禁用确认。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref I2C_acknowledgement */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> I2C_AcknowledgedAddress; <span class="comment">/*!&lt; 指定是确认 7 位地址还是 10 位地址。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref I2C_acknowledged_address */</span></span><br><span class="line">&#125;I2C_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>这里不一个一个解释了，直接上配置代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">I2C_InitTypeDef I2C_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">I2C_InitStruct.I2C_Ack = ENABLE;                                            <span class="comment">// 使能ACK响应</span></span><br><span class="line">I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;      <span class="comment">// 设置地址为7位地址</span></span><br><span class="line">I2C_InitStruct.I2C_ClockSpeed = <span class="number">50000</span>;                                      <span class="comment">// 时钟速率</span></span><br><span class="line">I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;                             <span class="comment">// 快速模式的占空比</span></span><br><span class="line">I2C_InitStruct.I2C_Mode = I2C_Mode_I2C;                                     <span class="comment">// I2C模式</span></span><br><span class="line">I2C_InitStruct.I2C_OwnAddress1 = <span class="number">0x00</span>;                                      <span class="comment">// 自身地址</span></span><br><span class="line">I2C_Init(I2C2, &amp;I2C_InitStruct);     <span class="comment">// 第一个是选择使用的IIC编号</span></span><br></pre></td></tr></table></figure>

<p>可以看到上面的这个注释来进行了解，其中IIC的速率可以去看对应从机能接收的最大速率来进行配置，然后占空比其实速率不高用1：2即可，如果速度高就用6：9。</p>
<h2 id="4-对寄存器进行写处理"><a href="#4-对寄存器进行写处理" class="headerlink" title="4.对寄存器进行写处理"></a>4.对寄存器进行写处理</h2><p>这里不需要再自己写开始信号和结束信号，这里直接用库函数即可。</p>
<p>首先开始信号使用的是<code>I2C_GenerateSTART()</code>，第一个参数是IIC的编号，第二个填使能或者失能，如果要发送开始信号就填写使能。</p>
<p>发送完成后用<code>I2C_CheckEvent()</code>函数判断一下<code>EV5</code>信号是否产生，<code>EV5</code>信号的宏定义是<code>I2C_EVENT_MASTER_MODE_SELECT</code>，然后产生会返回<code>SUCCESS</code>，否则返回<code>ERROR</code>。</p>
<p>然后开始发送从机地址，这里使用<code>I2C_Send7bitAddress()</code>函数进行发送，第一个参数是IIC的编号，第二个参数是填写从机地址，从机地址可以在数据手册中寻找，第三个参数是填写读还是写操作。</p>
<p>发送完成后用<code>I2C_CheckEvent()</code>函数判断一下<code>EV6</code>信号是否产生，这里就需要注意一下了，它有两个<code>EV6</code>信号，分别是：<code>I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED </code>和<code>I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED</code>。</p>
<p>第一个是发送，也就是写操作的时候产生的信号，第二个是接收，也就是读操作的时候产生的信号，这里需要看你在<code>I2C_Send7bitAddress()</code>函数的第三个参数填写的是什么，如果是写，那就用第一个，如果是读就用第二个。</p>
<p>然后就是写数据，这里使用<code>I2C_SendData</code>函数进行写数据，第一个参数也是IIC的编号，第二个是要写入的数据。</p>
<p>最后使用<code>I2C_GenerateSTOP()</code>发送结束信号，参数和<code>I2C_GenerateSTART()</code>一致。</p>
<p>所以这里的完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">I2C_GenerateSTART(I2C2, ENABLE);</span><br><span class="line"><span class="keyword">while</span> (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT) == ERROR);      <span class="comment">// 判断是否接收到EV5信号</span></span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2, MPU6050_ADDR, I2C_Direction_Transmitter);</span><br><span class="line"><span class="keyword">while</span> (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) == ERROR);     <span class="comment">// 判断是否接收到EV6信号的写信号</span></span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2, addr);</span><br><span class="line"><span class="keyword">while</span> (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTING) == ERROR);     <span class="comment">// 判断是否接收到EV8，后面还需要传输一个字节数据</span></span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2, dat);</span><br><span class="line"><span class="keyword">while</span> (I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED) == ERROR);       <span class="comment">// 判断是否接收到EV8_2，</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTOP(I2C2, ENABLE);</span><br></pre></td></tr></table></figure>

<h2 id="5-对寄存器进行读处理"><a href="#5-对寄存器进行读处理" class="headerlink" title="5.对寄存器进行读处理"></a>5.对寄存器进行读处理</h2><p>主要注重于读操作即可，前面和二次的都一样，在发送地址这就有问题了，这里要的是读信号，所以得判断是否产生<code>I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED</code>。</p>
<p>然后使用<code>I2C_ReceiveData()</code>函数进行读取，但在读取前需要用<code>I2C_AcknowledgeConfig()</code>函数不发送ACK，然后发送结束信号，发送完结束信号后用读取函数进行读取，最后再用<code>I2C_AcknowledgeConfig()</code>函数发送ACK信号。</p>
<p>这里我觉得麻烦，所以把<code>I2C_CheckEvent()</code>给封装了一下，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> byte;</span><br><span class="line">    </span><br><span class="line">I2C_GenerateSTART(I2C2, ENABLE);</span><br><span class="line">MPU6050_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT);     <span class="comment">// 检测是否产生EV5事件</span></span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2, MPU6050_ADDR, I2C_Direction_Transmitter);</span><br><span class="line">MPU6050_WaitEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);   <span class="comment">// 检测是否产生EV6事件</span></span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2, addr);</span><br><span class="line">MPU6050_WaitEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTING);     <span class="comment">// 检测是否产生EV8事件</span></span><br><span class="line"></span><br><span class="line">I2C_GenerateSTART(I2C2, ENABLE);</span><br><span class="line">MPU6050_WaitEvent(I2C_EVENT_MASTER_MODE_SELECT);    <span class="comment">// 检测是否产生EV5事件</span></span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2, MPU6050_ADDR, I2C_Direction_Receiver);</span><br><span class="line">MPU6050_WaitEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);    <span class="comment">// 检测是否产生EV6事件</span></span><br><span class="line"></span><br><span class="line">I2C_AcknowledgeConfig(I2C2, DISABLE);       <span class="comment">// 不发送ACK</span></span><br><span class="line">I2C_GenerateSTOP(I2C2, ENABLE);        <span class="comment">// 发送停止信号</span></span><br><span class="line"></span><br><span class="line">MPU6050_WaitEvent(I2C_EVENT_MASTER_BYTE_RECEIVED);        <span class="comment">// 检测是否产生EV7事件</span></span><br><span class="line">byte = I2C_ReceiveData(I2C2);            <span class="comment">// 读取数据</span></span><br><span class="line"></span><br><span class="line">I2C_AcknowledgeConfig(I2C2, ENABLE);     <span class="comment">// 发送ACK</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>IIC协议其实了解了它的时序图后会发现，其实IIC是非常的简单的，其实就做个项目就可以明白了的，这一章只讲其中驱动的使用，后面我会单独出一个专题来介绍一些大型项目的实现。</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>13 BKP和RTC</title>
    <url>/2025/01/17/8f874554046b/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一节主要是讲解RTC时钟和BKP内部寄存器的，代表着单片机裸机开发就快结束了，后面可能会出RTOS的教程。</p>
<h1 id="一、BKP备份寄存器"><a href="#一、BKP备份寄存器" class="headerlink" title="一、BKP备份寄存器"></a>一、BKP备份寄存器</h1><h2 id="1-BKP介绍"><a href="#1-BKP介绍" class="headerlink" title="1.BKP介绍"></a>1.BKP介绍</h2><p>该寄存器是在stm32内部的一个RAM寄存器，需要在外部为单片机的<code>VBT</code>引脚接一个电池，保证内部的BKP寄存器中的数据不丢失。</p>
<p>当系统在待机模式下被唤醒，或系统复位或电源复位时，BKP也不会被复位。</p>
<p><code>TAMPER</code>引脚产生的侵入事件将所有备份寄存器内容清除，保障重要的内容在被入侵时清空。</p>
<p>在小容量或者中等容量的单片机中该寄存器中用户可以存放20字节的数据，在大容量和互联型设备中可以存放84字节的数据。</p>
<h2 id="2-BKP的使用"><a href="#2-BKP的使用" class="headerlink" title="2.BKP的使用"></a>2.BKP的使用</h2><p>BKP是挂载到APB1总线上的设备，所以需要使用<code>RCC_APB1PeriphClockCmd()</code>来对BKP进行时钟的打开。</p>
<p>BKP需要PWR电源管理设备的配合使用，所以还需要打开一下PWR的时钟，PWR的时钟也是挂载到APB1总线上的，所以这里就知道了，先打开BKP的时钟，然后再打开PWR的时钟。</p>
<p>最后使能一下PWR，这样就可以对BPK进行使用了。</p>
<p>这里直接上代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		<span class="comment">//开启PWR的时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);		<span class="comment">//开启BKP的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*备份寄存器访问使能*/</span></span><br><span class="line">PWR_BackupAccessCmd(ENABLE);							<span class="comment">//使用PWR开启对备份寄存器的访问</span></span><br></pre></td></tr></table></figure>

<p>这样就可以对BKP进行使用了，对于寄存器的使用其实就是读取和写入，我们可以使用<code>BKP_WriteBackupRegister()</code>函数对对应的BKP位置写入数据。</p>
<p>然后使用<code>BKP_ReadBackupRegister()</code>函数读取对应BKP寄存器中的位置的数据。</p>
<h1 id="二、RTC实时时钟"><a href="#二、RTC实时时钟" class="headerlink" title="二、RTC实时时钟"></a>二、RTC实时时钟</h1><p>这个是这一节的重点，前面的BKP是和RTC连在一起的，因为都是由VBT引脚进行独立供电的设备。</p>
<h2 id="1-RTC时钟的介绍"><a href="#1-RTC时钟的介绍" class="headerlink" title="1.RTC时钟的介绍"></a>1.RTC时钟的介绍</h2><p>RTC是一个独立的定时器，可为系统提供时钟和日历的功能，断电不丢失，由VBT引脚提供电源来进行运行。</p>
<p>32位的可编程计数器，可对应Unix时间戳的秒计数器。20位的可编程预分频器，可适配不同频率的输入时钟</p>
<p>可选择三种RTC时钟源：</p>
<ul>
<li>HSE时钟除以128（通常为8MHz&#x2F;128）</li>
<li>LSE振荡器时钟（通常为32.768KHz）</li>
<li>LSI振荡器时钟（40KHz）</li>
</ul>
<h2 id="2-RTC内部结构"><a href="#2-RTC内部结构" class="headerlink" title="2.RTC内部结构"></a>2.RTC内部结构</h2><p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240822201116654-1130494609.png" alt="img"></p>
<p>这个是RTC的内部框图，可以看到RTC是挂载到APB1总线上的，由RTCCLK输入频率后开始计时，对Unix时钟戳继续计数值。</p>
<p>我们可以通过RTC来让STM32从待机模式中退出。</p>
<p>外部时钟通过RTCCLK进行选择后输入到RTC预分频器中进行分频。</p>
<h2 id="3-RTC代码编写的注意事项"><a href="#3-RTC代码编写的注意事项" class="headerlink" title="3.RTC代码编写的注意事项"></a>3.RTC代码编写的注意事项</h2><p>对RTC时钟的开启也是需要通过打开PWR和BKP的时钟的，打开后还需要使能PWR，使得BPK和RTC都能使用。</p>
<p>在写入RTC的寄存器前需要使RTC进入配置模式后才能写入RTC的RTC_PRL、RTC_CNT、RTC_ALR寄存器，当写完后还需要退出RTC的配置模式。</p>
<p>在写完寄存器后还需要查询RTC_CR寄存器中的RTOFF状态位对RTC任何寄存器的写操作，都必须在前一次写操作结束后进行。可以通过查询RTC_CR寄存器中的RTOFF状态位，判断RTC寄存器是否处于更新中。仅当RTOFF状态位是1时，才可以写入RTC寄存器。</p>
<p>若在读取RTC寄存器时，RTC的APB1接口曾经处于禁止状态，则软件首先必须等待RTC_CRL寄存器中的RSF位（寄存器同步标志）被硬件置1。</p>
<h2 id="4-代码的实现"><a href="#4-代码的实现" class="headerlink" title="4.代码的实现"></a>4.代码的实现</h2><p>这里直接就上代码吧，本质上来说RTC的操作还是比较的简单的，这里就不细说了，注意等待同步和等待上一次操作完成即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		<span class="comment">//开启PWR的时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);		<span class="comment">//开启BKP的时钟RCC_LSEConfig(RCC_LSE_ON);							//开启LSE时钟</span></span><br><span class="line"><span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET);	<span class="comment">//等待LSE准备就绪</span></span><br><span class="line"></span><br><span class="line">RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);				<span class="comment">//选择RTCCLK来源为LSE</span></span><br><span class="line">RCC_RTCCLKCmd(ENABLE);								<span class="comment">//RTCCLK使能</span></span><br><span class="line"></span><br><span class="line">RTC_WaitForSynchro();								<span class="comment">//等待同步</span></span><br><span class="line">RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成</span></span><br><span class="line"></span><br><span class="line">RTC_SetPrescaler(<span class="number">32768</span> - <span class="number">1</span>);						<span class="comment">//设置RTC预分频器，预分频后的计数频率为1Hz</span></span><br><span class="line">RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成RTC_WaitForSynchro();								//等待同步</span></span><br><span class="line">RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>12 spi通讯协议</title>
    <url>/2025/01/17/fec2c343dcd4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面介绍了IIC协议的通讯，这一节介绍一下比较简单的SPI通讯协议，spi使用的地方也是很多的，而且也很简单，所以这一章就来介绍一下。</p>
<h1 id="一、SPI协议"><a href="#一、SPI协议" class="headerlink" title="一、SPI协议"></a>一、SPI协议</h1><h2 id="1-什么是SPI协议"><a href="#1-什么是SPI协议" class="headerlink" title="1.什么是SPI协议"></a>1.什么是SPI协议</h2><p>SPI是由摩托罗拉公司开发的一种通用的数据总线。有四根信号线，分别是<code>SCK</code>时序控制线、<code>SS</code>片选线、<code>MOSI</code>主机发送从机接收信号线和<code>MISO</code>主机接收从机发送信号线。</p>
<p>是一个同步、全双工的通讯协议，支持一主一从和一主多从。</p>
<h2 id="2-SPI连接方法"><a href="#2-SPI连接方法" class="headerlink" title="2.SPI连接方法"></a>2.SPI连接方法</h2><p>所有设备的<code>MOSI</code>要连接到一起，<code>MISO</code>要连接到一起，<code>SCK</code>也是一样的，从机的<code>SS</code>要连接到主机的指定引脚上，就如下图一样：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240822111636537-1188143648.png" alt="img"></p>
<p>在配置时如果是软件模拟SPI协议，那需要将除去<code>MISO</code>的所有引脚都配置为推挽输出，而<code>MISO</code>配置为上拉输入。</p>
<p>如果是硬件SPI时，需要把除去<code>MISO</code>的所有引脚配置为复用推挽输出，<code>MISO</code>还是配置为上拉输入。</p>
<h2 id="3-SPI的工作方式"><a href="#3-SPI的工作方式" class="headerlink" title="3.SPI的工作方式"></a>3.SPI的工作方式</h2><p>SPI协议和IIC是不一样的，在IIC中是半双工，在发送时不能接收，接收时不能发送，并且只有一个数据寄存器来接收和发送数据。</p>
<p>但在SPI中是全双工的，可以边发送数据边接收数据，在SPI中也有一个寄存器，而这个寄存器是移位寄存器，如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240822112213569-454944302.png" alt="img"></p>
<p>在规定的时钟信号下，移位寄存器会根据设定的方式先把高位或者低位数据转移到<code>MOSI</code>信号线上发送给从机，并从<code>MISO</code>信号线中接收从机发送过来的数据到移位寄存器中，这就是SPI的一个工作过程。</p>
<p>我们要用软件模拟SPI协议就要搞清楚这个协议的工作方法和起始和结束信号。</p>
<h2 id="4-SPI的起始和结束信号"><a href="#4-SPI的起始和结束信号" class="headerlink" title="4.SPI的起始和结束信号"></a>4.SPI的起始和结束信号</h2><p>起始和结束信号并不是依靠于发送一个特定的波形信号，而是只用给<code>SS</code>片选引脚一个使能或者失能信号即可。</p>
<p>要选中哪个从机，就给对应的从机<code>SS</code>引脚发送一个低电平即可选中，如果不想和该从机进行通讯，就给对应从机的<code>SS</code>引脚发送一个高电平即可取消选中。</p>
<p>所以这里就明白了，起始信号就是给从机的<code>SS</code>引脚发送低电平，结束信号就是给从机的<code>SS</code>发送高电平。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240822113016199-1668432803.png" alt="img"></p>
<h2 id="5-SPI工作时序"><a href="#5-SPI工作时序" class="headerlink" title="5.SPI工作时序"></a>5.SPI工作时序</h2><p>在SPI中有四种工作时序，都可以进行使用，只不过就是在每个时许执行的内容不一样而已。</p>
<h3 id="5-1-方式0"><a href="#5-1-方式0" class="headerlink" title="5.1 方式0"></a>5.1 方式0</h3><p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240822113401133-514647708.png" alt="img"></p>
<p>在方式0中，CPOL &#x3D; 0，CPHA &#x3D; 0，SCK默认空闲为低电平，SS被拉为低电平后就会将数据通过<code>MOSI</code>发送给从机，在<code>SCK</code>信号上升沿后将<code>MISO</code>信号线中的数据转移到移位寄存器中。</p>
<p>也就是说在下降沿的时候将移位寄存器中的数据通过<code>MOSI</code>信号线发送到从机，在上升沿时主机会从<code>MISO</code>信号线中读取从机发送过来的数据到移位寄存器中。</p>
<h3 id="5-2-方式1"><a href="#5-2-方式1" class="headerlink" title="5.2 方式1"></a>5.2 方式1</h3><p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240822114254273-1147701013.png" alt="img"></p>
<p>在方式1中，CPOL &#x3D; 0，CPHA &#x3D; 1，SCK默认空闲为低电平，在SCK上升沿的时候将数据通过<code>MOSI</code>发送给从机，在下降沿的时候将<code>MISO</code>信号线中的数据转移到移位寄存器中。</p>
<h3 id="5-3-方式2"><a href="#5-3-方式2" class="headerlink" title="5.3 方式2"></a>5.3 方式2</h3><p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240822114935029-647869136.png" alt="img"></p>
<p>在方式2中，CPOL &#x3D; 1，CPHA &#x3D; 0，SCK默认空闲为高电平，该模式是和方式0是反过来的，方式0是高电平采集，而方式2是低电平采集，发送也是一样的。</p>
<h3 id="5-4-方式3"><a href="#5-4-方式3" class="headerlink" title="5.4 方式3"></a>5.4 方式3</h3><p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240822115211842-198106029.png" alt="img"></p>
<p>在方式3中，CPOL &#x3D; 1，CPHA &#x3D; 1，SCK默认为高电平，该模式是和方式1是发过来的，方式1是高电平发送，方式3是高电平接收。</p>
<h1 id="二、软件模拟SPI协议"><a href="#二、软件模拟SPI协议" class="headerlink" title="二、软件模拟SPI协议"></a>二、软件模拟SPI协议</h1><p>前面介绍了一下SPI的各种东西，这里就开始代码的实现，其实实现的方法很简单，首先配置GPIO口，起始信号和结束信号，发送接收时序的拼接，然后就结束了。</p>
<h2 id="1-配置GPIO口"><a href="#1-配置GPIO口" class="headerlink" title="1.配置GPIO口"></a>1.配置GPIO口</h2><p>因为这里我们使用的是软件来模拟SPI协议，所以需要配置一下GPIO口，对于GPIO口的模式配置前面也是说过的，如果是软件模拟则需要配置为推挽输出的模式，这里我使用GPIOB下的引脚，下面是宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CS   GPIO_Pin_4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MISO   GPIO_Pin_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_MOSI   GPIO_Pin_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CLK  GPIO_Pin_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_GPIO GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_RCC RCC_APB2Periph_GPIOB</span></span><br></pre></td></tr></table></figure>

<p>然后开始配置GPIO口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">RCC_APB2PeriphClockCmd(SPI_RCC, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = SPI_CS | SPI_MOSI | SPI_CLK;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(SPI_GPIO, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = SPI_MISO;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(SPI_GPIO, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<p>MISO引脚主要是作为输入的，这里需要配置为上拉输入。</p>
<p>然后封装一下输入和输出吧，这里我将所有的引脚都封装了一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_MOSI_Set</span><span class="params">(<span class="type">uint8_t</span> <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(SPI_GPIO, SPI_MOSI, (BitAction)<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SPI_MISO_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GPIO_ReadInputDataBit(SPI_GPIO, SPI_MISO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_CLK_Set</span><span class="params">(<span class="type">uint8_t</span> <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(SPI_GPIO, SPI_CLK, (BitAction)<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_CS_Set</span><span class="params">(<span class="type">uint8_t</span> <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(SPI_GPIO, SPI_CS, (BitAction)<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面IIC协议也是这样封装的，但是没有在那里着重说明。</p>
<p>然后就还需要在初始化中添加两句代码，第一个是将SS引脚初始化为高电平，也就是不选中，这样在初始化完成后就默认不选中，需要使用的话就调用一下<code>SPI_CS_Set(0)</code>进行选中。</p>
<p>然后再确定一下模式，如果要使用模式0或者模式1则需要将SCK的电平拉低，默认低电平；如果使用模式2或者模式3则信息要将SCK的电平拉高，完整的初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">RCC_APB2PeriphClockCmd(SPI_RCC, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = SPI_CS | SPI_MOSI | SPI_CLK;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(SPI_GPIO, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = SPI_MISO;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(SPI_GPIO, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">SPI_CS_Set(<span class="number">1</span>);</span><br><span class="line">SPI_CLK_Set(<span class="number">0</span>);        <span class="comment">// 这里选择的是模式0或者模式1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-起始和结束信号"><a href="#2-起始和结束信号" class="headerlink" title="2.起始和结束信号"></a>2.起始和结束信号</h2><p>前面说了，起始信号和结束信号起始就是拉低和拉高SS引脚即可，所以这里的写法很简单，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SPI_CS_Set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SPI_CS_Set(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-时序编写"><a href="#3-时序编写" class="headerlink" title="3.时序编写"></a>3.时序编写</h2><p>这里也是比较简单的，按照上面的时序图来进行代码的编写即可，这里每个都会讲一个例子来说明。</p>
<h3 id="3-1-方式0"><a href="#3-1-方式0" class="headerlink" title="3.1 方式0"></a>3.1 方式0</h3><p>方式0是在SS拉低后就开始数据的传输，所以这里可以直接先把数据通过<code>MOSI</code>进行发送，然后拉高SCK后再通过<code>MISO</code>获取接收的数据，最后再拉低SCK为下一次传输做准备，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">SPI_ReadWrite</span><span class="params">(<span class="type">uint8_t</span> date)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SPI_MOSI_Set(date &amp; <span class="number">0x80</span>);</span><br><span class="line">        date &lt;&lt;= <span class="number">1</span>;      <span class="comment">// 将高位已经传输的数据位移出去</span></span><br><span class="line">        SPI_CLK_Set(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (SPI_MISO_Read() == <span class="number">1</span>)</span><br><span class="line">            date |= <span class="number">0x01</span>;     <span class="comment">// 移入的数据放在最后</span></span><br><span class="line">        SPI_CLK_Set(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-方式1"><a href="#3-2-方式1" class="headerlink" title="3.2 方式1"></a>3.2 方式1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">SPI_ReadWrite</span><span class="params">(<span class="type">uint8_t</span> date)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SPI_CLK_Set(<span class="number">1</span>);</span><br><span class="line">        SPI_MOSI_Set(date &amp; <span class="number">0x80</span>);</span><br><span class="line">        date &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        SPI_CLK_Set(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (SPI_MISO_Read() == <span class="number">1</span>)</span><br><span class="line">            date |= <span class="number">0x01</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在模式1中，在SCK的上升沿时发送数据，在下降沿时接收数据。</p>
<h3 id="3-3-方式2"><a href="#3-3-方式2" class="headerlink" title="3.3 方式2"></a>3.3 方式2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">SPI_ReadWrite</span><span class="params">(<span class="type">uint8_t</span> date)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SPI_MOSI_Set(date &amp; <span class="number">0x80</span>);</span><br><span class="line">        date &lt;&lt;= <span class="number">1</span>;      <span class="comment">// 将高位已经传输的数据位移出去</span></span><br><span class="line">        SPI_CLK_Set(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (SPI_MISO_Read() == <span class="number">1</span>)</span><br><span class="line">            date |= <span class="number">0x01</span>;     <span class="comment">// 移入的数据放在最后</span></span><br><span class="line">        SPI_CLK_Set(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上方式2只是在方式0的基础上的电平翻转了一下，并且在初始化的那里需要将SCK的电平默认为高电平即可。</p>
<h3 id="3-4-方式3"><a href="#3-4-方式3" class="headerlink" title="3.4 方式3"></a>3.4 方式3</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">SPI_ReadWrite</span><span class="params">(<span class="type">uint8_t</span> date)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SPI_CLK_Set(<span class="number">0</span>);</span><br><span class="line">        SPI_MOSI_Set(date &amp; <span class="number">0x80</span>);</span><br><span class="line">        date &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        SPI_CLK_Set(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (SPI_MISO_Read() == <span class="number">1</span>)</span><br><span class="line">            date |= <span class="number">0x01</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式3和方式1一样，只不过电平需要翻转，并且SCK的默认值得为高电平。</p>
<h2 id="4-时序编写"><a href="#4-时序编写" class="headerlink" title="4.时序编写"></a>4.时序编写</h2><p>时序的编写起始很简单，之前就已经写好了的，就是发送一个起始信号，然后发送内容接收内容最后再发送一个结束信号即可。</p>
<h1 id="三、硬件SPI协议"><a href="#三、硬件SPI协议" class="headerlink" title="三、硬件SPI协议"></a>三、硬件SPI协议</h1><p>熟悉了软件模拟SPI协议后应该知道SPI协议的时序图和方式，硬件的SPI使用的是硬件来进行实现SPI协议，STM32F103中有两个SPI组件，分别是SPI1和SPI2。</p>
<p>这两个组件在的总线是不一样的，SPI1的总线是在APB2上，而SPI2的总线是在APB1上的，两个SPI的频率是不一样的，需要使用高频率的就使用SPI1，低频率的就所用SPI2。</p>
<h2 id="1-SPI内部结构"><a href="#1-SPI内部结构" class="headerlink" title="1.SPI内部结构"></a>1.SPI内部结构</h2><p>下图就是硬件SPI的内部结构：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202408/3083010-20240822132729532-1706996729.png" alt="img"></p>
<p>可以看到MISO和MOSI引脚都连接到了一个移位寄存器，可以从移位寄存器中读出数据到接收缓冲区中，然后再到数据总线上，也可以通过数据总线向发送缓冲区中写入需要发送的数据，发送寄存器再发送给移位寄存器中。</p>
<p>SCK是由波特率发生器来进行控制的，通过APB2总线或者APB1总线上的频率来进行分频后得到一个输出频率，这个输出频率就是SCK的时钟频率。</p>
<p>NSS是一个主从控制引脚，这个一般都是使用GPIO口直接控制SS引脚来选中从机，所以这个引脚一般不进行使用。</p>
<p>硬件SPI其实和硬件IIC一样，需要通过判断一些事件来知道是否发送或者接收到一些内容，只不过在硬件SPI中是使用的是标志位来进行读取。</p>
<p>这里使用的比较多的是TXD发送缓冲区标志位、TXNE接收。</p>
<h2 id="2-软件实现"><a href="#2-软件实现" class="headerlink" title="2.软件实现"></a>2.软件实现</h2><p>了解了内部结构后我们就可以开始来书写代码了，书写的逻辑就是配置GPIO口，配置SPI，使能SPI，使用SPI发送数据，这样就是一个完整的配置和使用过程。</p>
<h3 id="2-1配置GPIO口"><a href="#2-1配置GPIO口" class="headerlink" title="2.1配置GPIO口"></a>2.1配置GPIO口</h3><p>这里配置就和软件不一样了，这里的配置需要使用复用推挽输出，因为SPI是属于GPIO口的复用功能，所以需要使用复用的输出，而输入就不用了，直接使用上拉即可，所以这里的代码就如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;RCC_APB2PeriphClockCmd(SPI_RCC, ENABLE);GPIO_InitStruct.GPIO_Pin = SPI_CS;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(SPI_GPIO, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = SPI_MOSI | SPI_CLK;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(SPI_GPIO, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Pin = SPI_MISO;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(SPI_GPIO, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>

<p>这里的SS不需要使用复用模式，因为是直接输出内容的。</p>
<h3 id="2-2-配置SPI"><a href="#2-2-配置SPI" class="headerlink" title="2.2 配置SPI"></a>2.2 配置SPI</h3><p>这里我是使用的是SPI1进行配置，上面的那些宏定义把GPIOB换成GPIOA就可以了，这里配置的方法其实也是使用一个结构体来进行配置，对应的宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> SPI_Direction;           <span class="comment">/*!&lt; 指定 SPI 单向或双向数据模式。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref SPI_data_direction */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> SPI_Mode;                <span class="comment">/*!&lt; 指定 SPI 操作模式。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref SPI_mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> SPI_DataSize;            <span class="comment">/*!&lt; 指定 SPI 数据大小。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref SPI_data_size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> SPI_CPOL;                <span class="comment">/*!&lt; 指定串行时钟稳定状态。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref SPI_Clock_Polarity */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> SPI_CPHA;                <span class="comment">/*!&lt; 指定位捕获的时钟活动边沿。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref SPI_Clock_Phase */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> SPI_NSS;                 <span class="comment">/*!&lt; 指定 NSS 信号是否由</span></span><br><span class="line"><span class="comment">  硬件（NSS 引脚）或使用 SSI 位的软件。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref SPI_Slave_Select_management */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">uint16_t</span> SPI_BaudRatePrescaler;   <span class="comment">/*!&lt; 指定波特率预分频器值，该值将为</span></span><br><span class="line"><span class="comment">  用于配置发送和接收 SCK 时钟。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref SPI_BaudRate_Prescaler。</span></span><br><span class="line"><span class="comment">  @note 通信时钟派生自主机时钟。从时钟无需设置。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> SPI_FirstBit;            <span class="comment">/*!&lt; 指定数据传输是从 MSB 位还是 LSB 位开始。</span></span><br><span class="line"><span class="comment">  此参数的值可以是 @ref SPI_MSB_LSB_transmission */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> SPI_CRCPolynomial;       <span class="comment">/*!&lt; 指定用于 CRC 计算的多项式。 */</span></span><br><span class="line">&#125;SPI_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>只用看这些介绍即可了，下面就开始进行配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SPI_InitTypeDef SPI_InitStruct = &#123;<span class="number">0</span>&#125;;RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;   <span class="comment">// 波特率分频128</span></span><br><span class="line">SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;      <span class="comment">// cpha = 0</span></span><br><span class="line">SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;        <span class="comment">// cpol = 0</span></span><br><span class="line">SPI_InitStruct.SPI_CRCPolynomial = <span class="number">7</span>;          <span class="comment">// 默认为7</span></span><br><span class="line">SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b; <span class="comment">// 数据长度</span></span><br><span class="line">SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex;      <span class="comment">// spi两根线全双工模式</span></span><br><span class="line">SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;    <span class="comment">// 高位先行</span></span><br><span class="line">SPI_InitStruct.SPI_Mode = SPI_Mode_Master;     <span class="comment">// 作为主机</span></span><br><span class="line">SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;         <span class="comment">// 软件控制SS</span></span><br><span class="line">SPI_Init(SPI1, &amp;SPI_InitStruct);</span><br></pre></td></tr></table></figure>

<p>这样就配置完成了，接下来就使能SPI：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SPI_Cmd(SPI1, ENABLE);</span><br></pre></td></tr></table></figure>

<p>别忘记给SCK一个默认值就可以了，这里选择的是方式0，所以默认的是低电平。</p>
<h3 id="2-3-发送数据"><a href="#2-3-发送数据" class="headerlink" title="2.3 发送数据"></a>2.3 发送数据</h3><p>发送也是比较简单，就是判断发送缓冲区中的是否为空，如果为空发送数据，判断接收寄存器是否为空，如果为空接收接收寄存器中的值，这样依次执行即可，所以代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">SPI_ReadWrite</span><span class="params">(<span class="type">uint8_t</span> date)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);      <span class="comment">// 判断输入缓冲区是否为空</span></span><br><span class="line">    SPI_I2S_SendData(SPI1, date);      <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);       <span class="comment">// 判断接收缓冲区是否为空</span></span><br><span class="line">    <span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);   <span class="comment">// 接收数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果接收缓冲区中有数据，那<code>TXE</code>中的值为RESET也就是0，当为空了才置为1，同理接收寄存器也是一样得到，如果接收寄存器中有数据就为1，没有数据就为0。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SPI协议还是比IIC协议简单，但是就是SPI需要的线比IIC的多，对于SPI来说也是需要多去练习才可以学会使用，这里只是讲一下理论，如果需要使用SPI和其它设备进行通讯的话等后面我搞一个专题专门来讲一些驱动的开发。</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础</title>
    <url>/2025/01/16/96d0a083572a/</url>
    <content><![CDATA[<h1 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>和所有编程语言一样，要认识一个语言的结构得从”hello,world”开始，我们使用C语言来输出”hello,world”吧。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们初识C语言了，下面是分析。</p>
<p>**分析：**第一行是调用头文件，<code>#include</code>是C语言调用标准头文件的标准方法。<code>stdio.h</code>是标准库，调用了这个库我们才可以使用<code>printf()</code>函数</p>
<p>第二行是主函数，在C语言中可以有好多个函数，当时只能有一个<code>main</code>函数，<code>main</code>函数是程序的入口。<code>main</code>前面的是返回值类型，在好多大学中，教C语言的老师喜欢把前面的类型省略，这个叫缺省（xing），但在C语言标准里，前面的<code>int</code>是不可以去掉的。</p>
<p>第三行是函数内执行的语句，这个是一个输出函数<code>printf()</code>，它的作用是将括号里的数据输出到显示屏中，给用户查看。(具体看第一章)</p>
<p>第四行是返回值。（具体内容在函数那一章再细讲）</p>
<p>**细节：**C语言对语法要求不是那么的高，不像python一样需要严格遵循缩进，C语言需要在函数内执行的语句只需要在 <code>&#123;&#125;</code> 中即可，一行语句执行完加 <code>;</code> 即可。</p>
<p>要执行C语言的程序必须得进行编译，编译完之后才能运行，简单解释一下为什么要这么做：</p>
<p>计算机它能认识0和1这种低级语言，而我们写代码是用C语言这种高级语言来写的，但计算机不认识，必须需要一个编译器来将高级语言转换为低级语言，这样计算机就可以执行。</p>
<p>C语言编译出来的后缀为： <code>.obj</code> </p>
<p>可运行的程序的后缀为： <code>.exe</code></p>
<p><strong>这只是一个笔记，笔记主要是将重要的内容记下来，所以好多不重要的内容或者是一看就会的内容我就省略了</strong></p>
<h2 id="一、输出函数"><a href="#一、输出函数" class="headerlink" title="一、输出函数"></a>一、输出函数</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>在C语言中是没有自带的输出函数的，而是必须通过调用标准库文件才能使用输出语句，先对输入输出函数进行了解，会使你对C语言有更好的兴趣。</p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf();"></a><code>printf();</code></h3><ul>
<li>头文件：<code>stdio.h</code></li>
</ul>
<ul>
<li><p><code>printf</code>函数的功能：</p>
<p><strong>格式化输出函数</strong>，用于向标准输出设备<strong>按规定格式</strong>输出信息。 </p>
</li>
<li><p>printf函数的调用格式：</p>
<p><code>printf(&quot;格式控制字符串&quot;,输出项清单);</code></p>
<p>格式控制字符串：用于指定输出格式；由格式字符串和非格式字符串两种组成。格式字符串是以%开头的字符串。</p>
<p>输出项清单：</p>
<ul>
<li>输出项可以是常量、变量或表达式</li>
<li>要求格式字符串和各输出项在数量和类型上应该一一对应</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> m=<span class="number">123</span>,n=<span class="number">12345</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;m=%5d,n= %3d\n&quot;</span>,m,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; 变量;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>对于整形数而言，当格式控制字符规定的长度比数据本身长度还大时，则左侧补空格；若个数控制字符规定的长度比数据本身长度小时，则数据按照其本身长度进行输出。</p>
<ul>
<li><p>格式化字符串  </p>
<table>
<thead>
<tr>
<th>表示方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>以十进制形式带符号整数（正数不输出符号）</td>
</tr>
<tr>
<td>%o</td>
<td>以八进制形式输出无符号整数（默认不输出前缀0，%#o输出前缀0）</td>
</tr>
<tr>
<td>%x</td>
<td>以十六进制形式输出无符号整数（默认不输出前缀0x，%#x输出前缀0x）</td>
</tr>
<tr>
<td>%u</td>
<td>以十进制形式输出无符号整数</td>
</tr>
<tr>
<td>%f</td>
<td>以小数形式输出单、双精度实数，默认保留6位小数<br>双精度型可用%lf或%le</td>
</tr>
<tr>
<td>%e</td>
<td>以指数形式输出单、双精度实数。<strong>格式是m.ddddddexxx</strong>，默认小数精度为6，指数精度为3，不足补零（明白即可）</td>
</tr>
<tr>
<td>%g</td>
<td>以%f或%e中较短的输出单、双精度实数</td>
</tr>
<tr>
<td>%c</td>
<td>输出单个字符</td>
</tr>
<tr>
<td>%s</td>
<td>输出字符串，直到遇到\0，若<strong>字符串长度超过指定的精度则自动突破，不截断</strong></td>
</tr>
<tr>
<td>%p</td>
<td>输出变量的内存地址</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="putchar"><a href="#putchar" class="headerlink" title="putchar();"></a><code>putchar();</code></h3><h4 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h4><p>主要是用于输出字符的函数</p>
<h4 id="2-格式"><a href="#2-格式" class="headerlink" title="2.格式"></a>2.格式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> x = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//一定是字符型变量</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&quot;%c&quot;</span>, x);<span class="comment">//格式化字符串一定要%c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、输入函数"><a href="#二、输入函数" class="headerlink" title="二、输入函数"></a>二、输入函数</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf();"></a><code>scanf();</code></h3><h4 id="1-调用格式"><a href="#1-调用格式" class="headerlink" title="1.调用格式"></a>1.调用格式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//调用头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须要加取值符 <code>&amp;</code> </p>
<h4 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h4><p>将用户输入的值赋值给取值符后的变量</p>
<h3 id="getchar"><a href="#getchar" class="headerlink" title="getchar();"></a><code>getchar();</code></h3><h4 id="1-用法-1"><a href="#1-用法-1" class="headerlink" title="1.用法"></a>1.用法</h4><p>输入字符</p>
<h4 id="2-格式-1"><a href="#2-格式-1" class="headerlink" title="2.格式"></a>2.格式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    getchar(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h2><p>在C语言中有局部变量和全局变量</p>
<h3 id="1-变量的类型"><a href="#1-变量的类型" class="headerlink" title="1.变量的类型"></a>1.变量的类型</h3><h5 id="1-整型变量"><a href="#1-整型变量" class="headerlink" title="(1)整型变量"></a>(1)整型变量</h5><table>
<thead>
<tr>
<th>类型</th>
<th>储存大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td>2-4个字节</td>
<td>整型</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2字节</td>
<td>短整型</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8字节</td>
<td>长整型</td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td>2字节</td>
<td>无符号短整型</td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td>2-4字节</td>
<td>无符号整型</td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td>8字节</td>
<td>无符号长整型</td>
</tr>
</tbody></table>
<h5 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="(2)浮点型"></a>(2)浮点型</h5><table>
<thead>
<tr>
<th>类型</th>
<th>储存大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>long double</td>
<td>16字节</td>
<td>长双</td>
</tr>
</tbody></table>
<h5 id="3-字符型"><a href="#3-字符型" class="headerlink" title="(3)字符型"></a>(3)字符型</h5><table>
<thead>
<tr>
<th>类型</th>
<th>储存大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1字节</td>
<td>字符型</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1字节</td>
<td>无符号字符型</td>
</tr>
</tbody></table>
<p>说明：字符型也可以存放数字类型</p>
<h3 id="2-变量的定义"><a href="#2-变量的定义" class="headerlink" title="2.变量的定义"></a>2.变量的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">类型名 变量名 = 赋的值;</span><br><span class="line">类型名 变量名;</span><br></pre></td></tr></table></figure>

<p>两个都可以定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)变量名不能是保留字</span><br><span class="line"><span class="number">2</span>)变量名不能由数字开头</span><br><span class="line"><span class="number">3</span>)变量名只能由下划线，数字，单词组成</span><br></pre></td></tr></table></figure>



<p>注：每次定义后储存的变量一定是同种类型，负责会报错，C语言并没有字符串这个类型，如果要定义字符串需要定义字符型数组</p>
<h3 id="3-变量的转换"><a href="#3-变量的转换" class="headerlink" title="3.变量的转换"></a>3.变量的转换</h3><p>例子1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> num1 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">char</span> num2 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> num3 = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个样子是可以转的，因为 <code>char</code> 类型是1个字节，而 <code>int</code> 为4个字节是可以装的</p>
<p>例子2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">5</span>,a;</span><br><span class="line">    </span><br><span class="line">    a=<span class="number">6</span>;</span><br><span class="line">    f=a/i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,f); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果存储计算后的结果为整型，则会抛弃小数点后的数。</p>
<p>如果为浮点型，则会输出小数点后的数</p>
<h3 id="4-变量的强制转换"><a href="#4-变量的强制转换" class="headerlink" title="4.变量的强制转换"></a>4.变量的强制转换</h3><p>有些时候无法通过赋值来进行类型转换</p>
<p>所以这个时候就需要使用强制转换</p>
<h4 id="1-语法"><a href="#1-语法" class="headerlink" title="(1)语法"></a>(1)语法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(数据类型) 变量；</span><br></pre></td></tr></table></figure>

<h3 id="5-全局变量和局部变量"><a href="#5-全局变量和局部变量" class="headerlink" title="5.全局变量和局部变量"></a>5.全局变量和局部变量</h3><h4 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="(1)全局变量"></a>(1)全局变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局变量是定义在函数体外的，在函数体中没办法修改全局变量</p>
<h4 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="(2)局部变量"></a>(2)局部变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;<span class="comment">//局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、常量"><a href="#四、常量" class="headerlink" title="四、常量"></a>四、常量</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><h4 id="1-define定义"><a href="#1-define定义" class="headerlink" title="(1)define定义"></a>(1)define定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 变量名 值</span></span><br></pre></td></tr></table></figure>

<h4 id="2-const关键字"><a href="#2-const关键字" class="headerlink" title="(2)const关键字"></a>(2)<code>const</code>关键字</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> 数据类型 变量名 = 值;</span><br></pre></td></tr></table></figure>

<p>重点在存储类中</p>
<h2 id="五、存储类"><a href="#五、存储类" class="headerlink" title="五、存储类"></a>五、存储类</h2><h3 id="1-auto"><a href="#1-auto" class="headerlink" title="1.auto"></a>1.<code>auto</code></h3><p>默认类，就是用完就释放</p>
<p>可写可不写</p>
<h3 id="2-register"><a href="#2-register" class="headerlink" title="2.register"></a>2.<code>register</code></h3><p>感觉没什么用</p>
<p>官方解释说是可以提高运算速度，但现在的CPU运算速度都很快，所以没什么用</p>
<h3 id="3-static"><a href="#3-static" class="headerlink" title="3.static"></a>3.<code>static</code></h3><p>和 <code>auto</code> 是反过来的，使用完它并不会释放</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    count();</span><br><span class="line">    count();</span><br><span class="line">    count();</span><br><span class="line">    count();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-const"><a href="#4-const" class="headerlink" title="4.const"></a>4.<code>const</code><a name="con_type"></a></h3><p>const 是将变量中的值固定，使得变量无法被修改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/const%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E4%BF%AE%E6%94%B9%E5%80%BC.png"></p>
<p>但是在vs编辑器中是可以通过指针来修改被const修改的值的</p>
<p>如下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/vs2019%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E6%9D%A5%E4%BF%AE%E6%94%B9%E8%A2%ABconst%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%80%BC.png"></p>
<p>运行结果</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="运行结果"></p>
<p>在dev-c++中就无法使用这个办法进行修改</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<h2 id="六、C语言编程结构"><a href="#六、C语言编程结构" class="headerlink" title="六、C语言编程结构"></a>六、C语言编程结构</h2><p>在所有编程语言中有着三种结构：顺序结构，选择结构，循环结构，循序结构</p>
<h3 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1.顺序结构"></a>1.顺序结构</h3><p>顺序结构是编程语言中最基础的一种结构，计算机不像人的思维，它得到代码后它没有办法自己行进跳转(有选择和分支除外)，它只能一条一条的执行，一条一条执行的情况就是顺序结构，如下代码</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81.png"></p>
<p>它的执行情况如下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6这样执行的。</p>
<p>这种执行是非常简单也很基础，但没有办法做一些逻辑很强的程序，所以我们引入了选择结构。</p>
<h3 id="2-选择结构"><a href="#2-选择结构" class="headerlink" title="2.选择结构"></a>2.选择结构</h3><p>在介绍选择结构前先介绍逻辑判断语句。</p>
<h4 id="2-1-逻辑判断"><a href="#2-1-逻辑判断" class="headerlink" title="2.1 逻辑判断"></a>2.1 逻辑判断</h4><p>在C语言中0表示假，1表示真</p>
<table>
<thead>
<tr>
<th>关系符</th>
<th>a1</th>
<th>a2</th>
<th>结果(a1)  (a2)</th>
</tr>
</thead>
<tbody><tr>
<td>||  逻辑或 or</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>||</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>||</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>&amp;&amp;   逻辑与  and</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>然后还有一个逻辑是 <code>!</code> 逻辑非</p>
<table>
<thead>
<tr>
<th>a1</th>
<th>a1!</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>补充</strong>：在c语言中还有一个对于二进制的逻辑表达式</p>
<p><code>|</code> ：二进制或</p>
<p><code>&amp;</code> ：二进制与</p>
<p><code>^</code> ：二进制异或</p>
<p><code>~</code>：二进制非</p>
<h4 id="2-2-逻辑判断"><a href="#2-2-逻辑判断" class="headerlink" title="2.2 逻辑判断"></a>2.2 逻辑判断</h4><p>两个数之间判断大小，如果成立则值等于1，如果不成立则等于0。</p>
<p>但在C语言中，只能两个数之间相比，不能多个</p>
<p>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a &gt; b;</span><br></pre></td></tr></table></figure>

<p>是可以的，但下面的是绝对不可以</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a &gt; b &gt; c;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-1-三元运算符"><a href="#2-3-1-三元运算符" class="headerlink" title="2.3.1 三元运算符"></a>2.3.1 三元运算符</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> max = (a&gt;b)?a:b;</span><br></pre></td></tr></table></figure>

<p>如果a&gt;b成立，则结果为a，否则返回b</p>
<h4 id="2-3-判断语句"><a href="#2-3-判断语句" class="headerlink" title="2.3 判断语句"></a>2.3 判断语句</h4><h5 id="2-3-1-if语句"><a href="#2-3-1-if语句" class="headerlink" title="2.3.1 if语句"></a>2.3.1 if语句</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">    <span class="comment">//成立后执行花括号里的语句</span></span><br><span class="line">    执行<span class="number">1</span>;</span><br><span class="line">    执行<span class="number">2</span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-else语句"><a href="#2-3-2-else语句" class="headerlink" title="2.3.2 else语句"></a>2.3.2 else语句</h5><p>else语句是可以没有判断条件的，但必须有执行语句</p>
<h5 id="2-3-3-else-if"><a href="#2-3-3-else-if" class="headerlink" title="2.3.3 else if"></a>2.3.3 else if</h5><p>用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">    <span class="comment">//成立后执行花括号里的语句</span></span><br><span class="line">    执行<span class="number">1</span>;</span><br><span class="line">    执行<span class="number">2</span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (判断条件)&#123;</span><br><span class="line">    <span class="comment">//成立后执行花括号里的语句</span></span><br><span class="line">    执行<span class="number">1</span>;</span><br><span class="line">    执行<span class="number">2</span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-4-注意"><a href="#2-3-4-注意" class="headerlink" title="2.3.4 注意"></a>2.3.4 注意</h5><p>在if语句里可以有也可以没有else、else if语句，但必须要有if语句</p>
<h5 id="2-3-5-switch"><a href="#2-3-5-switch" class="headerlink" title="2.3.5 switch"></a>2.3.5 switch</h5><p>switch是单个判断的语句</p>
<p>语法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:语句<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>:语句<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">3</span>:语句<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">default</span> : 语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这个语句执行会一直</p>
<p>例如</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/switch%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81.png"></p>
<p>然后输出的结果如下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/switch%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>它第一个条件判断成功了，但它却继续执行下面的输出代码。</p>
<p>所以我们会在后面添加一个 <code>break</code> 使它判断成功后执行玩就结束。</p>
<p>如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A0%E4%BA%86break%E7%9A%84switch%E8%AF%AD%E5%8F%A5.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png"></p>
<h5 id="2-3-6-switch判断范围问题"><a href="#2-3-6-switch判断范围问题" class="headerlink" title="2.3.6 switch判断范围问题"></a>2.3.6 switch判断范围问题</h5><p>在C语言中，一些时候可以用if-else来判断范围问题，有些时候也可以使用switch来判断范围问题。</p>
<p>使用switch的思路是将个个范围的数化为一个特定的数，然后使用switch语句进行判断。</p>
<p>例如：我们需要计算每个销售数段获得的提成的题目</p>
<p>我们使用if-else语句的写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你总共销售额(单位:万):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">100</span> &lt; a &amp;&amp; a &lt;=<span class="number">120</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.02</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">120</span> &lt; a &amp;&amp; a &lt;= <span class="number">140</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.05</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">140</span> &lt; a &amp;&amp; a &lt;= <span class="number">190</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.08</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">190</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有提成&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if-else的写法是非常的简单，但是，如果使用switch来改写这个if-else就有点困难，所以我们要有将范围变成具体的数的思路，然后通过数来进行判断。</p>
<p>switch改写的第一种方法：</p>
<p>我们知道，在C语言中进行的是逻辑判断，通过逻辑判断的出来的只能是或则是，所以我们可以在外部对输入的数进行逻辑判断，然后再乘以具体的1，2，3，因为如果成立则为1，不成立则为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, max;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    max = ((a &gt; <span class="number">100</span>)&amp;&amp;(a&lt;=<span class="number">120</span>)) + <span class="number">2</span>*((a&gt;<span class="number">120</span>)&amp;&amp;(a&lt;=<span class="number">140</span>)) + <span class="number">3</span>*((a&gt;<span class="number">140</span>)&amp;&amp;(a&lt;=<span class="number">190</span>)) + <span class="number">4</span>*(a&gt;<span class="number">190</span>);</span><br><span class="line">    <span class="keyword">switch</span>(max)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.02</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.05</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.08</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有提成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-循环结构"><a href="#2-4-循环结构" class="headerlink" title="2.4 循环结构"></a>2.4 循环结构</h4><p>循环结构可以让你完成一件重复的事情而不写多条代码</p>
<p>例如，我们要输出100次“hello，world”，完成这件事需要写100次printf函数和100次“hello，world”，这样子是很麻烦的，但如果有循环结构，那我们就可以很轻松的完成这个程序了。</p>
<h5 id="2-4-1-for循环"><a href="#2-4-1-for循环" class="headerlink" title="2.4.1 for循环"></a>2.4.1 for循环</h5><p>for循环是编程语言中最简单的循环了，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化值; 循环条件; 值的操作)&#123;</span><br><span class="line">    循环体<span class="number">1</span>;</span><br><span class="line">    循环体<span class="number">2</span>;</span><br><span class="line">    循环体<span class="number">3</span>;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入for循环先初始化值，然后判断循环条件，满足条件后运行循环体中的值，运行完之后执行值的操作。重复运行直到不满足循环条件为止。</p>
<p>注意：学过Java的可能会这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fot(<span class="type">int</span> i = <span class="number">0</span>; ;)</span><br></pre></td></tr></table></figure>

<p>虽然C99可以这样写，但是在C语言中并不能这样写</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-012.png"></p>
<p>这个标准只能在C++文件中这么使用</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-013.png"></p>
<h5 id="2-4-2-while循环"><a href="#2-4-2-while循环" class="headerlink" title="2.4.2 while循环"></a>2.4.2 while循环</h5><p>while循环相对于for循环要简单一点，因为只有一个判断条件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (判断条件)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入循环然后判断是否满足判断条件，如果满足则加入循环体内。</p>
<h5 id="2-4-3-do-while循环"><a href="#2-4-3-do-while循环" class="headerlink" title="2.4.3 do while循环"></a>2.4.3 do while循环</h5><p>do while循环增加了一个do语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;执行语句&#125;</span><br><span class="line"><span class="keyword">while</span>(判断条件);</span><br></pre></td></tr></table></figure>

<p>先执行do语句内，然后判断是否满足条件，如果满足则继续执行do中的语句。</p>
<p>如果不满足则跳出。</p>
<p>相比于while循环，do while是可以执行一次的。</p>
<h5 id="2-4-4-嵌套循环"><a href="#2-4-4-嵌套循环" class="headerlink" title="2.4.4 嵌套循环"></a>2.4.4 嵌套循环</h5><p>简单来说就是循环里套循环，这里借用菜鸟教程的流程图</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%8F%9C%E9%B8%9F%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h5 id="2-4-5-break和continue"><a href="#2-4-5-break和continue" class="headerlink" title="2.4.5 break和continue"></a>2.4.5 break和continue</h5><h6 id="break"><a href="#break" class="headerlink" title="break"></a>break</h6><p>break是直接跳出当前循环体</p>
<h6 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h6><p>continue是跳过一次</p>
<h2 id="七、数组"><a href="#七、数组" class="headerlink" title="七、数组"></a>七、数组</h2><h3 id="1-一维数组的创建和初始化"><a href="#1-一维数组的创建和初始化" class="headerlink" title="1.一维数组的创建和初始化"></a>1.一维数组的创建和初始化</h3><h4 id="1-1-数组的创建"><a href="#1-1-数组的创建" class="headerlink" title="1.1 数组的创建"></a>1.1 数组的创建</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态创建</span></span><br><span class="line">类型 变量名[数组的长度(必须是常量)];</span><br><span class="line"><span class="comment">//静态创建</span></span><br><span class="line">类型 变量名[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//不完全初始化</span></span><br><span class="line">类型 变量名[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>不完全初始化，剩下的元素默认为0</p>
<h4 id="1-2-数组的索引取值"><a href="#1-2-数组的索引取值" class="headerlink" title="1.2 数组的索引取值"></a>1.2 数组的索引取值</h4><p>下标从0开始</p>
<p>例子1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> x[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(x); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(str)/<span class="keyword">sizeof</span>(str[<span class="number">0</span>])); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-二维数组的创建和初始化"><a href="#2-二维数组的创建和初始化" class="headerlink" title="2.二维数组的创建和初始化"></a>2.二维数组的创建和初始化</h3><h4 id="2-1数组的创建"><a href="#2-1数组的创建" class="headerlink" title="2.1数组的创建"></a>2.1数组的创建</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x[][数组的长度(必须是常量)] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[数组的长度(必须是常量)][数组的长度(必须是常量)];</span><br></pre></td></tr></table></figure>

<p>二维数组必须初始化行，可以省略列</p>
<h4 id="2-2-二维数组的使用"><a href="#2-2-二维数组的使用" class="headerlink" title="2.2 二维数组的使用"></a>2.2 二维数组的使用</h4><p>一样使用索引值</p>
<h4 id="2-3-数组的地址"><a href="#2-3-数组的地址" class="headerlink" title="2.3 数组的地址"></a>2.3 数组的地址</h4><p>数组的地址一般都是第一个元素的地址值，之后的地址就是首地址加字节数</p>
<p>注意：有两种情况不是数组的首地址</p>
<p>1.sizeof(数组名) - 数组名表示整个数组，sizeof(数组名)计算的是整个数组的大小，单位是字节</p>
<p>2.&amp;数组名，数组名代表的是整个数组。&amp;数组名，取出的是整个数组的地址</p>
<h3 id="3-数组传入函数中"><a href="#3-数组传入函数中" class="headerlink" title="3.数组传入函数中"></a>3.数组传入函数中</h3><p>我们在使用数组的时候，可能会把数组放入函数中进行数据清洗，所以数组如何传入函数就需要说明一下。</p>
<h4 id="3-1-将整个函数复制到函数中使用"><a href="#3-1-将整个函数复制到函数中使用" class="headerlink" title="3.1 将整个函数复制到函数中使用"></a>3.1 将整个函数复制到函数中使用</h4><p>第一种传参的方式是将数组中的所有元素拷贝一份到函数中使用</p>
<p>写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是将数组的地址放入函数中定义的数组中，然后使用里面的元素</p>
<h4 id="3-2-将数组的地址传入函数中使用"><a href="#3-2-将数组的地址传入函数中使用" class="headerlink" title="3.2 将数组的地址传入函数中使用"></a>3.2 将数组的地址传入函数中使用</h4><p>这种方式是将数组的地址传入函数中提供，这种方式需要的内存小，推荐使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(pa + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法相对于只是把数组的地址传入到函数中使用，没有额外创建新的空间。</p>
<h4 id="3-3-数组指针来使用"><a href="#3-3-数组指针来使用" class="headerlink" title="3.3 数组指针来使用"></a>3.3 数组指针来使用</h4><p>这个需要等到C语言进阶中才会学到</p>
<h2 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h2><p>在C语言中，有一个或多个函数，我们最熟悉的main()就是一个函数。</p>
<p>函数的作用是将需要反复使用的代码包含在一起，使我们使用更方便。</p>
<h3 id="1-函数的定义"><a href="#1-函数的定义" class="headerlink" title="1.函数的定义"></a>1.函数的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_type <span class="title function_">def_name</span> <span class="params">(value1, value2,...)</span>&#123;</span><br><span class="line">    body of the function;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return_type：返回值的类型</p>
<p>def_name：函数名</p>
<p>value1：形参，如果有多个用英文逗号分开</p>
<p>body of the function：函数体，函数中执行的内容</p>
<p>value：返回值</p>
<h4 id="1-1-返回指针类型的函数"><a href="#1-1-返回指针类型的函数" class="headerlink" title="1.1 返回指针类型的函数"></a>1.1 返回指针类型的函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_type* <span class="title function_">def_name</span><span class="params">(value1, value2,...)</span>&#123;</span><br><span class="line">    body of the function;</span><br><span class="line">    <span class="keyword">return</span> value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value1：为返回的地址</p>
<h3 id="2-函数的使用"><a href="#2-函数的使用" class="headerlink" title="2.函数的使用"></a>2.函数的使用</h3><h4 id="2-1-有返回值的函数的使用"><a href="#2-1-有返回值的函数的使用" class="headerlink" title="2.1 有返回值的函数的使用"></a>2.1 有返回值的函数的使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type variable = def_name(user_value1,user_value2,...);</span><br></pre></td></tr></table></figure>

<p>type：数据类型</p>
<p>variable：变量</p>
<p>user_value1：传入的参数，如果有多个用英文逗号隔开</p>
<h4 id="2-2-无返回值的函数的使用"><a href="#2-2-无返回值的函数的使用" class="headerlink" title="2.2 无返回值的函数的使用"></a>2.2 无返回值的函数的使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def_name(user_value1,user_value2,...);</span><br></pre></td></tr></table></figure>

<p>variable：变量</p>
<p>user_value1：传入的参数，如果有多个用英文逗号隔开</p>
<h3 id="3-函数的形参和实参"><a href="#3-函数的形参和实参" class="headerlink" title="3.函数的形参和实参"></a>3.函数的形参和实参</h3><p>函数的形参可以传入变量和指针，而两种方式需要的内存是不一样的</p>
<h4 id="3-1-函数的形参传入的是变量"><a href="#3-1-函数的形参传入的是变量" class="headerlink" title="3.1 函数的形参传入的是变量"></a>3.1 函数的形参传入的是变量</h4><p>这个很容易理解，就是在调用的时候传入的是变量的形式，如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    test(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是把a和b的变量传入到函数test中，然后在test中将传入进来的a，b拷贝下来，这样的话需要更多的空间给a，b，非常的消耗空间。</p>
<h4 id="3-2-函数的形参传入的是指针"><a href="#3-2-函数的形参传入的是指针" class="headerlink" title="3.2 函数的形参传入的是指针"></a>3.2 函数的形参传入的是指针</h4><p>这个是给函数传入指针变量，如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    test(&amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是直接把地址传入到函数里，在函数里只使用传入进去的地址，这样对内存的使用比较小，推荐使用。</p>
<h3 id="4-函数的返回值"><a href="#4-函数的返回值" class="headerlink" title="4.函数的返回值"></a>4.函数的返回值</h3><p>我们在使用函数的时候，有些时候是需要返回一些特定的值的，这个时候我们就需要让函数有返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> 返回的值;</span><br></pre></td></tr></table></figure>

<p>返回的值一定要和对应的类型相同，这样是规范的写法，如果不同，只要储存的大小合适则还是能运行的。</p>
<p>返回的值也可以是指针类型的</p>
<h2 id="九、指针"><a href="#九、指针" class="headerlink" title="九、指针"></a>九、指针</h2><h3 id="1-什么是指针"><a href="#1-什么是指针" class="headerlink" title="1.什么是指针"></a>1.什么是指针</h3><p>指针是编程语言中的一个对象，是将内存的地址赋值给指针变量。</p>
<p>它的值直接指向存在电脑存储器中另一个储存单元</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指针其实是地址</span><br><span class="line">地址就是变量</span><br><span class="line">指针就是变量</span><br><span class="line">存放地址的变量</span><br></pre></td></tr></table></figure>

<ul>
<li>指针是用于存放地址的，地址是唯一表示一块地址空间的</li>
<li>指针的大小在32位平台是4个字节，在64位平台上是8个字节</li>
</ul>
<p>指针类型决定了指针进行解引用操作的时候，能够访问空间的大小</p>
<p><code>int *p</code> 能够访问4个字节</p>
<p><code>char *p</code> 能够访问1个字节</p>
<p><code>double *p</code> 能够访问8个字节</p>
<p>指针类型决定了：指针走一步走多远（指针的步长）</p>
<p><code>int *p; --&gt; 4</code></p>
<p><code>char *p; --&gt; 1 </code></p>
<p><code>double *p; --&gt; 8</code></p>
<p>总结：指针的类型决定了指针向前或向后走一步有多大（距离）</p>
<h3 id="2-指针的使用"><a href="#2-指针的使用" class="headerlink" title="2.指针的使用"></a>2.指针的使用</h3><h4 id="（1）指针的定义"><a href="#（1）指针的定义" class="headerlink" title="（1）指针的定义"></a>（1）指针的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(指针类型) *(指针名);</span><br><span class="line"><span class="comment">//变量方式</span></span><br><span class="line">(指针类型) *(指针名) = &amp;变量名;</span><br><span class="line"><span class="comment">//数组方式</span></span><br><span class="line">(指针类型) *(指针名) = 数组名;</span><br></pre></td></tr></table></figure>

<h4 id="（2）指针的赋值"><a href="#（2）指针的赋值" class="headerlink" title="（2）指针的赋值"></a>（2）指针的赋值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指针名 = &amp;变量名;</span><br></pre></td></tr></table></figure>

<h4 id="（3）指针类型"><a href="#（3）指针类型" class="headerlink" title="（3）指针类型"></a>（3）指针类型</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="type">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="type">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="type">char</span>   *ch;    <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* 访问<span class="number">4</span>个字节</span><br><span class="line"><span class="type">float</span>* 访问<span class="number">4</span>个字节</span><br><span class="line"><span class="type">char</span>* 访问<span class="number">1</span>个字节</span><br><span class="line"><span class="type">double</span>* 访问<span class="number">8</span>个字节</span><br></pre></td></tr></table></figure>

<h4 id="（4）如何使用指针"><a href="#（4）如何使用指针" class="headerlink" title="（4）如何使用指针"></a>（4）如何使用指针</h4><h3 id="3-野指针"><a href="#3-野指针" class="headerlink" title="3.野指针"></a>3.野指针</h3><p>概念：野指针就是指向的位置不可知的</p>
<h4 id="（1）导致野指针的原因"><a href="#（1）导致野指针的原因" class="headerlink" title="（1）导致野指针的原因"></a>（1）导致野指针的原因</h4><p>① 未初始化指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②指针越界访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *p = arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//当指针指向的范围超出数组arr的范围时，p就是野指针</span></span><br><span class="line">        *(p + i) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③指针指向的空间释放</p>
<h4 id="（2）如何避免野指针"><a href="#（2）如何避免野指针" class="headerlink" title="（2）如何避免野指针"></a>（2）如何避免野指针</h4><p>①指针初始化</p>
<p>②小心指针越界</p>
<p>③指针指向空间释放即用null占位</p>
<p>④指针使用之前检查有效性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// int a = 10;</span></span><br><span class="line">    <span class="comment">// int *p = &amp;a;//初始化</span></span><br><span class="line">    <span class="comment">// int *pa = NULL;//NULL - 用来初始化指针的，给指针赋值</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *pa = &amp;a;</span><br><span class="line">    *pa = <span class="number">20</span>;</span><br><span class="line">    pa = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pa != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *pa = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-指针运算"><a href="#4-指针运算" class="headerlink" title="4.指针运算"></a>4.指针运算</h3><ul>
<li>指针+-整数</li>
<li>指针-指针</li>
<li>指针的关系运算</li>
</ul>
<h4 id="指针-整数"><a href="#指针-整数" class="headerlink" title="指针+-整数"></a>指针+-整数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> *p = &amp;arr[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">        p--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针-指针"><a href="#指针-指针" class="headerlink" title="指针-指针"></a>指针-指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *start = str;</span><br><span class="line">    <span class="type">char</span> *end = str;</span><br><span class="line">    <span class="keyword">while</span> (*end != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end - start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//strlen - 求字符串长度</span></span><br><span class="line">    <span class="type">char</span> arr[] = <span class="string">&quot;bit&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = my_strlen(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针-指针可以得到这个数组的长度 - 1 </p>
<h3 id="5-指针和数组"><a href="#5-指针和数组" class="headerlink" title="5.指针和数组"></a>5.指针和数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);<span class="comment">//地址-首元素的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr);<span class="comment">//整个数组的地址</span></span><br><span class="line">    <span class="comment">//1.&amp;arr - &amp;数组名不是首元素的地址-数组名表示整个数组 - &amp;数组名 取出的是整个数组的地址</span></span><br><span class="line">    <span class="comment">//2.sizeof(arr) - sizeof(数组名) - 数组名表示的整个数组 - sizeof(数组名)计算的是整个数组的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：数组名表示的是数组首元素的地址</p>
<p><strong>注意：数组可以使用[]来修饰，但是指针使用[]来修饰</strong></p>
<h3 id="6-指针的关系运算"><a href="#6-指针的关系运算" class="headerlink" title="6.指针的关系运算"></a>6.指针的关系运算</h3><h4 id="（1）指针数组-数组指针"><a href="#（1）指针数组-数组指针" class="headerlink" title="（1）指针数组 &amp;&amp; 数组指针"></a>（1）指针数组 &amp;&amp; 数组指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指针数组 - 数组 - 存放指针的数组</span></span><br><span class="line"><span class="comment">//数组指针 - 指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b =<span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// int *pa = &amp;a;</span></span><br><span class="line">    <span class="comment">// int *pb = &amp;b;</span></span><br><span class="line">    <span class="comment">// int *pc = &amp;c;</span></span><br><span class="line">    <span class="comment">//整型数组 - 存放整型</span></span><br><span class="line">    <span class="comment">//字符数组 - 存放字符</span></span><br><span class="line">    <span class="comment">//指针数组 - 存放指针</span></span><br><span class="line">    <span class="type">int</span> *arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;<span class="comment">//指针数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-二级指针"><a href="#7-二级指针" class="headerlink" title="7.二级指针"></a>7.二级指针</h3><h4 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *pa = &amp;a;</span><br><span class="line">    <span class="type">int</span> **ppa = &amp;pa;<span class="comment">//ppa就是二级指针</span></span><br><span class="line">    <span class="comment">//int ***pppa = &amp;ppa;//pppa是三级指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）使用"><a href="#（2）使用" class="headerlink" title="（2）使用"></a>（2）使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *pa = &amp;a;</span><br><span class="line">    <span class="type">int</span> **ppa = &amp;pa;<span class="comment">//ppa就是二级指针</span></span><br><span class="line">    <span class="comment">//int ***pppa = &amp;ppa;//pppa是三级指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *ppa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, **ppa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）总结"><a href="#（3）总结" class="headerlink" title="（3）总结"></a>（3）总结</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>这句话的意思是将a的地址给p，然后*p得到的是a中的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ppa = &amp;pa;</span><br></pre></td></tr></table></figure>

<p><em>ppa存放的是pa指针中的地址，然后**ppa是</em>pa</p>
<h3 id="8-const修饰指针（一级指针）"><a href="#8-const修饰指针（一级指针）" class="headerlink" title="8.const修饰指针（一级指针）"></a>8.const修饰指针（一级指针）</h3><p>通常，我们的指针变量是可以随便使用的，但如果我们想让指针变量或者解引用的指针的内容不改变，那我们就需要使用 <code>const</code> 来修饰指针。</p>
<h4 id="8-1-const-在-左边"><a href="#8-1-const-在-左边" class="headerlink" title="8.1 const 在 * 左边"></a>8.1 const 在 * 左边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> * p;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p;</span><br></pre></td></tr></table></figure>

<p>const 在* 左边是修饰 *p的，通过这样修饰后，*p就不能再重新赋值了，*p的值是被固定了，但是指针变量p中的地址是可以重新赋值的。</p>
<h4 id="8-2-const-在-右边"><a href="#8-2-const-在-右边" class="headerlink" title="8.2 const 在 * 右边"></a>8.2 const 在 * 右边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<p>const 在* 右边是修饰 p的，通过这样修饰后，p就不能再重新赋值了，\p的值是被固定了，但是解引用*p中的值是可以重新赋值的。</p>
<h3 id="9-const修饰指针（二级指针）"><a href="#9-const修饰指针（二级指针）" class="headerlink" title="9.const修饰指针（二级指针）"></a>9.const修饰指针（二级指针）</h3><p>在二级指针中有三个位置可以加const修饰符</p>
<h4 id="9-1-在-的左边"><a href="#9-1-在-的左边" class="headerlink" title="9.1 在**的左边"></a>9.1 在**的左边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* *p;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * *p;</span><br></pre></td></tr></table></figure>

<p>const在**的左边是修饰**p的，但*p和p的值是可以改变的</p>
<h4 id="9-2-在-中间"><a href="#9-2-在-中间" class="headerlink" title="9.2 在**中间"></a>9.2 在**中间</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> *p;</span><br></pre></td></tr></table></figure>

<p>const在**的中间是修饰*p的，但**p和p的值是可以改变的</p>
<h4 id="9-3-在-的右边"><a href="#9-3-在-的右边" class="headerlink" title="9.3 在**的右边"></a>9.3 在**的右边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* *<span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<p>const在**的右边是修饰p的，但**p和*p的值是可以改变的</p>
<h4 id="9-4-通过二级指针修改被const修饰的一级指针"><a href="#9-4-通过二级指针修改被const修饰的一级指针" class="headerlink" title="9.4 通过二级指针修改被const修饰的一级指针"></a>9.4 通过二级指针修改被const修饰的一级指针</h4><p>我们回顾上面讲const修饰符中，别const修饰的变量中的值能被一级指针所修改，那如果别const修改的一级指针能否别二级指针修改呢。</p>
<p>我们来试试：</p>
<p>我们有以下的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">5</span>, n = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p = &amp;m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个语句中，const是修饰指针变量p的，所以我们无法对p变量进行修改。（如下图）</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E8%A2%ABconst%E4%BF%AE%E9%A5%B0%E7%9A%84%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88.png"></p>
<p>但是如果我们通过二级指针来间接修改呢？</p>
<p>如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">5</span>, n = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p = &amp;m;</span><br><span class="line">    <span class="type">int</span>* *pp = &amp;pm;</span><br><span class="line">    *pp = &amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>我们声明了一个二级指针，然后给这个二级指针赋值一级指针的地址，然后我们对二级指针变量重新赋n的地址值，然后输出*p里面的内容。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9C%A8vs%E9%87%8C%E9%80%9A%E8%BF%87%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9const%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E4%BB%A3%E7%A0%81.png"></p>
<p>然后运行的结果：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9C%A8vs%E9%87%8C%E9%80%9A%E8%BF%87%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9const%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>我们可以看到，我们输出*p的结果已经改变，所以可以通过二级指针来修改被const修饰的一级指针的值。但是，这个方法只能在vs中才能运行成功，在dev-C++中就不能成功。如下图：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9C%A8dev%E9%87%8C%E9%80%9A%E8%BF%87%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9const%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E4%BB%A3%E7%A0%81.png"></p>
<p>可以看到这个直接就报错了，无法通过编译。</p>
<h2 id="十、结构体"><a href="#十、结构体" class="headerlink" title="十、结构体"></a>十、结构体</h2><p>在C语言中，结构是另一种用户自定义的可用数据类型，它允许您存储不同的数据类型，结构体是属于自定义数据结构。</p>
<h3 id="1-结构体的创建"><a href="#1-结构体的创建" class="headerlink" title="1.结构体的创建"></a>1.结构体的创建</h3><h4 id="1-1-第一种方法"><a href="#1-1-第一种方法" class="headerlink" title="1.1 第一种方法"></a>1.1 第一种方法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span></span><br><span class="line">    type name;</span><br><span class="line">    type name;</span><br><span class="line">    .........</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>tag</strong> 是结构体标签</p>
<p><strong>type</strong> 数据类型</p>
<p><strong>name</strong> 类型名字</p>
<h4 id="1-2-第二种方法"><a href="#1-2-第二种方法" class="headerlink" title="1.2 第二种方法"></a>1.2 第二种方法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span></span><br><span class="line">    type name;</span><br><span class="line">    type name;</span><br><span class="line">    .........</span><br><span class="line">&#125;tags;</span><br></pre></td></tr></table></figure>

<p>结尾后的<strong>tags</strong> 是结构的变量，是全局变量，也可以多指很多结构变量。</p>
<h4 id="1-3-全局结构体和局部结构体的声明"><a href="#1-3-全局结构体和局部结构体的声明" class="headerlink" title="1.3 全局结构体和局部结构体的声明"></a>1.3 全局结构体和局部结构体的声明</h4><p>全局结构体的声明是声明在函数外，局部结构体是声明在函数内。</p>
<h3 id="2-结构体的使用"><a href="#2-结构体的使用" class="headerlink" title="2.结构体的使用"></a>2.结构体的使用</h3><h4 id="2-1-局部结构体的声明-初始化"><a href="#2-1-局部结构体的声明-初始化" class="headerlink" title="2.1 局部结构体的声明 &amp; 初始化"></a>2.1 局部结构体的声明 &amp; 初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> <span class="title">new_name</span> =</span> &#123;value1, value2, &#123;value3, value4&#125;, .....&#125;;  </span><br></pre></td></tr></table></figure>

<p><code>new_name</code> 声明的新名字</p>
<p><code>value</code> 声明的值，如果有多个值，需要使用{}括起来</p>
<p>value前面要有类型</p>
<h5 id="2-1-1-指针方法"><a href="#2-1-1-指针方法" class="headerlink" title="2.1.1 指针方法"></a>2.1.1 指针方法</h5><p>指针声明方法必须先对结构体进行声明，然后才能用指针声明</p>
<p>例一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> arr1[<span class="number">5</span>];</span><br><span class="line">        <span class="type">char</span> arr2[<span class="number">5</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span> =</span> &#123;<span class="number">1</span>, &#123;<span class="number">4</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>* <span class="title">pb</span> =</span> &amp;book;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>struct Books book &#x3D; {1, {4, 3}, {‘g’, ‘a’}}; </p>
<p>struct Books* pb &#x3D; &book; </p>
</blockquote>
<p>这个就是结构体的声明指针方法</p>
<h4 id="2-2-全局结构体全局的使用-初始化"><a href="#2-2-全局结构体全局的使用-初始化" class="headerlink" title="2.2 全局结构体全局的使用 &amp; 初始化"></a>2.2 全局结构体全局的使用 &amp; 初始化</h4><p>和局部结构体的声明和初始化一样</p>
<h3 id="3-结构体的输出"><a href="#3-结构体的输出" class="headerlink" title="3.结构体的输出"></a>3.结构体的输出</h3><h4 id="3-1-使用结构体变量的输出"><a href="#3-1-使用结构体变量的输出" class="headerlink" title="3.1 使用结构体变量的输出"></a>3.1 使用结构体变量的输出</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">结构体声明的变量 . 结构体中的值</span><br></pre></td></tr></table></figure>

<p>使用如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span>;</span></span><br><span class="line">    book.a = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, book.a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-使用指针变量的输出"><a href="#3-2-使用指针变量的输出" class="headerlink" title="3.2 使用指针变量的输出"></a>3.2 使用指针变量的输出</h4><h5 id="3-2-1-第一种方法"><a href="#3-2-1-第一种方法" class="headerlink" title="3.2.1 第一种方法"></a>3.2.1 第一种方法</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">指针变量 -&gt; 结构体中的值</span><br></pre></td></tr></table></figure>

<p>使用如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>* <span class="title">pb</span> =</span> &amp;b;</span><br><span class="line">    pb -&gt; a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, pb -&gt; a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2第二种方法"><a href="#3-2-2第二种方法" class="headerlink" title="3.2.2第二种方法"></a>3.2.2第二种方法</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(*指针变量) . 结构体中的值</span><br></pre></td></tr></table></figure>

<p>使用如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>* <span class="title">pb</span> =</span> &amp;b;</span><br><span class="line">    (*pb).a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (*pb).a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-结构体做函数的参数-结构体指针做函数的参数"><a href="#4-结构体做函数的参数-结构体指针做函数的参数" class="headerlink" title="4.结构体做函数的参数 &amp; 结构体指针做函数的参数"></a>4.结构体做函数的参数 &amp; 结构体指针做函数的参数</h3><h4 id="4-1结构体变量做参数"><a href="#4-1结构体变量做参数" class="headerlink" title="4.1结构体变量做参数"></a>4.1结构体变量做参数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Books b)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%c&quot;</span>, b.a, b.name[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span> =</span> &#123;<span class="number">5</span>, &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;&#125;;</span><br><span class="line">    Print(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2结构体指针做参数"><a href="#4-2结构体指针做参数" class="headerlink" title="4.2结构体指针做参数"></a>4.2结构体指针做参数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Books* b)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%c&quot;</span>, b-&gt;a, b-&gt;name[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span> =</span> &#123;<span class="number">5</span>, &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;&#125;;</span><br><span class="line">    Print(&amp;book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-两种定义在内存中的模式"><a href="#4-3-两种定义在内存中的模式" class="headerlink" title="4.3 两种定义在内存中的模式"></a>4.3 两种定义在内存中的模式</h4><p>4.1的方式是在函数中将变量又重新拷贝一份，占用更多的空间，而且用完就会被释放，不能修改结构体内的值；而4.2的方法是将结构体的地址放入函数里，函数操作地址，内存的占用非常的少，能直接修改函数体内的值。</p>
<h2 id="十一、debug和release方法"><a href="#十一、debug和release方法" class="headerlink" title="十一、debug和release方法"></a>十一、debug和release方法</h2><h3 id="1-debug"><a href="#1-debug" class="headerlink" title="1.debug"></a>1.debug</h3><p>debug方法是提供给程序员调试的方法。调试时会生成很多配置文件。不会做任何优化</p>
<h3 id="2-release"><a href="#2-release" class="headerlink" title="2.release"></a>2.release</h3><p>release是提供用户使用的</p>
<h2 id="十二、文件操作"><a href="#十二、文件操作" class="headerlink" title="十二、文件操作"></a>十二、文件操作</h2><p>在C语言中可以很简单的打开文件进行一些操作，这里主要是在Windows环境下使用标准输入输出库函数的对文件操作。</p>
<h3 id="1-文件打开"><a href="#1-文件打开" class="headerlink" title="1.文件打开"></a>1.文件打开</h3><p>对文件操作的基础是将文件打开，如果不打开文件就没办法对文件中的内容进行操作。</p>
<p>文件打开的方法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* <span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * __restrict__ _Filename,<span class="type">const</span> <span class="type">char</span> * __restrict__ _Mode)</span></span><br></pre></td></tr></table></figure>

<p>第一个参数是你需要打开文件的路径，这里的路径可以是绝对路径或者是相对路径。</p>
<p>第二个参数是打开文件的方式，有下面几种方式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>只读方式</td>
</tr>
<tr>
<td>w</td>
<td>写入文件，如果文件不存在会创建出一个文件，如果文件中有内容会删除里面的内容</td>
</tr>
<tr>
<td>a</td>
<td>追加模式，如果文件不存在会创建出一个文件，如果里面有数据就往后写入</td>
</tr>
<tr>
<td>r+</td>
<td>允许读写文件</td>
</tr>
<tr>
<td>w+</td>
<td>允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件</td>
</tr>
<tr>
<td>a+</td>
<td>允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody></table>
<p>例如我打开一个文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* fd = <span class="literal">NULL</span>; <span class="comment">// 创建一个FILE类型的指针</span></span><br><span class="line">fd = fopen(<span class="string">&quot;E:\\a.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码就是打开一个文件，以追加的方式进行打开的。</p>
<h3 id="2-关闭文件"><a href="#2-关闭文件" class="headerlink" title="2.关闭文件"></a>2.关闭文件</h3><p>当我们打开文件后进行操作后是需要关闭，不关闭文件会导致文件一直处于一种打开状态，所以需要关闭文件，关闭文件的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">( FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>参数是刚才打开的文件，如果关闭文件出问题，这个函数会返回<code>EOF</code>，但是基本上关闭都是会成功的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fclose(fd);</span><br></pre></td></tr></table></figure>

<h3 id="3-写入内容"><a href="#3-写入内容" class="headerlink" title="3.写入内容"></a>3.写入内容</h3><p>打开文件后可以向文件中写入内容，写入的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> c, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数是可以向文件中光标位置处写入一个字符，比如说在文件中写入一个a字符，那代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fputc(<span class="string">&#x27;a&#x27;</span>, fd);</span><br></pre></td></tr></table></figure>

<p>如果要写入字符串也是可以的，使用下面的函数就可以写入一个字符串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>比如说我要写入一个”hello”，那语法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;hello&quot;</span>, fd);</span><br></pre></td></tr></table></figure>

<h3 id="4-读取内容"><a href="#4-读取内容" class="headerlink" title="4.读取内容"></a>4.读取内容</h3><p>使用的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">( FILE * fp )</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数可以读取文件中光标后的一个字符，读取后的内容是以返回值的方式进行输出，但是输出不了中文，它返回的只能是ASCII。</p>
<p>如果想读取中文，需要使用读取字符串的函数，函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *buf, <span class="type">int</span> n, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数是可以读取字符串，返回的就是你读取的字符串。</p>
<p>第一个参数是字符串存放的位置，需要定义一个数组进行接收。</p>
<p>第二个参数是读取字符串的个数。</p>
<p>第三个参数是文件指针。</p>
<p>比如说我读取一个文件中的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE* fd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    fd = fopen(<span class="string">&quot;E:\\a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">//以r的方式打开文件</span></span><br><span class="line">    fgets(buf, <span class="number">20</span>, fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fd);</span><br><span class="line">    fd = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-设置光标位置"><a href="#5-设置光标位置" class="headerlink" title="5.设置光标位置"></a>5.设置光标位置</h3><p>上面一直提到光标，在文件中光标的位置是非常重要的，就如同我们向一个<code>txt</code>文件中写入内容是需要设置光标位置的，光标的位置是你输入字符进入的位置。</p>
<p>设置光标位置的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE * fp, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>其中最后的一个参数是需要使用宏定义的，宏定义如下：</p>
<p><code>SEEK_SET</code>：设置光标在开头位置</p>
<p><code>SEEK_CUR</code>：设置光标在指定位置</p>
<p><code>SEEK_END</code>：设置光标在最后的位置</p>
<p>最后这个设置光标在指定位置第二个参数才有效。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS系统移植</title>
    <url>/2025/01/20/7aa762eacec7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习RTOS之前最重要的就是要学会将系统移植到单片机中，这里可以直接使用cubemx生成移植好的工程，也可以下载库来进行自己移植，这里我选择下载库来自己移植，因为这样可以配合Linux开发stm32单片机程序。</p>
<h1 id="一、下载系统代码"><a href="#一、下载系统代码" class="headerlink" title="一、下载系统代码"></a>一、下载系统代码</h1><p>首先打开FreeRTOS的<a href="https://www.freertos.org/zh-cn-cmn-s">官网</a>这个是中文站点，所以速度很快，然后点击下载：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD.png"></p>
<p>在下载里面不要最新的系统，这里我需要V9.0.0就可以了，因为高版本的增加了很多物联网相关的内容，对于我们现在的系统开发不太需要，所以这里点击更多下载</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%B8%8B%E8%BD%BD%E5%90%8E%E7%BB%AD.png"></p>
<p>然后选择下面不带LTS的，LTS没有示例项目，有一些文件我们需要在示例工程中拿，然后需要转到github中去下载</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8E%BBgithub.png"></p>
<p>来到GitHub中是最新版本，我们要找老版本需要点击<code>Code</code>转去代码那里，然后找到V9.0.0的代码</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%89%BE%E5%88%B0V9.0.0.png"></p>
<p>来到了后在标签这找到V9.0.0</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/releases%E5%8C%85.png"></p>
<p>然后点击下载zip格式的文件</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%B8%8B%E8%BD%BD%E8%BF%99%E4%B8%AA%E5%8C%85.png"></p>
<p>下载完成后就可以解压，解压完成就是下面这几个软件</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%A7%A3%E5%8E%8B.png"></p>
<p>可以看到有两个文件夹，一个是<code>FreeRTOS</code>，另一个是<code>FreeRTOS-Plus</code>，这两个是有区别的，第一个是内核，是我们需要的，第二个Plus的是在内核的基础上增加了一系列扩展组件和工具，提供了更丰富的功能和更高层次的抽象，例如，包含文件系统、TCP&#x2F;IP 协议栈、USB 主机 &#x2F; 设备栈、安全功能（如加密库）、图形用户界面（GUI）库等。如果做一些高级的东西可以用这个，但我们现在只是学习，选择第一个基础的就可以了。</p>
<p>打开第一个文件夹后会有三个文件夹，我们先看<code>Source</code>文件夹，在<code>Source</code>文件夹中存放的是内核源代码和对应的头文件</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%BA%90%E6%96%87%E4%BB%B6.png"></p>
<p>在<code>Source</code>文件夹中有一个<code>portable</code>这个是内核文件，其中内核文件是分平台的，这个平台是编译器的平台，比如我们用Keil，那就在这个文件夹中找到Keil进行移植就可以了，但是这里不能直接把Keil文件夹直接拿过去用，原因在移植的时候会说</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6.png"></p>
<p>然后在<code>include</code>文件夹中存放的是对应的头文件</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%A4%B4%E6%96%87%E4%BB%B6.png"></p>
<p>回到上一层，有一个<code>Demo</code>文件夹，这个文件夹就是每个芯片所对应的示例工程，有一些文件我们需要在这个示例文件中</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.png"></p>
<p>然后我们就可以开始工程的移植了。</p>
<h1 id="二、移植工程"><a href="#二、移植工程" class="headerlink" title="二、移植工程"></a>二、移植工程</h1><p>这里需要拿之前做好的标准库工程来进行改，只需要在做好的工程来新增文件就可以了，打开工程后点击这个三个正方形设置文件</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86.png"></p>
<p>在这里面新建一个<code>freeRTOS</code>文件夹，在里面添加一下的<code>.c</code>文件，我这为了工程的干净，不增加<code>.h</code>文件了</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8A%8A%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%8E%BB.png"></p>
<p>然后点击<code>Options</code>中点击<code>C/C++</code>点击<code>Include Paths</code>中的三个点，增加一下编译文件目录</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E8%B7%AF%E5%BE%84.png"></p>
<p>需要添加的文件目录如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A0%E8%BD%BD%E5%90%8E.png"></p>
<p>然后在<code>main.c</code>中增加两个头文件，并且添加一个测试的内容，这里使用的是最小系统上的测试灯，所以需要进行一下初始化</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%BC%95%E5%85%A5%E5%A4%B4%E6%96%87%E4%BB%B6.png"></p>
<p>然后编写一下控制函数</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/LED%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0.png"></p>
<p>编写一下任务函数，记得这个任务函数的格式是<code>void TaskName(void*)</code></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/LED%E4%BB%BB%E5%8A%A1%E5%87%BD%E6%95%B0.png"></p>
<p>然后在<code>main.c</code>中创建任务并且进行任务的调度：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    NVIC_SetPriorityGrouping(NVIC_PriorityGroup_4); <span class="comment">// 设置中断优先级分组为第四组 这个是为了后面的定时器需要增加的</span></span><br><span class="line">    Init_Led();</span><br><span class="line">    xTaskCreate(LED_Test, <span class="string">&quot;LED_Test&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>); <span class="comment">// 创建任务</span></span><br><span class="line">    vTaskStartScheduler();                          <span class="comment">// 调度任务</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9.png"></p>
<p>作为上面的操作后还不能进行测试，如果这样测试的话会导致在<code>vTaskStartScheduler()</code>函数的位置卡死，因为还没有移植成功，需要先在<code>freeRTOSConfig.h</code>文件中的最后面添加这三个宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xPortPendSVHandler PendSV_Handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xPortSysTickHandler SysTick_Handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vPortSVCHandler SVC_Handler</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9C%A8freertosConfig%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%AF%AD%E5%8F%A5.png"></p>
<p>然后在<code>stm32f10x_it.c</code>中需要注释一下这三个回调函数，因为这三个回调函数在系统中是进行了一下实现的，如果还没有，那会重复定义：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/it%E4%B8%AD%E6%B3%A8%E9%87%8A1.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/it%E4%B8%AD%E6%B3%A8%E9%87%8A2.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/it%E4%B8%AD%E6%B3%A8%E9%87%8A3.png"></p>
<p>这样就可以编译并且运行测试了，可以看到LED灯在闪烁。</p>
<h1 id="三、完整代码"><a href="#三、完整代码" class="headerlink" title="三、完整代码"></a>三、完整代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_Led</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Cmd</span><span class="params">(<span class="type">uint8_t</span> bit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bit == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_ResetBits(GPIOA, GPIO_Pin_5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bit == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_SetBits(GPIOA, GPIO_Pin_5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Test</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED_Cmd(<span class="number">1</span>);</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);</span><br><span class="line">        LED_Cmd(<span class="number">0</span>);</span><br><span class="line">        vTaskDelay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    NVIC_SetPriorityGrouping(NVIC_PriorityGroup_4); <span class="comment">// 设置中断优先级分组为第四组</span></span><br><span class="line">    Init_Led();</span><br><span class="line">    xTaskCreate(LED_Test, <span class="string">&quot;LED_Test&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>); <span class="comment">// 创建任务</span></span><br><span class="line">    vTaskStartScheduler();                          <span class="comment">// 调度任务</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、Linux下的MarkDown文件"><a href="#四、Linux下的MarkDown文件" class="headerlink" title="四、Linux下的MarkDown文件"></a>四、Linux下的MarkDown文件</h1><p>这里上面的工程一模一样，只不过就是需要在那个编译器工程那选择<code>GCC</code>的文件，因为使用的是<code>arm-gcc</code>进行编译，所以这里要选择的是<code>GCC</code>的文件夹</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/GCC.png"></p>
<p>然后其它的内容不改变，然后开始编辑makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET=test	<span class="comment"># 这里是项目名，改就可以</span></span><br><span class="line">CC=arm-none-eabi-gcc</span><br><span class="line">OBJCOPY=arm-none-eabi-objcopy</span><br><span class="line">RM=rm -f</span><br><span class="line">CORE=3</span><br><span class="line">CPUFLAGS=-mthumb -mcpu=cortex-m<span class="variable">$(CORE)</span></span><br><span class="line">INCFLAGS=-I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/lib/CMSIS -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/lib/ -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/freeRTOS/<span class="keyword">include</span> -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/freeRTOS/portable/GCC -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/freeRTOS/portable/GCC/MemMang FWlib/inc -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/freeRTOS/portable/GCC/ARM_CM3 -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/user</span><br><span class="line">LDFLAGS = -T stm32_flash.ld -Wl,-cref,-u,Reset_Handler -Wl,-Map=<span class="variable">$(TARGET)</span>.map -Wl,--gc-sections -Wl,--defsym=malloc_getpagesize_P=0x80 -Wl,--start-group -lc -lm -Wl,--end-group</span><br><span class="line">CFLAGS=<span class="variable">$(INCFLAGS)</span> -D STM32F10X_HD -D USE_STDPERIPH_DRIVER -Wall -g</span><br><span class="line">START_SRC=<span class="variable">$(<span class="built_in">shell</span> find ./ -name &#x27;startup_stm32f10x_hd.s&#x27;)</span></span><br><span class="line">START_OBJ=$(START_SRC:%.s=%.o)</span><br><span class="line">C_SRC=<span class="variable">$(<span class="built_in">shell</span> find ./ -name &#x27;*.c&#x27;)</span></span><br><span class="line">C_OBJ=$(C_SRC:%.c=%.o)</span><br><span class="line">INTERRFACE_CFG=/usr/local/share/openocd/scripts/interface/stlink-v2.cfg      <span class="comment"># 这里就是下载器的配置文件，可以在前面提到的文件夹中找到对应下载器的配置文件</span></span><br><span class="line">TARGET_CFG=/usr/local/share/openocd/scripts/target/stm32f1x.cfg </span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(START_OBJ)</span> <span class="variable">$(C_SRC)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$^</span> <span class="variable">$(CPUFLAGS)</span> <span class="variable">$(LDFLAGS)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$(TARGET)</span>.elf</span><br><span class="line">	<span class="variable">$(OBJCOPY)</span> <span class="variable">$(TARGET)</span>.elf <span class="variable">$(TARGET)</span>.bin</span><br><span class="line">	<span class="variable">$(OBJCOPY)</span> <span class="variable">$(TARGET)</span>.elf -Oihex <span class="variable">$(TARGET)</span>.hex</span><br><span class="line"><span class="variable">$(START_OBJ)</span>:<span class="variable">$(START_SRC)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$^</span> <span class="variable">$(CPUFLAGS)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(C_OBJ)</span>:%.o:%.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$^</span> <span class="variable">$(CPUFLAGS)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(<span class="built_in">shell</span> find ./ -name &#x27;*.o&#x27;)</span> <span class="variable">$(TARGET)</span>.*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个是一键下载，如果不是stlink下载器可以改对应的变量</span></span><br><span class="line"><span class="section">download:</span></span><br><span class="line">	openocd -f <span class="variable">$(INTERRFACE_CFG)</span> -f <span class="variable">$(TARGET_CFG)</span> -c init -c halt -c <span class="string">&quot;flash write_image erase <span class="variable">$(PWD)</span>/<span class="variable">$(TARGET)</span>.bin&quot;</span> -c reset -c shutdown</span><br></pre></td></tr></table></figure>
<p>其实最主要的是增加编译的头文件，然后剩下的一样。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是一小步，但是系统学习和高级功能实现的一大步，好好搞一下就ok了。</p>
]]></content>
      <categories>
        <category>freeRTOS</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言进阶</title>
    <url>/2025/01/16/9db92f684b04/</url>
    <content><![CDATA[<h1 id="C语言进阶"><a href="#C语言进阶" class="headerlink" title="C语言进阶"></a>C语言进阶</h1><h2 id="一、数据储存"><a href="#一、数据储存" class="headerlink" title="一、数据储存"></a>一、数据储存</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h3><p>C语言中，栈区是用于存放局部变量的。</p>
<p>栈区的使用习惯是：先使用高地址，再使用低地址</p>
<h3 id="2-release和debug的区别"><a href="#2-release和debug的区别" class="headerlink" title="2.release和debug的区别"></a>2.release和debug的区别</h3><p>在基础章节里说了，它们面向的对象是不一样的，但除了面向的对象不一样外还有一些地方也是不一样的，例如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道这样的写法会导致指针越界，但这串代码在debug和release中的运行结果是不一样的。</p>
<p>在debug中的运行结果如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/debug%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>可以看到这个是一个死循环了。</p>
<p>而在release中：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/release%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>他运行了几次就结束了。</p>
<p>为什么会出现上面的情况呢？这就需要介绍debug和release在内存中的储存了。</p>
<h4 id="2-1-debug的内存结构"><a href="#2-1-debug的内存结构" class="headerlink" title="2.1 debug的内存结构"></a>2.1 debug的内存结构</h4><p>我们知道，在栈中先进后用，加入我们还是使用上面的代码，我们输出一下 <code>i</code> 和 <code>arr</code>的地址。</p>
<p>代码如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8B%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%A3%E7%A0%81.png"></p>
<p>通过这一行代码我们可以输出在debug方式中局部变量的地址值</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/debug%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%80%BC.png"></p>
<p>我们可以看到，在debug方式运行后，<code>arr</code>变量的地址比<code>i</code>的地址低，在内存结构中，图是这样画的：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/debug%E5%86%85%E5%AD%98%E5%9B%BE.png"></p>
<p><code>arr</code>只有个数，所以索引的值为0-9</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/debug%E5%86%85%E5%AD%98%E5%9B%BE2.png"></p>
<p>从这个位置开始走，给它赋值为0，走着走着，到<code>arr</code>最后一个元素时，<code>i</code>的大小还没到12，<code>arr[i]</code>还要继续赋值，一直走到<code>i</code>地址的位置，然后将<code>i</code>又重新赋值为0</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/debug%E5%86%85%E5%AD%98%E5%9B%BE3.png"></p>
<p>一直重复该过程，就导致了死循环。</p>
<h4 id="2-2-release的内存结构"><a href="#2-2-release的内存结构" class="headerlink" title="2.2 release的内存结构"></a>2.2 release的内存结构</h4><p>我们还是通过上面的方法来进行分析，代码如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8B%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%A3%E7%A0%81.png"></p>
<p>然后运行的结果为：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/release%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%80%BC.png"></p>
<p>在release中，<code>arr</code>的地址要高于<code>i</code>变量的地址，所以无论我们索引是否超过数组<code>arr</code>内元素的值，所以变量<code>i</code>就不会被重新的覆盖，就不会出生死循环。</p>
<h3 id="3-数据在内存中存储"><a href="#3-数据在内存中存储" class="headerlink" title="3.数据在内存中存储"></a>3.数据在内存中存储</h3><h4 id="3-1-数据类型"><a href="#3-1-数据类型" class="headerlink" title="3.1 数据类型"></a>3.1 数据类型</h4><h5 id="3-1-1-整型"><a href="#3-1-1-整型" class="headerlink" title="3.1.1 整型"></a>3.1.1 整型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char</span><br><span class="line">    signed char</span><br><span class="line">    unsigned char</span><br><span class="line">short</span><br><span class="line">    signed short[int]</span><br><span class="line">    unsigned short[int]</span><br><span class="line">int</span><br><span class="line">    signed int</span><br><span class="line">    unsigned int</span><br><span class="line">long </span><br><span class="line">    signed long[int]</span><br><span class="line">    unsigned long[int]</span><br></pre></td></tr></table></figure>

<h5 id="3-1-2-浮点型"><a href="#3-1-2-浮点型" class="headerlink" title="3.1.2 浮点型"></a>3.1.2 浮点型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float</span><br><span class="line">double</span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-构造类型"><a href="#3-1-3-构造类型" class="headerlink" title="3.1.3 构造类型"></a>3.1.3 构造类型</h5><p>自定义类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组类型</span><br><span class="line">结构体类型 struct</span><br><span class="line">枚举类型enum</span><br><span class="line">联合体类型union</span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-指针类型"><a href="#3-1-4-指针类型" class="headerlink" title="3.1.4 指针类型"></a>3.1.4 指针类型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* p;</span><br><span class="line">char* p;</span><br><span class="line">float* p;</span><br><span class="line">void* p;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-5-空类型"><a href="#3-1-5-空类型" class="headerlink" title="3.1.5 空类型"></a>3.1.5 空类型</h5><p><code>void</code></p>
<p>用于：函数的返回类型 void test();</p>
<p>​	   函数参数 void test(void);</p>
<p>​	   指针 void* p;</p>
<h4 id="3-2-探究整型在内存中存储模式"><a href="#3-2-探究整型在内存中存储模式" class="headerlink" title="3.2 探究整型在内存中存储模式"></a>3.2 探究整型在内存中存储模式</h4><p>在探究这个问题的时候，我们拿一个代码在演示</p>
<p>如下的代码：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F1.png"></p>
<p>然后我们调用vs2019中的调试模式，注意，调试时请一定确定是在<code>debug</code> 模式下，否则调试会失败</p>
<p>打开后</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F2.png"></p>
<p>我们找到<code>调试</code>中的<code>窗口</code>，在里面找到<code>内存</code>,然后选择一个进行查看</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F3.png"></p>
<p>进去后我们可以看到，调试器并没有定位到我们创建的变量a上</p>
<p>所以我们要通过a的地址来查找a的地址，我们找到<code>&amp;a</code>能获得a的地址，所以我们在<code>查找</code>那一行输入</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F4.png"></p>
<p>然后按回车键</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F5.png"></p>
<p>我们知道，数据在内存中都以二进制的形式存储</p>
<p>对呀整数来说，整数二进制有3种表示形式</p>
<h5 id="3-2-1-原码、补码、反码"><a href="#3-2-1-原码、补码、反码" class="headerlink" title="3.2.1 原码、补码、反码"></a>3.2.1 原码、补码、反码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原码：十进制的二进制形式就是原码</span><br><span class="line">反码：符号位不变，其他的依次取反</span><br><span class="line">补码：反码加一，就可以得到反码</span><br></pre></td></tr></table></figure>

<p><strong>注：正数的原码、补码、反码相同</strong></p>
<p><code>int</code>类型的变量在内存中占4个字节，1个字节等于8个比特，所以就有32位二进制的数，为了方便我们查看，计算机转换为十六进制的数。</p>
<p>我们知道，4位二进制数等于一位十六进制数，然后32位二进制数就应该等于8个十六进制数，所以我们要将列改成4位</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F6.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F7.png"></p>
<p>改完之后就是这样的了</p>
<h5 id="3-2-2-原码、补码、反码-续"><a href="#3-2-2-原码、补码、反码-续" class="headerlink" title="3.2.2 原码、补码、反码(续)"></a>3.2.2 原码、补码、反码(续)</h5><p>刚刚只是简单介绍了一下原码、补码、反码，还说正数的原码、补码、反码相同，那负数呢？</p>
<p>现在我们介绍一下负数的原码、补码、反码的计算</p>
<p>例如：我们有一个a的值位-10，在<code>int</code>型中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = -10</span><br></pre></td></tr></table></figure>

<p>它的原码的形式是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 1010</span><br></pre></td></tr></table></figure>

<p>然后我们把原码转换为反码后，反码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 0101</span><br></pre></td></tr></table></figure>

<p>之后我们再将反码+1就可以得到补码，补码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 0110</span><br></pre></td></tr></table></figure>

<p>之后我们再把补码转换成十六进制的形式就得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>

<p>我们把刚刚的代码改变一下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%94%B9%E5%8F%981.png"></p>
<p>然后使用上面的方法来查看变量a中存放的数</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%94%B9%E5%8F%982.png"></p>
<p>我们可以看到，a变量中的-10存放的方式是以补码的形式存放的，所以我们就可以得出一个结论。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结论：数据在内存中是以补码的形式进行存放的</span><br></pre></td></tr></table></figure>

<p>为什么在内存中数据是以补码的形式进行存储的呢？</p>
<h5 id="3-2-3-为什么存放补码"><a href="#3-2-3-为什么存放补码" class="headerlink" title="3.2.3 为什么存放补码"></a>3.2.3 为什么存放补码</h5><p>我们知道，在CPU中只有加法器而没有减法器，我们要计算1-1其实是计算1+(-1)</p>
<p>，如果我们直接拿原码相加的话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1的原码0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-1的原码1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">结果：1000 0000 0000 0000 0000 0000 0000 0010</span><br></pre></td></tr></table></figure>

<p>上面的结果换算出来是-2，肯定是不对的，但如果我们用原码来计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1的原码0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-1的原码1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-1的补码1111 1111 1111 1111 1111 1111 1111 1110</span><br><span class="line">结果：1 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>我们发现它已经超出32位了，但是我们只能存放32位长度的数，所以33位的1要省略，所以最后的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>结果就为0。</p>
<p>补码和原码的互相转换是非常方便的，它们的电路是一样的，就比如-1的原码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>补码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>我们将补码取反再加1就能得到原码。</p>
<p>补码取反+1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>所以为什么数据在内存中存放的形式必须是补码了。</p>
<p>我们回到最上面，为什么我们自己算出来的是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>

<p>但在vs2019中的存储却是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F6 FF FF FF</span><br></pre></td></tr></table></figure>

<p>呢？</p>
<p>这个就是需要知道大端存储和小段存储了</p>
<h5 id="3-2-4-大端存储和小段存储"><a href="#3-2-4-大端存储和小段存储" class="headerlink" title="3.2.4 大端存储和小段存储"></a>3.2.4 大端存储和小段存储</h5><p>大端存储和小段存储是我们了解数据在内存中存储模式最需要了解的一个知识点</p>
<h6 id="3-2-4-1-大端和小段"><a href="#3-2-4-1-大端和小段" class="headerlink" title="3.2.4.1 大端和小段"></a>3.2.4.1 大端和小段</h6><p>在开始讲大端存储和小段存储之前，我们先了解一下数据的大端是什么，小段是什么，有微机接口原理基础的小伙伴可以跳过这一节。</p>
<p>我们先用十进制给大家说，在十进制中，数据从左到右位数越来越大，例如我们有一个数为5623，5为千位，6为百位，2为十位，3为个位，所以5就为这个数的大端，3为这个数的小段。</p>
<p>但上面的这个例子只是让大家知道大端是在左，小段是在右，在计算机内部并不是以上面那个例子来的。</p>
<p>在计算机中，数据是以二进制的形式存放的，我们这里拿两位十六进制数来举例子，如下图：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E6%AE%B5.png"></p>
<p>（2为十六进制数等于8位二进制数）</p>
<p>在这个数中，前4位为大端，后4位为小段</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E6%AE%B52.png"></p>
<p>这样我们就知道二进制的大端和小段的位在哪了。</p>
<h6 id="3-2-4-2-什么是大端存储"><a href="#3-2-4-2-什么是大端存储" class="headerlink" title="3.2.4.2 什么是大端存储"></a>3.2.4.2 什么是大端存储</h6><p>大端存储又可以叫<strong>大端字节序</strong></p>
<p>大端字节序是把数据的小段字节放在高地址处，把大端字节放在低位地址处。</p>
<p>举个例子：如果我们有一个数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1001 1100</span><br></pre></td></tr></table></figure>

<p>这个数据放在大端字节序中的存放方式是：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%A4%A7%E7%AB%AF%E5%AD%98%E5%82%A8.png"></p>
<h6 id="3-2-4-3-什么是小端存储"><a href="#3-2-4-3-什么是小端存储" class="headerlink" title="3.2.4.3 什么是小端存储"></a>3.2.4.3 什么是小端存储</h6><p>小端存储又可以叫<strong>小端字节序</strong></p>
<p>小段字节序是把数据的小端字节放在低地址处，把大端字节放在高地址处。</p>
<p>例如：我们拿-10的二进制来距离</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>

<p>用大端字节存储的话就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>
<p>我们拿大端存储的那个例子来说，在小端字节序中的存放方式是：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8.png"></p>
<h5 id="3-2-5-通过代码判断当前机器的字节序"><a href="#3-2-5-通过代码判断当前机器的字节序" class="headerlink" title="3.2.5 通过代码判断当前机器的字节序"></a>3.2.5 通过代码判断当前机器的字节序</h5><p>通过上面的内容我们了解了数据在内存中的存放形式，还有存储方式中的大端存储和小端存储，通过这些我们可以通过代码来判断，一个数的存放方式为大端还是小端了。</p>
<p><strong>补充：在调试的情况下，一般在左边的为低地址，右边为高地址</strong></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%B0%83%E8%AF%95.png"></p>
<p>接下来我们要写代码对大端和小端进行判断了。</p>
<p>我们现在有一个<code>int</code>型变量a，它里面的值为1（这里我们拿1来举例子）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>int</code>类型的数在内存中占4个字节，也就是32位，8个十六进制数，在内存中的存放为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 01</span><br></pre></td></tr></table></figure>

<p>如果它在小端存储的话，写法应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01 00 00 00</span><br></pre></td></tr></table></figure>

<p>如果是大端存储的话，写法应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 01</span><br></pre></td></tr></table></figure>

<p>所以我们要进行判断就需要判断第一个2位十六进制数即可。</p>
<p>问题又来了，我们该如何判断第一个2位十六进制数呢？我们知道<code>char</code>类型占一个字节，也就是8位，再换就是2个十六进制数，但我们要专门指向该用什么呢？</p>
<p>没错，就是使用指针，指针是指向地址的首地址值，如果指向的第一个数是1，那就证明是小端存储，而如果第一个数是0，则证明是大端存储。</p>
<p>所以我们代码就可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*)&amp;a;</span><br><span class="line">    <span class="keyword">if</span> ((*p) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端存储&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端存储&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一定要强制转换一下类型，虽然不会报错，但还是养成规范写法吧。</p>
<h5 id="3-2-6-练习"><a href="#3-2-6-练习" class="headerlink" title="3.2.6 练习"></a>3.2.6 练习</h5><h6 id="3-2-6-1-练习1"><a href="#3-2-6-1-练习1" class="headerlink" title="3.2.6.1 练习1"></a>3.2.6.1 练习1</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> b = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d,b = %d,c=%d&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**分析：**这道题考察的是原码补码的转换，还有不同类型的位数，和整型提升</p>
<p>-1的原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>然后转换为补码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>因为a是<code>char</code>类型的，所以要阶段，留8位，所以为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111</span><br></pre></td></tr></table></figure>

<p>但是输出需要整型提升，整型提升看有无符号位，如果有符号位，补1，没符号位补0，</p>
<p><code>char</code>类型有符号位，所以我们将<code>char</code>类型的-1补位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>然后计算它的原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>所以输出-1，<code>signed char</code>类型也是一样的。</p>
<p>但<code>unsigned char</code>整型提升是提升0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 1111 1111</span><br></pre></td></tr></table></figure>

<p>因为最高位是0，是正数，原码就等于补码，所以输出为：255</p>
<h6 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h6><h6 id="1-char-是-signed-char-还是-unsigned-char"><a href="#1-char-是-signed-char-还是-unsigned-char" class="headerlink" title="1.char 是 signed char 还是 unsigned char"></a>1.<code>char</code> 是 <code>signed char</code> 还是 <code>unsigned char</code></h6><p>C语言中是没有规定的，取决于编译器</p>
<h6 id="2-int-是signed-int-还是-unsigned-int"><a href="#2-int-是signed-int-还是-unsigned-int" class="headerlink" title="2.int 是signed int 还是 unsigned int"></a>2.<code>int</code> 是<code>signed int</code> 还是 <code>unsigned int</code></h6><p><code>int</code> 就是 <code>signed int</code></p>
<p><code>short</code> 默认 <code>signed short</code></p>
<h6 id="3-2-6-2-练习2"><a href="#3-2-6-2-练习2" class="headerlink" title="3.2.6.2 练习2"></a>3.2.6.2 练习2</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">-128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a);<span class="comment">//%u输出的是无符号的十进制数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>-128的二进制数为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 1000 0000</span><br></pre></td></tr></table></figure>

<p>补码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1000 0000</span><br></pre></td></tr></table></figure>

<p>因为是 <code>char</code> 类型进行存放的，所以只保留后8位，所以保存的形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000</span><br></pre></td></tr></table></figure>

<p>到输出位时，要求的是打印一个无符号的整数，所以要整型提升，整型提升时看存放的类型，在编译器中默认存储的是 <code>signed char</code> 类型的，所以前面补1，就得：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1000 0000</span><br></pre></td></tr></table></figure>

<p>因为需要打印的无符号数，所以最高位不是符号位，答案就为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4294967168</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE-%E7%BB%83%E4%B9%A02.png"></p>
<h6 id="3-2-6-3-练习3"><a href="#3-2-6-3-练习3" class="headerlink" title="3.2.6.3 练习3"></a>3.2.6.3 练习3</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题和练习2的答案一样。</p>
<p>128在内存中的存放是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 1000 0000</span><br></pre></td></tr></table></figure>

<p>但 <code>char</code> 只能存放8位，所以是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000</span><br></pre></td></tr></table></figure>

<p>然后进行整型提升：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1000 0000</span><br></pre></td></tr></table></figure>

<p>所以答案是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4294967168</span><br></pre></td></tr></table></figure>

<h6 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h6><p>探讨char类型的取值范围</p>
<p>在char类型中可以存放8位比特位，所以在内存中可以取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char 0000 0000</span><br><span class="line">     0000 0001</span><br><span class="line">     0000 0010</span><br><span class="line">     0111 1111</span><br><span class="line">     1000 0000</span><br><span class="line">     1000 0001</span><br><span class="line">     ....</span><br><span class="line">     1111 1110</span><br><span class="line">     1111 1111</span><br></pre></td></tr></table></figure>

<p>前面0开头的都是正数，1开头的是负数，因为正数的原补码相同，所以前面存储的是0~127。</p>
<p>在负数中，我们要将补码变成原码，例如1111 1111的原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111</span><br></pre></td></tr></table></figure>

<p>然后取反加一就得原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0001</span><br></pre></td></tr></table></figure>

<p>我们转换一下这个数是不是等于-1。</p>
<p>一直这样算，1000 0001的原码是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111</span><br></pre></td></tr></table></figure>

<p>转换一下就是-127。</p>
<p>1000 0000这个数没有办法再进行计算了，它默认为-128</p>
<p>如果我们在 <code>char</code> 类型中存放128，它会默认为是-128。</p>
<h6 id="3-2-6-4-练习4"><a href="#3-2-6-4-练习4" class="headerlink" title="3.2.6.4 练习4"></a>3.2.6.4 练习4</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-20</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i + j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题非常的简单，重点就是二进制的加法，答案是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-10</span><br></pre></td></tr></table></figure>

<h6 id="3-2-6-5-练习5"><a href="#3-2-6-5-练习5" class="headerlink" title="3.2.6.5 练习5"></a>3.2.6.5 练习5</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是死循环，因为 <code>i</code> 是无符号数据，所以最小的是0。</p>
<h6 id="3-2-6-6-练习6"><a href="#3-2-6-6-练习6" class="headerlink" title="3.2.6.6 练习6"></a>3.2.6.6 练习6</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">-1</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">strlen</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong><code>char</code>类型有一个存储数据值的图：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/char%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE.png"></p>
<p>正常进行 <code>char</code> 类型加法的话，图应该是这样走的：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/char%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE1.png"></p>
<p>但是我们现在是进行减法，所以这幅图要倒着计算：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/char%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE2.png"></p>
<p>程序开始，整型-1-0，得到的结果为-1，-1-1，得到的结果为-2…..然后到-1-128，得到的结果为127。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/-128-1%E7%9A%84%E7%BB%93%E6%9E%9C.png"></p>
<p>继续相减，-1 - 254 &#x3D; 1，-1 - 255 &#x3D; 0，-1 - 256 &#x3D; -1….一直重复，直到不满足条件为止，然后执行 <code>strlen()</code> ，</p>
<p>这个函数是遇见 <code>\0</code> 就结束，我们知道 <code>\0</code> 就是 <code>0</code> ，所以就128 + 127 &#x3D; 255，结果就为255。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BB%83%E4%B9%A06%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<h6 id="3-2-6-7-练习7"><a href="#3-2-6-7-练习7" class="headerlink" title="3.2.6.7 练习7"></a>3.2.6.7 练习7</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**答案 **：死循环</p>
<p>**分析：**变量 <code>i</code> 的类型为 <code>unsigned char</code> ，最大值为255，当 <code>i</code> 到最大数后再加1就得0了，就变成了死循环了。</p>
<h4 id="3-3-探究浮点型在内存中存储模式"><a href="#3-3-探究浮点型在内存中存储模式" class="headerlink" title="3.3 探究浮点型在内存中存储模式"></a>3.3 探究浮点型在内存中存储模式</h4><p>在开始仔细研究浮点数在内存中的存储模式之前，我们先看下面的这一道练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">float</span>* pFloat = (<span class="type">float</span>*) &amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    </span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题很容易就会写错，大家可能觉得输出的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n的值为:9</span><br><span class="line">pFloat的值为:9.0</span><br><span class="line">n的值为:9</span><br><span class="line">pFloat的值为:9.0</span><br></pre></td></tr></table></figure>

<p>那这样就错了，我们拿到dev-c++中进行一下验证：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F.png"></p>
<p>是不是跟我们自己想的输出不一样，为什么会出现这种情况？这就要介绍一下浮点型数据在内存中存储模式了。</p>
<h5 id="3-3-1-在内存中浮点数的存储"><a href="#3-3-1-在内存中浮点数的存储" class="headerlink" title="3.3.1 在内存中浮点数的存储"></a>3.3.1 在内存中浮点数的存储</h5><p>在C语言中存储浮点数是按照IEEE 754的规则进行存储的。</p>
<p>IEEE 754规定存储浮点数的方式为：<code>S E M</code>。</p>
<ul>
<li><p>S：符号位，正数写0，负数为1.</p>
</li>
<li><p>E：指数。</p>
<p>对于指数E的情况是比较复杂的，因为一些时候指数为正数，而有些时候指数为负数，所以就找一个中间数，让指数在存储前需要加上中间数。对于8位E(也就是float数据)，中间数为127，而对于11位E(double型数据)，中间数为1023。</p>
</li>
<li><p>M：有效数字。</p>
<p>在存储时会省略小数点前的一个数，因为前面的那个数默认为1，因此可以被省略，拿出时只需要加上1即可。</p>
<p>留给M的位数：</p>
<p>float：23位</p>
<p>double：52位</p>
</li>
</ul>
<p>例如浮点数5.5f用二进制的形式转换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0101.1</span><br></pre></td></tr></table></figure>

<p>然后我们把它移动一下变为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.011 * 2^2</span><br></pre></td></tr></table></figure>

<p>s &#x3D; 0</p>
<p>M &#x3D; 1.011</p>
<p>E &#x3D; 2</p>
<p>因为是存在float中，所以E位要加127，在内存中的存储就应该为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0100 0000 1011 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>转换为十六进制为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40 B0 00 00</span><br></pre></td></tr></table></figure>

<p>我们在程序中走一下看看结果是不是一样</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/5.5f%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8.png"></p>
<p>倒着读，是不是和我们计算的一样呀。所以浮点数在内存中存储的方式也是分大小端的。</p>
<h5 id="3-3-2-从内存中读浮点数"><a href="#3-3-2-从内存中读浮点数" class="headerlink" title="3.3.2 从内存中读浮点数"></a>3.3.2 从内存中读浮点数</h5><p>从内存中读取浮点数的方法是需要具体分析的</p>
<h6 id="E不全为0或不全为1"><a href="#E不全为0或不全为1" class="headerlink" title="E不全为0或不全为1"></a>E不全为0或不全为1</h6><p>就那我们上面的5.5f举例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0100 0000 1011 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>这样子看有点复杂，我们把它写成<code>SEM</code>形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 10000001 01100000000000000000000</span><br></pre></td></tr></table></figure>

<p>我们将E减去刚才加的127，然后就得：0.011*2^2，之后我们把1加上去，就得1.011*2^2。转换一下就得101.1</p>
<h6 id="E为全0"><a href="#E为全0" class="headerlink" title="E为全0"></a>E为全0</h6><p>如果E为全0，那有效数字M前面不再加1。这样做是为表示+-0，以及接近0的数</p>
<h6 id="E为全1"><a href="#E为全1" class="headerlink" title="E为全1"></a>E为全1</h6><p>表示+-无穷大(正负有S决定)</p>
<p>我们知道浮点数在内存中的存储模式后，我们就可以分析最开始的那个题目了</p>
<h5 id="3-3-3-分析最开始的例子"><a href="#3-3-3-分析最开始的例子" class="headerlink" title="3.3.3 分析最开始的例子"></a>3.3.3 分析最开始的例子</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">float</span>* pFloat = (<span class="type">float</span>*) &amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    </span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始时有一个<code>int</code>型变量n，n中的值为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 1001</span><br></pre></td></tr></table></figure>

<p>之后<code>float*</code>获取的直接是n变量的值，它默认上面n的二进制数为浮点数的形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 00000000 00000000000000000001001</span><br><span class="line">s = 0</span><br><span class="line">E = -127</span><br><span class="line">M = 00000000000000000001001</span><br></pre></td></tr></table></figure>

<p><code>printf(&quot;n的值为:%d\n&quot;, n);</code>这个输出没什么问题，只要是<code>printf(&quot;pFloat的值为:%f\n&quot;, *pFloat);</code>的输出</p>
<p>因为它默认为浮点数的存储方式，所以要输出出来就是要把上面二进制转换为十进制数，而上面这种情况是我们<code>E为全0</code>的形式，所以M位前面不+1。</p>
<p>转换的结果就为：1.001 * 2^-127，这个数接近为0，我们又知道，<code>%f</code>只能输出小数点后6位的数，所以第二个输出就为：0.000000</p>
<p>之后我们将指针变量<code>pFloat</code>中的内容修改为9.0，9.0的二进制为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1001.0</span><br></pre></td></tr></table></figure>

<p>在内存中的存储形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 10000010 00100000000000000000000</span><br></pre></td></tr></table></figure>

<p>执行代码<code>printf(&quot;n的值为:%d\n&quot;, n);</code>，输出是以<code>%d</code>整型的输出方式，直接将上面的二进制看成整型的二进制，最高位为0，所以是正数直接输出出来，答案就为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1091567616</span><br></pre></td></tr></table></figure>

<p>和我们执行代码输出的结果一样。</p>
<p>执行代码<code>printf(&quot;pFloat的值为:%f\n&quot;, *pFloat);</code>就将浮点型的二进制转换成十进制的浮点型。</p>
<h2 id="二、指针进阶"><a href="#二、指针进阶" class="headerlink" title="二、指针进阶"></a>二、指针进阶</h2><p>之前我们学了基础的指针，现在我们要对指针进行更深入的讲解。</p>
<p>我们知道</p>
<ul>
<li>指针就是个变量，用于存放地址的变量。</li>
<li>指针的大小是固定的4&#x2F;8个字节(32位&#x2F;64位)</li>
</ul>
<p>这些是比较基础的概念，我们讲指针进阶先从字符指针开始讲</p>
<h3 id="1-字符指针"><a href="#1-字符指针" class="headerlink" title="1.字符指针"></a>1.字符指针</h3><p>我们知道，在C语言中我们可以通过数组的方式来存储字符和字符串，但其实指针也可以存储字符串的。</p>
<p>例如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>* p = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个字符型指针<code>p</code>，但我们知道指针变量最高只能存放8个字节，但我们给<code>p</code> 赋值的变量有12个字节(最后的<code>\0</code>)，指针应该是存不下的，那为什么我们说指针可以存放字符串呢？</p>
<blockquote>
<p>是因为指针并不是存放这个字符串，而是存放字符串的首元素地址</p>
</blockquote>
<p>我们可以验证一下这个说法，我们将<code>*p</code>进行输出，如果输出的结果为<code>h</code>，则指针就是存放字符串的首元素地址。</p>
<p>我们在dev-c++中将代码写好</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88.png"></p>
<p>然后运行：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88/1-2.png"></p>
<p>看，结果是不是和我们猜想的一样</p>
<blockquote>
<p>字符指针存放的其实是字符串的首元素值</p>
</blockquote>
<p>可能有些同学会说是不是和数组一样的存放方式呀？</p>
<p>其实是不一样的，在数组中存放的是整个字符串，但是指针存放不了整个字符串，所以只能存放首元素的地址。</p>
<p>还有一点就是指针储存的字符串是不能修改里面的值的</p>
<p>例如：我们将首元素的地址中的元素修改</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-3.png"></p>
<p>运行的结果：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-4.png"></p>
<p>可以看出，我们使用指针方式是不能修改字符串中的字符的。</p>
<h4 id="1-1-面试题"><a href="#1-1-面试题" class="headerlink" title="1.1 面试题"></a>1.1 面试题</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* str3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* str4 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str1 == str2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 == str2&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 != str2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str3 == str4)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一道题会输出什么结果呢？</p>
<p>我们知道，数组是单独开辟一个空间来存放内容，但指针是使用的是共用的地址</p>
<p>我们从内存的角度进行分析，在内存中变量是存放在栈中</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-5.png"></p>
<p>我们创建了一个 <code>str1</code> 的数组，在栈中的存放：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-6.png"></p>
<p>然后在里面存放的值为”hello,world”， <code>str1</code> 指向就为：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-7.png"></p>
<p>之后我们又创建了一个变量 <code>str2</code> ，给它的值也为”hello,world”，但在数组变量中就算是相同的值也会重新开辟空间来存放</p>
<p>存放情况：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-8.png"></p>
<p>所以在数组变量中，我们在不同的数值中存放相同的值，它们的地址指向绝对不可能是相同的。</p>
<p>之后我们创建了一个 <code>char</code> 型的指针 <code>str3</code> ，创建完后在内存中会创建一个字符串”hello,world”</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-9.png"></p>
<p>然后指针 <code>str3</code> 就会指向创建出来的字符串的首元素地址</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-10.png"></p>
<p>之后又创建了一个 <code>char</code> 型的指针 <code>str4</code> ，这个指针指向的也是字符串”hello,world”，内存中已经存在字符串”hello,world”，所以就不需要再重新创建，指针 <code>str4</code> 直接指向创建出来的字符串”hello,world”了</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-11.png"></p>
<p>这两个指针都指向的是同一个字符串的首元素地址，所以它们的地址相同。</p>
<h3 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2.指针数组"></a>2.指针数组</h3><p>在前面我们知道，指针数组就是存放指针的数组，它的使用方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* arr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>上面的代码是一个数组中可以存放2个 <code>int</code> 型的指针变量。</p>
<p>使用的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="type">int</span>* arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;</span><br><span class="line">    <span class="comment">//输出内容</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个用法基本上没什么人使用。</p>
<p>一般指针数组的使用是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">5</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> c[<span class="number">5</span>] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* arr[<span class="number">3</span>] = &#123;a, b, c&#125;;</span><br><span class="line">    <span class="comment">//输出内容</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr[i] + j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将多个数组的地址存入一个数组中，方便使用。</p>
<p>上面那个代码的输出其实也可以写成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr[i][j]));</span><br></pre></td></tr></table></figure>

<p>使用解引用 <code>[]</code> 意思也是和+j一样的，只不过写法不一样。</p>
<p>在进阶内容中我们重点不是指针数组，指针数组在基础部分已经讲完了，现在的重点是我们在基础没有讲的一个知识，就是数组指针。</p>
<h3 id="3-数组指针"><a href="#3-数组指针" class="headerlink" title="3.数组指针"></a>3.数组指针</h3><p>我们前面学习了整型指针，浮点数正整，字符型指针，这些都是指针，数组指针也是一个指针</p>
<p>整型指针就是操作整型的指针，数组指针就是操作数组的指针。</p>
<h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><p>我们前面学过，数组名就是首元素的地址，我们 <code>&amp;数组名</code> 得到的是整个数组的地址，我们可以使用 <code>&amp;数组名</code> 来获取数组的地址然后存入指针中。</p>
<p>但这个数组指针如何定义？</p>
<p>数组指针的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> (*pa)[<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<p>怎么理解呢？</p>
<p>我们一步一步来</p>
<p>首先我们先写 <code>&amp;arr</code> ，这个获取的是 <code>arr</code> 的地址值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;arr;</span><br></pre></td></tr></table></figure>

<p>我们取了地址后需要一个指针来存放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*pa = &amp;arr;</span><br></pre></td></tr></table></figure>

<p>指针<code>pa</code>是需要有类型的，<code>pa</code>的类型是数组，而在C语言中要表示数组类型是用<code>type [number]</code>来表示的，所以我们可以按照这样来进行写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pa [<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<p>但是我们看，如果这样写，计算机会先将</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pa[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>结合在一起，然后就变成了指针数组，但我们 <code>*pa</code> 是在一起的，所以我们需要用括号将 <code>*pa</code></p>
<p>结合在一起</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*pa) [<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<p><strong>注：解引用<code>[]</code>中的值是该数组中的长度，要定义哪一个数组的指针，里面的值就为该数组的长度</strong></p>
<h4 id="3-2-指针数组和数组名"><a href="#3-2-指针数组和数组名" class="headerlink" title="3.2 指针数组和数组名"></a>3.2 指针数组和数组名</h4><p>在定义中说到，数组名就是首元素的地址，指针数组获取数组的地址是整个数组的地址，我们可以通过下面的程序来说明</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-014.png"></p>
<p>数组名和指针数组的地址都相同，那我们为什么还有指针数组这个东西呢？</p>
<p>我们用数组进行移位+1，得到的就是下一个元素的值</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-015.png"></p>
<p>我们使用一下数组指针进行一下位移看看会发生什么</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-016.png"></p>
<p>我们发现，通过数组指针+1后它直接就跳过20个字节，也就是一个数组</p>
<p>我们可以总结</p>
<blockquote>
<p>数组指针前进是跳过这个数组</p>
</blockquote>
<p>数组名就是首元素地址，但是有两个例外：</p>
<blockquote>
<p><code>sizeof</code>后的数组名代表的是整个数组，单位是字节</p>
<p>&amp;数组名表示的是整个数组，取出的是整个数组的地址</p>
</blockquote>
<h4 id="3-3-数组指针的使用"><a href="#3-3-数组指针的使用" class="headerlink" title="3.3 数组指针的使用"></a>3.3 数组指针的使用</h4><h5 id="3-3-1-一维数组中的使用"><a href="#3-3-1-一维数组中的使用" class="headerlink" title="3.3.1 一维数组中的使用"></a>3.3.1 一维数组中的使用</h5><p>数组指针<code>pa</code>中的地址是整个数组的地址，<code>*pa</code>就为数组本身</p>
<p>例如我们有一个数组名，我们需要使用数组指针将它全部打印出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*pa)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*pa)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>*pa</code>+<code>i</code>得出下一个位置的地址出来，然后再进行解引用输出出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*pa)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *((*pa) + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个的输出是一样的</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-017.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-018.png"></p>
<p>我们也可以把输出的功能放在函数中使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *((*pa) + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    print1(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在函数中的形参中定义的是数组指针，输出的结果和上面的结果一样</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-021.png"></p>
<p>但是一维数组基本上用不到数组指针，只有在二维数组中才能很好的使用</p>
<h5 id="3-3-2-二维数组中的使用"><a href="#3-3-2-二维数组中的使用" class="headerlink" title="3.3.2 二维数组中的使用"></a>3.3.2 二维数组中的使用</h5><p>一般使用二维数组的时候我们都是通过下面的代码来实现的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line">    print(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们使用一下数组指针的方式来输出一下二维数组中的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*(pa + i)) + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line">    print(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*(pa + i))[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line">    print(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组的数组名表示的是首元素的地址，二维数组首元素的地址是第一行，就比如我们上面的那个例子中的数组</p>
<p>二维数组的首元素的地址就是</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-019.png"></p>
<p>所以我们的数组指针其实指向的是二维数组中的第一行，如果我们用这一行的地址加1就直接跳过第一行的所有元素，然后到第二行</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-020.png"></p>
<p>所以我们的数组指针的正确指向其实是该数组每一行的长度。</p>
<p>输出的解释参考一维数组的输出即可，重点是二维数组的定义和指针到底指向的是哪一个地址。</p>
<h5 id="3-3-3-使用函数输出数组传入加-该怎么用"><a href="#3-3-3-使用函数输出数组传入加-该怎么用" class="headerlink" title="3.3.3 使用函数输出数组传入加&amp;该怎么用"></a>3.3.3 使用函数输出数组传入加<code>&amp;</code>该怎么用</h5><p>数组传入函数是传的地址值，我们可以在函数中使用指针或者数组来接受，一般都不使用 <code>&amp;</code> 取址符来获取数组的地址，但如果你偏要使用 <code>&amp;数组名</code> 那函数中该怎么写呢？</p>
<h6 id="3-3-3-1-一维数组中"><a href="#3-3-3-1-一维数组中" class="headerlink" title="3.3.3.1 一维数组中"></a>3.3.3.1 一维数组中</h6><p>如果是一维数组的话，传的数组参数必须加上 <code>&amp;</code></p>
<p>看下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">(<span class="type">int</span> (*pa) [<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*pa)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    print3(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还是用数组指针进行接受，在上面代码中数组指针 <code>pa</code> 接受的是整个数组的地址，我们没有办法对它进行+1的操作，操作后就会跳过整个数组。</p>
<p>在上面说到， <code>pa</code> 是数组地址， <code>*pa</code> 就是整个数组，所以我们可以直接通过<code>数组名[索引]</code> 来转换成指针的形式 <code>(*pa)[索引值]</code></p>
<p>当然我们也可以用下面的输出办法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">(<span class="type">int</span> (*pa) [<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *((*pa) + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    print3(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个原理也和上面的差不多，就是把 <code>[]</code> 转换为+了。</p>
<h6 id="3-3-3-2-二维数组中"><a href="#3-3-3-2-二维数组中" class="headerlink" title="3.3.3.2 二维数组中"></a>3.3.3.2 二维数组中</h6><p>在传二维数组的参数时我们一般都不添加 <code>&amp;</code> 符号</p>
<p>如果传入函数中我们传 <code>&amp;数组名</code> 那函数的形参该如何写呢？</p>
<p>用我们之前的那个函数的形参可以吗</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-022.png"></p>
<p>很显然这个方法是不行的</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-023.png"></p>
<p>我们可以通过上面学到的知识来说明这个问题</p>
<p>讲数组指针操作二维数组中说过，它获取的是二维数组的地址，二维数组的地址就是第一行的地址，我们其实是在对二维数组的行进行操作，也指定了操作的行的长度</p>
<p>而如果直接 <code>&amp;arr</code> ，其实是将整个二维数组的地址传到这个函数中，我们要对整个二维数组进行操作就需要定义数组指针的长度，因为是二维数组，所以是需要有两个长度的。所以我们定义就需要这样定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">3</span>][<span class="number">5</span>])</span></span><br></pre></td></tr></table></figure>

<p>这样才是对整个二维数组的操作的方式。</p>
<p>我们现在知道函数的形参如何定义的了，那该如何对整个二维数组进行操作呢？</p>
<p>其实也和一维数组的操作差不多</p>
<p>第一种方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">3</span>][<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*pa)[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    print2(&amp;arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们传入的是整个二维数组的地址，所以 <code>*pa</code> 直接就是二维数组 <code>arr</code> </p>
<p>我们可以通过 <code>*pa[][]</code> 来获取值</p>
<p>这个办法是很简单的，但还有一个办法，有点复杂，需要仔细想想</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">3</span>][<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*((*pa) + i) + j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    print2(&amp;arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个办法我们在3.3.2中说过，只不过那种直接加得到的就是该元素的值，而我们这里得到的其实是地址，所以还需要使用<code>*</code>来转义一下 ，才能得到值。</p>
<h5 id="3-3-4-分析几个例子"><a href="#3-3-4-分析几个例子" class="headerlink" title="3.3.4 分析几个例子"></a>3.3.4 分析几个例子</h5><p>我们先看下面的几个定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> parr1[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* parr2[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> (*parr3)[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> (*parr4[<span class="number">10</span>])[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>parr1很简单这就是数组</p>
</li>
<li><p>parr2也容易理解，是一个指针数组</p>
</li>
<li><p>parr3我们也学过，是一个数组指针</p>
</li>
<li><p>parr4有点复杂，我们之前没有见过。</p>
<p>我们可以一个一个的分析，看到<code>(*)</code>的就可以理解为一个数组指针，然后<code>parr4[10]</code>就是一个数组，这就是一个存储数组指针的数组，该数组存放的长度为10，每个数组指针能指向一个数组，然后指向的数组的长度是5</p>
</li>
</ul>
<h3 id="4-数组参数、指针参数"><a href="#4-数组参数、指针参数" class="headerlink" title="4.数组参数、指针参数"></a>4.数组参数、指针参数</h3><h4 id="4-1-一维数组传参"><a href="#4-1-一维数组传参" class="headerlink" title="4.1 一维数组传参"></a>4.1 一维数组传参</h4><p>在一维数组中，传参有几种方法是可以的</p>
<h5 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h5><p>形参是数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h5><p>形参是指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h5><p>形参是数组指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(&amp;arr, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h5><p>形参是指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* arr[<span class="number">20</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第五种"><a href="#第五种" class="headerlink" title="第五种"></a>第五种</h5><p>形参是二级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* *ppa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-二维数组传输"><a href="#4-2-二维数组传输" class="headerlink" title="4.2 二维数组传输"></a>4.2 二维数组传输</h4><h5 id="第一种-1"><a href="#第一种-1" class="headerlink" title="第一种"></a>第一种</h5><p>形参是二维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[][<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test(arr, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二种-1"><a href="#第二种-1" class="headerlink" title="第二种"></a>第二种</h5><p>形参是数组指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test1(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; left; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ((*pa) + i)[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不能写的"><a href="#不能写的" class="headerlink" title="不能写的"></a>不能写的</h5><p>形参为一级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* arr)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参为二级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> **pa, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test1(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> **pa, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参为指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span>* pa[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test1(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span>* pa[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参为二维数组，但第二个 <code>[]</code> 中的数值省略</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[<span class="number">3</span>][])</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一定要看好传入的是什么类型的，要用相同的类型去接收</strong></p>
<h4 id="4-3-一级指针传参"><a href="#4-3-一级指针传参" class="headerlink" title="4.3 一级指针传参"></a>4.3 一级指针传参</h4><p>我们写一个程序的时候，一般是先写main函数里的东西，如果要传参数给函数也是规定好函数的形参是是什么形式的</p>
<p>例如我们下面写好了一个main函数，我们也规定函数test2中的形参为一个指针和一个整数来接受</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* p = arr;</span><br><span class="line">    test2(p, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们的函数的写法就如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(pa + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果我们有一个写好的函数，我们需要使用，能给这个函数传什么值进去呢？</p>
<p>例如下面的这个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span>* pa)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看，我们有一个函数，形参是一个指针，我们需要给这个函数传参数，只能选择传地址。</p>
<p>主函数main中有一个 <code>char</code> 类型的变量a</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要把这个值传入函数中其实有两种写法</p>
<p>第一种直接就是把a的地址传入函数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    print(&amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种写法就是用一个指针来接收a的地址，然后再传入函数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="type">char</span>* pa = &amp;a;</span><br><span class="line">    print(pa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式都要明白，传一级指针用什么接收，形参为一级指针该传什么值我们需要明白。</p>
<h4 id="4-4-二级指针传参"><a href="#4-4-二级指针传参" class="headerlink" title="4.4 二级指针传参"></a>4.4 二级指针传参</h4><p>当有一个二级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* pa = &amp;a;</span><br><span class="line">    <span class="type">int</span>** ppa = &amp;pa;</span><br><span class="line">    print(ppa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要将这个二级指针传给一个函数中使用，函数的形参的写法可以是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>** ppa)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, **ppa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那反过来，如果这个函数写好了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>** ppa)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**ppa)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该传什么值呢？有两种办法</p>
<p>第一种：</p>
<p>我们直接将定义的一级指针的地址传进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* pa = &amp;a;</span><br><span class="line">    print(&amp;pa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式是定义二级指针，然后把二级指针传进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* pa = &amp;a;</span><br><span class="line">    <span class="type">int</span>** ppa = &amp;pa;</span><br><span class="line">    print(ppa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种方式是把指针数组传进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    print(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组中是存放一级指针，所以可以使用二级指针的方式来接收，但尽量不要使用该方法，有可能会出现野指针的情况。</p>
<p>内容不是很难，重点是要将这些方法记住，并且能熟练的使用。</p>
<h3 id="5-函数指针"><a href="#5-函数指针" class="headerlink" title="5.函数指针"></a>5.函数指针</h3><p>在C语言中，所有的数据都有它的地址，整型变量、数组等都有地址，在函数中，函数也是有地址的，比如我们创建一个函数来输出它的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;Add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-024.png"></p>
<p>所以函数是有地址的，只要有地址就可以使用指针来进行接收</p>
<h4 id="5-1-函数指针的定义"><a href="#5-1-函数指针的定义" class="headerlink" title="5.1 函数指针的定义"></a>5.1 函数指针的定义</h4><p>可以结合数组指针的定义来互相推</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数返回值类型 (*指针名)(形参类型) = &amp;函数名</span><br></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初学的时候，可能会写成下面这个样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *<span class="title function_">pa</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> = &amp;Add;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个写法是错误的，因为 <code>*</code> 的结合优先级低，会让 <code>pa(int x, int y)</code> 先进行结合，然后再和 <code>*</code> 结合。</p>
<h4 id="5-2-函数指针的使用"><a href="#5-2-函数指针的使用" class="headerlink" title="5.2 函数指针的使用"></a>5.2 函数指针的使用</h4><p>定义就是为了使用，定义好之后该如何进行使用，是需要知道的重点。</p>
<p>从上面定义知道， <code>pa</code> 是函数 <code>Add</code> 的地址，在前面如果加上 <code>*</code> 就直接是函数了，所以可以这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> sum = (*pa)(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-025.png"></p>
<p>答案是没有问题的。</p>
<h4 id="5-3-探究函数的地址"><a href="#5-3-探究函数的地址" class="headerlink" title="5.3 探究函数的地址"></a>5.3 探究函数的地址</h4><p>在数组前面说过输出数组的地址可以用 <code>&amp;数组名</code> ，也可以直接使用 <code>数组名</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-026.png"></p>
<p>带入函数中，<code>&amp;函数名</code> 是函数的地址，那直接输出 <code>函数名</code> 得到的是不是函数的地址呢？</p>
<p>测试一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;Add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, Add);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-027.png"></p>
<p>通过上面的运行结果，可以发现，使用 <code>&amp;函数名</code> 和 <code>函数名</code> 的输出结果是一样的，所以可以总结为</p>
<blockquote>
<p>函数名是函数的地址</p>
</blockquote>
<p>在使用的时候是直接通过</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数名();</span><br></pre></td></tr></table></figure>

<p>进行调用的</p>
<p>可以尝试直接使用指针名来调用函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> sum = pa(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-028.png"></p>
<p>可以看出，直接用指针名也可以调用函数，所以可以总结</p>
<blockquote>
<p>可以使用函数指针直接调用函数</p>
<p>但不能使用数组指针直接调用数组</p>
</blockquote>
<p>当然，将函数的地址传给函数指针的时候也可以不添加 <code>&amp;</code> 就可以获得函数的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = Add;</span><br><span class="line">    <span class="type">int</span> x = pa(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-033.png"></p>
<h4 id="5-4-阅读代码"><a href="#5-4-阅读代码" class="headerlink" title="5.4 阅读代码"></a>5.4 阅读代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*(<span class="type">void</span> (*)())<span class="number">0</span>)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>出处：C陷阱和缺陷</p>
</blockquote>
<p>这段代码得一步一步分析，<code>void (*)()</code> 是一个函数指针类型，它将 <code>0</code> 强制类型转换成一个函数指针的地址</p>
<p>然后对其解引用 <code>*(void (*)()0)</code> 后进行了调用</p>
<p><code>(*(void (*)()0))()</code> 。</p>
<p>也就是调用了地址为0处的函数，它的返回值为0，无形参。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (* signal(<span class="type">int</span>, <span class="type">void</span>(*)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数其实就是指针函数套一个指针函数</p>
<p>先看 <code>signal(int, void(*)(int))</code> 这是一个函数，第一个参数是 <code>int</code> 第二个参数是指向返回值为 <code>void</code> 形参为 <code>int</code> 的函数。</p>
<p>而这个函数它的返回值为一个函数指针。这个函数指针是指向返回值为 <code>void</code> ，形参为 <code>int</code> 的函数。</p>
<p>简化一下这个代码就能能看懂了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*) (<span class="type">int</span>) signal(<span class="type">int</span>, <span class="type">void</span> (*)(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>这个函数的返回类型是一个函数指针类型，但是这种写法在C语言中是不能支持的，如果一个函数的返回类型是函数指针类型，那它的写法只能是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (* (signal(<span class="type">int</span>, <span class="type">void</span> (*)(<span class="type">int</span>)))) (<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-029.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-030.png"></p>
<p>如果真的要简化其实也是可以的，可以使用 <code>typedef</code> 对类型重命名</p>
<p>在讲用 <code>typedef</code> 简化前，先把前面漏的东西补充一下</p>
<h5 id="5-4-1-typedef"><a href="#5-4-1-typedef" class="headerlink" title="5.4.1 typedef"></a>5.4.1 <code>typedef</code></h5><p><code>typedef</code> 的作用就是对类型进行重新命名</p>
<p>比如要将 <code>unsigned int</code> 类型名字变成 <code>ui</code> 来使用，就需要在程序中这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line">    ui i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行的结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-031.png"></p>
<p>如果你要将一个函数指针重新命名使用下面的代码是不行的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span> <span class="type">pfun_t</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-032.png"></p>
<blockquote>
<p>这个和5.4中的不能简化的那个一样</p>
</blockquote>
<p>如果要给函数指针重新命名只能写成下面的样子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* <span class="type">pfun_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写成这样就不会出现问题了</p>
<p>现在就可以进行简化了，将函数指针类型重新命名，然后再使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* <span class="type">pfun_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">pfun_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> (*)(<span class="type">int</span>))</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看是不是更好的就明白这个代码的意思了。</p>
<h3 id="6-函数指针数组"><a href="#6-函数指针数组" class="headerlink" title="6.函数指针数组"></a>6.函数指针数组</h3><p>之前学过指针数组，指针数组就是存放指针的数组</p>
<p>例如需要有一个数组来存放5个整型指针，那代码可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* pa[<span class="number">5</span>]; </span><br></pre></td></tr></table></figure>

<p>那函数指针数组不就是存放函数指针的一个数组吗，按照上面的写法改一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*)() pa[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>但是从上面知道，不能这样写的，虽然 <code>int(*)()</code> 是函数指针类型，但是不能放在前面，数组名放在后面，而是要把数组名和 <code>*</code> 放在一起</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* pa[<span class="number">5</span>])();</span><br></pre></td></tr></table></figure>

<h4 id="6-1-使用例子"><a href="#6-1-使用例子" class="headerlink" title="6.1 使用例子"></a>6.1 使用例子</h4><p>例如有两个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这两个函数的返回值类型和形参类型都一样，可以直接使用一个函数指针数组将它存放在里面</p>
<p>main函数就可以这么写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;Add, Sub&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接写的是函数的名字，因为在5.3中讲到，函数名就是函数的地址，所以这直接可以将函数名存储在函数指针中。</p>
<p>也可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pA)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> (*pS)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Sub;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;pA, pS&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-函数指针数组的使用"><a href="#6-2-函数指针数组的使用" class="headerlink" title="6.2 函数指针数组的使用"></a>6.2 函数指针数组的使用</h4><p>和查找数组中元素的方法一样，通过数组的索引来查找，只不过这里得到的是函数的地址，但前面说过，函数名就是函数地址，可以直接通过函数地址来调函数</p>
<p>还是用上面那个例子，已经将函数指针存放在函数指针数组中后，进行调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pA)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> (*pS)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Sub;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;pA, pS&#125;;</span><br><span class="line">    <span class="type">int</span> x = pa[<span class="number">0</span>](<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-034.png"></p>
<p>知道函数指针数组的使用后，就可以找一个项目来练习了。</p>
<h4 id="6-3-计数器项目"><a href="#6-3-计数器项目" class="headerlink" title="6.3 计数器项目"></a>6.3 计数器项目</h4><p>需要写一个程序，这个程序能做整型的加减乘除。</p>
<p>在没有学会函数指针数组前，写的程序应该是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">switch</span>(input)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Add(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Sub(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Mul(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:	</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Div(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这个程序可以执行，但是有很多地方有冗余(rong yu)，重复得太多是不好的，可以使用函数指针数组来代替，因为这些函数都是同样的返回类型和同样的形参，所以可以使用函数指针数组来替代</p>
<p>替代之后的程序就为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;Add, Sub, Mul, Div&#125;;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> arr_size = <span class="keyword">sizeof</span>(pa) / <span class="keyword">sizeof</span>(pa[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">if</span> (input &lt; (arr_size - <span class="number">1</span>) &amp;&amp; input != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">            res = (pa[input - <span class="number">1</span>])(num1, num2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;res = %d\n&quot;</span>, res);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(input &gt; (arr_size - <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉上面的代码比之前的代码要简单且没造成冗余，这个使用了函数指针数组，通过函数指针数组存放函数地址，然后再通过函数指针数组的索引调用函数，这样就不用一直用 <code>switch</code> 和 <code>case</code> 进行反复判断，而且在后面需要增加新功能时也能很好的添加。</p>
<p>这种方法用专业的说法就是：转义表</p>
<blockquote>
<p>在《C和指针》中提到</p>
</blockquote>
<h4 id="6-4-取函数指针数组的地址"><a href="#6-4-取函数指针数组的地址" class="headerlink" title="6.4 取函数指针数组的地址"></a>6.4 取函数指针数组的地址</h4><p>之前学数组的时候知道，数组名就是数组地址，只要是地址就可以用指针来接收</p>
<p>比如说有一个整型变量 <code>a</code> ，可以使用一个整型指针来进行接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* pa = &amp;a;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向【整型】的指针</p>
</blockquote>
<p>比如说现在有一个数组，需要获得这个数组的地址，可以使用数组指针来进行接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> (*pa)[<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向【数组】的指针</p>
</blockquote>
<p>再比如说有一个指针数组，需要获取指针数组的地址，可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* arr[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* (*pa)[<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向【整型指针的数组】的指针</p>
</blockquote>
<p>那现在有一个函数指针，取它的地址值，用函数指针数组来接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (* pa[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) = &amp;pa</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向函数指针的数组</p>
</blockquote>
<p>那现在需要将函数指针数组的地址取出来，用一个指针来接收地址，那这个类型该如何写呢？</p>
<p>现在一步一步进行分析</p>
<p>有一个函数指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* pa[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>取这个数组的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;pa;</span><br></pre></td></tr></table></figure>

<p>用一个指针进行接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*ppa = &amp;pa;</span><br></pre></td></tr></table></figure>

<p>但这个类型应该为函数指针的数组，所以类型应该为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* [<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>如果直接把指针名加到后面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* [<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) (*ppa);</span><br></pre></td></tr></table></figure>

<p>是不可以的，可以参考5.4，所以应该写为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* (*ppa)[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) = &amp;pa;</span><br></pre></td></tr></table></figure>

<p><strong>本节内容了解即可</strong></p>
<h3 id="7-回调函数"><a href="#7-回调函数" class="headerlink" title="7.回调函数"></a>7.回调函数</h3><h4 id="7-1-什么是回调函数"><a href="#7-1-什么是回调函数" class="headerlink" title="7.1 什么是回调函数"></a>7.1 什么是回调函数</h4><p>回调函数可以理解为函数的形参是函数指针，并且在函数中调用函数指针。</p>
<p>例如有一个a函数，需要它在b函数中使用</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-035.png"></p>
<p>它的传送就是这个样子。</p>
<h4 id="7-2-计算器-回调函数"><a href="#7-2-计算器-回调函数" class="headerlink" title="7.2 计算器(回调函数)"></a>7.2 计算器(回调函数)</h4><p>继续使用6.3的计数器的例子，这里使用的是没有进行优化的版本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">switch</span>(input)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Add(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Sub(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Mul(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:	</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Div(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有用函数指针数值进行优化的例子中有好多地方冗余，其实可以把冗余的部分放在一个函数中，使用的时候直接调用函数即可。</p>
<p>但在每一行都调了不同的函数，所以就需要使用回调函数在重新定义的函数中调用</p>
<p>优化后的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Cope</span><span class="params">(<span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>))</span>&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">    <span class="keyword">return</span> pa(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">switch</span>(input)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                res = Cope(&amp;Add);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                res = Cope(&amp;Sub);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                res = Cope(&amp;Mul);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:	</span><br><span class="line">                res = Cope(&amp;Div);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-快速排序函数"><a href="#8-快速排序函数" class="headerlink" title="8.快速排序函数"></a>8.快速排序函数</h3><p>在讲数值的时候讲到了一个冒泡排序的算法，但这种方法只能对整型数组进行排序，无法对其他类型进行排序，所以要介绍一种可以对任意类型进行排序的函数 <code>qsort</code></p>
<h4 id="8-1-qsort-的结构"><a href="#8-1-qsort-的结构" class="headerlink" title="8.1 qsort 的结构"></a>8.1 <code>qsort</code> 的结构</h4><p>在学习一个函数时，需要了解这个函数的形参和返回值。</p>
<p>可以通过 <code>cplusplus</code> 网站来查找这个函数的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span> <span class="params">(<span class="type">void</span>* base, <span class="type">size_t</span> num, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span>*,<span class="type">const</span> <span class="type">void</span>*))</span>;</span><br></pre></td></tr></table></figure>

<p>上面的就是 <code>qsort</code> 函数的形参，现在一步一步分析，等后面就可以自己仿照写一个 <code>qsort</code> 函数了。</p>
<p>首先看第一个形参 <code>base</code>，是一个无类型的指针，因为函数一开始的设计者考虑到使用者可能会使用其他类型的值，所以直接就使用无类型的指针来接收。而这个接收的是需要排序的数组&#x2F;结构体的地址</p>
<p>再看第二个形参 <code>num</code>，这个参数的功能是接收数组的长度的，之前在写冒泡排序的时候也有这一个参数。</p>
<p>第三个形参 <code>size</code>，这个函数的第一个形参接收的是一个无类型的指针，不是指定形式的指针，没办法通过+1来查找下一个数，所以需要用户提交一下这个数组类型的大小。</p>
<p>最后一个形参是一个函数指针，指向的函数的返回值为 <code>int</code>，两个形参都为无符号的指针。这个是需要用户自己写一个函数然后传进去，这个函数的功能主要是提供一个判断数，用这个判断数来决定是用升序还是降序，而返回的值要么大于1(&gt;1)，要么等于1(&#x3D;1)，要么小于1(&lt;1)。</p>
<p>上面的内容可以会容易迷糊，所以举个使用例子</p>
<h4 id="8-2-qsort-的使用-数组"><a href="#8-2-qsort-的使用-数组" class="headerlink" title="8.2 qsort 的使用(数组)"></a>8.2 <code>qsort</code> 的使用(数组)</h4><p>先拿一个<code>int</code>型的数组来进行一下排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中调用一下 <code>qsort</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    qsort();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就需要传函数的参数了，第一个参数是一个指针，所以需要把数组名传入，第二个是数组的长度，所以需要使用 <code>sizeof</code> 来计算，并传进去，第三个参数是类型的大小，也可以用 <code>sizeof</code> 来计算，所以前3个参数可以这么写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最难写的是第四个参数，需要使用者自己写一个判断函数，在官方文档中的写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">int</span>*)pa) - *((<span class="type">int</span>*)pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下，因为无类型的指针没有办法取得对应位置的值，所以需要强制类型转换一下，把类型转换成数组的类型进行计算，计算完后需要取到返回值，得到返回值后就可以进行排序了。</p>
<p>完善一下写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">int</span>*)pa) - *((<span class="type">int</span>*)pb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在dev++中演示一下运行的结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-036.png"></p>
<p>如果这个函数只能对整型或者浮点型进行排序的话，就没有必要花时间来说了。</p>
<p>现在来对字符数组进行一下排序</p>
<h4 id="8-3-qsort-的使用-字符数组"><a href="#8-3-qsort-的使用-字符数组" class="headerlink" title="8.3 qsort 的使用(字符数组)"></a>8.3 <code>qsort</code> 的使用(字符数组)</h4><p>在C语言中，存放字符其实是存放该字符的ASCII码，所以字符也是可以比较大小的，还是按照上面的写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">char</span>*)pa - *(<span class="type">char</span>*)pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[] = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), i;</span><br><span class="line">    qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-037.png"></p>
<p>现在来测试一下结构体中的数组的排序</p>
<h4 id="8-4-qsort-的使用-结构体"><a href="#8-4-qsort-的使用-结构体" class="headerlink" title="8.4 qsort 的使用(结构体)"></a>8.4 <code>qsort</code> 的使用(结构体)</h4><p>结构体中的数组的排列和上面的一样，先创建出一个记录学生消息的结构体 <code>Stu</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>name</code> 用于存放学生的名字</p>
<p><code>age</code> 用来存放年龄</p>
<p>之后写主函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&#x27;b&#x27;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>&#125;&#125;;<span class="comment">//1</span></span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);<span class="comment">//2</span></span><br><span class="line">    qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %d\n&quot;</span>, stu[i].name, stu[i].age);<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个语句是创建一个结构体类型的数组 <code>stu</code> 并赋值</p>
<p>第二条语句是获取结构体数组的长度。</p>
<p>第三条语句就是调用一下 <code>qsort</code> 函数来进行排序，其中 <code>cmp</code> 函数的内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa)-&gt;age - ((<span class="keyword">struct</span> Stu*)pb)-&gt;age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为传入的是结构体，所以要按照结构体的写法来进行书写，需要对年龄进行排序，就调用 <code>age</code> ，如果需要对名字进行排序就调用  <code>name</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa)-&gt;name - ((<span class="keyword">struct</span> Stu*)pb)-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到上面，第四条语句是将结果打印出来，方便观察数据是否被修改。</p>
<p>上面的名字只是一个字符，如果按照真实的情况下，名字是一个字符串，如果要对字符串名字进行排序，那该如何写呢？</p>
<h4 id="8-5-qsort-的使用-结构体更改"><a href="#8-5-qsort-的使用-结构体更改" class="headerlink" title="8.5 qsort 的使用(结构体更改)"></a>8.5 <code>qsort</code> 的使用(结构体更改)</h4><p>现在需要结构体中的 <code>name</code> 存放字符串，所以要对结构体进行一下修改，只需要把它变成一个数组即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要介绍一个比较字符串大小的一个函数 <code>strcmp</code></p>
<h5 id="8-5-1-strcmp"><a href="#8-5-1-strcmp" class="headerlink" title="8.5.1 strcmp"></a>8.5.1 <code>strcmp</code></h5><p>比较字符的内核就是比较它们之间的ASCII码值，而比较字符串的办法也是一样的，只不过比较繁琐，不适合在开发中花时间写，所以C语言的工程师很贴心的写好了比较字符串的函数，用户可以直接使用</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-068.png"></p>
<p>继续回到上面，现在已经学会了 <code>strcmp</code> 函数后，可以使用三种办法来解决上面的问题</p>
<h5 id="8-5-2-第一种办法"><a href="#8-5-2-第一种办法" class="headerlink" title="8.5.2 第一种办法"></a>8.5.2 第一种办法</h5><p>第一种办法就是直接调用 <code>strcmp</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(((<span class="keyword">struct</span> Stu*)pa)-&gt;name, ((<span class="keyword">struct</span> Stu*)pb) -&gt; name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&quot;aike&quot;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&quot;js&quot;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&quot;sjd&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);</span><br><span class="line">    qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, stu[i].name, stu[i].age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>strcmp</code> 的返回值是1，-1，0，所以直接就可以返回。</p>
<h5 id="8-5-3-第二种方法"><a href="#8-5-3-第二种方法" class="headerlink" title="8.5.3 第二种方法"></a>8.5.3 第二种方法</h5><p>直接使用 <code>-</code> 来获得</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa)-&gt;name - ((<span class="keyword">struct</span> Stu*)pb)-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&quot;aike&quot;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&quot;js&quot;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&quot;sjd&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);</span><br><span class="line">    qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, stu[i].name, stu[i].age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法也可以得到排序的结果。</p>
<h5 id="8-5-4-第三种方法"><a href="#8-5-4-第三种方法" class="headerlink" title="8.5.4 第三种方法"></a>8.5.4 第三种方法</h5><p>这种方法特别不推荐，这种方法主要是让自己写一个 <code>strcmp</code> 函数来使用，觉得麻烦的可以直接跳过</p>
<p><code>strcmp</code> 主要是对字符串进行比较，传入的值主要是字符型的数组，所以自己写的 <code>my_strcmp</code> 的形参为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_strcmp(<span class="type">const</span> <span class="type">char</span>* pa, <span class="type">const</span> <span class="type">char</span>* pb)</span><br></pre></td></tr></table></figure>

<p>在测试 <code>strcmp</code> 函数的时候，它的返回值只有3种情况，并且都是 <code>int</code> 型的，所以返回值的类型就应该为 <code>int</code> ，再完善一下写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa, <span class="type">const</span> <span class="type">char</span>* pb)</span></span><br></pre></td></tr></table></figure>

<p>现在要对函数内部功能开始书写</p>
<p>要模仿前先要确定一下 <code>strcmp</code> 如何判断哪一条字符串大，判断字符串的大小其实就是单个字符的比较，如果 <code>str1</code> 中有一个位置上的字符比 <code>str2</code> 同位置的字符大，则返回1，如果等于返回0。</p>
<p>还有一点就是需要找到最大的字符串来比较，如果 <code>str1</code> 终止了但 <code>str2</code> 还有字符，就会出现问题，所以需要在函数中添加一下判断长度的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, num_a = <span class="number">0</span>, num_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pa + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_a = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pb + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_b = i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这串代码很容易理解，它的本质就是遍历数组，把数组的长度获取，可以便于使用</p>
<p>有了长度之后就可以对数组进行遍历比值了，比较的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= ((num_a &gt; num_b)?num_a:num_b); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*(pa + i) &gt; *(pb + i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*(pa + i) &lt; *(pb + i))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>for</code> 循环中使用了一下三元运算符来判断最大的长度，这样可以有效的避免短的数组没有长度而结束判断了</p>
<p>在 <code>for</code> 循环中有两个判断条件，一个是大于一个是小于，如果在字符串中找到一个值如果大或者小就直接结束函数。</p>
<p>如果都相等就在外面结束函数。</p>
<p>全部代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa, <span class="type">const</span> <span class="type">char</span>* pb)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, num_a = <span class="number">0</span>, num_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pa + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_a = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pb + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_b = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= ((num_a &gt; num_b)?num_a:num_b); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*(pa + i) &gt; *(pb + i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*(pa + i) &lt; *(pb + i))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>strcmp</code> 和我们写的 <code>my_strcmp</code> 进行一下比较<br><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-069.png"></p>
<p>结果一样的，自己写的 <code>my_strcmp</code> 成功了，然后把这个带进去就能得到第三种方法了</p>
<h4 id="8-6-my-qsort"><a href="#8-6-my-qsort" class="headerlink" title="8.6 my_qsort"></a>8.6 <code>my_qsort</code></h4><p>这一节从 <code>qsort</code> 函数来分析并写出一个 <code>my_qsort</code> 函数</p>
<p>回顾学过的排序算法，就只有冒泡好用，所以这里使用冒泡排序作为 <code>my_qsort</code> 的排序方法。</p>
<p>知道使用什么方法进行排序后，要确定函数的形参如何书写。第一个形参可以作为需要比较的内容的指针，但不确定传入的是什么类型的数组的地址，所以可以用 <code>void</code> 类型来接收。</p>
<p>然后再传入数组的长度和步长还有判断数即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span>(*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span></span><br></pre></td></tr></table></figure>

<p>函数的形参写好了</p>
<blockquote>
<p>加上 <code>const</code> 是为了不改变变量的值</p>
</blockquote>
<p>现在需要的是完成函数内部的功能，用冒泡排序的办法就要设计2个循环变量，一个是计循环的次数的，另一个是索引位数，所以内部写法就为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span>(*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内容的结构就完成了，现在要加上判断条件，通过判断数来决定，这里写的是 <code>&gt;0</code> ，你自己写也可以写成 <code>&lt;0</code> ，只不过用户写的判断函数就会改动一下。</p>
<p>如果把第j个元素和第j+1个元素带入到判断函数中，如果 <code>&gt;0</code> 就进行交换，否则就不进行什么操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span>(*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp((<span class="type">char</span>*)p + j * width, (<span class="type">char</span>*)p + (j+<span class="number">1</span>)*width))&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要把判断数带入用户写的判断函数中，因为不知道是什么类型的数，无法用加来查找下一个元素，所以这里就需要让数变成一个字节长度小的类型来进行加运算</p>
<p>这里现在了 <code>char</code> ，因为一个 <code>char</code> 类型只有一个字节长度，用 <code>char</code> 类型加上1再乘类型长度，这样就可以找到下一个元素的位置</p>
<p>进入循环后就要进行交换，交换代码放在一个函数 <code>Spack</code> 中，和之前冒泡一样的写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Spack</span><span class="params">(<span class="type">char</span>* pa, <span class="type">char</span>* pb, <span class="type">int</span> width)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; width - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp = *(pa + i);</span><br><span class="line">        *(pa + i) = *(pb + i);</span><br><span class="line">        *(pb + i) = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在前面把 <code>void</code> 类型的全部强制类型转换成 <code>char</code> 了，传入交换函数的类型也为 <code>char</code> 类型的，加1只能移动1位，如果是 <code>int</code> 类型的，加1只能移动一位，但它有4个位，所以这使用循环长度，然后把所有位都交换。</p>
<p>完善一下函数的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Spack</span><span class="params">(<span class="type">char</span>* pa, <span class="type">char</span>* pb, <span class="type">int</span> width)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; width; i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp = *(pa + i);</span><br><span class="line">        *(pa + i) = *(pb + i);</span><br><span class="line">        *(pb + i) = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp((<span class="type">char</span>*)p + j * width, (<span class="type">char</span>*)p + (j+<span class="number">1</span>) * width) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                Spack(((<span class="type">char</span>*)p + j * width), ((<span class="type">char</span>*)p + (j+<span class="number">1</span>) * width), width);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在对函数进行一下调试，用 <code>int</code> 型的数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)pa - *(<span class="type">int</span>*)pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    my_qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-070.png"></p>
<p>测试一下结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa) -&gt; age - ((<span class="keyword">struct</span> Stu*)pb) -&gt; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&quot;zdw&quot;</span>, <span class="number">18</span>&#125;, &#123;<span class="string">&quot;djs&quot;</span>, <span class="number">54</span>&#125;, &#123;<span class="string">&quot;sdx&quot;</span>, <span class="number">14</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    my_qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, stu[i].age, stu[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-071.png"></p>
<p>试试用名字进行排序</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-072.png"></p>
<h3 id="9-指针和数组的练习题"><a href="#9-指针和数组的练习题" class="headerlink" title="9.指针和数组的练习题"></a>9.指针和数组的练习题</h3><h4 id="9-1-一维数组"><a href="#9-1-一维数组" class="headerlink" title="9.1 一维数组"></a>9.1 一维数组</h4><h5 id="9-1-1-第一题"><a href="#9-1-1-第一题" class="headerlink" title="9.1.1 第一题"></a>9.1.1 第一题</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br></pre></td></tr></table></figure>

<p>在程序中执行的结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-1.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-2.png"></p>
<p>**分析：**第一个 <code>sizeof(a)</code> 语句是输出整个数组的长度，该数组是一个长度为4的数组，每个元素的大小为4为，所以整个数组的长度就为16</p>
<p><code>sizeof(a + 0) </code> 输出的是8，在学数组的时候知道，数组的首元素是该数组的地址，现在使用地址+1，就是获取地址的长度，在32位机中，地址长为4，64位中，地址长度为8.</p>
<p><code>sizeof(*a)</code> 这个就是地址的解引用，数组的地址为首元素的地址，所以这里计算的是数组第一个元素的长度，就为4。</p>
<p><code>sizeof(a + 1)</code> 和上面的a+0一个道理</p>
<p><code>sizeof(a[1])</code> 这个就是去索引位置</p>
<h5 id="9-1-2-第二题"><a href="#9-1-2-第二题" class="headerlink" title="9.1.2 第二题"></a>9.1.2 第二题</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br></pre></td></tr></table></figure>

<p>在电脑上执行一下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-3.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-4.png"></p>
<p><strong>分析：</strong> <code>sizeof(&amp;a)</code> 获得的是数组地址的大小，在之前学过，&amp;数组名获得的是整个数组的地址，所以这里输出的是8（在64位）</p>
<p><code>sizeof(*&amp;a)</code> 先是取数组整个的地址，然后再用 <code>*</code> 解引用，得到的就是数组第一个元素，然后再输出长度，得到的就是4</p>
<p>其他的都是一样的道理，得到的就是地址的大小</p>
<h4 id="9-2-字符数组"><a href="#9-2-字符数组" class="headerlink" title="9.2 字符数组"></a>9.2 字符数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr + <span class="number">0</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>] + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-5.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-6.png"></p>
<h4 id="9-3-字符串数组"><a href="#9-3-字符串数组" class="headerlink" title="9.3 字符串数组"></a>9.3 字符串数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr + <span class="number">0</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>] + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-7.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-8.png"></p>
<h4 id="9-4-字符指针"><a href="#9-4-字符指针" class="headerlink" title="9.4 字符指针"></a>9.4 字符指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p = <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p[<span class="number">0</span>] + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-9.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-10.png"></p>
<h4 id="9-5-二维数组"><a href="#9-5-二维数组" class="headerlink" title="9.5 二维数组"></a>9.5 二维数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(a[<span class="number">0</span>] + <span class="number">1</span>)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(a + <span class="number">1</span>)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(&amp;a[<span class="number">0</span>] + <span class="number">1</span>)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">3</span>]));</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-11.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-12.png"></p>
<h3 id="10、指针练习题"><a href="#10、指针练习题" class="headerlink" title="10、指针练习题"></a>10、指针练习题</h3><h4 id="10-1-一维数组"><a href="#10-1-一维数组" class="headerlink" title="10.1 一维数组"></a>10.1 一维数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)(&amp;a + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h4 id="10-2-结构体"><a href="#10-2-结构体" class="headerlink" title="10.2 结构体"></a>10.2 结构体</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span>* pcNumber;</span><br><span class="line">    <span class="type">short</span> sDate;</span><br><span class="line">    <span class="type">char</span> cha[<span class="number">2</span>];</span><br><span class="line">    <span class="type">short</span> sBa[<span class="number">4</span>];</span><br><span class="line">&#125;* p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">0x1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)p + <span class="number">0x1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>*)p + <span class="number">0x1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//设p中存放的地址为0x10000</span></span><br></pre></td></tr></table></figure>

<p>这道题考察的是指针的运算方法，先看这个结构体的大小为20个字节，指针p是结构体的指针。</p>
<p>第一步先将 <code>p + 0x1</code>，也就是让指针p跳过一个结构体，跳过20个字节，所以输出的地址就为 <code>0x10014</code></p>
<p>第二步将结构体指针p强制类型转换为 <code>unsigned long</code> 类型，现在指针p变成了整型p，整型+1，而地址不会改变</p>
<p>第三步将结构体指针p强制类型转换为无符号的整型指针类型，用无符号整型指针+1跳过的就是整个整型指针的长度，而整型指针的长度为4个字节，所以输出的地址为0x10004。</p>
<h4 id="10-3-二维数组"><a href="#10-3-二维数组" class="headerlink" title="10.3 二维数组"></a>10.3 二维数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123;(<span class="number">0</span>,<span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>,<span class="number">5</span>)&#125;;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题考察的是逗号表达式，真正存放在这二维数组中的格式为：<code>&#123;&#123;1,3&#125;,&#123;5,0&#125;,&#123;0,0&#125;&#125;</code></p>
<h4 id="10-4-复杂模式"><a href="#10-4-复杂模式" class="headerlink" title="10.4 复杂模式"></a>10.4 复杂模式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> (*p) [<span class="number">4</span>];</span><br><span class="line">    p = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %d\n&quot;</span>, &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>], &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题考察的是指针互相-和数组指针指向的关系。</p>
<h2 id="三、字符串函数和内存函数"><a href="#三、字符串函数和内存函数" class="headerlink" title="三、字符串函数和内存函数"></a>三、字符串函数和内存函数</h2><h3 id="1-模拟实现字符串函数"><a href="#1-模拟实现字符串函数" class="headerlink" title="1.模拟实现字符串函数"></a>1.模拟实现字符串函数</h3><h4 id="1-1-strlen"><a href="#1-1-strlen" class="headerlink" title="1.1 strlen"></a>1.1 strlen</h4><p>对于查看字符串长度的函数有3中模拟的写法</p>
<h5 id="第一种-2"><a href="#第一种-2" class="headerlink" title="第一种"></a>第一种</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    assert(pa != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(*pa != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        pa++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二种-2"><a href="#第二种-2" class="headerlink" title="第二种"></a>第二种</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa)</span>&#123;</span><br><span class="line">    assert(pa != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (*pa != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + my_strlen(pa + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-内存函数"><a href="#2-内存函数" class="headerlink" title="2.内存函数"></a>2.内存函数</h3><p>其实内存函数就是对数组的拷贝，属于深拷贝的范畴，之前已经讲过深拷贝了，这里就不多说了。</p>
<h2 id="四、结构体提高"><a href="#四、结构体提高" class="headerlink" title="四、结构体提高"></a>四、结构体提高</h2><p>在之前的学习了一下结构体的基本使用，这一节主要是学习一下结构体更多的用法</p>
<h3 id="1-结构体中的数组赋值"><a href="#1-结构体中的数组赋值" class="headerlink" title="1.结构体中的数组赋值"></a>1.结构体中的数组赋值</h3><p>先看下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">60</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在一个结构体中存放着一个字符型数组，现在要对它进行赋值只能使用初始化值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span> =</span> &#123;<span class="string">&quot;tom&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果要单独对结构体中的数组进行赋值，使用 <code>=</code> 是会报错的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    p1.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这里需要使用到字符拷贝函数 <code>strcpy</code> ，在使用的时候一定要引头文件 <code>string.h</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">60</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以单独修改结构体中的数组内的元素。</p>
<h3 id="2-结构体中的深浅拷贝"><a href="#2-结构体中的深浅拷贝" class="headerlink" title="2.结构体中的深浅拷贝"></a>2.结构体中的深浅拷贝</h3><h4 id="2-1-堆区操作函数"><a href="#2-1-堆区操作函数" class="headerlink" title="2.1 堆区操作函数"></a>2.1 堆区操作函数</h4><p>在学习之前，先了解一下在C语言中将数据存放在堆区的几个函数</p>
<h5 id="2-1-1-malloc"><a href="#2-1-1-malloc" class="headerlink" title="2.1.1 malloc"></a>2.1.1 malloc</h5><p>这个函数是属于 <code>stdlib.h</code> 头文件的函数，函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态的开辟一块size大小的空间，并返回该内存的地址，如果出现错误则会返回NULL。</p>
<h5 id="2-1-2-calloc"><a href="#2-1-2-calloc" class="headerlink" title="2.1.2 calloc"></a>2.1.2 calloc</h5><p>该函数所属的头文件也是 <code>stdlib.h</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> n, <span class="type">unsigned</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态分配n个长度为size的内存空间，并返回开辟空间的首地址，如果发生错误，则返回NULL。</p>
<h5 id="2-1-3-free"><a href="#2-1-3-free" class="headerlink" title="2.1.3 free"></a>2.1.3 free</h5><p>该函数也是属于 <code>stdlib.h</code> 头文件中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数是将指针ptr指向的内存释放出来。</p>
<h4 id="2-2-结构体的浅拷贝"><a href="#2-2-结构体的浅拷贝" class="headerlink" title="2.2 结构体的浅拷贝"></a>2.2 结构体的浅拷贝</h4><p>比如下面的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">60</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span> =</span> &#123;<span class="string">&quot;tom&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span> =</span> &#123;<span class="string">&quot;alax&quot;</span>, <span class="number">19</span>&#125;;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\n&quot;</span>, p1.name, p1.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\n&quot;</span>, p2.name, p2.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种是将p2中的内容逐字逐句的拷贝到p1中</p>
<p>而如果将结构体中的name开辟到堆区，然后再使用 <code>=</code> 进行拷贝，然后使用完再将堆区的内容释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>;</span></span><br><span class="line">    p1.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p1.name)*<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    p1.age = <span class="number">18</span>;</span><br><span class="line">    p2.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2.name)*<span class="number">120</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p2.name, <span class="string">&quot;alax&quot;</span>);</span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    <span class="keyword">if</span> (p1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1.name);</span><br><span class="line">        p1.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p2.name);</span><br><span class="line">        p2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码会导致程序崩溃，为什么会导致整个情况，原因就是深拷贝和浅拷贝的问题</p>
<h4 id="2-3-结构体的深拷贝"><a href="#2-3-结构体的深拷贝" class="headerlink" title="2.3 结构体的深拷贝"></a>2.3 结构体的深拷贝</h4><p>在上一节讲到了直接使用 <code>=</code> 将p1中的内容浅拷贝到p2中，这种是结构体中的内容存放到栈区才能使用这种拷贝方法，但如果是在堆区的内容使用浅拷贝就会导致报错</p>
<p>拿上面的代码来说：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>;</span></span><br><span class="line">    p1.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p1.name)*<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    p1.age = <span class="number">18</span>;</span><br><span class="line">    p2.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2.name)*<span class="number">120</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p2.name, <span class="string">&quot;alax&quot;</span>);</span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    <span class="keyword">if</span> (p1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1.name);</span><br><span class="line">        p1.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p2.name);</span><br><span class="line">        p2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先分配出 <code>sizeof(p1.name)*60</code> 的空间到堆区，执行完语句之后会返回出该堆区的地址，然后将返回的地址放在 <code>p1.name</code> 中，p2也是，只不过存放的是 <code>sizeof(p2.name)*120</code> 大小的堆空间中。</p>
<p>接下来执行 <code>p1 = p2</code> ，是将p2中的内容逐条放入p1中，这里也包括开辟的堆区空间，后面就进入释放堆区内存了，因为p1中的name存放的是p2中name存储的地址，在释放时p1先释放了那块区域，p2后面又释放了那块区域的地址，导致重复释放了。</p>
<p>为了解决这个问题，就需要使用到深拷贝的方法了，这种方法就是先将p1中的name中存放的地址释放，然后再开辟一块空间，将p2 name中存放的值放到那块新开辟的空间，然后把那块空间的地址存放到p1.name中，这样就可以避免重复释放的问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deep_copy</span><span class="params">(<span class="keyword">struct</span> Person* p1, <span class="keyword">struct</span> Person* p2)</span>&#123;</span><br><span class="line">    <span class="comment">//深拷贝函数</span></span><br><span class="line">    <span class="keyword">if</span> (p1-&gt;name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1-&gt;name); <span class="comment">//先释放原来p1中堆区地址</span></span><br><span class="line">        p1-&gt;name = <span class="literal">NULL</span>; <span class="comment">//避免空指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    p1-&gt;name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2-&gt;name)*<span class="number">120</span>);<span class="comment">//重新开辟空间</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1-&gt;name, p2-&gt;name);</span><br><span class="line">    p1-&gt;age = p2-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>;</span></span><br><span class="line">    p1.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p1.name)*<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    p1.age = <span class="number">18</span>;</span><br><span class="line">    p2.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2.name)*<span class="number">120</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p2.name, <span class="string">&quot;alax&quot;</span>);</span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    deep_copy(&amp;p1, &amp;p2);</span><br><span class="line">    <span class="keyword">if</span> (p1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1.name);</span><br><span class="line">        p1.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p2.name);</span><br><span class="line">        p2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码运行后就会达到指定的效果且不会崩。</p>
<h2 id="五、结构体和共用体"><a href="#五、结构体和共用体" class="headerlink" title="五、结构体和共用体"></a>五、结构体和共用体</h2><h3 id="1-结构体的嵌套"><a href="#1-结构体的嵌套" class="headerlink" title="1.结构体的嵌套"></a>1.结构体的嵌套</h3><p>这里是对结构体的一个补充，在一个结构体中又有一个结构体，这个就叫做结构体的嵌套。</p>
<p>比如说有一个物品它是由零件1、零件2、零件3、零件4组成，但在零件4中又包含着小零件1、小零件2、小零件3，用代码表示出来为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> short_part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_3[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">goods</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_3[<span class="number">10</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> <span class="title">p4</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化值的写法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> short_part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_3[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">goods</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_3[<span class="number">10</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> <span class="title">p4</span>;</span></span><br><span class="line">&#125; g = &#123; <span class="string">&quot;luosi&quot;</span>, <span class="string">&quot;jigai&quot;</span>, <span class="string">&quot;suiji&quot;</span>, &#123;<span class="string">&quot;xiao&quot;</span>, <span class="string">&quot;da&quot;</span>, <span class="string">&quot;op&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>如果要给 <code>part_4</code> 中的内容重新赋值是不可以的，只能使用字符串函数 <code>strcpy</code> 但是这个在不同的编译器上可以执行操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">part_4</span> &#123;</span><br><span class="line">    <span class="type">char</span> short_part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_3[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">goods</span> &#123;</span><br><span class="line">    <span class="type">char</span> part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_3[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">part_4</span> p4;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">goods</span> g = &#123; <span class="string">&quot;luosi&quot;</span>, <span class="string">&quot;jigai&quot;</span>, <span class="string">&quot;suiji&quot;</span>, &#123;<span class="string">&quot;xiao&quot;</span>, <span class="string">&quot;da&quot;</span>, <span class="string">&quot;op&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(g.part_1, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, g.part_1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><p>在之前学数组的时候知道，在定义数组时需要先固定好数组的长度，这样会面临着一个问题就是如果该数组定义的长度不够存储的数据长度，会导致多出来的内容无法存储。如果存储的数据少于数组的长度，就会导致内存浪费。</p>
<p>这个时候就可以使用链表来解决这些问题。</p>
<h4 id="2-1-链表概述"><a href="#2-1-链表概述" class="headerlink" title="2.1 链表概述"></a>2.1 链表概述</h4><p>链表的本质是结构体，它里面包含一个尾指针来指向下一块链表的内容，还包含一块区域来存储内容。</p>
<p>简单的链表示意图：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%93%BE%E8%A1%A8%E6%A6%82%E8%BF%B0%E7%A4%BA%E6%84%8F%E5%9B%BE1.png"></p>
<p>就像是一堆小朋友手拉着手一样，第一个就是老师做指向。</p>
<p>下面简单创建一个班级的链表，而这个链表的每个节点是学生</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> cName[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span><span class="comment">//用于指向下一个节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>链表就不用担心长度会超范围了。</p>
<h4 id="2-2-静态链表"><a href="#2-2-静态链表" class="headerlink" title="2.2 静态链表"></a>2.2 静态链表</h4><p>静态链表和上面的一样，每个节点后跟着下一个节点的地址，而这个节点的地址需要手动去添加，最后一个节点的地址为NULL是为了避免空指针的产生。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s5</span> =</span> &#123;<span class="number">10</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s4</span> =</span> &#123; <span class="number">20</span>, &amp;s5 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s3</span> =</span> &#123; <span class="number">30</span>, &amp;s4 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s2</span> =</span> &#123; <span class="number">40</span>, &amp;s3 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span> =</span> &#123; <span class="number">50</span>, &amp;s2 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是实现了静态的链表，但拿到第一个节点的地址就能得到整个链表了，如何将静态链表输出出来，就是需要靠另外一个指针来辅助输出出来</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s5</span> =</span> &#123;<span class="number">10</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s4</span> =</span> &#123; <span class="number">20</span>, &amp;s5 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s3</span> =</span> &#123; <span class="number">30</span>, &amp;s4 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s2</span> =</span> &#123; <span class="number">40</span>, &amp;s3 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span> =</span> &#123; <span class="number">50</span>, &amp;s2 &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pCount</span> =</span> &amp;s1;</span><br><span class="line">    <span class="keyword">while</span> (pCount != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pCount-&gt;iNumber);</span><br><span class="line">        pCount = pCount-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现先创建一个指针用于存储第一条节点的地址，在每次变量完之后该指针又指向下一条节点的地址，直到最后一个节点，最后一个节点没有任何指向，所以地址为 <code>NULL</code> ，这样就实现了静态指针的输出。</p>
<h4 id="2-3-动态链表"><a href="#2-3-动态链表" class="headerlink" title="2.3 动态链表"></a>2.3 动态链表</h4><p>动态链表并不是像静态链表一样，每次添加元素就是用声明的方式，非常的麻烦，而动态链表是每次存入数据时使用语句开辟空间，再将数据存放链表中</p>
<p>这里先了解一下分配内存空间的三个函数</p>
<p>1.malloc</p>
<p>这个函数是属于 <code>stdlib.h</code> 头文件的函数，函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态的开辟一块size大小的空间，并返回该内存的地址，如果出现错误则会返回NULL。</p>
<p>2.calloc</p>
<p>该函数所属的头文件也是 <code>stdlib.h</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> n, <span class="type">unsigned</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态分配n个长度为size的内存空间，并返回开辟空间的首地址，如果发生错误，则返回NULL。</p>
<p>3.free</p>
<p>该函数也是属于 <code>stdlib.h</code> 头文件中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数是将指针ptr指向的内存释放出来。</p>
<p>如何创建动态的链表，其实和前面静态链表的一样，在一个链表中有节点，节点中一部分是存放数据的，另一部分是存放下一个节点的地址，创建动态链表也是依靠的是这个，而和静态不同的是，动态链表是在函数中动态分配一块内存给下一个节点，而不是我们使用声明静态的分配内存</p>
<p>动态链表的写法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student* <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNew</span>, *<span class="title">pEnd</span>;</span></span><br><span class="line">    pNew = pEnd = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Place input number\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    <span class="keyword">while</span> (pNew-&gt;iNumber != <span class="number">-1</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">            pHead = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">            pEnd-&gt;pNext = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Place input number\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Student</code> 是每个节点的结构</p>
<p>而 <code>Create</code> 为创建动态节点，首先需要创建出一个头链，头链固定不动，如果后面的节点要增加和删除只需要改变它前面一个节点中指向下一个节点的地址即可。</p>
<p>这里创建了两个指针，分别是 <code>pNew</code> 和 <code>pEnd</code> </p>
<p><code>pNew</code> 是创建出内存的指针，当每次在链表中增加一个节点时， <code>pNew</code> 就是为了接受到这一个新节点的地址。</p>
<p><code>pEnd</code> 是指向增加的节点，避免每次添加节点后又重新遍历一遍链表元素后再在最后添加，所以每一次增加都会用 <code>pEnd</code> 来记录最后一个节点的地址。</p>
<p>输出链表的方法和静态输出的方法一致</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">p</span> =</span> create();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;iNumber);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-1-链表练习1"><a href="#2-3-1-链表练习1" class="headerlink" title="2.3.1 链表练习1"></a>2.3.1 链表练习1</h5><p>新建一个班级类，每一个学生作为一个节点，每个节点的内容有学生名字和学号。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> cName[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">struct</span> Student* <span class="title function_">Create</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pEnd</span>, *<span class="title">pNew</span>;</span></span><br><span class="line">    pEnd = pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Place input name and number\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;(pNew-&gt;cName));</span><br><span class="line">    <span class="keyword">while</span> (pNew-&gt;iNumber != <span class="number">-1</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            pNew-&gt;pNext = pHead;</span><br><span class="line">            pHead = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">            pEnd-&gt;pNext = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Place input name and number\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;(pNew-&gt;cName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Student* ph)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (ph != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, ph-&gt;iNumber, ph-&gt;cName);</span><br><span class="line">        ph = ph-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">ph</span> =</span> Create();</span><br><span class="line">    Print(ph);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-增加节点"><a href="#2-4-增加节点" class="headerlink" title="2.4 增加节点"></a>2.4 增加节点</h4><p>节点的增加其实是将该节点前的指针的地址指向该节点，并让该节点的指针指向原来是一个节点的地址给它重新赋值过去即可。</p>
<h5 id="2-4-1-在头节点增加"><a href="#2-4-1-在头节点增加" class="headerlink" title="2.4.1 在头节点增加"></a>2.4.1 在头节点增加</h5><p>在头节点增加节点是一种非常简单的方法传入的参数就只需要传入一个头节点即可。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student* <span class="title function_">insert</span><span class="params">(<span class="keyword">struct</span> Student* pHead)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNew</span>;</span></span><br><span class="line">    pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    pNew-&gt;pNext = pHead;</span><br><span class="line">    pHead = pNew;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程</title>
    <url>/2025/01/17/5f463418ae32/</url>
    <content><![CDATA[<h1 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h1><h2 id="一、网络编程概念"><a href="#一、网络编程概念" class="headerlink" title="一、网络编程概念"></a>一、网络编程概念</h2><h3 id="1-mac地址"><a href="#1-mac地址" class="headerlink" title="1.mac地址"></a>1.mac地址</h3><p>标识网卡的id，理论上这个id全球唯一</p>
<p>mac地址一般用来标识主机的id，这个id是物理地址，不会改变</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8Bmac.png"></p>
<h3 id="2-IP地址"><a href="#2-IP地址" class="headerlink" title="2. IP地址"></a>2. IP地址</h3><p>IP地址是标识主机的id，这个id是虚拟的，会改变的。</p>
<p>一个IP将其分为子网id和主机id，子网id和主机id需要和子网掩码一起看，比如说下面有一个IP地址和子网掩码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.1.1.2</span><br><span class="line">255.255.255.0</span><br></pre></td></tr></table></figure>

<p>上面的192.168.11.23是IP地址，而下面的255.255.255.0是子网掩码，查看时需要看下面的子网掩码。</p>
<p>IP中被连续的1覆盖的位就是子网id</p>
<p>IP中被连续的0覆盖的位就是主机id</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8B%E5%AD%90%E7%BD%91id.png"></p>
<p>所以子网id是：10.1.1</p>
<p>主机id是：2</p>
<p>网段地址：10.1.1.0</p>
<p>广播地址：10.1.1.255</p>
<p>主机id分配的范围：10.1.1.1-&gt;10.1.1.254</p>
<p>ping：这是一个用来测试两台主机的网络联通性的命令</p>
<p>ens33是网络名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.131.133 设置的ip</span><br><span class="line">netmask子网掩码255.255.255.0</span><br></pre></td></tr></table></figure>

<h3 id="3-端口"><a href="#3-端口" class="headerlink" title="3.端口"></a>3.端口</h3><p>作用：用来标识应用程序（进程）</p>
<p>port：2个字节 0-65535</p>
<p>0-1023知名端口</p>
<p>自定义端口1024-65535</p>
<h3 id="4-OSI七层模型"><a href="#4-OSI七层模型" class="headerlink" title="4.OSI七层模型"></a>4.OSI七层模型</h3><p>物理层：双绞线接口类型，光纤的传输速率等等</p>
<p>数据链路层：mac 负责收发数据</p>
<p>网络层：IP 给两台提供路径选择</p>
<p>传输层：port 区分数据递送到哪一个应用程序</p>
<p>会话层：建立连接</p>
<p>表示层：解码</p>
<p>应用层：应用程序，拿到数据</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/7%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<p>TCP&#x2F;IP四层协议</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/4%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<h3 id="5-协议"><a href="#5-协议" class="headerlink" title="5.协议"></a>5.协议</h3><p>规定了数据传输的方法和格式</p>
<p>应用层协议：<br>FTP：文本传输协议</p>
<p>HTTP：超文本传输协议</p>
<p>NFS：网络文件系统</p>
<p>传输层协议：</p>
<p>TCP：传输控制协议</p>
<p>UDP：用户数据包协议</p>
<p>网络层协议：</p>
<p>IP：因特网互联协议</p>
<p>ICMP：因特网控制报文协议，比如ping</p>
<p>IGMP：因特网组管理协议</p>
<p>链路层协议：<br>ARP：地址解析协议 通过IP找mac地址</p>
<p>RARP：反向地址解析协议，通过mac找IP</p>
<p>mac头部：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/mac%E5%A4%B4%E9%83%A8.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/mac%E5%A4%B4%E9%83%A82.png"></p>
<h3 id="6-网络通讯过程"><a href="#6-网络通讯过程" class="headerlink" title="6.网络通讯过程"></a>6.网络通讯过程</h3><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BB%84%E5%8C%85%E8%BF%87%E7%A8%8B.png"></p>
<h3 id="7-arp"><a href="#7-arp" class="headerlink" title="7.arp"></a>7.arp</h3><p>地址解析协议：通过IP找mac地址</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/arp%E8%AF%B7%E6%B1%82.png"></p>
<p>arp请求包：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/arp%E5%A4%B4%E9%83%A8.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/arp%E9%80%9A%E8%AE%AF.png"></p>
<h3 id="8-网络设计模式"><a href="#8-网络设计模式" class="headerlink" title="8.网络设计模式"></a>8.网络设计模式</h3><p>有两种设计模式</p>
<p>B&#x2F;S browser&#x2F;server 使用服务器进行计算</p>
<p>优点：客户端安全，开发周期短</p>
<p>缺点：性能低</p>
<p>C&#x2F;S cilent&#x2F;server 使用客户端就行计算</p>
<p>优点：性能好</p>
<p>缺点：客户端容易篡改数据，开发周期较长</p>
<h3 id="9-进程间通讯"><a href="#9-进程间通讯" class="headerlink" title="9.进程间通讯"></a>9.进程间通讯</h3><p>之前学习了一些进程间的通讯，比如无名管道、有名管道、mmap、文件、信号、消息队列、共享内存，但这些通讯都存在一个问题就是只能用于本机的进程间通讯。</p>
<p>如果我们想让不同的主机之间进行通讯，我们需要使用到 socket。</p>
<h3 id="10-三次握手"><a href="#10-三次握手" class="headerlink" title="10.三次握手"></a>10.三次握手</h3><p>在TCP通讯的时候会需要进行三次握手，当上次握手结束后就会建立TCP的通讯。一般使用在连接。</p>
<p>这个过程和我们打电话的过程是一样的，当你打了一个电话给对方首先需要确定一下对方是不是接通了，就得先说一声喂，对方收到你的喂后也会回复一个喂，接收到这个喂之后再进行一个确认就可以与对方进行通话了。</p>
<p>三次握手的示意图如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>当客户端连接服务器的时候会先发送一个数据包，数据包中的<code>SYN</code>位会置为1，当服务器接收到这个数据包后也会发送一个数据包给客户端，告诉客户端我已经接收到你的连接，而这个数据包中的<code>ACK</code>会置为1，当客户端接收到这个服务器的数据包后又会再发送一个数据包，这个数据包中的<code>SYN</code>会置为0，发送完这个数据包后就可以开始通讯了。</p>
<p>而每个数据包中都有一个序列号<code>seq</code>和确定序列号<code>ack</code>，序列号是拿来表示发送的数据包的序号的，而确定序列号的含义有两条：</p>
<ul>
<li>确定收到对方的数据包</li>
<li>期待下一次对方的序列号为我的确定序列号</li>
</ul>
<p>这里的握手必须得是三次，因为在传输的过程中很有可能会发生传输了一个数据包但是延迟比较高的情况，如果是只握两次手，那么第一次扔包过去的时候可能时间会很长，那么客户端又会扔一个数据包，这个数据包一下子就扔到了服务器上，然后服务器马上就返回一个确定数据包，然后客户端就开始通讯了，在通讯的时候，第一次扔的包成功的给到了服务器，服务器又以为要建立一个行的连接，这个时候就会产生另外一个连接队列，但本质上两个队列都是一样的。</p>
<p>而如果是三次握手，客户端已经确定好连接了，当那个包又回来时，服务器就会自动忽略那个数据包，就不会再创建一个连接队列了。</p>
<h3 id="11-四次挥手"><a href="#11-四次挥手" class="headerlink" title="11.四次挥手"></a>11.四次挥手</h3><p>四次挥手一般出现在关闭连接的时候。</p>
<p>这个过程可以理解为你和别人打电话结束后要挂电话的情况，你要挂电话你就得说我要挂了，对方会回复说好的，然后就会说我也要挂掉电话了，然后你回复好的，就可以把电话挂了。</p>
<p>四次挥手的示意图如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p>
<p>主动方执行<code>close</code>时，就会给被动方一个数据包，这个数据包中<code>FIN</code>置为1，然后被动方接收到这个关闭数据包后也会回复一个数据包，这个数据包中<code>ACK</code>为1，<code>FIN</code>为0，紧接着再发送一个挂掉的数据包，也就是<code>close</code>，这个数据包和主动方第一次发送的包一样，然后等待主动方发送挂掉的数据包，接收到这个数据包后就可以结束连接了。</p>
<p>而这个主动和被动可以是客户端主动，服务器被动，也可以是服务器主动，客户端被动，这个无所谓的</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p>
<p>而最大报文生存时间是被动方需要等待的，不管被动方是哪一个。</p>
<p>在这个过程中虽然调用了close，但是还是可以收发数据的，这个过程叫做半关闭，半关闭的函数后面会说</p>
<h3 id="12-mss"><a href="#12-mss" class="headerlink" title="12.mss"></a>12.mss</h3><p>mss是最大报文长度，一般出现在三次握手的前两次，用来告诉对方发送数据的最大长度。</p>
<h3 id="13-MTU"><a href="#13-MTU" class="headerlink" title="13.MTU"></a>13.MTU</h3><p>网卡的最大传输单元</p>
<h3 id="14-2MSL"><a href="#14-2MSL" class="headerlink" title="14.2MSL"></a>14.2MSL</h3><p>为了让4次握手关闭流程更加可靠。还有其它功能，但这里只了解这个问题即可。</p>
<h3 id="14-滑动窗口"><a href="#14-滑动窗口" class="headerlink" title="14.滑动窗口"></a>14.滑动窗口</h3><p>每一次读取数据之后，回ack报文，报文中携带当前缓冲区大小，用来告知对方我缓冲区的空间。</p>
<h3 id="15-TCP转换图"><a href="#15-TCP转换图" class="headerlink" title="15.TCP转换图"></a>15.TCP转换图</h3><p>TCP转换图其实如下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/TCP%E8%BD%AC%E6%8D%A2%E5%9B%BE.png"></p>
<p>本质上就是在建立连接和断开连接的过程中主动方和被动方的一些标志位</p>
<h2 id="二、Socket编程"><a href="#二、Socket编程" class="headerlink" title="二、Socket编程"></a>二、Socket编程</h2><h3 id="1-套接字概念"><a href="#1-套接字概念" class="headerlink" title="1.套接字概念"></a>1.套接字概念</h3><p>套接字其实就是一个插座，是计算机之间进行通讯的一种约定或一种方法。</p>
<h3 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2.预备知识"></a>2.预备知识</h3><h4 id="2-1-网络字节序"><a href="#2-1-网络字节序" class="headerlink" title="2.1 网络字节序"></a>2.1 网络字节序</h4><p>这里需要重新回忆一下C语言中的大端存储和小端存储了。其实也就是每个人的计算机的字节序存储方式不一样，有些是大端存储，而有些是小端存储，如果直接进行通讯就像中国人和英语人交流信笺一样，两边的人都看不懂对象书写的内容，这个时候如果在写信的时候将自己写的内容转换成对方看得懂的内容是不是就能很好的解决看不懂的问题了。</p>
<p>为了使网络程序具有可移植性，使同样的C代码在大端计算机和小端计算机上编译后都能正常运行，就可以使用以下库函数做网络字节序和主机字节序的转换</p>
<p>主机字节序转换为网络字节序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将无符号整数hostlong从主机字节序转换为网络字节序</span><br><span class="line">参数：</span><br><span class="line">    hostlong：需要转换的主机字节序</span><br><span class="line">返回值：</span><br><span class="line">    转换后的网络字节序</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将无符号短整型hostshort从主机字节序转换为网络字节序</span><br><span class="line">参数：</span><br><span class="line">    hostshort：需要转换的主机字节序</span><br><span class="line">返回值：</span><br><span class="line">    转换后的网络字节序    </span><br></pre></td></tr></table></figure>

<p>网络字节序转换成主机字节序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将无符号短整数netlong转换为主机字节序</span><br><span class="line">参数：</span><br><span class="line">    netlong：需要转换的网络字节序</span><br><span class="line">返回值：</span><br><span class="line">    转换后的主机字节序</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将无符号短整数netshort转换为主机字节序</span><br><span class="line">参数：</span><br><span class="line">    netshort：需要转换的网络字节序</span><br><span class="line">返回值：</span><br><span class="line">    转换后的主机字节序</span><br></pre></td></tr></table></figure>

<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将长主机字节序转换为网络字节序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = *((<span class="type">unsigned</span> <span class="type">int</span>*)buf);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sum = htonl(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d.%d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//将短主机字节序转换为网络字节序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = htons(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, b);</span><br><span class="line">    <span class="comment">//将长网络字节序转换为主机字节序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c = ntohl(sum);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* pc = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d.%d\n&quot;</span>, *pc, *(pc+<span class="number">1</span>), *(pc+<span class="number">2</span>), *(pc+<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//将短网络字节序转换为主机字节序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d = htons(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-IP地址转换函数"><a href="#2-2-IP地址转换函数" class="headerlink" title="2.2 IP地址转换函数"></a>2.2 IP地址转换函数</h4><p>当你选择已经有一个需要发送的IP：192.168.1.2，你如果直接发送，网络是没办法知道你这个是什么内容的，需要进行一次转换将192.168.1.2转换为192，168，1，2这种使用数组存放的形式。而网络传给主机的IP地址为192，168，1，2这种使用数组的IP地址，所以需要经过转换变成192.168.1.2的形式。</p>
<p>在C语言中提供了两个函数来处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">void</span>* dst)</span>;</span><br><span class="line">功能；</span><br><span class="line">    将点分十进制串转成<span class="number">32</span>位网络大端的数据</span><br><span class="line">参数：</span><br><span class="line">    af：</span><br><span class="line">        AF_INET	IPV4</span><br><span class="line">        AF_INET6 IPV6</span><br><span class="line">    src：点分十进制串的首地址</span><br><span class="line">    dst：<span class="number">32</span>位网络数据的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回<span class="number">1</span>（网络地址已成功连接）</span><br><span class="line">    失败：<span class="number">0</span>（src 不包含表示指定地址系列中有效网络地址的字符串）</span><br><span class="line">        <span class="number">-1</span>（af 不包含有效的地址系列）</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">char</span>* dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将<span class="number">32</span>位大端的网络数据转成点分十进制</span><br><span class="line">参数：</span><br><span class="line">    af：</span><br><span class="line">        AF_INET	IPV4</span><br><span class="line">        AF_INET6 IPV6</span><br><span class="line">    src：<span class="number">32</span>位大端网络数地址</span><br><span class="line">    dst：存储点分十进制串地址</span><br><span class="line">    size：存储点分制串数组的大小</span><br><span class="line">返回值：</span><br><span class="line">    存储点分制串数组首地址</span><br></pre></td></tr></table></figure>

<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;192.168.1.2&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    inet_pton(AF_INET, buf, &amp;number);</span><br><span class="line">    p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;number;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p + <span class="number">2</span>), *(p + <span class="number">3</span>));</span><br><span class="line">    inet_ntop(AF_INET, &amp;number, ip, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-sockaddr数据结构"><a href="#2-3-sockaddr数据结构" class="headerlink" title="2.3 sockaddr数据结构"></a>2.3 sockaddr数据结构</h4><p>ipv4套接字结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">/* 地址族: AF_INET */</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port; <span class="comment">/* 按网络字节次序的端口 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* internet地址 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet地址. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">u_int32_t</span> s_addr; <span class="comment">/* 按网络字节次序的地址 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ipv6套接字结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="type">in_port_t</span>       sin6_port;     <span class="comment">/* port number */</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_scope_id; <span class="comment">/* Scope ID (new in 2.4) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   s6_addr[<span class="number">16</span>];   <span class="comment">/* IPv6 address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通用套接字结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; <span class="comment">/*AF_xxx*/</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];	<span class="comment">/*通用的地址*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-网络套接字函数"><a href="#3-网络套接字函数" class="headerlink" title="3.网络套接字函数"></a>3.网络套接字函数</h3><h4 id="3-1-socket模型创建流程图"><a href="#3-1-socket模型创建流程图" class="headerlink" title="3.1 socket模型创建流程图"></a>3.1 socket模型创建流程图</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/socket%E6%A8%A1%E5%9E%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h4 id="3-2-socket函数"><a href="#3-2-socket函数" class="headerlink" title="3.2 socket函数"></a>3.2 socket函数</h4><p>创建套接字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">功能：</span><br><span class="line">    建立一个用于交流的端点并且返回一个描述符</span><br><span class="line">参数：</span><br><span class="line">    domain：AF_INET</span><br><span class="line">    type：确定通信语句</span><br><span class="line">        SOCK_STREAM 提供有序的，可靠的，双向的，基于字节流的通讯。可能支持带外传输。</span><br><span class="line">        SOCK_DGRAM 提供数据报（不面向连接的, 不可靠的固定最大长度的信息）。</span><br><span class="line">        SOCK_SEQPACKET 提供有序的，可靠的，双向的，基于固定最大长度的数据报传输路径；需要一个读取整个伴有输入系统调用的包的用户。</span><br><span class="line">        SOCK_RAW 提供未加工(raw)的网络协议通道。</span><br><span class="line">        SOCK_RDM 提供可靠的数据报层，但是不保证顺序。</span><br><span class="line">        SOCK_NONBLOCK 设置  O_NONBLOCK 的标志于新打开的文件描述符。 通过这个标志可以不用调用 fcntl(<span class="number">2</span>) 来达到相同的结果。</span><br><span class="line">        SOCK_CLOEXEC 设置 close-on-exec  (FD_CLOEXEC)  的标志于新打开的文件描述符。参见 open(<span class="number">2</span>) 中关于 O_CLOEXEC 的描述，因为一些原因这个标志很有用。</span><br><span class="line">    protocol：指定一个协议用于套接字，一般为<span class="number">0</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-connect函数"><a href="#3-3-connect函数" class="headerlink" title="3.3 connect函数"></a>3.3 connect函数</h4><p>连接服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    连接服务器的函数</span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字文件描述符</span><br><span class="line">    addr：ipv4或者ipv6的结构体，但需要转换为通用结构体</span><br><span class="line">    addrlen：结构体的大小。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sock_fd, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    sock_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//连接主机</span></span><br><span class="line">    sa.sin_family = AF_INET;</span><br><span class="line">    sa.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.160.1&quot;</span>, &amp;sa.sin_addr.s_addr);</span><br><span class="line">    connect(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="comment">//发送内容</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(sock_fd, buf, <span class="keyword">sizeof</span>(buf));<span class="comment">//发送数据给服务器</span></span><br><span class="line">        n = read(sock_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDIN_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-tcp服务器通信流程"><a href="#3-4-tcp服务器通信流程" class="headerlink" title="3.4 tcp服务器通信流程"></a>3.4 tcp服务器通信流程</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/tcp%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B1.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/tcp%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png"></p>
<h4 id="3-5-bind绑定"><a href="#3-5-bind绑定" class="headerlink" title="3.5 bind绑定"></a>3.5 bind绑定</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    给套接字绑定端口和ip</span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字</span><br><span class="line">    addr：ipv4套接字结构体地址</span><br><span class="line">    addrlen：ipv4套接字结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">    成功<span class="number">0</span></span><br><span class="line">    失败<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="3-6-listen"><a href="#3-6-listen" class="headerlink" title="3.6 listen"></a>3.6 listen</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> backlog)</span>;</span><br><span class="line">功能：</span><br><span class="line">    在一个套接字上设置倾听连接</span><br><span class="line">参数：</span><br><span class="line">    s：套接字</span><br><span class="line">    backlog：已完成连接队列和未完成连接队列数值和的最大值 <span class="number">128</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span>，并设置相应错误代码</span><br></pre></td></tr></table></figure>

<h4 id="3-7-accept"><a href="#3-7-accept" class="headerlink" title="3.7 accept"></a>3.7 accept</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> socket, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    在一个套接字上接收一个连接,如果连接队列没有新的连接，accept回阻塞</span><br><span class="line">参数：</span><br><span class="line">    socket：套接字</span><br><span class="line">    address：获取客户端的ip和端口信息 ipv4套接字结构体地址</span><br><span class="line">    addrlen：IPv4套接字结构体的大小的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：新的已连接套接字的文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>这里要说明一下，accept很任意被系统的中断给关闭，所以在使用accept的时候我们需要添加一个判断，并且要过滤系统中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">agare:</span><br><span class="line">ret = accept(sock, &amp;ipv4, &amp;ipv4_len);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))&#123;</span><br><span class="line">        <span class="keyword">goto</span> agare;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-tcp服务器通信步骤"><a href="#3-8-tcp服务器通信步骤" class="headerlink" title="3.8 tcp服务器通信步骤"></a>3.8 tcp服务器通信步骤</h4><p>1.创建套接字 socket</p>
<p>2.绑定 bind</p>
<p>3.监听 listen</p>
<p>4.提取 accept</p>
<p>5.读写</p>
<p>6.关闭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sock_fd, new_sock_fd, ret = <span class="number">-1</span>, size, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    sa.sin_family = AF_INET;</span><br><span class="line">    sa.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line">    <span class="comment">//inet_pton(AF_INET, &quot;192.168.160.132&quot;, &amp;sa.sin_addr.s_addr);</span></span><br><span class="line">    sa.sin_addr.s_addr = INADDR_ANY;<span class="comment">//绑定的是通配地址</span></span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    sock_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock_fd == SO_ERROR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.绑定bind</span></span><br><span class="line">    ret = bind(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="keyword">if</span> (ret == SO_ERROR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.监听listen</span></span><br><span class="line">    ret = listen(sock_fd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == SO_ERROR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(sa);</span><br><span class="line">    <span class="comment">//4.提取accept</span></span><br><span class="line">    new_sock_fd = accept(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;sa, &amp;size);</span><br><span class="line">    <span class="keyword">if</span> (new_sock_fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, word\n&quot;</span>);</span><br><span class="line">    <span class="comment">//5.读写</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        n = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(new_sock_fd, buf, SIZE);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, SIZE);</span><br><span class="line">        n = read(new_sock_fd, buf, SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;He speak:%s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.关闭</span></span><br><span class="line">    close(new_sock_fd);</span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以利用read读取客户端发送的数据长度来判断客户端是否关闭，当read读取的内容为0，就可以判断客户端关闭。</p>
<h4 id="3-9-tcp服务器多客户端连接（进程版）"><a href="#3-9-tcp服务器多客户端连接（进程版）" class="headerlink" title="3.9 tcp服务器多客户端连接（进程版）"></a>3.9 tcp服务器多客户端连接（进程版）</h4><p>3.8中的只能连接一个客户端，但如果我们这个服务端要连接多个客户端，这个时候就需要使用到之前学过的进程方面的知识点了，过程如下：</p>
<p>主进程连接队列，子进程处理进入已连接队列的套接字</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF.png"></p>
<p>按照这样设计，那么主进程中就可以不需要已连接队列的操作，子进程就可以不需要未连接队列。</p>
<p>代码设计如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">1.创建套接字</span><br><span class="line">2.绑定端口</span><br><span class="line">3.监听</span><br><span class="line">4.提取连接</span><br><span class="line">5.创建进程</span><br><span class="line">6.关闭</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signum, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* context)</span>&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        p = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有子进程要退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;信号为:%d\n子进程退出\n&quot;</span>, signum);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="number">-1</span>, ret = <span class="number">-1</span>, forkNumber = <span class="number">-1</span>, new_sock = <span class="number">-1</span>, ipv4_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ipv4</span>, <span class="title">client_ipv4</span>;</span></span><br><span class="line">    <span class="comment">//设置一个阻塞集，避免在接收信号之前就有这个信号</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.绑定端口</span></span><br><span class="line">    ipv4.sin_family = AF_INET;</span><br><span class="line">    ipv4.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.40.131&quot;</span>, &amp;ipv4.sin_addr.s_addr);</span><br><span class="line">    ret = bind(sock, (<span class="keyword">struct</span> sockaddr*)&amp;ipv4, <span class="keyword">sizeof</span>(ipv4));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.监听</span></span><br><span class="line">    ret = listen(sock, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.提取连接</span></span><br><span class="line">        <span class="type">char</span> ip[<span class="number">16</span>];</span><br><span class="line">        ipv4_len = <span class="keyword">sizeof</span>(ipv4);</span><br><span class="line">        again:</span><br><span class="line">        new_sock = accept(sock, (<span class="keyword">struct</span> sockaddr*)&amp;ipv4, &amp;ipv4_len);</span><br><span class="line">        <span class="keyword">if</span> (new_sock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))&#123;</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;new client ip:%s port:%d\n&quot;</span>, inet_ntop(AF_INET, &amp;ipv4.sin_addr.s_addr, ip, <span class="number">16</span>), ntohs(ipv4.sin_port));</span><br><span class="line">        <span class="keyword">if</span> (new_sock == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.创建进程</span></span><br><span class="line">        forkNumber = fork();</span><br><span class="line">        <span class="keyword">if</span> (forkNumber == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (forkNumber == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//关闭等待队列</span></span><br><span class="line">            <span class="type">char</span> buf[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            ret = close(sock);</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="comment">//对就绪的套接字进行操作</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                n = read(new_sock, buf, <span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;new client ip:%s port:%d is close!\n&quot;</span>, inet_ntop(AF_INET, &amp;ipv4.sin_addr.s_addr, ip, <span class="number">16</span>), ntohs(ipv4.sin_port));</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//客户端退出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;new client ip:%s port:%d is close!\n&quot;</span>, inet_ntop(AF_INET, &amp;ipv4.sin_addr.s_addr, ip, <span class="number">16</span>), ntohs(ipv4.sin_port));</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">                    write(new_sock, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//父进程</span></span><br><span class="line">            <span class="comment">//关闭就绪队列</span></span><br><span class="line">            ret = close(new_sock);</span><br><span class="line">            <span class="keyword">while</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">                ret = close(new_sock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当子进程结束后，会产生一个信号</span></span><br><span class="line">            <span class="comment">//6.关闭</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">            act.sa_sigaction = fun1;</span><br><span class="line">            act.sa_flags = <span class="number">0</span>;</span><br><span class="line">            sigemptyset(&amp;act.sa_mask);</span><br><span class="line">            sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-tcp服务器多客户端连接（线程版）"><a href="#3-10-tcp服务器多客户端连接（线程版）" class="headerlink" title="3.10 tcp服务器多客户端连接（线程版）"></a>3.10 tcp服务器多客户端连接（线程版）</h4><p>其实设计的逻辑和进程的差不多</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP <span class="string">&quot;192.168.18.128&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockMessage</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">recvThread</span><span class="params">(<span class="type">void</span>* sockfd)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SockMessage</span> <span class="title">message</span> =</span> *((<span class="keyword">struct</span> SockMessage*)sockfd);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 用来接收客户端传过来的信息</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        n = recv(message.sockfd, buf, SIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fail not recv\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The client quited\n&quot;</span>);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s %d] is exit\n&quot;</span>, inet_ntoa(message.clientaddr.sin_addr), ntohs(message.clientaddr.sin_port));</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s %d]:%s\n&quot;</span>, inet_ntoa(message.clientaddr.sin_addr), ntohs(message.clientaddr.sin_port), buf);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    <span class="type">int</span> new_sockfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail not socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = htons(PORT);</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail not bind&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd, <span class="number">8</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail not listen&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">pthread_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockMessage</span> <span class="title">message</span>;</span></span><br><span class="line">        <span class="comment">// 接收连接</span></span><br><span class="line">        new_sockfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (new_sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fail not accept&quot;</span>);</span><br><span class="line">            close(sockfd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Get new link:[%s %d]\n&quot;</span>, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line">        message.sockfd = new_sockfd;</span><br><span class="line">        message.clientaddr = clientaddr;</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;pid, <span class="literal">NULL</span>, recvThread, (<span class="type">void</span>*)&amp;message) != <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to pthread_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_detach(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-半关闭"><a href="#4-半关闭" class="headerlink" title="4.半关闭"></a>4.半关闭</h3><p>在讲四次握手的时候说了，当调用了close后，并没有完全关闭，而会处于一种半关闭的情况，也就是主动方发生在<code>FIN_WAIT_2</code>状态时，主动方不可以在应用层发送数据，但是应用层还可以接收数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line">sockfd:需要关闭的socket的描述符</span><br><span class="line">how:允许为shutdown操作选择一下几种方法：</span><br><span class="line">    SHUT_RD(<span class="number">0</span>):关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字**不再接收数据**，任何当前在套接字接收缓冲区的数据将被无声丢弃掉</span><br><span class="line">    SHUT_WR(<span class="number">1</span>):关闭sockfd的写功能，此选项将不允许sockfd进行写操作，进程不能在对此套接字发出写操作</span><br><span class="line">    SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD，然后是SHUT_WR。</span><br></pre></td></tr></table></figure>

<h3 id="5-心跳包"><a href="#5-心跳包" class="headerlink" title="5.心跳包"></a>5.心跳包</h3><p>如果对方异常断开，本机检测不到，一直等待会浪费资源</p>
<p>所以这里可以设置一个心跳包来检测对方是不是断开了，这里的原理其实就是每隔一定的时间间隔就发送一个探测分节，如果连续发送多个探测分节对方未回，就将次连接断开</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> keepAlive = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="type">void</span>*)&amp;keepAlive, <span class="keyword">sizeof</span>(keepAlive));</span><br></pre></td></tr></table></figure>

<h3 id="6-设置端口复用"><a href="#6-设置端口复用" class="headerlink" title="6.设置端口复用"></a>6.设置端口复用</h3><p>在有些时候操作服务端时，服务端强制退出了，这个时候还没有反应过来就会导致这个端口还在占用，需要再过一段时间才会释放调这个端口的资源，那如果我们还想继续使用这个端口就得等这个端口的释放，但是我们可以设置端口的复用来解决这个问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

<p>注意：程序中设置某个端口重新使用，在这之前的其它网络程序将不能使用这个端口</p>
<h2 id="三、高并发服务器"><a href="#三、高并发服务器" class="headerlink" title="三、高并发服务器"></a>三、高并发服务器</h2><p>之前学会写了一个服务器，但之前写的服务器只是阻塞等待的服务器，也就是说来了一个客户端，服务器就需要创建一个进程或者线程去连接那个服务器，这样是很消耗资源的。</p>
<p>而还有一种服务器是非阻塞忙轮服务器，这个服务器是创建出一些进程，然后CPU就会去遍历这些进程，看看这些进程有没有空闲的，如果有客户端需要连接，CPU就会让没有连接的线程去连接，这种方法比较消耗CPU。</p>
<p>最后一种就是我们要讲的了，就是多路IO，多路IO这种方法是利用这内核的中断，当一个线程空闲后，内核就会产生一个信号给CPU，让CPU知道有进程空闲。</p>
<p>多路IO有三种监听的方式：<code>poll</code>、<code>epoll</code>、<code>select</code></p>
<p>它是用内核监听多个文件描述符的属性（读写缓冲区）变化，如果某个文件描述符的读缓冲区变化了，这个时候就是可以读了，将这个事件告知应用层。</p>
<h3 id="1-select"><a href="#1-select" class="headerlink" title="1.select"></a>1.select</h3><p>在Windows中比较采用，而且能跨平台</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, <span class="keyword">struct</span> timeval* timeout)</span>;</span><br><span class="line">功能：监听多个文件描述符的属性变化（读写异常）</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set* <span class="built_in">set</span>)</span>;  <span class="comment">// 将fd文件描述符从set集合中删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set* <span class="built_in">set</span>)</span>; <span class="comment">// 判断fd文件描述符是否在set集合中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set* <span class="built_in">set</span>)</span>; <span class="comment">// 将fd描述符添加到set集合中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set* <span class="built_in">set</span>)</span>;  <span class="comment">// 将set集合中的文件描述符清空</span></span><br><span class="line">参数：</span><br><span class="line">    nfds：最大文件描述符+<span class="number">1</span></span><br><span class="line">    readfds：需要监听的读的文件描述符存放集合</span><br><span class="line">    writefds：需要监听的写的文件描述符存放集合 <span class="literal">NULL</span></span><br><span class="line">    exceptfds：需要监听的异常的文件描述符存放集合 <span class="literal">NULL</span></span><br><span class="line">    timeout：多长时间监听一次 固定的时间，限时等待 <span class="literal">NULL</span> 永久监听</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">        <span class="type">long</span> tv_sec:<span class="comment">//秒</span></span><br><span class="line">        <span class="type">long</span> tv_usec;<span class="comment">//微秒</span></span><br><span class="line">    &#125;</span><br><span class="line">返回值：</span><br><span class="line">    返回的是变化的文件描述符的个数</span><br><span class="line">注意：变化的文件描述符会存放在监听的集合中，未变化的文件描述符会从集合中删除</span><br></pre></td></tr></table></figure>

<h4 id="1-1-使用select写TCP服务器"><a href="#1-1-使用select写TCP服务器" class="headerlink" title="1.1 使用select写TCP服务器"></a>1.1 使用select写TCP服务器</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8888     <span class="comment">// 绑定的端口</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span>    <span class="comment">// 链接的客户端</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> maxfd;</span><br><span class="line">    fd_set oldset, reset;</span><br><span class="line">    <span class="type">int</span> lenfd;     <span class="comment">// 存放变化的个数</span></span><br><span class="line">    <span class="type">int</span> cfd;</span><br><span class="line">    <span class="type">int</span> clientlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;server, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxfd = lfd;</span><br><span class="line">    <span class="comment">// 将集合中的内容清空</span></span><br><span class="line">    FD_ZERO(&amp;oldset);</span><br><span class="line">    FD_ZERO(&amp;reset);</span><br><span class="line">    <span class="comment">// 将lfd放进oldset中</span></span><br><span class="line">    FD_SET(lfd, &amp;oldset);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        reset = oldset;</span><br><span class="line">        lenfd = select(maxfd + <span class="number">1</span>, &amp;reset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (lenfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lenfd == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(lfd, &amp;reset))&#123;</span><br><span class="line">                <span class="comment">// lfd变化了，接受cfd</span></span><br><span class="line">                clientlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;clientlen);</span><br><span class="line">                <span class="keyword">if</span> (cfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 接收失败</span></span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;    <span class="comment">// 跳过这次接收</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;link!client IP:%s port:%d\n&quot;</span>, inet_ntoa(client.sin_addr), ntohs(client.sin_port));</span><br><span class="line">                <span class="comment">// 接收成功将这个文件描述符添加到oldset中</span></span><br><span class="line">                FD_SET(cfd, &amp;oldset);</span><br><span class="line">                <span class="comment">// 判断一下这个描述符是否大于最大文件描述符</span></span><br><span class="line">                <span class="keyword">if</span> (cfd &gt; maxfd)&#123;</span><br><span class="line">                    maxfd = cfd;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果只有lfd变化那就跳过这次</span></span><br><span class="line">                <span class="keyword">if</span> (--lenfd == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i++)&#123;</span><br><span class="line">                <span class="comment">// 判断哪个文件描述符在变化集合中</span></span><br><span class="line">                <span class="keyword">if</span> (FD_ISSET(i, &amp;reset))&#123;</span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1500</span>];</span><br><span class="line">                    ret = read(i, buf, <span class="number">1500</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 这个文件描述符有问题</span></span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="comment">// 关闭这个文件描述符</span></span><br><span class="line">                        close(i);</span><br><span class="line">                        <span class="comment">// 然后把这个文件描述符从中删除</span></span><br><span class="line">                        FD_CLR(i, &amp;oldset);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 这个文件描述符已经关闭</span></span><br><span class="line">                        close(i);</span><br><span class="line">                        FD_CLR(i, &amp;oldset);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 正常输出</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">                        write(i, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">                        bzero(buf, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-select的优缺点"><a href="#1-2-select的优缺点" class="headerlink" title="1.2 select的优缺点"></a>1.2 select的优缺点</h4><p>优点：跨平台</p>
<p>缺点：</p>
<p>文件描述符1024的限制，由于<code>FD_SETSIZE</code>的限制，只能返回变化的文件描述符的个数，具体哪个变化需要遍历，每次都需要将需要监听的文件描述符集合由应用层拷贝到内核。</p>
<p>大量并发，少活跃，select效率低。</p>
<p>假设现在有4-1023个文件描述符需要监听，但是5-1000这些文件描述符关闭了。</p>
<h4 id="1-3-解决缺点中的问题"><a href="#1-3-解决缺点中的问题" class="headerlink" title="1.3 解决缺点中的问题"></a>1.3 解决缺点中的问题</h4><p>这里使用到数组来进行解决。</p>
<h3 id="2-poll"><a href="#2-poll" class="headerlink" title="2.poll"></a>2.poll</h3><p>用得比较少</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">功能：监听多个文件描述符的首元素地址的属性变化</span><br><span class="line">参数：</span><br><span class="line">    fds:监听的数组的首元素地址</span><br><span class="line">    nfds:数组有效元素的最大下标+<span class="number">1</span></span><br><span class="line">    timeout:超时时间，<span class="number">-1</span>是永久监听，&gt;=<span class="number">0</span>限时等待</span><br><span class="line">数组元素：</span><br><span class="line">    <span class="keyword">struct</span> pollfd&#123;</span><br><span class="line">        <span class="type">int</span> fd;   <span class="comment">// 需要监听的文件描述符，如果是-1就不监听</span></span><br><span class="line">        <span class="type">short</span> events;   <span class="comment">// 需要监听的文件描述符什么事件 EPOLLIN 读事件  EPOLLOUT 写事件</span></span><br><span class="line">        <span class="type">short</span> revents;  <span class="comment">// 返回监听到的事件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3.epoll"></a>3.epoll</h3><p>用得比较多，在Linux中使用得比较多</p>
<p>特点：</p>
<p>没有文件描述符1024的限制，以后每次监听都不需要在此将需要监听的文件描述符拷贝到内核，返回的是变化的文件描述符，不需要遍历树。</p>
<p>工作原理：</p>
<p>1.创建红黑树</p>
<p>2.将需要监听的文件描述符上树</p>
<p>3.监听</p>
<h4 id="3-1-创建红黑树"><a href="#3-1-创建红黑树" class="headerlink" title="3.1 创建红黑树"></a>3.1 创建红黑树</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">参数:</span><br><span class="line">    size:监听的文件描述符的上限，<span class="number">2.6</span>版本之后写<span class="number">1</span>即可</span><br><span class="line">返回值:返回树的句柄</span><br></pre></td></tr></table></figure>

<h4 id="3-2-上树、下树、修改节点"><a href="#3-2-上树、下树、修改节点" class="headerlink" title="3.2 上树、下树、修改节点"></a>3.2 上树、下树、修改节点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event* event)</span>;</span><br><span class="line">参数:</span><br><span class="line">    epfd:树的句柄</span><br><span class="line">    op:</span><br><span class="line">        EPOLL_CTL_ADD 上树</span><br><span class="line">        EPOLL_CTL_DEL 下树</span><br><span class="line">        EPOLL_CTL_MOD 修改树</span><br><span class="line">    fd:上树、下树的文件描述符</span><br><span class="line">    event:上树的结点</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events;   <span class="comment">// 需要监听的事件</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;  <span class="comment">// 需要监听的文件描述符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-监听"><a href="#3-3-监听" class="headerlink" title="3.3 监听"></a>3.3 监听</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">参数:</span><br><span class="line">    epfd:树的句柄</span><br><span class="line">    events:接收变化的节点的数组的首地址</span><br><span class="line">    maxevents:数组元素的个数</span><br><span class="line">    timeout:<span class="number">-1</span>永久监听 大于<span class="number">0</span>限时等待</span><br></pre></td></tr></table></figure>



<h2 id="四、TFTP"><a href="#四、TFTP" class="headerlink" title="四、TFTP"></a>四、TFTP</h2><h3 id="1-TFTP概述"><a href="#1-TFTP概述" class="headerlink" title="1.TFTP概述"></a>1.TFTP概述</h3><p>TFTP是简单文件传送协议</p>
<p>最初用于引导无盘系统，被设计用来传输小文件</p>
<p>基于UDP协议实现，不进行用户有效性认证</p>
<p><strong>数据传输模式：</strong></p>
<p>octet：二进制模式</p>
<p>netascii：文本模式</p>
<p>mail：已经不再支持</p>
<h3 id="2-TFTP通讯过程"><a href="#2-TFTP通讯过程" class="headerlink" title="2.TFTP通讯过程"></a>2.TFTP通讯过程</h3><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/TFTP%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B.png"></p>
<p>1.服务器在69端口等待请求</p>
<p>2.服务器若批准此请求，则使用临时端口与客户端进行通信</p>
<p>3.每个数据包的编号都有变化（从1开始）</p>
<p>4.每个数据包都要得到ACK确认，如果出现超时，则需要重新发送最后的包（数据或ACK）</p>
<p>5.数据的长度以512Byte传输</p>
<p>6.小于512Byte的数据意味着传输结束</p>
<h3 id="3-TFTP协议分析"><a href="#3-TFTP协议分析" class="headerlink" title="3.TFTP协议分析"></a>3.TFTP协议分析</h3><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/TFTP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90.png"></p>
<p><strong>注意：</strong></p>
<p>以上0代表的是<code>\0</code></p>
<p>不同的差错码对应不同的错误信息</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/TFTP%E5%B7%AE%E9%94%99%E7%A0%81.png"></p>
<p><strong>错误码：</strong></p>
<p>0 未定义，参见错误信息</p>
<p>1 File not found</p>
<p>2 Access violation</p>
<p>3 Disk full or allocation exceeded</p>
<p>4.illegal TFTP operation</p>
<p>5.Unknown transfer ID</p>
<p>6.File already exists</p>
<p>7.No such user</p>
<p>8.Unsuppored option(s) requested</p>
<h3 id="4-TFTP客户端"><a href="#4-TFTP客户端" class="headerlink" title="4.TFTP客户端"></a>4.TFTP客户端</h3><p>使用TFTP协议下载server上的文件到本地</p>
<p><strong>思路</strong></p>
<p>1、构造请求报文，送至服务器（69号端口）</p>
<p>2、等待服务器回应</p>
<p>3、分析服务器回应</p>
<p>4、接收数据，直到接收到的数据包小于规定长度</p>
<p>代码：</p>
<h2 id="五、UDP广播"><a href="#五、UDP广播" class="headerlink" title="五、UDP广播"></a>五、UDP广播</h2><h3 id="1-广播的概念"><a href="#1-广播的概念" class="headerlink" title="1.广播的概念"></a>1.广播的概念</h3><p>广播：由一台主机向该主机所在子网内的所有主机发送数据的方式，例如192.168.3.103发送广播信息，则192.168.3.1~192.168.3.254所有主机都可以接收到数据。</p>
<p>广播只能用UDP或者原始IP实现，不能用TCP。</p>
<h3 id="2-广播的用途"><a href="#2-广播的用途" class="headerlink" title="2.广播的用途"></a>2.广播的用途</h3><p>单个服务器与多个客户主机通讯时减少分组流通，以下几个协议都用到广播：</p>
<p>1、地址解析协议（ARP）</p>
<p>2、动态主机配置协议（DHCP）</p>
<p>3、网络时间协议（NTP）</p>
<h3 id="3-广播的特点"><a href="#3-广播的特点" class="headerlink" title="3.广播的特点"></a>3.广播的特点</h3><p>1、处于同一子网的所有主机都必须处理数据</p>
<p>2、UDP数据包会沿协议栈向上一直到UDP层</p>
<p> 3、运行音视频等较高速率工作的应用，会带来很大的负担</p>
<p>4、局限于局域网内使用</p>
<h3 id="4-广播地址"><a href="#4-广播地址" class="headerlink" title="4.广播地址"></a>4.广播地址</h3><p>{网络ID，主机ID}</p>
<p>网络ID表示由子网掩码中1覆盖的连续位</p>
<p>主机ID表示由子网掩码中0覆盖的连续位</p>
<p>**定向广播地址：**主机ID全为1</p>
<p>1、例如：对192.168.200.0&#x2F;24，其定向广播地址为：192.168.200.255</p>
<p>2、通常路由器不转发该广播</p>
<p>**受限广播地址：**255.255.255.255</p>
<p>路由器从不转发该广播</p>
<h1 id="未完待续…一直鸽着的"><a href="#未完待续…一直鸽着的" class="headerlink" title="未完待续…一直鸽着的"></a>未完待续…一直鸽着的</h1>]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>使用stm32控制esp01s</title>
    <url>/2025/02/09/06e37ae090b3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用stm32f103控制esp01s是步入物联网的第一步，接下来的文章会详细讲解如何使用stm32控制esp01s。</p>
<h1 id="一、电路图设计"><a href="#一、电路图设计" class="headerlink" title="一、电路图设计"></a>一、电路图设计</h1><p>对于这个模块的使用我是用我制作的项目来进行使用的，本质的内容很简单，因为esp01s它要进行通讯其实本质上就是用串口来进行通讯的，所以我们只需要使用串口来进行通讯就可以了。电路图如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%94%B5%E8%B7%AF%E5%9B%BE.png"></p>
<p>这个电路图很简单，只需要将单片机的串口和esp01s的串口进行连接就可以了，然后再连接电源线，这样就可以了，剩下的就是对于串口通讯的编写了，实现串口收发数据的功能，控制esp01s的操作就是比较简单的了。</p>
<h1 id="二、程序编写"><a href="#二、程序编写" class="headerlink" title="二、程序编写"></a>二、程序编写</h1><p>这里主要针对于串口的编写和功能的实现，测试使用的TFT显示屏的代码编写就不说明了，因为不是这一节的内容。</p>
<h2 id="1-串口的编写"><a href="#1-串口的编写" class="headerlink" title="1.串口的编写"></a>1.串口的编写</h2><h3 id="1-1-串口的时钟的开启"><a href="#1-1-串口的时钟的开启" class="headerlink" title="1.1 串口的时钟的开启"></a>1.1 串口的时钟的开启</h3><p>这里在教程中我没有书写，这里简单介绍一下，实现是开启串口的时钟，这里要开启两个时钟，因为串口是借助GPIO口的，所以需要开启GPIO的时钟后再开启串口的时钟。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-串口的配置"><a href="#1-2-串口的配置" class="headerlink" title="1.2 串口的配置"></a>1.2 串口的配置</h3><p>这里的串口的配置其实就是配置串口的一些参数，比如波特率、数据位、停止位、校验位等，首先先创建一个配置的变量，这里创建的变量类型为<code>USART_InitTypeDef</code>，然后配置变量的相关参数后使用的<code>USART_Init()</code>函数来进行配置的，配置的时候先需要配置一下GPIO。</p>
<p>对于<code>GPIO</code>来说，首先要确定使用的是<code>USART1</code>还是<code>USART2</code>，如果是一些高性能的，可能还要其它的，这个需要参考手册，对于我们这个基础型来说，只有<code>USART1</code>和<code>USART2</code>，所以这里我们使用的是<code>USART1</code>，然后配置的是<code>GPIOA</code>，然后配置的是<code>GPIOA9</code>和<code>GPIOA10</code>，这里需要注意的是，<code>GPIOA9</code>和<code>GPIOA10</code>一个是<code>TX</code>输入，一个是<code>RX</code>输出，所以这里需要将<code>GPIOA9</code>配置成复用推挽输出的模式，<code>GPIOA10</code>配置为浮空输入。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">USART_InitTypeDef USART_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_InitStruct.USART_BaudRate = <span class="number">115200</span>;</span><br><span class="line">USART_InitStruct.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">USART_InitStruct.USART_StopBits = USART_StopBits_1;</span><br><span class="line">USART_InitStruct.USART_Parity = USART_Parity_No;</span><br><span class="line">USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class="line">USART_Init(USART1, &amp;USART_InitStruct);</span><br><span class="line">USART_Cmd(USART1, ENABLE);</span><br></pre></td></tr></table></figure>

<h3 id="1-3-配置串口中断"><a href="#1-3-配置串口中断" class="headerlink" title="1.3 配置串口中断"></a>1.3 配置串口中断</h3><p>因为我们没办法知道串口多久才接收数据，所以这里使用的是中断来进行接收数据的，这里使用的是串口的中断接收，所以需要配置一下串口的中断，这里需要先配置串口开启中断后再配置的是串口的中断优先级，然后配置中断。</p>
<p>首先配置串口中断的开启：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);</span><br></pre></td></tr></table></figure>

<p>这里的<code>USART_IT_RXNE</code>是串口的中断接收，然后配置串口的中断优先级：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br></pre></td></tr></table></figure>

<p>这里的<code>NVIC_PriorityGroup_2</code>是中断优先级分组为2，然后配置中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure>

<p>这样就写好了中断配置，然后在中断服务函数中进行接收数据的处理，这里的中断服务函数我使用状态机来进行实现，因为我们不知道串口什么时候会接收数据，所以这里使用状态机来进行实现，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    RECEIVE_IDLE,  <span class="comment">// 空闲状态</span></span><br><span class="line">    RECEIVE_DATA,  <span class="comment">// 接收数据状态</span></span><br><span class="line">    RECEIVE_FINISH  <span class="comment">// 接收完成状态</span></span><br><span class="line">&#125;USART_STATE;</span><br><span class="line"></span><br><span class="line">USART_STATE usart_state = RECEIVE_IDLE;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> usart_recv_buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> usart_recv_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// USART_ClearITPendingBit(USART1, USART_IT_RXNE);</span></span><br><span class="line">        res = USART_ReceiveData(USART1);</span><br><span class="line">        <span class="keyword">switch</span>(usart_state)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> RECEIVE_IDLE:</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="string">&#x27;\r&#x27;</span> &amp;&amp; res != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    usart_recv_buf[usart_recv_index++] = res;</span><br><span class="line">                    usart_state = RECEIVE_DATA;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    usart_recv_buf[usart_recv_index++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RECEIVE_DATA:</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 跳过\r</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    usart_state = RECEIVE_IDLE;</span><br><span class="line">                    usart_recv_buf[usart_recv_index++] = res;</span><br><span class="line">                    <span class="keyword">if</span> (usart_recv_index &gt;= <span class="number">100</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        usart_recv_index = <span class="number">0</span>;</span><br><span class="line">                        usart_state = RECEIVE_FINISH;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RECEIVE_FINISH:</span><br><span class="line">                usart_state = RECEIVE_IDLE;</span><br><span class="line">                usart_recv_index = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        USART_ClearITPendingBit(USART1, USART_IT_RXNE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的状态机还是比较简单的，就是一开始是未接收状态，如果接收到的不是<code>\r</code>或者<code>\n</code>就开始接收数据，然后如果都不是那就开始接收数据，当接收到<code>\r</code>或者<code>\n</code>就开始接收完成状态，然后将接收的数据进行处理。</p>
<p>但是我感觉这个状态机有点问题，但暂时没有更好的方案，大家如果有更好的方案可以和我交流一下。</p>
<h3 id="1-4-发送数据"><a href="#1-4-发送数据" class="headerlink" title="1.4 发送数据"></a>1.4 发送数据</h3><p>发送数据的代码很简单，就是先判断发送标志位是否置位，然后发送数据，然后等待发送完成，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Usart_Send</span><span class="params">(<span class="type">uint8_t</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);    <span class="comment">// 等待发送寄存器为空</span></span><br><span class="line">        USART_SendData(USART1, *str++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>USART_FLAG_TXE</code>是发送寄存器为空的标志位，然后发送数据，然后等待发送完成。</p>
<p>这样对于串口的代码就写好了，然后就是对于esp01s的控制了。</p>
<h2 id="2-esp01s的控制"><a href="#2-esp01s的控制" class="headerlink" title="2.esp01s的控制"></a>2.esp01s的控制</h2><p>对于esp01s的控制其实就是串口的发送数据，然后等待接收数据，然后将接收的数据进行处理，这里的处理就是判断接收的数据是否正确，然后进行相应的操作，这里的操作就是连接WiFi，然后将连接的数据显示在TFT显示屏上，因为只是简单的介绍，对于更多的操作我还没有加，因为只要把这些最基础的问题解决了后，剩下的只是在这个基础上增加东西。</p>
<p>这里的操作其实就是发送AT指令，当esp01s接收到AT指令后就会进行相应的操作，然后将操作的结果返回给esp01s，然后esp01s将结果返回给单片机，单片机就可以进行相应的操作了。</p>
<p>这里的AT指令我就不一一介绍了，因为我也不是很清楚，大家可以去百度一下，然后就可以了。</p>
<p>这里就简单的把我写的代码贴出来，大家可以去百度一下，然后就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp01s.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;system_config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是去除空格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear_String_Lj</span><span class="params">(<span class="type">uint8_t</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> recv_buf[<span class="number">100</span>];</span><br><span class="line">    <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> j = <span class="number">0</span>;</span><br><span class="line">    Usart_Get_Recv_Buf(recv_buf);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (recv_buf[i]==<span class="string">&#x27;\n&#x27;</span> &amp;&amp; recv_buf[i+<span class="number">1</span>]==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[j++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            buf[j++] = recv_buf[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(recv_buf[i] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    buf[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ESP01S_Init</span><span class="params">(<span class="type">uint8_t</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化串口</span></span><br><span class="line">    Usart_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ESP01S_Test</span><span class="params">(<span class="type">uint8_t</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    Usart_Send(<span class="string">&quot;AT+CWSTATE?\r\n&quot;</span>);</span><br><span class="line">    delay_ms(<span class="number">1000</span>);</span><br><span class="line">    Clear_String_Lj(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ESP01S_Rst</span><span class="params">(<span class="type">uint8_t</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    Usart_Send(<span class="string">&quot;AT+RST\r\n&quot;</span>);</span><br><span class="line">    delay_ms(<span class="number">1000</span>);</span><br><span class="line">    Clear_String_Lj(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ESP01S_Look_GMR</span><span class="params">(<span class="type">uint8_t</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    Usart_Send(<span class="string">&quot;AT+GMR\r\n&quot;</span>);</span><br><span class="line">    delay_ms(<span class="number">1000</span>);</span><br><span class="line">    Usart_Get_Recv_Buf(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ESP01S_Wifi_Mode_Show</span><span class="params">(<span class="type">uint8_t</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    Usart_Send(<span class="string">&quot;AT+CWMODE?\r\n&quot;</span>);</span><br><span class="line">    delay_ms(<span class="number">1000</span>);</span><br><span class="line">    Clear_String_Lj(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ESP01S_Wifi_Mode_Set</span><span class="params">(<span class="type">uint8_t</span>* buf, ESP01S_WIFI_MODE mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> str[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)str, <span class="string">&quot;AT+CWMODE=%d\r\n&quot;</span>, mode);</span><br><span class="line">    Usart_Send(str);</span><br><span class="line">    delay_ms(<span class="number">1000</span>);</span><br><span class="line">    Clear_String_Lj(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ESP01S_Wifi_Join</span><span class="params">(<span class="type">uint8_t</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> str[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)str, <span class="string">&quot;AT+CWJAP=\&quot;%s\&quot;,\&quot;%s\&quot;\r\n&quot;</span>, WIFI_NAME, WIFI_PASSWORD);</span><br><span class="line">    Usart_Send(str);</span><br><span class="line">    delay_ms(<span class="number">1000</span>);</span><br><span class="line">    Usart_Get_Recv_Buf(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ESP01S_Wifi_Join_Show</span><span class="params">(<span class="type">uint8_t</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    Usart_Send(<span class="string">&quot;AT+CIPSTATE?\r\n&quot;</span>);</span><br><span class="line">    delay_ms(<span class="number">1000</span>);</span><br><span class="line">    Usart_Get_Recv_Buf(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以让esp01s连接WiFi，后面就可以通过网络来进行其它的操作了，这里只是简单的介绍一下，后面的文章我会详细介绍一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TFT144.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;button.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buzz.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DS3231.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span>          <span class="comment">// HACK 测试</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp01s.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> buf[<span class="number">100</span>];</span><br><span class="line">    TFT_Clear(TFT_Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    ESP01S_Wifi_Join(buf);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TFT_Show_String(<span class="number">0</span>, <span class="number">0</span>, TFT_Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), TFT_Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), buf);</span><br><span class="line">        <span class="keyword">if</span> (Read_Button_B())</span><br><span class="line">        &#123;</span><br><span class="line">            TFT_Clear(TFT_Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">            <span class="type">void</span> <span class="title function_">ESP01S_Wifi_Join_Show</span><span class="params">(<span class="type">uint8_t</span>* buf)</span>;</span><br><span class="line">            TFT_Show_String(<span class="number">0</span>, <span class="number">0</span>, TFT_Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), TFT_Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    TFT_Init();</span><br><span class="line">    Button_Init();</span><br><span class="line">    Buzz_Init();</span><br><span class="line">    DS3231_Init();</span><br><span class="line">    TFT_Clear(TFT_Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    delay_ms(<span class="number">1000</span>);</span><br><span class="line">    ESP01S_Init(buf);</span><br><span class="line">    ESP01S_Wifi_Mode_Set(buf, ESP01S_WIFI_STATION);</span><br><span class="line">    TFT_Show_String(<span class="number">0</span>, <span class="number">0</span>, TFT_Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), TFT_Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), buf);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Read_Button_B())</span><br><span class="line">        &#123;</span><br><span class="line">            menu2();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1.jpg"></p>
<p>这样就连接到WiFi了，因为是连接的电脑热点，所有可以在电脑上看到设备连接情况：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/2.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实对于esp01s的控制还是比较简单的，因为它本质上就是串口的通讯，所以我们只需要使用串口来进行通讯就可以了，然后就可以了，后面的文章我会详细介绍一下。</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>模块使用</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习开始</title>
    <url>/2025/03/07/6d31b87ff14a/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构是一门比较重要的学科，真好这段时间我又重新学习了一下数据结构，然后就开始写下文章来记录我学习的内容。</p>
<h1 id="一、数据结构研究的内容"><a href="#一、数据结构研究的内容" class="headerlink" title="一、数据结构研究的内容"></a>一、数据结构研究的内容</h1><p>这里在学习数据结构的时候都会给大家介绍，学习数据结构主要是为了处理一些现实问题，跳过数据结构将这些问题抽象成计算机能够处理的方式让计算机进行操作。</p>
<p>比如在学校，需要通过一个系统来管理学生的信息，这个系统就需要将学生的信息存储起来，然后通过这个系统来管理学生的信息。</p>
<p>可以将学生的信息抽象成一个结构体，然后将这个结构体存储起来，然后通过这个系统来管理学生的信息。</p>
<p>这样就可以将学生的信息存储起来，然后通过这个系统来管理学生的信息。</p>
<p>再比如地图，我们使用导航软件，它可以找到你去那个地方的最快路径的长度，它的实现也是通过将这些地点和道路抽象成一个图，然后通过图的算法来找到最短路径的长度。</p>
<p>说了这么多大家应该了解到数据结构主要研究的内容了吧，其实研究的是将这些现实问题抽象为一些数据结构，然后通过这些数据结构来解决这些问题。</p>
<h1 id="二、基本的概念和术语"><a href="#二、基本的概念和术语" class="headerlink" title="二、基本的概念和术语"></a>二、基本的概念和术语</h1><p>这里需要了解几个概念和术语，等后面都会进行使用的：</p>
<h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h2><p>数据是指所有能输入到计算机中并被计算机处理的符号的总称。</p>
<h2 id="2-数据元素"><a href="#2-数据元素" class="headerlink" title="2.数据元素"></a>2.数据元素</h2><p>数据元素是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。</p>
<h2 id="3-数据对象"><a href="#3-数据对象" class="headerlink" title="3.数据对象"></a>3.数据对象</h2><p>数据对象是性质相同的数据元素的集合，是数据的一个子集。</p>
<h2 id="4-逻辑结构"><a href="#4-逻辑结构" class="headerlink" title="4.逻辑结构"></a>4.逻辑结构</h2><p>逻辑结构是指数据对象中数据元素之间的相互关系。它与存储结构无关，是独立于计算机的。</p>
<h2 id="5-物理结构"><a href="#5-物理结构" class="headerlink" title="5.物理结构"></a>5.物理结构</h2><p>物理结构也称存储结构，是指数据的逻辑结构在计算机中的存储形式。</p>
<h1 id="三、逻辑结构的分类"><a href="#三、逻辑结构的分类" class="headerlink" title="三、逻辑结构的分类"></a>三、逻辑结构的分类</h1><p>逻辑结构是表示数据之间的关系的，它主要是考察数据之间的关系的，根据这个可以分为下面这几类：</p>
<h2 id="1-集合结构"><a href="#1-集合结构" class="headerlink" title="1.集合结构"></a>1.集合结构</h2><p>集合结构中的数据元素之间除了同属于一个集合的关系外，无其他关系。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%9B%86%E5%90%88.png"></p>
<p>可以看到每个元素之间没有任何的联系，所以集合中所有元素没有前驱也没有后继。</p>
<h2 id="2-线性结构"><a href="#2-线性结构" class="headerlink" title="2.线性结构"></a>2.线性结构</h2><p>线性结构中的数据元素之间是一对一的关系。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.png"></p>
<p>线性结构中每个元素都有且只有一个前驱和一个后继，除了第一个元素没有前驱，最后一个元素没有后继。</p>
<h2 id="3-树形结构"><a href="#3-树形结构" class="headerlink" title="3.树形结构"></a>3.树形结构</h2><p>树形结构中的数据元素之间存在一种一对多的层次关系。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%A0%91%E7%BB%93%E6%9E%84.png"></p>
<p>树形结构中每个元素都有多个前驱和多个后继，除了第一个元素没有前驱，最后一个元素没有后继。</p>
<h2 id="4-图形结构"><a href="#4-图形结构" class="headerlink" title="4.图形结构"></a>4.图形结构</h2><p>图形结构中的数据元素是多对多的关系。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9B%BE%E7%BB%93%E6%9E%84.png"></p>
<p>图形结构中每个元素都有多个前驱和多个后继。</p>
<h1 id="四、物理结构的分类"><a href="#四、物理结构的分类" class="headerlink" title="四、物理结构的分类"></a>四、物理结构的分类</h1><p>物理结构也称为存储结构，是指数据的逻辑结构在计算机中的存储形式。</p>
<p>相当于把前面的逻辑结构使用物理结构进行存放，这里存放的物理结构可分为线性的和非线性的。</p>
<h2 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="1.顺序存储结构"></a>1.顺序存储结构</h2><p>顺序存储结构是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</p>
<p>对于顺序结构是在逻辑上相邻的数据元素，其存储位置也是相邻的，例如下图：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%A1%BA%E5%BA%8F%E8%A1%A8.png"></p>
<h2 id="2-非线性存储结构"><a href="#2-非线性存储结构" class="headerlink" title="2.非线性存储结构"></a>2.非线性存储结构</h2><p>非线性存储结构是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%93%BE%E6%8E%A5%E8%A1%A8.png"></p>
<h1 id="五、数据类型和抽象数据类型"><a href="#五、数据类型和抽象数据类型" class="headerlink" title="五、数据类型和抽象数据类型"></a>五、数据类型和抽象数据类型</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><p>以借助程序设计语言的数据类型来描述数据对象的基本操作。</p>
<h2 id="2-抽象数据类型"><a href="#2-抽象数据类型" class="headerlink" title="2.抽象数据类型"></a>2.抽象数据类型</h2><p>抽象就是抽出实际问题的本质，忽略其非本质的细节。</p>
<p>一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称。</p>
<p>抽象数据类型是指一个数学模型以及定义在该模型上的一组操作。</p>
<p>抽象数据类型的定义格式为：</p>
<pre><code>ADT 抽象数据类型名&#123;
    数据对象：&lt;数据对象的定义&gt;
    数据关系：&lt;数据关系的定义&gt;
    基本操作：&lt;基本操作的定义&gt;
&#125;ADT 抽象数据类型名

# 总结

数据结构是一门非常重要的学科，它可以帮助我们解决一些现实问题，将这些问题抽象为一些数据结构，然后通过这些数据结构来解决这些问题。
</code></pre>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程</title>
    <url>/2025/01/17/3011135ba729/</url>
    <content><![CDATA[<h1 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a>Linux系统编程</h1><h2 id="一、静态和动态"><a href="#一、静态和动态" class="headerlink" title="一、静态和动态"></a>一、静态和动态</h2><p>在linux中有两种有静态和动态的方式</p>
<h3 id="1-静态链接和动态链接"><a href="#1-静态链接和动态链接" class="headerlink" title="1.静态链接和动态链接"></a>1.静态链接和动态链接</h3><p>链接分为两种：静态链接、动态链接</p>
<h4 id="1）静态链接"><a href="#1）静态链接" class="headerlink" title="1）静态链接"></a>1）静态链接</h4><p>静态链接：由链接器在链接时将库的内容加入到可执行程序中。</p>
<p>优点：</p>
<ul>
<li>对运行环境的依赖性较小，具有较好的兼容性</li>
</ul>
<p>缺点：</p>
<ul>
<li>生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间</li>
<li>库函数有了更新，必须重新编译应用程序</li>
</ul>
<h4 id="2）动态链接"><a href="#2）动态链接" class="headerlink" title="2）动态链接"></a>2）动态链接</h4><p>动态链接：连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。</p>
<p>优点：</p>
<ul>
<li>在需要的时候才会调用对应的资源函数</li>
<li>简化程序的升级；有着较小的程序体积</li>
<li>实现进程之间的志愿共享（避免重复拷贝）</li>
</ul>
<p>缺点：</p>
<ul>
<li>依赖动态库，不能独立运行</li>
<li>动态库依赖版本问题严重</li>
</ul>
<h4 id="3）静态、动态编译对比"><a href="#3）静态、动态编译对比" class="headerlink" title="3）静态、动态编译对比"></a>3）静态、动态编译对比</h4><p>在Linux中的gcc是默认使用动态链接来生成代码。</p>
<p>如果想使用静态链接来生成代码，则需要使用下面的指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -static</span><br></pre></td></tr></table></figure>

<p>剩下的和动态链接一样</p>
<h3 id="2、静态库和动态库介绍"><a href="#2、静态库和动态库介绍" class="headerlink" title="2、静态库和动态库介绍"></a>2、静态库和动态库介绍</h3><p>所谓”程序库“，简单说，就是包含了数据和执行码的文件。其不能单独执行，可以作为出现都一部分来完成某些功能</p>
<p>库的存在可以使得程序模块化，可以加快程序的再编译，可以实现代码重用，可以使得程序便于升级</p>
<p>程序库可分 <strong>静态库</strong> 和 <strong>共享库</strong></p>
<h3 id="3-静态库制作和使用"><a href="#3-静态库制作和使用" class="headerlink" title="3.静态库制作和使用"></a>3.静态库制作和使用</h3><p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行代码中，成为执行程序的一部分。</p>
<p>按照习惯，一般以 <code>.a</code> 作为文件后缀名。静态库的命名一般分为三个部分：</p>
<ul>
<li>前缀：lib</li>
<li>库名称：自己定义即可</li>
<li>后缀： <code>.a</code></li>
</ul>
<p>所以最终的静态库的名字应该为：<code>libxxx.a</code></p>
<h4 id="3-1-静态库制作"><a href="#3-1-静态库制作" class="headerlink" title="3.1 静态库制作"></a>3.1 静态库制作</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B.png"></p>
<p>步骤1：将C源文件生成对应的<code>.o</code>文件</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8A%8A%E6%89%80%E6%9C%89h%E7%BC%96%E7%A8%8Bo.png"></p>
<p>步骤2：使用打包工具ar将准备好的.o文件打包为.a文件 libtest.a</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B0%86o%E5%85%A8%E9%83%A8%E6%89%93%E5%8C%85%E6%88%90a.png"></p>
<p>在使用ar工具是需要添加参数：rcs</p>
<ul>
<li>r更新</li>
<li>c创建</li>
<li>s建立索引</li>
</ul>
<h4 id="3-2-静态库使用"><a href="#3-2-静态库使用" class="headerlink" title="3.2 静态库使用"></a>3.2 静态库使用</h4><p>静态库制作完成后，需要将.a文件和头文件一起发布给用户。</p>
<p>假设测试文件为test.c，静态库文件为libtest.a头文件为head.h</p>
<p>编译命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -L. -I. -l test -o test</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>-L：表示要连接的库所在目录</li>
<li>-l（小写L）：指定链接时需要的库，去除前缀和后缀</li>
</ul>
<p>在执行程序的时候，程序1使用到这个静态库，就会在内存中开辟出这块空间来存放静态库，程序2执行的时候也会和程序1的过程一样，会产生大量的空间，导致程序会很大，如果执行多次那空间就会非常大</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%9D%99%E6%80%81%E5%BA%93.png"></p>
<h3 id="4-动态库制作和使用"><a href="#4-动态库制作和使用" class="headerlink" title="4.动态库制作和使用"></a>4.动态库制作和使用</h3><p>共享库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入、不同的应用程序如果调用系统的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。</p>
<p>动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布带来的麻烦。用户只需要更新动态库即可，增量更新。</p>
<p>按照习惯，一般以 <code>.so</code> 作为文件后缀名。共享库的命名一般分为三个部分：</p>
<ul>
<li>前缀：lib</li>
<li>库名称</li>
<li>后缀：.so</li>
</ul>
<p>所以最终的动态库的名字应该为：libxxx.so</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93.png"></p>
<h4 id="4-1-动态库制作"><a href="#4-1-动态库制作" class="headerlink" title="4.1 动态库制作"></a>4.1 动态库制作</h4><p>步骤一：生成目标文件，此时要加编译选项：-fpic</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93o.png"></p>
<p>参数：-fpic创建与地址无关的编译程序，是为了能够在多个应用程序间共享。</p>
<p>步骤二：生成共享库，此时要加链接器选项：-shared（指定生成动态链接库）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared *.o -o libxxx.so</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%94%9F%E6%88%90so.png"></p>
<p>步骤三：通过nm命令查看对应函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nm libtest.so | grep add</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8Badd.png"></p>
<h4 id="4-2-动态库使用"><a href="#4-2-动态库使用" class="headerlink" title="4.2 动态库使用"></a>4.2 动态库使用</h4><p>在使用的时候也是需要对其进行编译</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E5%BA%93.png"></p>
<p>编译完成后运行，会发现报错了</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99.png"></p>
<p>原因是因为在链接的时候需要用到连接器才可以使用</p>
<ul>
<li>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器。</li>
<li>对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段-环境变量LD_LIBRARY_PATH-&#x2F;etc&#x2F;ld.so.cache文件列表-&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib目录找到库文件将其载入内存</li>
</ul>
<h4 id="4-3-如何让系统找到动态库"><a href="#4-3-如何让系统找到动态库" class="headerlink" title="4.3 如何让系统找到动态库"></a>4.3 如何让系统找到动态库</h4><ul>
<li><p>将动态库放到 <code>/lib</code> 目录中即可</p>
</li>
<li><p>临时设置LD_LIBRARY_PATH:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>永久设置，把 <code>export LD_LIBRARY_PATH=&amp;LD_LIBRARY_PATH:库路径</code> ，设置到 <code>~/.bashrc</code> 或 <code>/etc/profile</code> 文件中</p>
<p>把 <code>export LD_LIBRARY_PATH=&amp;LD_LIBRARY_PATH:库路径</code> 添加到最后一行即可</p>
<p>执行下面代码让文件生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/.bashre</span><br></pre></td></tr></table></figure>
</li>
<li><p>将其添加到 <code>/etc/ld.so.conf</code> 文件中</p>
<p>编辑 <code>/etc/ld.so.conf</code> 文件，加入库文件所在目录的路径</p>
<p>运行 <code>sudo ldconfig -v</code> ，该命令会重建 <code>/etc/ld.so.cache</code> 文件</p>
</li>
<li><p>使用符号链接，但一定要使用绝对1路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/deng/test/6share_test/libtest.so /lib/libtest.so</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-GDB调试器"><a href="#5-GDB调试器" class="headerlink" title="5.GDB调试器"></a>5.GDB调试器</h3><h4 id="5-1-GDB简介"><a href="#5-1-GDB简介" class="headerlink" title="5.1 GDB简介"></a>5.1 GDB简介</h4><p>GNU工具集中的调试器是GDB，该程序是一个交互式工具，工作在字符模式。除GDB外，Linux下比较有名的调试器还有xxgdb，ddd，kgdb，ups</p>
<p>GDB主要帮助你完成下面四个方面的功能：</p>
<p>1.启动程序，可以按照你的自定义的要求随心所欲的运行程序。</p>
<p>2.可以被调试的程序在你所指定的调置的断点处停止。</p>
<p>3.当程序被停住时，可以检查此时你的程序中所发生的事</p>
<p>4.动态的改变你的程序的执行环境</p>
<h4 id="5-2-生成调试信息"><a href="#5-2-生成调试信息" class="headerlink" title="5.2 生成调试信息"></a>5.2 生成调试信息</h4><p>一般来说GDB主要调试的是C&#x2F;C++的程序。要调试C&#x2F;C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器(cc&#x2F;gcc&#x2F;g++)的-g参数可以做到这一点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g hello.c -o hello</span><br><span class="line">g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>

<p>如果没有-g，你将看不到程序的函数名、变量名，所替代的全是运行时的内存地址</p>
<h4 id="5-3-启动GDB"><a href="#5-3-启动GDB" class="headerlink" title="5.3 启动GDB"></a>5.3 启动GDB</h4><ul>
<li><p>启动GDB：gdb program</p>
<p>program 也是你的执行文件，一般在当前目录下。</p>
</li>
<li><p>设置运行参数</p>
<p>set args  可指定运行时参数。（如：set args 10 20 30 40 50）</p>
<p>show args 命令可以查看设置好的运行参数。</p>
</li>
<li><p>启动程序</p>
<p>run：程序开始执行，如果有断点，停在第一个断点处</p>
<p>start：程序向下执行一行</p>
</li>
</ul>
<h4 id="5-4-显示源代码"><a href="#5-4-显示源代码" class="headerlink" title="5.4 显示源代码"></a>5.4 显示源代码</h4><p>用list命令来打印程序的源代码。默认打印10行。</p>
<ul>
<li>list linenum：打印第linenm行的上下文内容</li>
<li>list function：显示函数名为function的函数的源程序</li>
<li>list：显示当前行后面的源程序</li>
<li>list -：显示当前行前面的源程序</li>
</ul>
<p>一般是打印当前行的上5行和下5行，如果显示的函数是上2行下8行，默认10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数</p>
<ul>
<li>set listsize count：设置一次显示源代码的行数</li>
<li>show listsize：查看当前listsize的设置。</li>
</ul>
<h4 id="5-5-断点操作"><a href="#5-5-断点操作" class="headerlink" title="5.5 断点操作"></a>5.5 断点操作</h4><h5 id="5-5-1-简单断点"><a href="#5-5-1-简单断点" class="headerlink" title="5.5.1 简单断点"></a>5.5.1 简单断点</h5><p>break设置断点，可以简写为b</p>
<ul>
<li>b 10 设置断点，在源文件第10行</li>
<li>b func 设置断点，在func函数入口处</li>
</ul>
<h5 id="5-5-2-多文件设置断点"><a href="#5-5-2-多文件设置断点" class="headerlink" title="5.5.2 多文件设置断点"></a>5.5.2 多文件设置断点</h5><p>如果有名称空间，可以使用namespace::class::function或者function(type, type) 格式来指定函数名。</p>
<ul>
<li>break filename:linenum –在源文件filename的linenum行处停住</li>
<li>break filename:function – 在源文件filename的function函数的入口处停住</li>
<li>break class::function 或 function(type, type) – 在类class的function函数入口处停住</li>
<li>break namespace::class::function – 在名称空间为namespace的类class的function函数的入口处停住</li>
</ul>
<h5 id="5-5-3-查询所有断点"><a href="#5-5-3-查询所有断点" class="headerlink" title="5.5.3 查询所有断点"></a>5.5.3 查询所有断点</h5><ul>
<li>info b</li>
<li>info break</li>
<li>i break</li>
<li>i b</li>
</ul>
<h5 id="5-5-4-条件断点"><a href="#5-5-4-条件断点" class="headerlink" title="5.5.4 条件断点"></a>5.5.4 条件断点</h5><p>一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。</p>
<p>设置一个条件断点：</p>
<blockquote>
<p>b test.c:8 if Value &#x3D;&#x3D; 5</p>
</blockquote>
<h5 id="5-5-5-维护断点"><a href="#5-5-5-维护断点" class="headerlink" title="5.5.5 维护断点"></a>5.5.5 维护断点</h5><p>1）delete [range…] 输出指定的断点，其简写命令为d。</p>
<ul>
<li>如果不指定断点号，则表示删除所有的断点。range表示断点号的范围*如：3-7）。</li>
<li>比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样</li>
</ul>
<p>2）disable [range…]使指定断点无效，简写命令是dis。</p>
<p>​		如果什么都不指定，表示disable所有的停止点无效</p>
<p>3）enable [range…] 使无效断定失效，缩写命令是ena。</p>
<p>​		如果什么都不指定，表示enable所有的停止点</p>
<h5 id="5-5-6-调试代码"><a href="#5-5-6-调试代码" class="headerlink" title="5.5.6 调试代码"></a>5.5.6 调试代码</h5><ul>
<li>run 运行程序，可简写为r</li>
<li>next 单步跟踪，函数调用当作一条简单语句执行，可简写为n</li>
<li>step 单步跟踪，函数调用进入被调用函数体内，可简写为s</li>
<li>finish 退出进入的函数</li>
<li>until 在一个循环体内单步跟踪时，这个命令可以运行直到退出循环体，可简写为u。</li>
<li>continue 继续运行程序，停在下一个断点的位置，可简写为c</li>
<li>quit 退出gdb，可简写为q</li>
</ul>
<h5 id="5-5-7-数据查看"><a href="#5-5-7-数据查看" class="headerlink" title="5.5.7 数据查看"></a>5.5.7 数据查看</h5><p>1）查看运行时数据</p>
<p>​	print 打印变量、字符串、表达式等的值，可简写为p</p>
<p>​	p count 打印count的值</p>
<h5 id="5-5-8-自动显示"><a href="#5-5-8-自动显示" class="headerlink" title="5.5.8 自动显示"></a>5.5.8 自动显示</h5><p>可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。</p>
<ul>
<li>display 变量名</li>
<li>info display  – 查看设置的自动显示的信息。</li>
<li>undisplay num （info display时显示的编号）</li>
<li>delete display dnums… – 删除自动显示，dnums意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</li>
<li>disable display dnums…</li>
<li>enable display dnums…</li>
<li>disable和enalbe不删除自动显示的设置，而只是让其失效和恢复</li>
</ul>
<h5 id="5-5-9-查看修改变量"><a href="#5-5-9-查看修改变量" class="headerlink" title="5.5.9 查看修改变量"></a>5.5.9 查看修改变量</h5><p>1）ptype width – 查看变量width的类型</p>
<p>​	type &#x3D; double</p>
<p>2）p width – 打印变量width的值</p>
<p>你可以使用set var命令告诉GDB，width不是你GDB的参数，而是程序的变量名，如：</p>
<p>​		set var width&#x3D;47 &#x2F;&#x2F;将变量var值设置为47</p>
<p><strong>在吧改变程序变量取值时，最好都使用set var格式的GDB命令</strong></p>
<h2 id="二、自动化编译"><a href="#二、自动化编译" class="headerlink" title="二、自动化编译"></a>二、自动化编译</h2><h3 id="1-Makefile"><a href="#1-Makefile" class="headerlink" title="1.Makefile"></a>1.Makefile</h3><h4 id="1-1-Makefile简介"><a href="#1-1-Makefile简介" class="headerlink" title="1.1 Makefile简介"></a>1.1 Makefile简介</h4><p>一个工程中的源文件不记其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至进行更复杂的功能操作，因为makefile就像一个shell脚本一样，其中也可以执行操作系统的命令。</p>
<p>Makefile代码来的好处就是–“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令。</p>
<p>make主要解决两个问题：</p>
<p><strong>1）大量代码的关系维护</strong></p>
<p>大项目中源代码比较多，手工维护、编译时间长而且命令复杂，难以记忆及维护</p>
<p>把代码维护命令及编译命令写在makefile文件中，然后再用make工具解析此文件自动执行相应命令，可实现代码的合理编译</p>
<p><strong>2）减少重复编译时间</strong></p>
<p>在改动其中一个文件的时候，能判断哪些文件被修改过，可以只对该文件进行重新编译，然后重新链接所有目标文件，节省编译时间</p>
<p><strong>Makefile文件命名规则</strong></p>
<p>makefile和Makefile都可以</p>
<p><strong>make工具安装</strong></p>
<blockquote>
<p>sudo apt install make</p>
</blockquote>
<h4 id="1-2-Makefile语法规则"><a href="#1-2-Makefile语法规则" class="headerlink" title="1.2 Makefile语法规则"></a>1.2 Makefile语法规则</h4><p>一条规则：</p>
<blockquote>
<p>目标：依赖文件列表</p>
<p><Tab>命令列表</p>
</blockquote>
<p>Makefile基本规则三要素：</p>
<p>1）目标：</p>
<ul>
<li>通常是要产生的文件名称，目标可以是可执行文件或其他obj文件，也可以是一个动作的名称</li>
</ul>
<p>2）依赖文件：</p>
<ul>
<li>用来输入从而产生目标的文件</li>
<li>一个目标通常有几个依赖文件（可以没有）</li>
</ul>
<p>3）命令：</p>
<ul>
<li>make执行的动作，一个规则可以含几个命令（可以没有）</li>
<li>有多个命令时，每个命令占一行</li>
</ul>
<h4 id="1-3-make命令格式"><a href="#1-3-make命令格式" class="headerlink" title="1.3 make命令格式"></a>1.3 make命令格式</h4><p>make是一个命令工具，它解释Makefile中的指令（应该说是规则）。</p>
<p>make命令格式：</p>
<p>make [-f file][options][targets]</p>
<p>1.[-f file]:</p>
<ul>
<li>make默认在工作目录中寻找名为makefile、makefile、Makefile的文件作为makefile输入文件</li>
<li>-f 可以指定以上名字以外的文件作为makefile输入文件</li>
</ul>
<p>2.[options]</p>
<ul>
<li>-v：显示make工具的版本信息</li>
<li>-w：在处理makefile之前和之后显示工作路径</li>
<li>-C dir：读取makefile之前改变工作路径至dir目录</li>
<li>-n：只打印要执行的命令但不执行</li>
<li>-s：执行但不显示执行的命令</li>
</ul>
<p>3.[targets]：</p>
<ul>
<li>若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个目标，然后退出</li>
<li>指定make工具要实现的目标，目标可以是一个或多个（多个目标间用空格隔开）。</li>
</ul>
<h4 id="1-4-Makefile实例"><a href="#1-4-Makefile实例" class="headerlink" title="1.4 Makefile实例"></a>1.4 Makefile实例</h4><p>比如要编译之前写的Add.c Sub.c Div.c Mul.c</p>
<p>在Makefile文件中的写法如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">test:Add.o Sub.o Div.o Mul.o test.o</span></span><br><span class="line">    gcc Add.o Sub.o Div.o Mul.o test.o -o test</span><br><span class="line"><span class="section">Add.o:Add.c</span></span><br><span class="line">    gcc -c Add.c -o Add.o</span><br><span class="line"><span class="section">Sub.o:Sub.c</span></span><br><span class="line">    gcc -c Sub.c -o Sub.o</span><br><span class="line"><span class="section">Div.o:Div.c</span></span><br><span class="line">    gcc -c Div.c -o Div.o</span><br><span class="line"><span class="section">Mul.o:Mul.c</span></span><br><span class="line">    gcc -c Mul.c -o Mul.o</span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">    gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure>

<p>这种写法后，在如果又修改其他文件话只需要重新编译刚写的文件</p>
<h4 id="1-5-Makefile中的变量"><a href="#1-5-Makefile中的变量" class="headerlink" title="1.5 Makefile中的变量"></a>1.5 Makefile中的变量</h4><p>在Makefile中使用变量有点类似于C语言中的宏定义，使用该变量相当于内存替换，使用变量可以使Makefile易于维护，修改内容变得简单变量定义及使用。</p>
<h5 id="1-5-1-自定义变量"><a href="#1-5-1-自定义变量" class="headerlink" title="1.5.1 自定义变量"></a>1.5.1 自定义变量</h5><p>1）定义变量方法：</p>
<p>​	变量名 &#x3D; 变量值</p>
<p>2）引用变量：</p>
<p>​	$(变量名)或${变量名}</p>
<p>3）makefile的变量名：</p>
<ul>
<li>makefile量名可以以数字开头</li>
<li>变量是大小写敏感的</li>
<li>变量一般都在makefile的头部定义</li>
<li>变量几乎可以在makefile的任何地方使用</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc $&#123;OBJS&#125; -o test</span><br><span class="line"><span class="section">Add.o:Add.c</span></span><br><span class="line">        gcc -c Add.c -o Add.o</span><br><span class="line"><span class="section">Sub.o:Sub.c</span></span><br><span class="line">        gcc -c Sub.c -o Sub.o</span><br><span class="line"><span class="section">Div.o:Div.c</span></span><br><span class="line">        gcc -c Div.c -o Div.o</span><br><span class="line"><span class="section">Mul.o:Mul.c</span></span><br><span class="line">        gcc -c Mul.c -o Mul.o</span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">        gcc -c test.c -o test.o</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户直接使用，我们可以直接对其进行赋值。</p>
<blockquote>
<p>CC&#x3D;gcc #arm-linux-gcc</p>
<p>CPPFLAGS: C预处理器的选择 如：-l</p>
<p>CFLAGS：C编译器的选择 -Wall -g -c</p>
<p>LDFLAGS：链接器选择 -L -l</p>
</blockquote>
<h5 id="1-5-2-自动变量"><a href="#1-5-2-自动变量" class="headerlink" title="1.5.2 自动变量"></a>1.5.2 自动变量</h5><ul>
<li>$@：表示规则中的目标</li>
<li>$&lt;：表示规则中的第一个依赖</li>
<li>$^：表示所有依赖</li>
<li>$?：所有目标依赖中被修改过的文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">Add.o:Add.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">Sub.o:Sub.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">Div.o:Div.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">Mul.o:Mul.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="1-5-3-规则模式"><a href="#1-5-3-规则模式" class="headerlink" title="1.5.3 规则模式"></a>1.5.3 规则模式</h5><p>模式规则示例：</p>
<blockquote>
<p>%.o:%.c</p>
<p>$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o &amp;@</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#Add.o:Add.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#Sub.o:Sub.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#Div.o:Div.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#Mul.o:Mul.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#test.o:test.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-Makefile中的函数"><a href="#1-6-Makefile中的函数" class="headerlink" title="1.6 Makefile中的函数"></a>1.6 Makefile中的函数</h4><p>makefile中的函数有很多，在这里给大家介绍两个最常用的。</p>
<blockquote>
<p>1.wildcard - 查找指定目录下的指定类型的文件</p>
<p>​	src &#x3D; $(wildcard *.c) &#x2F;&#x2F;找到当前目录下所有后缀为.c的文件，赋值	给src</p>
<p>2.patsubst - 匹配替换</p>
<p>obj &#x3D; $(patsubst %.c, %.o, $(src)) &#x2F;&#x2F;把src变量里所有后缀为.c的文件替换成.o</p>
</blockquote>
<p>在makefile中所有的函数都有返回值的。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取当前目录下所有的.c文件</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将SRC中所有出现的.c的替换成.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-7-Makefile中的伪目标"><a href="#1-7-Makefile中的伪目标" class="headerlink" title="1.7 Makefile中的伪目标"></a>1.7 Makefile中的伪目标</h4><p>clean用途：清除编译生成的中间文件.o文件和最终目标文件</p>
<p>make clean如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：</p>
<ul>
<li><p>伪目标声明：.PHONY:clean</p>
<p>声明目标为伪目标之后，makefile将不会该判断目标是否存在或者该目标是否需要更新</p>
</li>
</ul>
<p>clean命令中的特殊符号：</p>
<ul>
<li><code>-</code> 此条命令出错，make也会继续执行后续的命令。如：“-rm main.o”</li>
<li>“@”不显示命令本身，只显示结果。如：“@echo clean done”</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取当前目录下所有的.c文件</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将SRC中所有出现的.c的替换成.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        @gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        @gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        -rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-8-makefile工作原理"><a href="#1-8-makefile工作原理" class="headerlink" title="1.8 makefile工作原理"></a>1.8 makefile工作原理</h4><p>1）若想生成目标，检查规则中的依赖条件是否存在，如果不出来，则寻找是否有规则用来生成该依赖文件</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<p>2）检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任一个被更新，则目标必须更新</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p>
<p>总结：</p>
<ul>
<li>分析各个目标和依赖之间的关系</li>
<li>根据依赖关系自底向上执行命令</li>
<li>根据修改事件比目标新，确定更新</li>
<li>如果目标不依赖任何条件，则执行对应命令，以示更新</li>
</ul>
<h2 id="三、系统文件调用"><a href="#三、系统文件调用" class="headerlink" title="三、系统文件调用"></a>三、系统文件调用</h2><h3 id="1-系统文件调用简介和实现"><a href="#1-系统文件调用简介和实现" class="headerlink" title="1.系统文件调用简介和实现"></a>1.系统文件调用简介和实现</h3><h4 id="1-1-什么是系统调用"><a href="#1-1-什么是系统调用" class="headerlink" title="1.1 什么是系统调用"></a>1.1 什么是系统调用</h4><p>操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过区组“特殊“接口来获得操作系统内核提供的服务，比如说用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获取系统时间或设置定时器等。</p>
<p>从逻辑上来说，系统调用可以看成是一个内核与用户空间程序交互的接口——它好比是一个中间人，把用户进程的请求传达给内核，待内核把请求处理完后再将处理结果送回给用户空间。</p>
<h4 id="1-2-系统调用的实现"><a href="#1-2-系统调用的实现" class="headerlink" title="1.2 系统调用的实现"></a>1.2 系统调用的实现</h4><p>系统调用是属于操作系统内核的一部分的，必须以某种方式提供给进程让它们去调用。CPU可以在不同的特权级别下运行，而相应的操作系统也有不同的运行级别，用户态和内核态。运行在内核态的进程可以毫无限制的访问各种资源，而在用户态的用户进程的各种操作都有着权限，比如不能随意的访问内存、不能开闭中断以及切换运行特权。显然，属于内核的系统调用一定是运行在内核态下，但是如何切换到内核态呢？</p>
<p>答案是软件中断。软件中断和我们常说的中断（硬件中断）不同之处在于，它是通过软件指令触发而非外设引发的中断，也就是说，又是编程人员开发出的一种异常（该异常为正常的异常）。<strong>操作系统一般是通过软件中断从用户态切换到内核态。</strong></p>
<h4 id="1-3-系统调用和库函数的区别"><a href="#1-3-系统调用和库函数的区别" class="headerlink" title="1.3 系统调用和库函数的区别"></a>1.3 系统调用和库函数的区别</h4><p>Linux下对文件操作方式有两种方法：<strong>系统调用（system call）</strong> 和 <strong>库函数调用（Library functions）</strong>。</p>
<p>库函数由两类函数组成：</p>
<p>1）不需要调用系统调用</p>
<p>不需要切换到内核空间即可完成函数全部功能，并且将结果反馈给应用程序，如strcpy、bzero 等字符串操作函数</p>
<p>2）需要调用系统调用</p>
<p>需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如printf、fread等</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%B3%BB%E7%BB%9F%E5%BA%93.png"></p>
<p>系统调用是需要时间的，程序中频繁的使用系统调用会降低程序的运行效率。当运行内核代码时，CPU工作在内核态，在系统调用发生前需要保存用户态和内存环境，然后转入内核态工作。系统调用结束后，又要切换回用户态。这种环境的切换会消耗许多时间。</p>
<h4 id="1-4-C库中IO函数工作流程"><a href="#1-4-C库中IO函数工作流程" class="headerlink" title="1.4 C库中IO函数工作流程"></a>1.4 C库中IO函数工作流程</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/IO%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<p>库函数访问文件的时候需要根据需要，设置不同类型的缓冲区，从而减少了直接调用IO系统调用的次数，提高了访问效率</p>
<p>这个过程类似于快递员给某个区域（内核空间）送快递一样，快递员有两种方法送：</p>
<p>1）来一件快递马上送到目的地，来一件送一件，这样导致来回走比较频繁（系统调用）</p>
<p>2）等快递攒着差不多后（缓冲区），才一次性送到目的地（库函数调用）</p>
<h3 id="2-错误处理函数"><a href="#2-错误处理函数" class="headerlink" title="2.错误处理函数"></a>2.错误处理函数</h3><p>errno是记录系统的最后一次错误代码。代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。</p>
<p>当Linux C api函数发生异常时，一般会将errno全局变量赋一个整数值，不同的值表示不同的意义，可以通过查看该值推测出出错原因。</p>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        FILE* fp = fopen(<span class="string">&quot;txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, errno);<span class="comment">//打印错误码</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno)); <span class="comment">//把errno的数字转换成相应的文字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看错误号：</p>
<blockquote>
<p>&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno-base.h</p>
<p>&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno.h</p>
</blockquote>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%94%99%E8%AF%AF%E7%A0%81.png"></p>
<h3 id="3-虚拟地址空间"><a href="#3-虚拟地址空间" class="headerlink" title="3.虚拟地址空间"></a>3.虚拟地址空间</h3><p>每个进程都会分配虚拟地址，在32位机器上，该地址空间为4G</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png"></p>
<p>在进程里平时说的指针变量，保存的就是虚拟地址。当应用程序使用虚拟地址访问内存时，处理器（CPU）会将其转化成物理地址（MMU）。</p>
<p>MMU：将虚拟的地址转化为物理地址。</p>
<p>这样做的好处在于：</p>
<ul>
<li>进程隔离，更好的保护系统安全运行</li>
<li>屏蔽物理差异带来的麻烦，方便操作系统和编译器安排进程地址</li>
</ul>
<h3 id="4-文件描述符"><a href="#4-文件描述符" class="headerlink" title="4.文件描述符"></a>4.文件描述符</h3><p>在Linux的世界里，一切设备皆为文件。我们可以调用系统中I&#x2F;O的函数（I：input，输入；O：output，输出），对文件进行相应的操作（open()、close()、write()、read()等）。</p>
<p>打开现存文件或新建文件时，系统（内核）会返回一个文件描述符，文件描述符用来指定已经打开的文件。这个文件描述符相当于这个文件已经打开文件的符号，文件描述符是非负整数，是文件的标识，操作这个文件描述符相当于操作这个描述符所指定的文件。</p>
<p>程序运行起来后（每个进程）都有一张文件描述符的表，标准输入、标准输出、标准错误输出设备文件被打开，对应的文件描述符0、1、2记录在表中。程序运行起来后这三个文件描述符是默认打开的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STDIN_FILENO 0 <span class="comment">//标准输入的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDOUT_FILENO 1 <span class="comment">//标准输出的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDERR_FILENO 2 <span class="comment">//标准错误的文件描述</span></span></span><br></pre></td></tr></table></figure>

<p>在程序运行起来后打开其它文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png"></p>
<h4 id="最大打开的文件个数"><a href="#最大打开的文件个数" class="headerlink" title="最大打开的文件个数"></a>最大打开的文件个数</h4><p>Linux中一个进程最多只能打开 NR_OPEN_DEFAULT （即1024）个文件，故当文件不再使用时应及时调用close()函数关闭文件。</p>
<ul>
<li><p>查看当前系统允许打开最大文件个数：</p>
<blockquote>
<p>cat&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</p>
</blockquote>
</li>
<li><p>当前默认设置最大打开文件个数1024</p>
<blockquote>
<p>ulimit -a</p>
</blockquote>
</li>
<li><p>修改默认设置最大打开文件个数4096</p>
<blockquote>
<p>ulimit -n 4096</p>
</blockquote>
</li>
</ul>
<h3 id="5-常用文件IO函数"><a href="#5-常用文件IO函数" class="headerlink" title="5.常用文件IO函数"></a>5.常用文件IO函数</h3><h4 id="5-1-open函数"><a href="#5-1-open函数" class="headerlink" title="5.1 open函数"></a>5.1 open函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    打开文件，如果文件不存在则可以选择创建。</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件的路径及文件名</span><br><span class="line">    flags：打开文件的行为标志，必选项 O_RDONLY O_WRONLY O_RDWR</span><br><span class="line">    mode：这个参数，只有在文件不存在时有效，指新建文件时指定文件的权限</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回打开的文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>flags详细说明</strong></p>
<p>必选项：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_RDONLY</td>
<td>以只读的方式打开</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>以只写的方式打开</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>以可读、可写的方式打开</td>
</tr>
</tbody></table>
<p>可选项，和必选项按位或起来</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_CREAT</td>
<td>文件不存在则创建文件，使用此选项时需要使用mode说明文件的权限</td>
</tr>
<tr>
<td>O_EXCL</td>
<td>如果同时指定了O_CREAT，则文件已经存在，则会出错</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>如果文件存在，则清空文件内容</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>写文件时，数据添加到文件末尾</td>
</tr>
<tr>
<td>O_NONBLOCK</td>
<td>对于设备文件，以O_NONBLOCK方式打开可以做非阻塞I&#x2F;O</td>
</tr>
</tbody></table>
<p><strong>mode补充说明</strong></p>
<p>1）文件最终权限：mode &amp; ~umask</p>
<p>2）shell进程的umask掩码可以用umask命令查看</p>
<ul>
<li>umask：查看掩码（补码）</li>
<li>umask mode：设置掩码，mode为八进制数</li>
<li>umask -S:查看各组用户的默认操作权限</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>八进制</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>S_IRWXU</td>
<td>00700</td>
<td>文件拿使用者的读、写、可执行权限</td>
</tr>
<tr>
<td>S_IRUSR</td>
<td>00400</td>
<td>文件所有者的读权限</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>00200</td>
<td>文件所有者的写权限</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>00100</td>
<td>文件所有者的可执行权限</td>
</tr>
<tr>
<td>S_IRWXG</td>
<td>00070</td>
<td>文件所有这同组用户的读、写、可执行权限</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>00040</td>
<td>文件所有者同用户组的读权限</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>00020</td>
<td>文件所有者同组用户的写权限</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>00010</td>
<td>文件所有者同组的可执行权限</td>
</tr>
<tr>
<td>S_IRWXO</td>
<td>00007</td>
<td>其它用户的读、写、可执行权限</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>00004</td>
<td>其它用户的读权限</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>00002</td>
<td>其它用户的写权限</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>00001</td>
<td>其它用户的可执行权限</td>
</tr>
</tbody></table>
<h4 id="5-2-close函数"><a href="#5-2-close函数" class="headerlink" title="5.2 close函数"></a>5.2 close函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    关闭已打开的文件</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符，open()的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span>，并设置errno</span><br></pre></td></tr></table></figure>

<p>需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用close关闭，所有即使用用户程序不调用close，在终止时内核也会自动关闭它打开的文件。</p>
<p>但对于一个长年累月运行的程序（比如网络服务器），打开的文件描述符一定要记得关闭，负责随着打开的文件越多，会占用大量文件描述符和系统资源</p>
<h4 id="5-3-write函数"><a href="#5-3-write函数" class="headerlink" title="5.3 write函数"></a>5.3 write函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据写到文件（fd）</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    buf：数据首地址</span><br><span class="line">    count：写入数据的长度（字节）</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际写入数据的字节个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="5-4-read函数"><a href="#5-4-read函数" class="headerlink" title="5.4 read函数"></a>5.4 read函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据到内存（缓冲区）</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    buf：内存首地址</span><br><span class="line">    count：读取的字节个数</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际读取的字节个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h5 id="阻塞和非阻塞的概念"><a href="#阻塞和非阻塞的概念" class="headerlink" title="阻塞和非阻塞的概念"></a>阻塞和非阻塞的概念</h5><p>读常规文件是不会阻塞，不管读多少字节，read一定会在有限的事件内返回。</p>
<p>从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会阻塞，如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于会阻塞多少事件也是不确定的，如果一直没有数据到达就一直阻塞在那里。</p>
<p>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</p>
<p>【注意】阻塞与非阻塞是对于文件而言的，而不是指read、write等的属性。</p>
<h4 id="5-5-lseek函数"><a href="#5-5-lseek函数" class="headerlink" title="5.5 lseek函数"></a>5.5 lseek函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">功能：</span><br><span class="line">    改变文件的偏移量</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    offset：根据whence来移动的位移量（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。</span><br><span class="line">    </span><br><span class="line">    whence：其取值如下：</span><br><span class="line">        SEEK_SET: 从文件开头移动offset个字节数</span><br><span class="line">        SEEK_CUR: 从当前位置移动offset个字节数</span><br><span class="line">        SEEK_END: 从文件末尾移动offset个字节数</span><br><span class="line">返回值：</span><br><span class="line">    若lseek成功执行，则返回新的偏移量</span><br><span class="line">    如果失败，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="四、文件操作相关函数"><a href="#四、文件操作相关函数" class="headerlink" title="四、文件操作相关函数"></a>四、文件操作相关函数</h2><h3 id="1-stat函数"><a href="#1-stat函数" class="headerlink" title="1.stat函数"></a>1.stat函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取文件状态信息</span><br><span class="line">    stat和lstat的区别：</span><br><span class="line">        当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；</span><br><span class="line">        而stat返回的是该链接指向的文件的信息。</span><br><span class="line">参数：</span><br><span class="line">    path：文件名</span><br><span class="line">    buf：保存文件信息的结构体</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>struct stat结构体说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">               <span class="type">dev_t</span>     st_dev;    <span class="comment">//文件的设备编号</span></span><br><span class="line">               <span class="type">ino_t</span>     st_ino;    <span class="comment">//节点</span></span><br><span class="line">               <span class="type">mode_t</span>    st_mode;  <span class="comment">//文件的类型和存储的权限</span></span><br><span class="line">               <span class="type">nlink_t</span>   st_nlink; <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">               <span class="type">uid_t</span>     st_uid; <span class="comment">//用户ID</span></span><br><span class="line">               <span class="type">gid_t</span>     st_gid;<span class="comment">//组ID</span></span><br><span class="line">               <span class="type">dev_t</span>     st_rdev; <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">               <span class="type">off_t</span>     st_size; <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line">               <span class="type">blksize_t</span> st_blksize; <span class="comment">//块大小(文件系统I/O缓冲区大小)</span></span><br><span class="line">               <span class="type">blkcnt_t</span>  st_blocks;   <span class="comment">//块数</span></span><br><span class="line"></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-stat获得文件类型-第一个版本"><a href="#1-1-stat获得文件类型-第一个版本" class="headerlink" title="1.1 stat获得文件类型(第一个版本)"></a>1.1 stat获得文件类型(第一个版本)</h4><p>之前说stat中有一个获取文件类型和存储权限中的st_mode，其实可以通过这个类型来获取文件的类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">show_file_type</span><span class="params">(<span class="keyword">struct</span> stat* s)</span>&#123;</span><br><span class="line">     <span class="keyword">switch</span>(s-&gt;st_mode &amp; S_IFMT)&#123;</span><br><span class="line">         <span class="keyword">case</span> S_IFREG:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;普通文件\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;目录\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;字符设备\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;块文件\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;套接字\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;管道\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;符号链接\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;未知的文件类型\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//容错判断</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ./a.out filename\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的很多内容都可以在官方手册上看到</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/stat.png"></p>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;st_mode &amp; S_IFMT</span><br></pre></td></tr></table></figure>

<p>是官方手册上规定的写法</p>
<p>运行时只需要执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a.out filename</span><br></pre></td></tr></table></figure>

<p>这里采用的是默认的编译</p>
<p>如果你使用了自定义文件名的话，只需要把 a.out 改成你自定义的文件名就可以了。</p>
<h4 id="1-2-第二种写法"><a href="#1-2-第二种写法" class="headerlink" title="1.2 第二种写法"></a>1.2 第二种写法</h4><p>在官方手册上还提供了第二种写法，比第一种要简单</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/st_mode%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%99%E6%B3%95.png"></p>
<p>直接写代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">show_file_type</span><span class="params">(<span class="keyword">struct</span> stat* s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;普通文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目录\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISCHR(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符设备\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISBLK(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;块文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISSOCK(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;套接字\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;符号链接\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知文件类型\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//容错判断</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out filename\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = stat(argv[<span class="number">1</span>], &amp;s);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    show_file_type(&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-获得文件权限"><a href="#1-3-获得文件权限" class="headerlink" title="1.3 获得文件权限"></a>1.3 获得文件权限</h4><p>在stat中st_mode中提供了查看文件权限的宏定义</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/stat%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">4</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="number">5</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"> <span class="number">6</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span> <span class="type">int</span> <span class="title function_">show_file_type</span><span class="params">(<span class="keyword">struct</span> stat* s)</span>&#123;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">if</span> (s-&gt;st_mode &amp; S_IRUSR)&#123;</span><br><span class="line"><span class="number">10</span>         <span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="number">13</span>         <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span>     <span class="keyword">if</span> (s-&gt;st_mode &amp; S_IWUSR)&#123;</span><br><span class="line"><span class="number">16</span>         <span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="number">19</span>         <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="number">20</span>     &#125;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">if</span> (s-&gt;st_mode &amp; S_IXUSR)&#123;</span><br><span class="line"><span class="number">22</span>         <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span>     <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="number">25</span>         <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span>     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="number">28</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">29</span> &#125;</span><br><span class="line"><span class="number">30</span> </span><br><span class="line"><span class="number">31</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line"><span class="number">32</span>     <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="number">33</span>     <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line"><span class="number">34</span> </span><br><span class="line"><span class="number">35</span>     <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="number">36</span>         <span class="built_in">printf</span>(<span class="string">&quot;./file_3 filename\n&quot;</span>);</span><br><span class="line"><span class="number">37</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">38</span>     &#125;</span><br><span class="line"><span class="number">39</span> </span><br><span class="line"><span class="number">40</span>     ret = stat(argv[<span class="number">1</span>], &amp;s);</span><br><span class="line"><span class="number">41</span>     <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="number">42</span>         perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line"><span class="number">43</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">44</span>     &#125;</span><br><span class="line"><span class="number">45</span>     show_file_type(&amp;s);</span><br><span class="line"><span class="number">46</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">47</span> &#125;                                    </span><br></pre></td></tr></table></figure>

<h3 id="2-access函数"><a href="#2-access函数" class="headerlink" title="2.access函数"></a>2.access函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> mode)</span>;</span><br><span class="line">功能：测试指定文件是否具有某种属性</span><br><span class="line">参数：</span><br><span class="line">    pathname:文件名</span><br><span class="line">    mode:文件权限，<span class="number">4</span>种权限</span><br><span class="line">        R_OK:	是否有读写权限</span><br><span class="line">        W_OK:	是否有写权限</span><br><span class="line">        X_OK:	是否有执行权限</span><br><span class="line">        F_OK:	测试文件是否存在</span><br><span class="line">返回值：</span><br><span class="line">    <span class="number">0</span>：有某种权限，或文件存在</span><br><span class="line">    <span class="number">-1</span>：没有，或文件不存在</span><br></pre></td></tr></table></figure>

<h3 id="3-chmod函数"><a href="#3-chmod函数" class="headerlink" title="3.chmod函数"></a>3.chmod函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：修改文件权限</span><br><span class="line">参数：</span><br><span class="line">    filename:文件名</span><br><span class="line">    mode:权限(<span class="number">8</span>进制数)</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-chown函数"><a href="#4-chown函数" class="headerlink" title="4.chown函数"></a>4.chown函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">uid_t</span> owner, <span class="type">git_t</span> group)</span>;</span><br><span class="line">功能：</span><br><span class="line">    修改文件所有者和所属组</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件或目录名</span><br><span class="line">    owner：文件所有者id，通过查看 /etc/passwd 得到所有者id</span><br><span class="line">    group:文件所属组id，通过 /etc/group 得到用户组id</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="5-truncate函数"><a href="#5-truncate函数" class="headerlink" title="5.truncate函数"></a>5.truncate函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">功能：修改文件大小</span><br><span class="line">参数：</span><br><span class="line">    path：文件名字</span><br><span class="line">    length：指定的文件大小</span><br><span class="line">        a)比用来小，删除后边的部分</span><br><span class="line">        b)比原来大，向后拓展</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="6-link函数"><a href="#6-link函数" class="headerlink" title="6.link函数"></a>6.link函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* oldpath, <span class="type">const</span> <span class="type">char</span>* newpath)</span>;</span><br><span class="line">功能：创建一个硬链接</span><br><span class="line">参数：</span><br><span class="line">    oldpath：源文件名字</span><br><span class="line">    newpath：硬链接名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="7-symlink函数"><a href="#7-symlink函数" class="headerlink" title="7.symlink函数"></a>7.symlink函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* target, <span class="type">const</span> <span class="type">char</span>* linkpath)</span>;</span><br><span class="line">功能：创建一个软链接</span><br><span class="line">参数：</span><br><span class="line">    target：源文件名字</span><br><span class="line">    linkpath：软链接名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="8-readlink函数"><a href="#8-readlink函数" class="headerlink" title="8.readlink函数"></a>8.readlink函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">char</span>* buf, <span class="type">size_t</span> bufsize)</span>;</span><br><span class="line">功能：读软连接对应的文件名，不是读内容(该函数只能读软链接文件)</span><br><span class="line">参数：</span><br><span class="line">    pathname：软连接名</span><br><span class="line">    buf：存放软链接对呀的文件名</span><br><span class="line">    bufsize：缓冲区大小(第二个参数存放的最大字节数)</span><br><span class="line">返回值：</span><br><span class="line">    成功：&gt;<span class="number">0</span>，读到buf中的字符个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="9-unlink函数"><a href="#9-unlink函数" class="headerlink" title="9.unlink函数"></a>9.unlink函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname)</span>;</span><br><span class="line">功能：删除一个文件(软硬链接文件)</span><br><span class="line">参数：</span><br><span class="line">    pathname：删除的文件名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="10-rename函数"><a href="#10-rename函数" class="headerlink" title="10.rename函数"></a>10.rename函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* oldpath, <span class="type">const</span> <span class="type">char</span>* newpath)</span>;</span><br><span class="line">功能：把oldpath的文件名改成newpath</span><br><span class="line">参数：</span><br><span class="line">    oldpath：旧文件名</span><br><span class="line">    newpath：新文件名</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="五、文件描述符复制"><a href="#五、文件描述符复制" class="headerlink" title="五、文件描述符复制"></a>五、文件描述符复制</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>dup() 和dup2() 是两个非常有用的系统调用，都是用来复制一个文件的描述符，使新的文件描述符也标识旧的文件描述符所标识的文件。</p>
<p>对于dup() dup2() 也一样，通过原来的文件描述符复制出一个新的文件描述符，这样的话，原来的我加你描述符和新的文件描述符都指向同一个文件，我们操作这两个文件描述符的任何一个，都能操作它所对应的文件。</p>
<h3 id="2-dup函数"><a href="#2-dup函数" class="headerlink" title="2.dup函数"></a>2.dup函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    通过 oldfd 复制出一个新的文件描述符，新的文件描述符表中最小可用的文件描述符，最终 oldfd 和新的文件描述符都指向同一个文件</span><br><span class="line">参数：</span><br><span class="line">    oldfd：需要复制的文件描述符 oldfd</span><br><span class="line">返回值：</span><br><span class="line">    成功：新文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%BB%93%E6%9E%84.png"></p>
<h3 id="3-dup2函数"><a href="#3-dup2函数" class="headerlink" title="3.dup2函数"></a>3.dup2函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    通过 oldfd 复制出一个新的文件描述符 newfd，如果成功，newfd 和函数返回值是同一个返回值，最终 oldfd 和新的文件描述符 newfd 都指向同一个文件。</span><br><span class="line">    oldfd：需要复制的文件描述符</span><br><span class="line">    newfd：新的文件描述符，这个描述符可以人为指定一个合法数字(<span class="number">0</span><span class="number">-1023</span>)，如果指定的数字已经被占用（和某个文件有关联），此函数会自动关闭close()断开这个数字和某个文件的关联，再来使用这个合法数字。</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回 newfd</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-案例分析"><a href="#4-案例分析" class="headerlink" title="4.案例分析"></a>4.案例分析</h3><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.png"></p>
<h3 id="5-fcntl函数"><a href="#5-fcntl函数" class="headerlink" title="5.fcntl函数"></a>5.fcntl函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line">功能：改变已打开的文件性质，fcntl针对描述符提供控制。</span><br><span class="line">参数：</span><br><span class="line">    fd：操作的文件操作符</span><br><span class="line">    cmd：操作方式</span><br><span class="line">    arg：针对cmd的值，fcntl能够接受第三个参数<span class="type">int</span> arg</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回某个其他值</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>fcntl函数有5种功能：</p>
<p>1）复制一个现有的描述符（cmd &#x3D; F_DUPFD）</p>
<p>2）获得 &#x2F; 设置文件描述符标记（cmd&#x3D;F_GETFD或F_SETFD）</p>
<p>3）获得 &#x2F; 设置文件状态标记（cmd&#x3D;F_GETFL或F_SETFL）</p>
<p>4）获得 &#x2F; 设置异步I&#x2F;O所有权（cmd&#x3D;F_GETOWN或F_SETOWN）</p>
<p>5）获得 &#x2F; 设置记录锁（cmd&#x3D;F_GETLK，F_SETLK或F_SETLKW）</p>
</blockquote>
<p>示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fcntl复制文件描述符功能</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> newfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="comment">//第三个参数0 表示返回第一个最小的可用的文件描述符，并且大于或等于0</span></span><br><span class="line">    newfd = fcntl(fd, F_DUPFD, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (newfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写文件</span></span><br><span class="line">    write(fd, <span class="string">&quot;123456789&quot;</span>, <span class="number">9</span>);</span><br><span class="line">    write(newfd, <span class="string">&quot;ABCDEFG&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    close(newfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-获得文件状态表示和设置"><a href="#5-1-获得文件状态表示和设置" class="headerlink" title="5.1 获得文件状态表示和设置"></a>5.1 获得文件状态表示和设置</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fcntl复制文件描述符功能</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> newfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件状态标记</span></span><br><span class="line">    ret = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &amp; O_APPEND)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before not append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置文件状态标记</span></span><br><span class="line">    ret = ret | O_APPEND;</span><br><span class="line">    ret = fcntl(fd, F_SETFL, ret);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件状态标记</span></span><br><span class="line">    ret = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &amp; O_APPEND)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before not append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-目录习惯操作"><a href="#6-目录习惯操作" class="headerlink" title="6.目录习惯操作"></a>6.目录习惯操作</h3><h4 id="6-1-getcwd函数"><a href="#6-1-getcwd函数" class="headerlink" title="6.1 getcwd函数"></a>6.1 getcwd函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getcwd</span><span class="params">(<span class="type">char</span>* buf, <span class="type">sie_t</span> size)</span>;</span><br><span class="line">功能：获取当前进程的工作目录</span><br><span class="line">参数：</span><br><span class="line">    buf：缓冲区，存储当前的工作目录</span><br><span class="line">    size：缓冲区大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：buf中保存当前进程工作目录位置</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-chdir函数"><a href="#6-2-chdir函数" class="headerlink" title="6.2 chdir函数"></a>6.2 chdir函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span>;</span><br><span class="line">功能：修改当前进程(应用程序)的路径</span><br><span class="line">参数：</span><br><span class="line">    path：切换的路径</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-opendir函数"><a href="#6-3-opendir函数" class="headerlink" title="6.3 opendir函数"></a>6.3 opendir函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR* <span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br><span class="line">功能：打开一个目录</span><br><span class="line">参数：</span><br><span class="line">    name：目录名</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回指向该目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="6-4-closedir函数"><a href="#6-4-closedir函数" class="headerlink" title="6.4 closedir函数"></a>6.4 closedir函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR* dirp)</span>;</span><br><span class="line">功能：关闭目录</span><br><span class="line">参数：</span><br><span class="line">    dirp：opendir返回的指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="6-5-readdir函数"><a href="#6-5-readdir函数" class="headerlink" title="6.5 readdir函数"></a>6.5 readdir函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent* <span class="title function_">readdir</span><span class="params">(DIR* dirp)</span>;</span><br><span class="line">功能：读取目录</span><br><span class="line">参数：</span><br><span class="line">    dirp：opendir的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p>相关结构体说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>&#123;</span></span><br><span class="line">    <span class="type">ino_t</span> d_ino;	<span class="comment">//此目录进入点的inode</span></span><br><span class="line">    <span class="type">off_t</span> d_off;	<span class="comment">//目录文件开头至目录进入点的位移</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">short</span> <span class="type">int</span> d_reclen;	<span class="comment">//d_name的长度，不包含NULL字符</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> d_type;	<span class="comment">//d_type所指的文件类型</span></span><br><span class="line">    <span class="type">char</span> d_name[<span class="number">256</span>];	<span class="comment">//文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>d_type文件类型说明</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DT_BLK</td>
<td>块设备</td>
</tr>
<tr>
<td>DT_CHR</td>
<td>字符设备</td>
</tr>
<tr>
<td>DT_DIR</td>
<td>目录</td>
</tr>
<tr>
<td>DT_LNK</td>
<td>软链接</td>
</tr>
<tr>
<td>DT_FIFO</td>
<td>管道</td>
</tr>
<tr>
<td>DT_REG</td>
<td>普通文件</td>
</tr>
<tr>
<td>DT_SOCK</td>
<td>套接字</td>
</tr>
<tr>
<td>DT_UNKNOWN</td>
<td>未知</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//目录打开和关闭</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    DIR* dir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">d</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//打开目录</span></span><br><span class="line">    dir = opendir(<span class="string">&quot;/home/pi/student/student03&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;dir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开目录成功...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//循读取目录中的内容</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        d = readdir(dir);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file_type:%hu\tfile_name:%s\n&quot;</span>, d-&gt;d_type, d-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="六、进程"><a href="#六、进程" class="headerlink" title="六、进程"></a>六、进程</h2><h3 id="1-进程和程序"><a href="#1-进程和程序" class="headerlink" title="1.进程和程序"></a>1.进程和程序</h3><p>程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。程序是静态的，进程是动态的。</p>
<p>在linux系统中，操作系统是通过进程去完成一个一个的任务，进程是管理事务的基本单元。</p>
<p>进程拥有自己独立的处理环境（如：当前需要用到哪些环境变量，程序运行的目录在哪是，当前是哪个用户在运行此程序等）和系统资源（如：处理器CPU占用率、存储器、I&#x2F;O设备、数据、程序）。</p>
<h3 id="2-单道、多道程序设计"><a href="#2-单道、多道程序设计" class="headerlink" title="2.单道、多道程序设计"></a>2.单道、多道程序设计</h3><h4 id="2-1-单道程序设计"><a href="#2-1-单道程序设计" class="headerlink" title="2.1 单道程序设计"></a>2.1 单道程序设计</h4><p>所有进程一个一个排队执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现是必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p>
<h4 id="2-2-多道程序设计"><a href="#2-2-多道程序设计" class="headerlink" title="2.2 多道程序设计"></a>2.2 多道程序设计</h4><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p>
<p>在计算机中时钟中断即为多道程序设计模型的理论基础。并发时，任意进程在执行期间都不希望放弃CPU。因此系统需要一种强制让进程让出CPU资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。操作系统中的中断处理函数来负责调度程序执行。</p>
<p>在多道程序设计模型中，多个进程轮流使用CPU（（分时复用CPU资源）。而当下常用CPU为纳秒级，1秒可执行大约10亿条指令。由于人眼的反应是毫秒级的，所以看似同时进行。</p>
<blockquote>
<p>1s &#x3D; 1000ms</p>
<p>1ms &#x3D; 1000um</p>
<p>1um &#x3D; 1000ns</p>
<p>1s &#x3D; 1000000000ns</p>
</blockquote>
<h3 id="3-并行和并发"><a href="#3-并行和并发" class="headerlink" title="3.并行和并发"></a>3.并行和并发</h3><p>**并行(parallel):**指同一时刻，有多条指令在多个处理器上同时执行</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B9%B6%E8%A1%8C.png"></p>
<p>**并发(concurrency):**指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使得进程快速交替的执行</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B9%B6%E5%8F%91.png"></p>
<h3 id="4-MMU"><a href="#4-MMU" class="headerlink" title="4.MMU"></a>4.MMU</h3><p>MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中原来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/MMU.png"></p>
<h3 id="5-进程控制块PCB"><a href="#5-进程控制块PCB" class="headerlink" title="5.进程控制块PCB"></a>5.进程控制块PCB</h3><p>进程运行时，内核为进程每个进程分配一个PCB（进程控制块），维护相关信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>其内部成员有很多，掌握以下部分即可</p>
<ul>
<li>进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</li>
<li>进程的状态，有就绪、运行、挂起、停止等状态</li>
<li>进程切换时需要保存和恢复的一些CPU存储器</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息。</li>
<li>当前工作目录（Current Working Directory）。</li>
<li>umask掩码</li>
<li>文件描述符，包含很多指向file结构体的指针。</li>
<li>和信号相关的信息</li>
<li>用户id和组id</li>
<li>会话（Session）和进程组</li>
<li>进程可以使用的资源上限（Resource Limit）。</li>
</ul>
<h3 id="6-进程的状态"><a href="#6-进程的状态" class="headerlink" title="6.进程的状态"></a>6.进程的状态</h3><p>进程状态反应进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。</p>
<p>在三态模型中，进程状态分为三个基本状态，即<strong>运行态、就绪态、阻塞态。</strong></p>
<p>在五态模型中，进程分为<strong>新建态、终止态、运行态、就绪态、阻塞态。</strong></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png"></p>
<p>查看进程的方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>

<h4 id="6-1-ps"><a href="#6-1-ps" class="headerlink" title="6.1 ps"></a>6.1 ps</h4><p>进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。</p>
<p>ps命令可以查看进程的详细情况，常用选项(选项可以不加”-“)如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示终端上的所有进程，包括其它用户的进程</td>
</tr>
<tr>
<td>-u</td>
<td>显示进程的详细状态</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
<tr>
<td>-w</td>
<td>显示加宽，以便显示更多的信息</td>
</tr>
<tr>
<td>-r</td>
<td>只显示正在运行的进程</td>
</tr>
</tbody></table>
<h4 id="6-2-top"><a href="#6-2-top" class="headerlink" title="6.2 top"></a>6.2 top</h4><p>top命令用来动态显示运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。可以在top命令时加上-d来指定显示信息更新的时间间隔。</p>
<p>在top命令执行后，可以按下按键得到对显示的结果进行排序：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>M</td>
<td>根据内存使用量来排序</td>
</tr>
<tr>
<td>P</td>
<td>根据CPU占有率来排序</td>
</tr>
<tr>
<td>T</td>
<td>根据进程运行时间的长短来排序</td>
</tr>
<tr>
<td>U</td>
<td>可以根据后面输入的用户名筛选进程</td>
</tr>
<tr>
<td>K</td>
<td>可以根据后面输入的PID来杀死进程</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>h</td>
<td>获得帮助</td>
</tr>
</tbody></table>
<h4 id="6-3-kill"><a href="#6-3-kill" class="headerlink" title="6.3 kill"></a>6.3 kill</h4><p>kill命令指定进程号的进程，需要配合ps使用</p>
<p>使用格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill [-signal] pid</span><br></pre></td></tr></table></figure>

<p>信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。</p>
<p>有些进程没办法直接杀死，需要添加 <code>-9</code> 参数强制杀死</p>
<h4 id="6-4-killall"><a href="#6-4-killall" class="headerlink" title="6.4 killall"></a>6.4 killall</h4><p>通过名字杀死进程</p>
<h3 id="7-进程号和相关函数"><a href="#7-进程号和相关函数" class="headerlink" title="7.进程号和相关函数"></a>7.进程号和相关函数</h3><p>每个进程都由一个进程号标识，其类型为pid_t（整形），进程号的范围：0~32767.进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用。</p>
<p><strong>进程号（PID）：</strong></p>
<p>标识进程的一个非负整形数</p>
<p><strong>父进程号（PPID）：</strong></p>
<p>任何进程（除init进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。如，A进程创建了B进程，A的进程号就是B进程的父进程号。</p>
<p><strong>进程组号（PGID）：</strong></p>
<p>进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。这个过程有点类似于QQ群，各个进程相当于各个好友，把各个好友都拉入这个QQ群里，主要是方便管理，特别是通知某些事时，只要在群里吼一声，所有人都收到，简单粗暴。但是，这个进程组号和QQ群号是有区别的，默认的情况下，当前的进程号会当作当前的进程号。</p>
<h4 id="7-1-getpid函数"><a href="#7-1-getpid函数" class="headerlink" title="7.1 getpid函数"></a>7.1 getpid函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取本进程号（PID）</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    本进程号</span><br></pre></td></tr></table></figure>

<h4 id="7-2-getppid函数"><a href="#7-2-getppid函数" class="headerlink" title="7.2 getppid函数"></a>7.2 getppid函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：获取调用此函数的进程的父进程号</span><br><span class="line">参数：无</span><br><span class="line">返回值：调用此函数的进程的父进程号（PPID）</span><br></pre></td></tr></table></figure>

<h4 id="7-3-getpgid函数"><a href="#7-3-getpgid函数" class="headerlink" title="7.3 getpgid函数"></a>7.3 getpgid函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取进程组号（PGID）</span><br><span class="line">参数：</span><br><span class="line">    查询进程的进程号</span><br><span class="line">返回值：</span><br><span class="line">    进程组号（PGID）</span><br></pre></td></tr></table></figure>

<h4 id="7-4-示例"><a href="#7-4-示例" class="headerlink" title="7.4 示例"></a>7.4 示例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取进程号 父进程号 进程组号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//获取当前进程的进程号</span></span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程号:%d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前进程的父进程号</span></span><br><span class="line">    pid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父进程号:%d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前进程组号</span></span><br><span class="line">    pid = getpgid(getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程组号:%d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-进程的创建"><a href="#8-进程的创建" class="headerlink" title="8.进程的创建"></a>8.进程的创建</h3><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程呢个，形成进程树结构模型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：用于从一个已经存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程。</span><br><span class="line">参数：无</span><br><span class="line">返回值：</span><br><span class="line">    成功：子进程中返回<span class="number">0</span>，父进程中返回子进程ID。<span class="type">pid_t</span>为整形</span><br><span class="line">    失败：返回<span class="number">-1</span></span><br><span class="line">    失败的两个原因：</span><br><span class="line">        <span class="number">1</span>）当前的进程数已经达到了系统规定的上限，这时errno的值为EAGAIN。</span><br><span class="line">        <span class="number">2</span>）系统内存不足，这时errno的值被设置为ENOMEM。</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,word\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">hello,word</span><br><span class="line">hello,word</span><br></pre></td></tr></table></figure>

<h3 id="9-父子进程关系"><a href="#9-父子进程关系" class="headerlink" title="9.父子进程关系"></a>9.父子进程关系</h3><p>使用fork()函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。</p>
<p>子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用fork()函数的代价是很大的。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png"></p>
<p>简单来说，一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p>
<p>实际上，更准确来说，Linux的fork()使用是通过写时拷贝（copy-on-write）实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只要在需要写入的社会才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</p>
<p>注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件文件偏移指针。</p>
<h3 id="10-区分父子进程"><a href="#10-区分父子进程" class="headerlink" title="10.区分父子进程"></a>10.区分父子进程</h3><p>子进程是父进程的一个复制品，可以简单认为父子进程的代码一样。父进程做了什么事，子进程也做什么事，如果我们需要实现多任务的要求该如何实现呢？答案是通过fork()的返回值。</p>
<p>fork()函数被调用一次，但返回两次。两次返回的区别是：子进程的返回值是0，而父进程的返回值则是子进程的ID。</p>
<p>测试程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> child_id;</span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程创建失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id: %d  pid: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id: %d  child_id: %d\n&quot;</span>, getpid(), child_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-父子进程地址空间"><a href="#11-父子进程地址空间" class="headerlink" title="11.父子进程地址空间"></a>11.父子进程地址空间</h3><p>父进程的值是在单独的空间，子进程的值是在单独空间，两者修改不会互相影响。</p>
<p>如果是在堆区开辟的空间也不会相互受到影响，但是记住一定要释放一下开辟出来的空间，比如下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> child_id;</span><br><span class="line">    <span class="type">int</span>* num = <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *num = <span class="number">200</span>;</span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程创建失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_id == <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程:%d\n&quot;</span>, *num);</span><br><span class="line">        <span class="built_in">free</span>(num);</span><br><span class="line">        num = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程前:%d\n&quot;</span>, *num);</span><br><span class="line">        (*num)++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程后:%d\n&quot;</span>, *num);</span><br><span class="line">        <span class="built_in">free</span>(num);</span><br><span class="line">        num = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不两次释放会导致内存溢出</p>
<h3 id="12-GDB调试多进程"><a href="#12-GDB调试多进程" class="headerlink" title="12.GDB调试多进程"></a>12.GDB调试多进程</h3><p>使用GDB调试的时候，GDB只能跟踪一个进程。可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者各种子进程。默认跟踪父进程。</p>
<ul>
<li>set follow-fork-mode child	设置GDB在fork之后跟踪子进程。</li>
<li>set follow-fork-mode parent  设置跟踪父进程（默认）</li>
</ul>
<p>注意，一定要在fork函数调用之前设置才有效</p>
<h3 id="13-进程退出函数"><a href="#13-进程退出函数" class="headerlink" title="13.进程退出函数"></a>13.进程退出函数</h3><p>相关函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line">功能：</span><br><span class="line">    结束调用此函数的进程。</span><br><span class="line">参数：</span><br><span class="line">    status：返回值给父进程的参数（低<span class="number">8</span>位有效），至于这个参数是多少根据需求来写。</span><br><span class="line">返回值：</span><br><span class="line">    无</span><br></pre></td></tr></table></figure>

<p>exit() 和 _exit() 函数功能和用法是一样的，无非是所包含的头文件不一样，exit() 属于标准库函数， _exit() 属于系统调用函数。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%80%80%E5%87%BA%E8%BF%9B%E7%A8%8B%E5%87%BD%E6%95%B0.png"></p>
<h3 id="14-等待进程退出函数"><a href="#14-等待进程退出函数" class="headerlink" title="14.等待进程退出函数"></a>14.等待进程退出函数</h3><h4 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h4><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号、退出状态、允许时间等）。</p>
<p>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除这个进程。</p>
<p>wait() 和 waitpid() 函数的功能一样，区别在于， wait() 函数会阻塞， waitpid() 可以设置不阻塞， waitpid() 还可以指定等待哪个子进程结束。</p>
<p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
<h4 id="14-2-wait函数"><a href="#14-2-wait函数" class="headerlink" title="14.2 wait函数"></a>14.2 wait函数</h4><p>函数说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>* status)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    status：进程结束时的状态信息</span><br><span class="line">返回值：</span><br><span class="line">    成功：已经结束子进程的进程号</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>调用 wait() 函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号才被唤醒（相当于继续往下执行）。</p>
<p>若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。</p>
<p>所以，wait()函数的主要功能为回收已经结束子进程的资源。</p>
<p>如果参数status的值不是NULL，wait() 就会把子进程退出时的状态取出并存入其中，这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的。</p>
<p>这个退出信息在一个int中包含了多个字段，直接使用这个值是没有意义的，我们需要用宏定义取出其中的每个字段。</p>
<p><strong>宏函数可以分为如下三组：</strong></p>
<p>1）WIFEXITED(status)</p>
<p>​	为非0 进程正常结束</p>
<p>WEXITSTATUS(status)</p>
<p>​	如果宏为真，使用此宏 获取进程退出状态（exit的参数）</p>
<p>2）WIFSIGNALED(status)</p>
<p>​	为非0 进程异常终止</p>
<p>WTERMSIG(status)</p>
<p>​	如上宏为真，使用此宏 取得进程终止的那个信号的编号</p>
<p>3）WIFSTOPPED(status)</p>
<p>​	为非0 进程处于暂停状态</p>
<p>WSTOPSIG(status)</p>
<p>​	如上宏为真，使用此宏 取得使进程暂停的那个信号的编号</p>
<p>WIFCONTINUED(status)</p>
<p>​	为真 进程暂停后已经继续运行</p>
<h4 id="14-3-waitpid函数"><a href="#14-3-waitpid函数" class="headerlink" title="14.3 waitpid函数"></a>14.3 waitpid函数</h4><p>函数说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">pid_d <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* status, <span class="type">int</span> options)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    pid：参数 pid 的值有以下几种类型：</span><br><span class="line">    pid &gt; <span class="number">0</span> 等待进程 ID 等于 pid 的子进程</span><br><span class="line">    pid = <span class="number">0</span> 等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid 不会等待它。</span><br><span class="line">    pid = <span class="number">-1</span> 等待任意子进程，此时 waitpid 和 wait 作用一样。</span><br><span class="line">    pid &lt; <span class="number">-1</span> 等待指定进程组中的任何子进程，这个进程组的 ID 等于 pid 的绝对值。</span><br><span class="line">    </span><br><span class="line">    status：进程退出时的状态信息。和 wait() 用法一样。</span><br><span class="line">    </span><br><span class="line">    options：options 提供了一些额外的选项来控制 waitpid()。</span><br><span class="line">        <span class="number">0</span>：同 wait(),阻塞父进程，等待子进程退出。</span><br><span class="line">        WNOHANG:没有任何已经结束的子进程，则立刻返回</span><br><span class="line">        WUNTRACED:如果子进程暂停了则此函数马上返回，并且不予理会子进程的结束状态。（由于涉及到一些调试方面的知识，加之极少用到）</span><br><span class="line">返回值：</span><br><span class="line">    waitpid() 的返回值比 wait() 稍微复杂一些，一共有 <span class="number">3</span> 种情况：</span><br><span class="line">        <span class="number">1</span>) 当正常返回的时候，waitpid() 返回收集到的已经回收子进程的进程号；</span><br><span class="line">        <span class="number">2</span>) 如果设置了选项 WNOHANG，而调用中 waitpid() 发现没有已退出的子进程可等待，则返回 <span class="number">0</span>；</span><br><span class="line">        <span class="number">3</span>) 如果调用中出错，则返回<span class="number">-1</span>，这时 errno 会被设置成相应的值以指示错误所在，如：当 pid 所对应的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid() 就会出错返回，这时 errno 被设置为 ECHILD；</span><br></pre></td></tr></table></figure>

<h3 id="15-孤儿进程"><a href="#15-孤儿进程" class="headerlink" title="15.孤儿进程"></a>15.孤儿进程</h3><p>父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程（Orphan Process）。</p>
<p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。</p>
<p>因此孤儿进程并不会有什么危害。</p>
<h3 id="16-僵尸进程"><a href="#16-僵尸进程" class="headerlink" title="16.僵尸进程"></a>16.僵尸进程</h3><p>进程终止，父进程尚未回收子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</p>
<p>这样就会导致一个问题，如果进程不调用wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有进程号而导致系统不能产生新的进程，这就是僵尸进程的危害，应当避免。</p>
<h3 id="17-进程替换"><a href="#17-进程替换" class="headerlink" title="17.进程替换"></a>17.进程替换</h3><p><strong>概述</strong></p>
<p>在Windows平台下，我们可以通过双击运行可执行程序成为一个进程；而在Linux平台，我们可以通过 <code>./</code> 运行，让一个可执行程序成为一个进程。</p>
<p>但是，如果我们本来就运行着一个程序（进程），我们如何在这个进程内部启动一个外部程序，由内核将这个程序读入内存，使其执行起来成为一个进程呢？这里我们通过 exec 函数族实现。</p>
<p>exec 函数族，顾名思义，就是一簇函数，在Linux中，并不存在 exec() 函数，exec 指的是一组函数，一共有6个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...<span class="comment">/*(char*)NULL */</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* arg, ...<span class="comment">/*(char*)NULL */</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...<span class="comment">/*(char*)NULL char* const envp[]*/</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<p>其中只有 execve() 是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</p>
<p>exec函数族的作用是根据指定的文件名或目录名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p>
<p>进程调用一种exec函数时，该进程完全由新程序交替，而新程序则从其main函数开始执行。因为调用exec并吧创建新进程，所以前后的进程 ID （当然还有父进程号、进程组号、当前工作目录……）并未改变。exec 只是用另一个新程序替换了当前进程的正文、数据、堆和栈段（进程替换）。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2.png"></p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/home&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、进程间通讯"><a href="#七、进程间通讯" class="headerlink" title="七、进程间通讯"></a>七、进程间通讯</h2><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p>
<p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信（IPC：Inter Processes Communication）。</p>
<p>进程间通讯的目的：</p>
<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ul>
<p><strong>Linux 操作系统支持的主要进程间通信的通信机制：</strong></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E4%B8%AD%E9%80%9A%E8%AE%AF%E6%A6%82%E5%BF%B5.png"></p>
<h3 id="1-无名管道"><a href="#1-无名管道" class="headerlink" title="1.无名管道"></a>1.无名管道</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>管道也叫无名管道，它是UNIX系统IPC（进程间通信）的最古老形式，所有的UNIX系统都支持这种通信机制。</p>
<p><strong>管道有如下特点：</strong></p>
<p>1）半双工，数据在同一时刻只能在一个方向上流动。</p>
<p>2）数据只能从管道的一端写入，从另一端读出。</p>
<p>3）写入管道中的数据遵循先入后出的规则。</p>
<p>4）管道所传送的数据是无格式的，这要求管道的读出方必须事先约定好数据的格式，如多少字节算一个消息等。</p>
<p>5）管道不是普通的文件，不属于某个文件系统，其只存放于内存中。</p>
<p>6）管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。</p>
<p>7）从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据。</p>
<p>8）管道没有名字，只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</p>
<p>对于管道特点的理解，我们可以类比实现生活中管子，管子的一端塞东西，管子的另一端取东西。</p>
<p>管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93.png"></p>
<h4 id="1-2-pipe函数"><a href="#1-2-pipe函数" class="headerlink" title="1.2 pipe函数"></a>1.2 pipe函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line">功能：创建无名管道。</span><br><span class="line">    </span><br><span class="line">参数：</span><br><span class="line">    pipefd：为 <span class="type">int</span> 型数组的首地址，其存放了管道的文件描述符 pipefd[<span class="number">0</span>]、pipefd[<span class="number">1</span>]。</span><br><span class="line">    </span><br><span class="line">    当一个管道建立时，它会创建两个文件描述符 fd[<span class="number">0</span>] 和 fd[<span class="number">1</span>]。其中 fd[<span class="number">0</span>] 固定用于读管道，而 fd[<span class="number">1</span>] 固定用于写管道。一般文件 I/O的函数都可以用来操作管道(lseek() 除外)。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>例子：父子进程通过无名管道进行通讯</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父子进程通讯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> read_string[SIZE];</span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>, child_id = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> read_bool = <span class="number">-1</span>, write_bool = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建无名管道</span></span><br><span class="line">    ret = pipe(pd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子进程 读内容</span></span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//禁用写端</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取管道中的内容</span></span><br><span class="line">        read_bool = read(pd[<span class="number">0</span>], read_string, SIZE);</span><br><span class="line">        <span class="keyword">if</span> (read_bool &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child read: %s\n&quot;</span>, read_string);</span><br><span class="line">        <span class="comment">//禁用读端</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父进程 写内容</span></span><br><span class="line">    <span class="comment">//关闭读管道</span></span><br><span class="line">    close(pd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    write_bool = write(pd[<span class="number">1</span>], <span class="string">&quot;ABCDEFGHIJK&quot;</span>, SIZE);</span><br><span class="line">    <span class="keyword">if</span>(write_bool &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent process write len: %d\n&quot;</span>, write_bool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭写管道</span></span><br><span class="line">    close(pd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意一下，创建匿名管道的时候需要在创建进程前创建，如果按照下面的代码创建匿名管道：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>], ret, i;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">            ret = read(fd[<span class="number">0</span>], buf, <span class="number">20</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, ret, buf);</span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">            ret = write(fd[<span class="number">1</span>], <span class="string">&quot;abcd&quot;</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样会导致子进程读不出父进程向管道传入的数据，原因是因为在创建好子进程后，子进程后父进程分别创建了一个管道，子进程使用的管道是子进程自己创建的管道，而父进程使用的管道是父进程创建的管道，父进程向管道中传入内容，其实是向它自己创建的管道中传入内容，而子进程读取管道中的内容是读取自己管道中的内容，所以子进程读不出来内容。 </p>
<h4 id="1-3-管道的读写特点"><a href="#1-3-管道的读写特点" class="headerlink" title="1.3 管道的读写特点"></a>1.3 管道的读写特点</h4><p>使用管道需要注意一下4种特殊情况（假设都是阻塞I&#x2F;O操作，没有设置O_NONBLOCK标志）：</p>
<p>1）如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</p>
<p>2）如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</p>
<p>3）如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。</p>
<p>4）如果有指向管道读端的文件描述符没关闭（管道读端引用计数器大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p>
<p><strong>总结：</strong></p>
<p><strong>读管道：</strong></p>
<ul>
<li>管道中有数据，read返回实际读到的字节数。</li>
<li>管道中无数据：<ul>
<li>管道写端被全部关闭，read返回0（相当于读到文件结尾）</li>
<li>写端没有全部被关闭，read阻塞等待（不久的将来可能有数据递达，此时会让出CPU）</li>
</ul>
</li>
</ul>
<p><strong>写管道：</strong></p>
<ul>
<li>管道读端全部被关闭，进程异常终止（也可使用捕捉SIGPIPE信号，使进程终止）</li>
<li>管道读端没有全部关闭：<ul>
<li>管道已满，write阻塞。</li>
<li>管道未满，writr将数据写入，并返回实际写入的字节数</li>
</ul>
</li>
</ul>
<h4 id="1-4-设置为非阻塞的方法"><a href="#1-4-设置为非阻塞的方法" class="headerlink" title="1.4 设置为非阻塞的方法"></a>1.4 设置为非阻塞的方法</h4><p>设置方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取原来的flags</span></span><br><span class="line"><span class="type">int</span> flage = fcntl(fd[<span class="number">0</span>], F_GETFL);</span><br><span class="line"><span class="comment">//设置新的flags</span></span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line"><span class="comment">//flags = flags | O_NONBLOCK;</span></span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flags);</span><br></pre></td></tr></table></figure>

<p>结论：如果写端没有关闭，读端设置为非阻塞，直接返回-1。</p>
<h4 id="1-5-查看管道缓冲区命令"><a href="#1-5-查看管道缓冲区命令" class="headerlink" title="1.5 查看管道缓冲区命令"></a>1.5 查看管道缓冲区命令</h4><p>可以使用ulimit-a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小</p>
<h4 id="1-6-查看管道缓冲区函数"><a href="#1-6-查看管道缓冲区函数" class="headerlink" title="1.6 查看管道缓冲区函数"></a>1.6 查看管道缓冲区函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line">功能：该函数可以通过name参数查看不同的属性值</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    name：</span><br><span class="line">        _PC_PIPE_BUF,查看管道缓冲区大小</span><br><span class="line">        _PC_NAME_MAX,文件名字字节数的上限</span><br><span class="line">返回值：</span><br><span class="line">    成功：根据name返回的值的意义也不同。</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>], ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建无名管道</span></span><br><span class="line">    ret = pipe(pd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看管道缓冲区函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, fpathconf(pd[<span class="number">0</span>], _PC_PIPE_BUF));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, fpathconf(pd[<span class="number">0</span>], _PC_NAME_MAX));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-有名管道"><a href="#2-有名管道" class="headerlink" title="2.有名管道"></a>2.有名管道</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>无名管道由于没有名字，只能用于亲缘关系的进程间通讯。为了克服这个缺点，提出了明名管道（FIFO），也叫有民管道、FIFO文件。</p>
<p>命名管道（FIFO）不同于无名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通讯，因此，通过FIFO不相关的进程也能交换数据。</p>
<p>命名管道（FIFO）和无名管道（pipe）有一些特点是相同的，不一样的地方在于：</p>
<p>1）FIFO在文件系统中作为一个特殊的文件而存在，但FIFO中的内容却存放在内存中。</p>
<p>2）当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。</p>
<p>3）FIFO有名字，不相关的进程可以通过打开命名管道进行通讯。</p>
<h4 id="2-2-通过命令创建有名管道"><a href="#2-2-通过命令创建有名管道" class="headerlink" title="2.2 通过命令创建有名管道"></a>2.2 通过命令创建有名管道</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93.png"></p>
<h4 id="2-3-通过函数创建有名管道"><a href="#2-3-通过函数创建有名管道" class="headerlink" title="2.3 通过函数创建有名管道"></a>2.3 通过函数创建有名管道</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：</span><br><span class="line">    命名管道的创建。</span><br><span class="line">参数：</span><br><span class="line">    pathname : 普通的路径名，也就是创建后 FIFO 的名字。</span><br><span class="line">    mode : 文件的权限，与打开普通文件的 open() 函数中的 mode 参数相同。（<span class="number">0666</span>）</span><br><span class="line">返回值：</span><br><span class="line">    成功: <span class="number">0</span>	状态码</span><br><span class="line">    失败：如果文件已经存在，则会出错且返回<span class="number">-1</span>。    </span><br></pre></td></tr></table></figure>

<h4 id="2-4-有名管道读写操作"><a href="#2-4-有名管道读写操作" class="headerlink" title="2.4 有名管道读写操作"></a>2.4 有名管道读写操作</h4><p>一旦使用mkfifo创建一个FIFO，就可以使用open打开它，常见的文件I&#x2F;O函数都可用于fifo。如：close、read、write、unlink等。</p>
<p>FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始到处返回数据，对它们的写则把数据添加到末尾。<strong>它们不支持诸如lseek()等文件定位操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*write.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fp = <span class="number">-1</span>, ret = <span class="number">-1</span>, i = <span class="number">14</span>;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="comment">//打开有名管道</span></span><br><span class="line">    fp = open(<span class="string">&quot;fifo&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写内容</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, SIZE);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello itcast:%d&quot;</span>, i);</span><br><span class="line">        ret = write(fp, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write fifo : %d\n&quot;</span>, ret);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭管道</span></span><br><span class="line">    close(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*read.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd =<span class="number">-1</span>, ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;fifo&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read....\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ret = read(fd, buf, SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-有名管道注意事项"><a href="#2-5-有名管道注意事项" class="headerlink" title="2.5 有名管道注意事项"></a>2.5 有名管道注意事项</h4><p>1）一个为只读而打开一个管道的进程会阻塞直到另一个进程为只写打开该管道</p>
<p>2）一个为只写而打开一个管道的进程会阻塞直到另一个进程为只读打开管道</p>
<p><strong>读管道：</strong></p>
<ul>
<li>管道中有数据，read返回实际读到的字节数。</li>
<li>管道中无数据：<ul>
<li>管道写端被全部关闭，read返回0（相当于读到文件结尾）</li>
<li>写端没有全部被关闭，read阻塞等待</li>
</ul>
</li>
</ul>
<p><strong>写管道：</strong></p>
<ul>
<li>管道读端全部被关闭，进程异常终止（也可使用捕捉SIGPIPE信号，使进程终止）</li>
<li>管道读端没有全部关闭：<ul>
<li>管道已满，write阻塞。</li>
<li>管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ul>
</li>
</ul>
<h3 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3.消息队列"></a>3.消息队列</h3><p>在上面说了一下管道，学习完管道后发现管道是一端发送什么，另一端就只能接收什么，而且只能传递一种类型，但在实际的项目中，有些时候需要选择性的接收另一端传递过来的数据，为了解决这个问题，Linux中出现了一个叫做消息队列的东西。</p>
<h4 id="3-1-什么是消息队列"><a href="#3-1-什么是消息队列" class="headerlink" title="3.1 什么是消息队列"></a>3.1 什么是消息队列</h4><p>消息队列其实是一个在内核地址空间中的内部链表，每一个链表的内容是一个数据块，数据块中能存放的内容有很多的类型，这些可以自己去定义，而且还能选择性的进行接收数据。</p>
<h4 id="3-2-通过命令查看消息队列"><a href="#3-2-通过命令查看消息队列" class="headerlink" title="3.2 通过命令查看消息队列"></a>3.2 通过命令查看消息队列</h4><p>在Linux中可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipcs -q</span><br></pre></td></tr></table></figure>

<p>来查看一下当前系统中的消息队列的个数和每个消息队列的大小</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png"></p>
<h4 id="3-3-创建消息队列"><a href="#3-3-创建消息队列" class="headerlink" title="3.3 创建消息队列"></a>3.3 创建消息队列</h4><p>可以使用<code>msgget</code>函数创建出一个消息队列，函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgfig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    功能：创建接口队列</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        key:消息队列中的键值，通常使用ftok()函数进行创建</span></span><br><span class="line"><span class="comment">        msgfig:权限标志</span></span><br><span class="line"><span class="comment">            IPC_CREATE:如果key值所对应的消息队列不存在，那么就创建一个</span></span><br><span class="line"><span class="comment">            IPC_EXCL:</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="4-共享存储映射"><a href="#4-共享存储映射" class="headerlink" title="4.共享存储映射"></a>4.共享存储映射</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>存储映射I&#x2F;O(Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84.png"></p>
<p>于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I&#x2F;O操作。</p>
<p>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式，因为进程可以直接读写内存，而不需要任何数据的拷贝。</p>
<h4 id="4-2-存储映射函数"><a href="#4-2-存储映射函数" class="headerlink" title="4.2 存储映射函数"></a>4.2 存储映射函数</h4><h5 id="（1）mmap函数"><a href="#（1）mmap函数" class="headerlink" title="（1）mmap函数"></a>（1）mmap函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    一个文件或者其它对象映射进内存</span><br><span class="line">参数：</span><br><span class="line">    addr ： 指定映射的起始地址，通常设为<span class="literal">NULL</span>，由系统指定</span><br><span class="line">    length ： 映射到内存的文件长度</span><br><span class="line">    prot ： 映射区的保护方式，最常用的：</span><br><span class="line">        a) 读：PROT_READ</span><br><span class="line">        b) 写：PROT_WRITE</span><br><span class="line">        c) 读写：PROT_READ | PROT_WRITE</span><br><span class="line">    flags: 映射区的特性，可以是</span><br><span class="line">        a) MAP_SHARED : 写入映射区的数据会复制回文件，且允许其它映射该文件的进程共享。</span><br><span class="line">        b) MAP_PRIVATE : 对映射区的写入操作会产生一个映射区的复制(copy - on - write)，对此区域所做的修改不会写回原文件。</span><br><span class="line">    fd: 由open返回的文件描述符，代表要映射的文件。</span><br><span class="line">    offset: 以文件开始处的偏移量，必须是<span class="number">4</span>k的整数倍，通常为<span class="number">0</span>，表示从文件头开始映射</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回创建的映射区首地址</span><br><span class="line">    失败：MAP_FAILED宏</span><br></pre></td></tr></table></figure>

<p>关于mmap函数的使用总结：</p>
<p>1）第一个参数写成NULL</p>
<p>2）第二个参数要映射的文件大小 &gt;0</p>
<p>3）第三个参数：PROT_READ、PROT_WRITE</p>
<p>4）第四个参数：MAP_SHARED 或者 MAP_PRIVATE</p>
<p>5）第五个参数：打开的文件对应的文件描述符</p>
<p>6）第六个参数：4k的整数倍，通常为0</p>
<h5 id="（2）munmap函数"><a href="#（2）munmap函数" class="headerlink" title="（2）munmap函数"></a>（2）munmap函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line">功能：</span><br><span class="line">    释放内存映射区</span><br><span class="line">参数：</span><br><span class="line">    addr: 使用mmap函数创建的映射区的首地址</span><br><span class="line">    length: 映射区的大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3 注意事项"></a>4.3 注意事项</h4><p>1）创建映射区的过程中，隐含着一次对映射文件的读操作。</p>
<p>2）当MAP_SHARED时，要求映射区的权限应 &lt;&#x3D;文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</p>
<p>3）映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。</p>
<p>4）特别注意，当映射文件大小为0时，不能创建映射区。所以，用于映射的文件必须要有实际大小。mmap使用时常常会出现总线程错误，通常是由于共享文件存储空间大小引起的。</p>
<p>5）munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。</p>
<p>6）如果文件偏移量必须为4K的整数倍。</p>
<p>7）mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</p>
<h4 id="4-4-共享映射的方式操作文件"><a href="#4-4-共享映射的方式操作文件" class="headerlink" title="4.4 共享映射的方式操作文件"></a>4.4 共享映射的方式操作文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取文件成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建映射</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建映射成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;关闭文件描述符成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向映射区写内容</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr, <span class="string">&quot;123456789&quot;</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存区</span></span><br><span class="line">    ret = munmap(addr, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;释放内存成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-共享映射实现父子进程通讯"><a href="#4-5-共享映射实现父子进程通讯" class="headerlink" title="4.5 共享映射实现父子进程通讯"></a>4.5 共享映射实现父子进程通讯</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* mp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">pid_t</span> child_id = <span class="number">-1</span>; </span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建映射</span></span><br><span class="line">    mp = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mp == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">memcpy</span>(mp, <span class="string">&quot;abcdefg&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mp:%s\n&quot;</span>, (<span class="type">char</span>*)mp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放内存映射</span></span><br><span class="line">    munmap(mp, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-不同进程使用存储映射进行进程间通讯"><a href="#4-6-不同进程使用存储映射进行进程间通讯" class="headerlink" title="4.6 不同进程使用存储映射进行进程间通讯"></a>4.6 不同进程使用存储映射进行进程间通讯</h4><p>write.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加映射</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存映射添加成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">//写文件</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr, <span class="string">&quot;qwertyuiop&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放映射内存</span></span><br><span class="line">    ret = munmap(addr, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;释放映射内存成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加映射</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存映射添加成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">//读文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">void</span>*)addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放映射内存</span></span><br><span class="line">    ret = munmap(addr, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;释放映射内存成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-7-匿名映射实现父子进程通讯"><a href="#4-7-匿名映射实现父子进程通讯" class="headerlink" title="4.7 匿名映射实现父子进程通讯"></a>4.7 匿名映射实现父子进程通讯</h4><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程通讯间也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。</p>
<p>通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。可以直接使用匿名映射来代替。</p>
<p>其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定</p>
<p>使用<strong>MAO_ANONYMOUS(或MAP_ANON)</strong>。</p>
<p><code>int* p - mmap(NULL, 4, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</code></p>
<ul>
<li>4“随意举例，该位置表示映射区大小，可依实际需要填写”。</li>
<li>MAP_ANONYMOUS 和 MAP_ANON 这两个宏是Linux操作系统特有的宏。推荐使用 <strong>MAP_ANONYMOUS</strong>。</li>
</ul>
<p>程序实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* arrd = <span class="literal">NULL</span>;</span><br><span class="line">    arrd = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (arrd == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    pd = fork();</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向文件中写内容</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(arrd, <span class="string">&quot;hello,word&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读文件中的内容</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arrd:%s\n&quot;</span>, (<span class="type">char</span>*)arrd);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭映射</span></span><br><span class="line">    munmap(arrd, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、信号"><a href="#八、信号" class="headerlink" title="八、信号"></a>八、信号</h2><h3 id="1-信号的概述"><a href="#1-信号的概述" class="headerlink" title="1.信号的概述"></a>1.信号的概述</h3><p>信号是Linux进程通讯的最古老的方式。信号是软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
<p><strong>信号的特点</strong></p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特设条件才发送</li>
</ul>
<p>信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。</p>
<p>一个完整的信号周期包括三个部分：信号的产生，信号在进程中的注册，信号在进程中的注销，执行信号处理函数。如下图所示：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E8%BF%B0.jpg"></p>
<p>注意：这里信号的产生，注册，注销时信号的内部机制，而不是信号的函数实现。</p>
<h3 id="2-信号的编号"><a href="#2-信号的编号" class="headerlink" title="2.信号的编号"></a>2.信号的编号</h3><p>1）信号编号：</p>
<p>Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了修改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p>
<p>Linux 可使用命令：kill -l，查看相应的信号</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%96%E5%8F%B7.png"></p>
<p>不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。</p>
<p>2）Linux常规信号一览表</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>信号</th>
<th>对应事件</th>
<th>默认动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>用户推出shell时，由该shell启动的所有进程将收到这个信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>当用户按下了**&lt;Ctrl+C&gt;**组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>用户按下了**&lt;ctrl+\&gt;**组合键时产生了该信号，用户终端向正在运行中的由该终端启动的程序发出些信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>CPU检测到某进程执行了非法指令</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>该信号由断点指令或其他trap指令产生</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>调用abort函数时产生该信号</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS</td>
<td>非法访问内存地址，包括内存对齐出错</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的运算时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止进程。本信号不能被忽略，处理和阻塞</td>
<td>终止进程，可以杀死任何进程</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSE1</td>
<td>用户定义的信号。即程序员可以在程序中定义并使用该信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>指示进程进行了无效内存访问（段错误）</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>另外一个用户自定义信号，程序员可以在程序中定义并使用该型号</td>
<td>终止进程</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>Broken pipe向一个没有读端的管道写数据</td>
<td>终止进程</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>定时器超时，超时的时间由系统调用alarm设置</td>
<td>终止进程</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令kill时，缺省产生这个信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>16</td>
<td>SIGSTKFLT</td>
<td>Linux早期版本出现的信号，现仍保留向后兼容</td>
<td>终止进程</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>子进程结束时，父进程会收到这个信号</td>
<td>忽略这个信号</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>如果进程已停止，则使其继续运行</td>
<td>继续&#x2F;忽略</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>停止进程的执行。信号不能被忽略，处理和阻塞</td>
<td>为终止进程</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号</td>
<td>暂停进程</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>后台进程读终端控制台</td>
<td>暂停进程</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生</td>
<td>暂停进程</td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程</td>
<td>终止进程</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>超过文件的最大长度设置</td>
<td>终止进程</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTLRM</td>
<td>虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用s’j</td>
<td>终止进程</td>
</tr>
<tr>
<td>27</td>
<td>SGIPROF</td>
<td>类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间</td>
<td>终止进程</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>窗口变化大小时发出</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO</td>
<td>此信号向进程指示发出了一个异步IO事件</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>关机</td>
<td>终止进程</td>
</tr>
<tr>
<td>31</td>
<td>SIGSYS</td>
<td>无效的系统调用</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>34~64</td>
<td>SIGRTMIN~</td>
<td>Linux的实时信号，它们没有固定的含义（可以自定义）</td>
<td>终止进程</td>
</tr>
</tbody></table>
<h3 id="3-信号四要素"><a href="#3-信号四要素" class="headerlink" title="3.信号四要素"></a>3.信号四要素</h3><p>每个信号必备4要素，分别是：</p>
<p>1）编号 2）名称 3）事件 4）默认处理动作</p>
<p>可通过 <strong>man 7 signal</strong> 查看帮助文档获取：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9B%9B%E8%A6%81%E7%B4%A0.png"></p>
<p>我这个是 arm 架构的，和教程上的不一样。</p>
<p>在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他框架，最后一个应用于mips架构。一个’-‘表示在对应架构上尚未定义该信号。</p>
<p>不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号。</p>
<p>Action为默认动作：</p>
<ul>
<li>Term：终止进程</li>
<li>lgn：忽略信号（默认即使对该种信号忽略操作）</li>
<li>Core：终止进程，生成Core文件。（查验死亡原因，用于gdb调试）</li>
<li>Stop：停止（暂停）进程</li>
<li>Cont：继续运行进程</li>
</ul>
<p>注意通过 man 7 signal 命令查看帮助文档，其中可看到：The signals <strong>SIGKILL</strong> and <strong>SIGSTOP</strong> cannot be caught，blocked，or ignored。</p>
<p>这里特别强调了 <strong>SIGKILL 和 SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></p>
<p>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送（但不一定递达），不应乱发信号！！！</p>
<h3 id="4-信号的状态"><a href="#4-信号的状态" class="headerlink" title="4.信号的状态"></a>4.信号的状态</h3><p><strong>1）产生</strong></p>
<p>a）当用户按某些终端键时，将产生信号。</p>
<p>​	终端上按“ctrl+c”组合键通常产生中断信号 SIGINT</p>
<p>​	终端上按“ctrl+\”键通常产生中断信号 SIGQUIT</p>
<p>​	终端上按“ctrl+z”键通常产生中断信号 SIGSTOP等。</p>
<p>b）硬件异常将产生信号。</p>
<p>除数为0，无效的内存访问等。这些情况通常由硬件检测到，并通知内核，然后内核产生适当的信号发送给相应的进程。</p>
<p>c）软件异常将产生信号。</p>
<p>当检测到某种软件条件已发生（如：定时器alarm），并将其通知有关进程时，产生信号。</p>
<p>d）调用系统函数（如：kill、raise、abort）将发送信号。</p>
<p>注意：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。</p>
<p>e）运行 kill &#x2F; killall命令将发送信号。</p>
<p>此程序实际上是使用 kill 函数来发送信号。也常用此命令终止一个失控的后台进程。 </p>
<p><strong>2）未决状态：没有被处理</strong></p>
<p><strong>3）递达状态：信号被处理了</strong></p>
<h3 id="5-阻塞信号集和未决信号集"><a href="#5-阻塞信号集和未决信号集" class="headerlink" title="5.阻塞信号集和未决信号集"></a>5.阻塞信号集和未决信号集</h3><p>信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。</p>
<p>Linux内核的进程控制块PCB是一个结构体，task_struct，除了包含进程id、状态、工作目录、用户id、组id、文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集。</strong></p>
<h4 id="5-1-阻塞信号集（信号屏蔽字）"><a href="#5-1-阻塞信号集（信号屏蔽字）" class="headerlink" title="5.1 阻塞信号集（信号屏蔽字）"></a>5.1 阻塞信号集（信号屏蔽字）</h4><p>将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，该信号的处理将推后（处理发送在解除屏蔽后）。</p>
<h4 id="5-2-未决信号集"><a href="#5-2-未决信号集" class="headerlink" title="5.2 未决信号集"></a>5.2 未决信号集</h4><p>信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位反转回为0.这一时刻往往非常短暂。</p>
<p>信号产生后由于某些原因（主要是阻塞）不能抵达。这类信号的集合称为未决信号集。在屏蔽解除前，信号一直处于未决状态。</p>
<h3 id="6-信号产生函数"><a href="#6-信号产生函数" class="headerlink" title="6.信号产生函数"></a>6.信号产生函数</h3><h4 id="6-1-kill函数"><a href="#6-1-kill函数" class="headerlink" title="6.1 kill函数"></a>6.1 kill函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#Include &lt;sys/types.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给指定进程发送指定信息（不一定杀死）</span><br><span class="line">    </span><br><span class="line">参数：</span><br><span class="line">    pid ： 取值有<span class="number">4</span>种情况：</span><br><span class="line">        pid &gt; <span class="number">0</span>:将信号传送给进程 ID 为pid的进程</span><br><span class="line">        pid = <span class="number">0</span>:将信号传送给当前进程所在进程组中的所有进程。</span><br><span class="line">        pid = <span class="number">-1</span>:将信号传送给系统内所有的进程。</span><br><span class="line">        pid &lt; <span class="number">-1</span>:将信号传送给指定进程组的所有进程。这个进程组号等于 pid 的绝对值。</span><br><span class="line">    sig：信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill -l 进行查看。不推荐直接使用数字，应该使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</span><br><span class="line">    返回值：</span><br><span class="line">            成功： <span class="number">0</span></span><br><span class="line">            失败： <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>super用户（root）可以发送信号给容易用户，普通用户是不能向系统用户发送信号的。</p>
<p>kill -9（root用户的pid）是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号。</p>
<p>普通用户基本规则是：发送者实际或有效用户ID &#x3D;&#x3D; 接收者实际或有效用户ID</p>
<p>程序示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    pd = fork();</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pd == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child is run\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child is not good\n&quot;</span>);</span><br><span class="line">        kill(pd, SIGTERM);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-raise函数"><a href="#6-2-raise函数" class="headerlink" title="6.2 raise函数"></a>6.2 raise函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给当前进程发送指定信号（自己给自己发），等价于 kill(getpid(), sig)</span><br><span class="line">参数：</span><br><span class="line">    sig：信号编号</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>值</span><br></pre></td></tr></table></figure>

<p>程序示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;run:%d\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">4</span>)&#123;</span><br><span class="line">            raise(SIGALRM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-abort函数"><a href="#6-3-abort函数" class="headerlink" title="6.3 abort函数"></a>6.3 abort函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：给自己发送异常终止信号 SIGABRT，并产生core文件，等价于 kill(getpid(), SIGABRT);</span><br><span class="line">参数：无</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<h4 id="6-4-alarm函数-闹钟"><a href="#6-4-alarm函数-闹钟" class="headerlink" title="6.4 alarm函数(闹钟)"></a>6.4 alarm函数(闹钟)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line">功能:</span><br><span class="line">    设置定时器(闹钟)。在指定的seconds后，内核会给当前进程发送 SIGALRM 信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。</span><br><span class="line">     取消定时器alarm(<span class="number">0</span>)，返回旧闹钟余下秒数。</span><br><span class="line">参数:</span><br><span class="line">    seconds: 指定的时间，以秒为单位</span><br><span class="line">返回值:</span><br><span class="line">    返回<span class="number">0</span>或剩余的秒数</span><br></pre></td></tr></table></figure>

<p>定时，与进程状态无关（自然定时法）！就绪、运行、挂起（阻塞、暂停）、终止、僵尸….无论进程处于何种状态，alarm都计时。</p>
<p>测试程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在运行程序\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    ret = alarm(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;之前的闹钟无效了，之前还剩 %d 秒\n&quot;</span>, ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按任意键退出...&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-5-setitimer函数（定时器）"><a href="#6-5-setitimer函数（定时器）" class="headerlink" title="6.5 setitimer函数（定时器）"></a>6.5 setitimer函数（定时器）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval* new_value, <span class="keyword">struct</span> itimerval* old_value)</span>;</span><br><span class="line">功能:</span><br><span class="line">    设置定时器(闹钟)。可代替alarm函数。精度微秒us，可以实现周期定时。</span><br><span class="line">参数:</span><br><span class="line">    which: 指定定时方法</span><br><span class="line">         a) 自然定时: ITIMER_REAL → SUGALR计算自然时间</span><br><span class="line">         b) 虚拟空间计时(用户空间): ITIMER_VIRTUAL → SIGPROF计算进程占用cpu的时间</span><br><span class="line">         c) 运行时计时(用户 + 内核): ITIMER_PROF → SIGPROF计算占用cpu及执行系统调用的时间</span><br><span class="line">    new_value: </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>&#123;</span></span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_interval</span>;</span> <span class="comment">//闹钟触发周期</span></span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_value</span>;</span>   <span class="comment">//闹钟触发时间</span></span><br><span class="line">         &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">            <span class="type">long</span> tv_sec;	<span class="comment">//秒</span></span><br><span class="line">            <span class="type">long</span> tv_user;	<span class="comment">//毫秒</span></span><br><span class="line">        &#125;;</span><br><span class="line">        itimerval.it_vale: 设定一次执行function所延迟的秒数</span><br><span class="line">        itimerval.it_interval: 设定以后每几秒执行function</span><br><span class="line">    old_value: 存放旧的timeout值，一般指定为<span class="literal">NULL</span></span><br><span class="line">返回值:</span><br><span class="line">    成功: <span class="number">0</span></span><br><span class="line">    失败: <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>程序示例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">iti</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//第一次触发时间</span></span><br><span class="line">    iti.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    iti.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//触发周期</span></span><br><span class="line">    iti.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    iti.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    ret = setitimer(ITIMER_REAL, &amp;iti, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setitmer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键退出...\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-信号集"><a href="#7-信号集" class="headerlink" title="7.信号集"></a>7.信号集</h3><h4 id="7-1-信号集概述"><a href="#7-1-信号集概述" class="headerlink" title="7.1 信号集概述"></a>7.1 信号集概述</h4><p>在PCB中有两个非常重要的信号集。一个称为“阻塞信号集”，另一个称为“未决信号集”。</p>
<p>这两个信号集都是内核使用<strong>位图机制</strong>来实现的。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数对PCB中的这两个信号集进行修改。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%A6%82%E8%BF%B0.png"></p>
<h4 id="7-2-自定义信号集函数"><a href="#7-2-自定义信号集函数" class="headerlink" title="7.2 自定义信号集函数"></a>7.2 自定义信号集函数</h4><p>为了方便对多个信号进行处理，一个用户进程常常需要对多个信号做出处理，在Linux系统中引入了信号集（信号的集合）。</p>
<p>这个信号集有点类似于我们的QQ群，一个个的信号相当于QQ群里的一个个好友。</p>
<p>信号集是一个能表示多个信号的数据类型，sigset_t set，set即一个信号集。既然是一个集合，就需要对集合进行添加&#x2F;删除等操作。</p>
<p>相关函数说明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;	<span class="comment">//将set集合置空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(sigset* <span class="built_in">set</span>)</span>;	<span class="comment">//将所有信号加入set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(sigset* <span class="built_in">set</span>, <span class="type">int</span> signo)</span>;	<span class="comment">//将signo信号加入到set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signo)</span>; <span class="comment">//从set集合中移除signo信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signo)</span>; <span class="comment">//判断信号是否存在</span></span><br></pre></td></tr></table></figure>

<p>除sigismember外，其余操作函数中的set均为传出参数。sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</p>
<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印信号集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_sigset</span><span class="params">(<span class="type">sigset_t</span>* s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sigismember(s, i))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">//清空信号集</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有信号加入set集中</span></span><br><span class="line">    sigfillset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将signo信号移除</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGHUP);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将signo信号重新加入到set集合中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGHUP);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-sigprocmask函数"><a href="#7-3-sigprocmask函数" class="headerlink" title="7.3 sigprocmask函数"></a>7.3 sigprocmask函数</h4><p>信号阻塞也称信号屏蔽集、信号掩码。每个进程都有应该阻塞集，创建进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。</p>
<p>所谓阻塞并不是禁止传送信号，而是暂缓信号的传送。若将阻塞的信号从信号阻塞集中删除，且对应的信号在阻塞时发生了，进程将会收到相应的信号。</p>
<p>我们可以通过 sigprocmask() 修改当前的信号掩码来改变信号的阻塞情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改信号阻塞集，根据 how 指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由 <span class="built_in">set</span> 指定，而原先的信号阻塞集合由 oldset 保存。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    how：信号阻塞集合的修改方法，有<span class="number">3</span>种情况：</span><br><span class="line">        SIG_BLOCK:向信号阻塞集合中添加 <span class="built_in">set</span> 信号集，新的信号掩码是<span class="built_in">set</span>和旧信号掩码的并集。相当于 mask = mask|<span class="built_in">set</span>。</span><br><span class="line">        SIG_UNBLOCK:从信号阻塞集合中删除 <span class="built_in">set</span> 信号集，从当前信号掩码中去除 <span class="built_in">set</span> 中的信号。相当于 mask = mask &amp; ~ <span class="built_in">set</span>。</span><br><span class="line">        SIG_SETMASK:将信号阻塞集合设为 <span class="built_in">set</span> 信号集，相当于原来信号阻塞集的内容清空，然后按照 <span class="built_in">set</span> 中的信号重新设置信号阻塞集，相当于 mask = <span class="built_in">set</span>。</span><br><span class="line">    <span class="built_in">set</span>：要操作的信号集地址。</span><br><span class="line">            若 <span class="built_in">set</span> 为 <span class="literal">NULL</span>，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到 oldset 中。</span><br><span class="line">    oldset：保存原来信号阻塞地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span>，失败时错误代码只可能是 EINVAL，表示参数 how不合法。</span><br></pre></td></tr></table></figure>

<h4 id="7-4-sigpending函数"><a href="#7-4-sigpending函数" class="headerlink" title="7.4 sigpending函数"></a>7.4 sigpending函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;</span><br><span class="line">功能：读取当前进程的未决信号集</span><br><span class="line">参数：</span><br><span class="line">    <span class="built_in">set</span>：未决信号集</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="8-信号捕捉"><a href="#8-信号捕捉" class="headerlink" title="8.信号捕捉"></a>8.信号捕捉</h3><h4 id="8-1-信号处理方式"><a href="#8-1-信号处理方式" class="headerlink" title="8.1 信号处理方式"></a>8.1 信号处理方式</h4><p>一个进程收到一个信号的时候，可以用如下方式进行处理：</p>
<p>1）执行系统默认动作</p>
<p>对于大多数信号来说，系统默认动作是用来终止该进程。</p>
<p>2）忽略此信号（丢弃）</p>
<p>接收到此信号后没有任何动作。</p>
<p>3）执行自定义信号处理函数（捕捉）</p>
<p>用用户定义的信号处理函数处理该信号。</p>
<p>【注意】：SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。</p>
<p>内核实现信号捕捉过程：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9B%BE%E7%89%87%5C%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89.png"></p>
<h4 id="8-2-signal函数"><a href="#8-2-signal函数" class="headerlink" title="8.2 signal函数"></a>8.2 signal函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line">功能：</span><br><span class="line">    注册信号处理函数（不可用于 SIGKILL、SIGSTOP 信号），即确定收到信号后处理函数的入口地址。此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    signum：信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill -l进行相应查看。</span><br><span class="line">    handler：取值有 <span class="number">3</span> 种情况：</span><br><span class="line">        SIG_IGN:忽略该信号</span><br><span class="line">        SIG_DFL:执行系统默认动作</span><br><span class="line">        信号处理函数名：自定义信号处理函数，如：func</span><br><span class="line">        回调函数的定义如下：</span><br><span class="line">            <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">                <span class="comment">//signo 为触发的信号，为signal() 第一个参数的值</span></span><br><span class="line">            &#125;</span><br><span class="line">返回值：</span><br><span class="line">    成功：第一次返回 <span class="literal">NULL</span>，下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面先声明此函数指针的类型。</span><br><span class="line">    失败：返回 SIG_ERR</span><br></pre></td></tr></table></figure>

<p>该函数由ANSI定义，因为Unix和Linux版本的原因不推荐使用这个函数，取而代之的是sigaction函数</p>
<h4 id="8-3-sigaction函数"><a href="#8-3-sigaction函数" class="headerlink" title="8.3 sigaction函数"></a>8.3 sigaction函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oldact)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改指定信号的设置（或同时执行这两种操作）。</span><br><span class="line">参数：</span><br><span class="line">    signum：要操作的信号。</span><br><span class="line">    act：要设置的对信号的新处理方式（传入参数）。</span><br><span class="line">    oldact：原来对信号的处理方式（传入参数）。</span><br><span class="line">    如果 act 指针非空，则要改变指定信号的处理方式（设置），如果 oldact 指针非空，则系统将此前指定信号的处理方式存入 oldact。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>struct sigaction结构体：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">    <span class="type">void</span>(*sa_handler)(<span class="type">int</span>); <span class="comment">//旧的信号处理函数指针</span></span><br><span class="line">    <span class="type">void</span>(*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span>*, <span class="type">void</span>* ); <span class="comment">//新的信号处理函数指针</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;	<span class="comment">//信号阻塞集</span></span><br><span class="line">    <span class="type">int</span> sa_flags;	<span class="comment">//信号处理的方式</span></span><br><span class="line">    <span class="type">void</span>(*sa_restorer)(<span class="type">void</span>); <span class="comment">//已弃用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1）sa_handler、sa_sigaction：信号处理函数指针，如signal()里的函数指针用法一样，应根据情况给 sa_sigaction、sa_handler 两者之一赋值，其取值如下：</p>
<p>a）SIG_IGN：忽略该信号</p>
<p>b）SIG_DFL:执行系统默认动作</p>
<p>c）处理函数名：自定义信号处理函数</p>
<p>2）sa_mask：信号阻塞集，在信号处理函数执行过程中，临时屏蔽指定的信号。</p>
<p>3）sa_flags：用于指定信号处理的行为，通常设置为0，表使用默认属性。它可以是一下值的”按位或“组合：</p>
<ul>
<li>SA_RESTART：使被信号打断的系统调用自动重新发起（已经废弃）</li>
<li>SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到SIGCHLD信号。</li>
<li>SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到SIGCHLD信号，这时子进程如果退出也不会成为僵尸进程。</li>
<li>SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。</li>
<li>SA_RESETHAND：信号处理之后重新设置为默认的处理方式。</li>
<li>SA_SIGINFO：使用sa_sigaction成员而不是sa_handler作为信号处理函数。</li>
</ul>
<p><strong>信号处理函数：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*sa_sigaction)(<span class="type">int</span> signum, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* context);</span><br><span class="line">参数说明：</span><br><span class="line">    signum：信号的编号。</span><br><span class="line">    info：记录信号发送进程信号的结构体。</span><br><span class="line">    context：可以赋给指向 <span class="type">ucontext_t</span> 类型的一个对象的指针，以引用在传递信号时被中断的接收进程或线程的上下文。</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signum, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* context)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号:%d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_sigaction = fun1;</span><br><span class="line">    <span class="comment">//标志指定使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按回车退出...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-不可重入、可重入"><a href="#9-不可重入、可重入" class="headerlink" title="9.不可重入、可重入"></a>9.不可重入、可重入</h3><p>如果一个函数不幸被设计成为这样：那么不同任务调用这个函数时可能修改其它任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数。</p>
<p>满足下列条件的函数是不可重入（不安全）的：</p>
<ul>
<li>函数体内使用了静态的数据结构</li>
<li>函数体内调用了malloc() 或者 free() 函数（谨慎使用堆）</li>
<li>函数体内调用了标准 I&#x2F;O 函数</li>
</ul>
<p>相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？所谓可重入函数是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。</p>
<p>保证函数的可重入性的方法：</p>
<ul>
<li>在写函数时尽量使用局部变量（例如寄存器、栈中的变量）</li>
<li>对于要使用的全局变量要加以保护（如采取关中断、信号量等互斥方法），这样构成的函数就一定是一个可重入的函数</li>
</ul>
<p><strong>注意：信号处理函数是可重入函数</strong></p>
<h3 id="10-SIGCHLE信号"><a href="#10-SIGCHLE信号" class="headerlink" title="10.SIGCHLE信号"></a>10.SIGCHLE信号</h3><h4 id="10-1-SIGCHLD信号产生的条件"><a href="#10-1-SIGCHLD信号产生的条件" class="headerlink" title="10.1 SIGCHLD信号产生的条件"></a>10.1 SIGCHLD信号产生的条件</h4><p>1）子进程终止时</p>
<p>2）子进程接收到SIGSTOP信号停止时</p>
<p>3）子进程处在停止态，接受到SIGCONT后唤醒时</p>
<h4 id="10-2-如何避免僵尸进程"><a href="#10-2-如何避免僵尸进程" class="headerlink" title="10.2 如何避免僵尸进程"></a>10.2 如何避免僵尸进程</h4><p>1）最简单的方式，父进程通过wait()和waitpid()等待子进程结束，但是，这会导致父进程挂起。</p>
<p>2）如果父进程要处理的事情很多，不能够挂起，通过 signal() 函数人为处理信号 SIGCHLD，只要子进程退出自动调用指定好的回调函数，因为子进程结束后，父进程会收到该信号 SIGCHLD，可以在其回调函数里调用wait() 或 waitpid() 回收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signum, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* context)</span>&#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程结束了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_sigaction = fun1;</span><br><span class="line">    <span class="comment">//标志指定使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    ret = sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3）如果父进程不关心子进程什么时候结束，那么可以用signal(SIGCHLD, SIG_IGN) 通知内核，自己对子进程的结束不感兴趣，父进程忽略此信号，那么子进程结束后，内核回收，并不再给父进程发送信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程结束了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="九、守护进程-线程"><a href="#九、守护进程-线程" class="headerlink" title="九、守护进程-线程"></a>九、守护进程-线程</h2><h3 id="1-终端的概念"><a href="#1-终端的概念" class="headerlink" title="1.终端的概念"></a>1.终端的概念</h3><p>在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端（Controlling Terminal），进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。</p>
<p>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是用户的键盘输入，进程往标准输出或标准错误输出也写到显示器上。</p>
<p>信号中还讲过，在控制终端输入有些特殊的控制按键可以给前台进程发信号，例如Ctrl+C表示SIGINT，Ctrl+\表示SIGQUIT。</p>
<p>函数说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">ttyname</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line">功能：由文件描述符查出对应的文件名</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">返回值：</span><br><span class="line">    成功：终端名</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h3 id="2-进程组概念"><a href="#2-进程组概念" class="headerlink" title="2.进程组概念"></a>2.进程组概念</h3><h4 id="2-1-进程组概述"><a href="#2-1-进程组概述" class="headerlink" title="2.1 进程组概述"></a>2.1 进程组概述</h4><p>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。<strong>代表一个或多个进程的集合。</strong></p>
<p>每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。</p>
<p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID为第一个进程ID（组长进程）。所以，组长进程标识：其进程组ID为其进程ID。</p>
<p>可以使用<strong>kill -SIGKILL -进程组ID</strong>（负的）来将整个进程组内的进程全部杀死：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BB%88%E7%AB%AF%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5.png"></p>
<p>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</p>
<p>进程组生存期：进程组创建的最后一个进程离开（终止或转移到另一个进程组）。</p>
<p>一个进程可以为自己或子进程设置进程组ID。</p>
<h4 id="2-2-相关函数说明"><a href="#2-2-相关函数说明" class="headerlink" title="2.2 相关函数说明"></a>2.2 相关函数说明</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能:获取当前进程组的进程ID;</span><br><span class="line">参数:无;</span><br><span class="line">返回值:总是返回调用者的进程组ID;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能:获取指定进程的进程组ID;</span><br><span class="line">参数:</span><br><span class="line">    pid:进程号，如果pid = <span class="number">0</span>，那么该函数作用和getpgrp一样</span><br><span class="line">返回值:</span><br><span class="line">    成功：进程组ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> setpgid(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid);</span><br><span class="line">功能：</span><br><span class="line">    改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。</span><br><span class="line">参数：</span><br><span class="line">    将参<span class="number">1</span>对应的进程，加入参<span class="number">2</span>对应的进程组中</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-会话"><a href="#3-会话" class="headerlink" title="3.会话"></a>3.会话</h3><h4 id="3-1-会话概述"><a href="#3-1-会话概述" class="headerlink" title="3.1 会话概述"></a>3.1 会话概述</h4><p>会话是一个或多个进程组的集合。</p>
<ul>
<li>一个会话可以有一个控制终端。这通常是终端设备或伪终端设备；</li>
<li>建立与控制终端连接的会话首进程被称为控制进程</li>
<li>一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，其它进程组为后台进程组</li>
<li>如果终端接口检测到断开连接，则将挂断信号发送至控制进程（会话首进程）。</li>
</ul>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BC%9A%E8%AF%9D.png"></p>
<h4 id="3-2-创建会话注意事项"><a href="#3-2-创建会话注意事项" class="headerlink" title="3.2 创建会话注意事项"></a>3.2 创建会话注意事项</h4><p>1）调用进程不能是进程组组长，该进程变成新会话首进程(session header)</p>
<p>2）该调用进程是组长进程，则出错返回</p>
<p>3）该进程成为一个新进程组的组长进程</p>
<p>4）需要root权限(ubuntu不需要)</p>
<p>5）新会话丢弃原有的控制终端，该会话没有控制终端</p>
<p>6）建立新会话时，先调用fork，父进程终止，子进程调用setsid</p>
<h4 id="3-3-API函数介绍"><a href="#3-3-API函数介绍" class="headerlink" title="3.3 API函数介绍"></a>3.3 API函数介绍</h4><p>getsid函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能: 获取进程所属的会话ID</span><br><span class="line">参数: </span><br><span class="line">    pid: 进程号，pid为<span class="number">0</span>表示查看当前进程session ID</span><br><span class="line">返回值：</span><br><span class="line">    返回值：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</p>
<p>setsid函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能:</span><br><span class="line">    创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。调用了setsid函数的进程，既是新的会长，也是新的组长。</span><br><span class="line">参数: 无</span><br><span class="line">返回值: </span><br><span class="line">    成功：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-守护进程"><a href="#4-守护进程" class="headerlink" title="4.守护进程"></a>4.守护进程</h3><h4 id="4-1-守护进程介绍"><a href="#4-1-守护进程介绍" class="headerlink" title="4.1 守护进程介绍"></a>4.1 守护进程介绍</h4><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立控制终端并且周期性地执行某种任务或等待处理某些发生的时间。一般采用以d结尾的名字。</p>
<p>守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离终端是为了避免进程被任何终端产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在Linux中，每一个系统用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个字段，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。</p>
<p>Linux的大多数服务器就是用守护进程实现的。比如，Internet服务器，web服务器，http等。</p>
<h4 id="4-2-守护进程模型"><a href="#4-2-守护进程模型" class="headerlink" title="4.2 守护进程模型"></a>4.2 守护进程模型</h4><p>1）创建子进程，父进程退出（必须）</p>
<ul>
<li>所有工作在子进程中进行形式上脱离了控制终端</li>
</ul>
<p>2）在子进程中创建新会话（必须）</p>
<ul>
<li>setsid()函数</li>
<li>使子进程完全独立出来，脱离控制</li>
</ul>
<p>3）改变当前目录为根目录（不是必须）</p>
<ul>
<li>chdir()函数</li>
<li>防止占用可卸载的文件系统</li>
<li>也可以换成其它路径</li>
</ul>
<p>4）重设文件权限掩码（不是必须）</p>
<ul>
<li>umask() 函数</li>
<li>防止继承的文件创建屏蔽字拒绝某些权限</li>
<li>增加守护进程灵活性</li>
</ul>
<p>5）关闭文件描述符（不是必须）</p>
<ul>
<li>继承的打开文件不会用到，浪费系统资源，无法卸载</li>
</ul>
<p>6）开始执行守护进程核心工作（必须）</p>
<ul>
<li>守护进程退出处理程序模型</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//1.创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在子进程中创建新会话</span></span><br><span class="line">    pid = setsid();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.改变当前工作目录</span></span><br><span class="line">    ret = chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.重设文件权限掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.关闭文件描述符</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.开始执行进程核心工作</span></span><br><span class="line">    <span class="comment">//要求每隔一秒种向txt文件插入时间</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        system(<span class="string">&quot;date &gt;&gt; /home/pi/time.txt&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-线程简介"><a href="#5-线程简介" class="headerlink" title="5.线程简介"></a>5.线程简介</h3><h4 id="5-1-线程概念"><a href="#5-1-线程概念" class="headerlink" title="5.1 线程概念"></a>5.1 线程概念</h4><p>在许多经典的操作系统教科书中，总是把进程定义为程序的执行实例，它并不执行什么，只是维护引用程序所需的各种资源，而线程则是真正的执行实体。</p>
<p>所以，线程是轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。</p>
<p>为了让进程完成一定的工作，进程必须至少包含一个线程。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0.png"></p>
<p>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统，操作系统会以进程为单位，分配系统资源，所以我们也说：<strong>进程是CPU分配资源的最小单位。</strong></p>
<p>线程存在与进程当中（进程可以认为是线程的容器），是操作系统调度执行的最小单位。说通俗点，线程就是干活的。</p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运动活动，进程是系统进程资源分配和调度的一个独立单位。</p>
<p>线程是进程的一个实体，是CPU调度和分配的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其它的线程共享进程所拥有的全部资源。</p>
<p>如果说进程是一个资源管家，负责从主人哪里要资源的话，那么线程就是干活的苦力。一个管家必须完成一项工作，就需要最少一个苦力，也就是说，一个进程最少包含一个线程，也可以包含多个线程。苦力要干活，就需要依托于管家，所以说一个线程，必须属于某个进程。</p>
<p>进程有自己的地址空间，线程使用进程的地址空间，也就是说，进程里的资源，线程都是有权访问的，比如说堆，栈，静态存储区。</p>
<blockquote>
<p>进程是操作系统分配资源的最小单位</p>
<p>线程是操作系统调度的最小单位</p>
</blockquote>
<h4 id="5-2-线程函数列表安装"><a href="#5-2-线程函数列表安装" class="headerlink" title="5.2 线程函数列表安装"></a>5.2 线程函数列表安装</h4><p>命令：</p>
<blockquote>
<p>sudo apt-get install manpages-posix-posix-dev</p>
</blockquote>
<p>【说明】manpages-posix-posix-dev 包含POSIX的header files 和calls的用法</p>
<p>查看：</p>
<blockquote>
<p>man -k pthread</p>
</blockquote>
<h4 id="5-3-NPTL"><a href="#5-3-NPTL" class="headerlink" title="5.3 NPTL"></a>5.3 NPTL</h4><p>当linux最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调用度的实体。这个调用创建了调用进程（calling process）的一个拷贝，这个拷贝与调用进程共享系统的地址空间。LinuxThreads 项目使用这个调用来完全在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程同步原语方面都存在问题。另外，这个线程模式也不符合POSIX的要求。</p>
<p>要改进LinuxThreads，非常明显我们需要内核的支持，并且需要重写线程库。有两个相互竞争的项目开始来满足这些要求。一个包括IBM的开发人员的团队开展了NGPT项目。同时，Red Hat 的一些开发人员开展了NPTL项目。NGPT在2003年中期被放弃了，把这个领域完全留给了NPTL。</p>
<p>NPTL或称为Native POSIX Thread Library，是Linux线程的一个新实现，它克服了LinuxThreads的缺陷，同时也符合POSIX的需求。与LinuxThreads相比，它在性能和稳定性方面都提供了重大的改进。</p>
<p>查看当前pthread库版本：getconf GNU_LIBPTHREAD_VERSION</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC.png"></p>
<h4 id="5-4-线程的特点"><a href="#5-4-线程的特点" class="headerlink" title="5.4 线程的特点"></a>5.4 线程的特点</h4><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进制机制实现出了线程的概念。</p>
<p>因此在这类系统中，进程和线程关系密切：</p>
<p>1）线程是轻量级进程（light-weight process），也有PCB，创建线程使用的底层函数和进程一样，都是clone。</p>
<p>2）从内核里看进程和线程是一样的，都有各自不同的PCB。</p>
<p>3）进程可以蜕变成线程</p>
<p>4）在Linux下，线程是最小的执行单位；进程是最小的分配资源单位</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9.png"></p>
<p>查看指定进程的LWP号：</p>
<blockquote>
<p>ps -Lf pid</p>
</blockquote>
<p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone。</p>
<ul>
<li>如果复制对方的地址空间，那么就产出一个“线程”。</li>
<li>如果共享对方的地址空间，就会产生一个“线程”</li>
</ul>
<p>Linux内核是不区分进程和线程的，只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p>
<h4 id="5-5-线程共享资源"><a href="#5-5-线程共享资源" class="headerlink" title="5.5 线程共享资源"></a>5.5 线程共享资源</h4><p>1）文件描述符表</p>
<p>2）每种信号的处理方式</p>
<p>3）当前工作目录</p>
<p>4）用户ID和组ID</p>
<p>内存地址空间（.test&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库）</p>
<h4 id="5-6-线程非共享资源"><a href="#5-6-线程非共享资源" class="headerlink" title="5.6 线程非共享资源"></a>5.6 线程非共享资源</h4><p>1）线程id</p>
<p>2）处理器现场和栈指针（内核栈）</p>
<p>3）独立的栈空间（用户空间栈）</p>
<p>4）errno变量</p>
<p>5）信号屏蔽字</p>
<p>6）调用优先级</p>
<h4 id="5-7-线程的优缺点"><a href="#5-7-线程的优缺点" class="headerlink" title="5.7 线程的优缺点"></a>5.7 线程的优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>提高程序并发性</li>
<li>开销小</li>
<li>数据通讯、共享数据方便</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>库函数，不稳定</li>
<li>调试、编写困难、gdb不支持</li>
<li>对信号支持不好</li>
</ul>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p>
<h3 id="6-线程常用操作"><a href="#6-线程常用操作" class="headerlink" title="6.线程常用操作"></a>6.线程常用操作</h3><h4 id="6-1-线程号"><a href="#6-1-线程号" class="headerlink" title="6.1 线程号"></a>6.1 线程号</h4><p>就像每个进程都有一个进程号一样，每个线程也有一个线程号。进程号在整个系统中是唯一的，但线程号不同，线程号只在它所属的进程环境中有效。</p>
<p>进程号用 pid_t 数据类型表示，是一个非负整数。线程号则用 pthread_t 数据类型来表示，Linux 使用无符号长整型表示。</p>
<p>有的系统在实现pthread_t 的时候，用一个结构体来表示，所以在可移植的操作系统实现不能把它做为整数处理。</p>
<p>pthread_self函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取线程号。</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    调用线程的线程ID。</span><br></pre></td></tr></table></figure>

<p>因为pthread_self这个函数是一个第三方库，所以在编译的时候需要链接一下外部的动态库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-pthread</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pt;</span><br><span class="line">    pt = pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, pt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pthread_equal函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line">功能:</span><br><span class="line">    判断线程号t1和t2是否相等。为了方便移植，尽量使用函数来比较</span><br><span class="line">参数:</span><br><span class="line">    t1，t2:待判断的线程号。</span><br><span class="line">返回值：</span><br><span class="line">     相等：非<span class="number">0</span></span><br><span class="line">     不相等：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pt;</span><br><span class="line">    pt = pthread_self();</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(pt, pthread_self()))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个线程号相等\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个线程号不相等\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-线程的创建"><a href="#6-2-线程的创建" class="headerlink" title="6.2 线程的创建"></a>6.2 线程的创建</h4><p>pthread_create函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthred_create</span><span class="params">(<span class="type">pthread_t</span>* thread, <span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* (*start_routine)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个线程</span><br><span class="line">参数：</span><br><span class="line">    thread：线程标识符地址。</span><br><span class="line">    attr：线程属性结构体地址，通常设置为<span class="literal">NULL</span>。</span><br><span class="line">    start_routine：线程函数的入口地址。</span><br><span class="line">    arg：传入线程函数的参数。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p> 在一个线程中调用pthread_create()创建新的线程后，当前进程从pthread_create()返回继续在下执行，而新的线程所执行的代码由我们传给pthread_create()的函数指针start_routine决定。</p>
<p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以先用strerror()把错误码转换成错误信息再打印。</p>
<p>实例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* agv)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新的线程执行任务 tid: %lu\n 传入的参数为:%d\n&quot;</span>, pthread_self(), (<span class="type">int</span>)(<span class="type">long</span>)agv); <span class="comment">//这里因为是void*类型，直接转换为int长度不够，先让它变成long，然后再转换为int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//打印错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread... tid:%lu\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按任意键结束\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-3-线程资源回收"><a href="#6-3-线程资源回收" class="headerlink" title="6.3 线程资源回收"></a>6.3 线程资源回收</h4><p>pthread_join函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span>** retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待线程结束（此函数会阻塞），并回收线程资源，类似于进程的 wait() 函数，如果线程已经结束，那么该函数会立刻返回。</span><br><span class="line">参数：</span><br><span class="line">    thread：被等待的线程号。</span><br><span class="line">    retval：用来储存线程退出状态的指针地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0x03</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* retp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, &amp;retp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;retp:%p\n&quot;</span>, retp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;man thread exit...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程不同的方式终止，通过pthread_join得到的终止状态是不同的，总结如下：</p>
<p>1）如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</p>
<p>2）如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED</p>
<p>3）如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</p>
<h4 id="6-4-线程连写"><a href="#6-4-线程连写" class="headerlink" title="6.4 线程连写"></a>6.4 线程连写</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现线程的连写</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1执行的函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);	<span class="comment">//刷新缓冲区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ((<span class="type">char</span>*)arg)[i]);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret1 = <span class="number">-1</span>, ret2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1 = <span class="number">-1</span>, tid2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arr1[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">//创建两个进程</span></span><br><span class="line">    ret1 = pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun, (<span class="type">void</span>*)arr1);</span><br><span class="line">    <span class="keyword">if</span> (ret1 != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程1创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret2 = pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun, (<span class="type">void</span>*)arr2);</span><br><span class="line">    <span class="keyword">if</span> (ret2 != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程2创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-5-线程分离"><a href="#6-5-线程分离" class="headerlink" title="6.5 线程分离"></a>6.5 线程分离</h4><p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获得它的状态为止。但是线程也可以被置为detach（分离）状态，这样的线程一旦终止就立刻回收它所有资源，而不保留终止状态。</p>
<p>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
<p>pthread_detach函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    使调用线程与当前进程分离，分离后不代表此线程不依赖于当前进程，线程分离的目的是将线程资源的回收工作交给系统自动来完成，也就是说当被分离的线程结束之后，系统会自动回收它的资源。所以，此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    thread：线程号</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="6-6-线程退出"><a href="#6-6-线程退出" class="headerlink" title="6.6 线程退出"></a>6.6 线程退出</h4><p>在进程中我们可以调用exit函数或_exit函数来结束进程，在一个线程中我们可以通过以下三种在不中断整个进程的情况下停止它的控制流。</p>
<ul>
<li>线程从执行函数中返回</li>
<li>线程调用pthread_exit退出线程</li>
<li>线程可以被同一进程中的其它线程取消。</li>
</ul>
<p>pthread_exit函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    退出调用线程。一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源不会释放。</span><br><span class="line">参数：</span><br><span class="line">    retval：存储线程退出状态的指针</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread:%d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分离进程失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按任意键继续...&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-7-线程取消"><a href="#6-7-线程取消" class="headerlink" title="6.7 线程取消"></a>6.7 线程取消</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">thread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    杀死(取消)线程</span><br><span class="line">参数：</span><br><span class="line">    thread：目标线程ID</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：出错编号</span><br></pre></td></tr></table></figure>

<p>注意：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某一个取消点（检查点）。</p>
<p>类似于玩游戏存档，必须到达指定的场所（存档点）才能存储进度</p>
<p>杀死线程也不是立刻就能完成，必须要到达取消点。</p>
<p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write…执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。</p>
<p>可粗略认为一个系统调用（进入内核）即为一个取消点</p>
<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_detach is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    ret = pthread_cancel(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_cancel is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子线程被取消\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-线程属性（了解）"><a href="#7-线程属性（了解）" class="headerlink" title="7.线程属性（了解）"></a>7.线程属性（了解）</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><p>Linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。</p>
<p>如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> etachstate;	<span class="comment">//线程分离状态</span></span><br><span class="line">    <span class="type">int</span> schedpolicy; <span class="comment">//线程调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">schedparam</span>;</span> <span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched; <span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="type">int</span> scope; <span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="type">size_t</span> guardsize; <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="type">int</span> stackadd_set; <span class="comment">//线程的栈设置</span></span><br><span class="line">    <span class="type">void</span>* stackaddr;  <span class="comment">//线程栈的位置</span></span><br><span class="line">    <span class="type">size_t</span> stacksize; <span class="comment">//线程栈的大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>

<p>主要结构体成员：</p>
<p>1）线程分离状态</p>
<p>2）线程栈大小（默认平均分配）</p>
<p>3）线程栈警戒缓冲区大小（位于栈末尾）</p>
<p>4）线程栈最低地址</p>
<p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。之后须用pthread_attr_destroy函数来释放资源。</p>
<p>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and paraneters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p>
<h4 id="7-2-线程属性初始化和销毁"><a href="#7-2-线程属性初始化和销毁" class="headerlink" title="7.2 线程属性初始化和销毁"></a>7.2 线程属性初始化和销毁</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span>* attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化线程属性函数，注意：应先初始化线程属性，再pthread_create创建线程</span><br><span class="line">参数：</span><br><span class="line">    attr：线程属性结构体</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span>* attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁线程属性所占用的资源函数</span><br><span class="line">参数：</span><br><span class="line">    attr：线程属性结构体</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br></pre></td></tr></table></figure>

<h4 id="7-3-线程分离状态"><a href="#7-3-线程分离状态" class="headerlink" title="7.3 线程分离状态"></a>7.3 线程分离状态</h4><p>线程的分离状态决定一个线程以什么样的方式来终止自己。</p>
<ul>
<li>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</li>
<li>分离状态：分离状态没有被其它的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</li>
</ul>
<p>相关函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line">功能：设置线程分离状态</span><br><span class="line">参数：</span><br><span class="line">    attr：已初始化的线程属性</span><br><span class="line">    detachstate：分离状态</span><br><span class="line">        PTHREAD_CREATE_DETACHED（分离状态）</span><br><span class="line">        PTHREAD_CREATE_JOINABLE（非分离状态）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">int</span>* detachstate)</span>;</span><br><span class="line">功能：获得线程分离状态</span><br><span class="line">参数：</span><br><span class="line">    attr：已初始化的线程属性</span><br><span class="line">    detachstate：分离状态</span><br><span class="line">        PTHREAD_CREATE_DETACHED（分离状态）</span><br><span class="line">        PTHREAD _CREATE_JOINABLE（非分离状态）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其它的线程使用，这样调用pthread_create的线程就得到了错误的线程号。</p>
<p>要避免这种情况可以采用一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会，留出足够的时间让函数pthread_create返回。</p>
<p>设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p>
<h4 id="7-4-线程栈地址"><a href="#7-4-线程栈地址" class="headerlink" title="7.4 线程栈地址"></a>7.4 线程栈地址</h4><p>POSIX.1定义了两个常量来检查系统是否支持栈属性：</p>
<ul>
<li>_POSIX_THREAD_ATTR_STACKADDR</li>
<li>_POSIX_THREAD_ATTR_STACKSIZE</li>
</ul>
<p>也可以给sysconf函数传递来进行检测：</p>
<ul>
<li>_SC_THREAD_ATTR_STACKADDR</li>
<li>_SC_THREAD_ATTR_STACKSIZE</li>
</ul>
<p>当进程栈地址空间不够时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过pthread_attr_setstack和pthread_attr_getstack两个函数分配设置和获取线程的栈地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* stackaddr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line">功能：设置线程的栈地址</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stackaddr：内存首地址</span><br><span class="line">    stacksize：返回线程的堆栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstack</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>** stackaddr, <span class="type">size_t</span>* stacksize)</span>;</span><br><span class="line">功能：获取线程的栈地址</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stackaddr：返回获取的栈地址</span><br><span class="line">    stacksize：返回获取的栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br></pre></td></tr></table></figure>

<h4 id="7-5-线程栈大小"><a href="#7-5-线程栈大小" class="headerlink" title="7.5 线程栈大小"></a>7.5 线程栈大小</h4><p>当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用，但线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line">功能：设置线程的大小</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stacksize：线程的堆栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">size_t</span>* stacksize)</span>;</span><br><span class="line">功能：获取线程的栈大小</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stacksize：返回线程的堆栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br></pre></td></tr></table></figure>

<h4 id="7-6-线程使用注意事项"><a href="#7-6-线程使用注意事项" class="headerlink" title="7.6 线程使用注意事项"></a>7.6 线程使用注意事项</h4><p>1）主线程退出其它线程不退出，主线程应该调用pthread_exit</p>
<p>2）避免僵尸线程</p>
<p>​	a）pthread_join</p>
<p>​	b）pthread_detach</p>
<p>​	c）pthread_create指定分离属性</p>
<p>​	被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值；</p>
<p>3）malloc和mmap申请的内存可以被其它线程释放</p>
<p>4）应避免在多线程模型中调用fork，除非马上exec，子进程中只有调用fork的线程存在，其它线程在子进程中均pthread_exit</p>
<p>5）信号的复杂语义很难和多线程共享，应避免在多线程中引用信号机制。</p>
<h2 id="十、线程同步"><a href="#十、线程同步" class="headerlink" title="十、线程同步"></a>十、线程同步</h2><h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1.互斥锁"></a>1.互斥锁</h3><h4 id="1-1-同步与互斥概述"><a href="#1-1-同步与互斥概述" class="headerlink" title="1.1 同步与互斥概述"></a>1.1 同步与互斥概述</h4><p>现代操作系统基本上都是多任务操作系统，即同时有大量可调度实体在运行。在多任务操作系统中，同时运行的多个任务可能：</p>
<ul>
<li>都需要访问&#x2F;使用同一种资源</li>
<li>多任务之间有依赖关系，某个任务的运行依赖于另一个任务</li>
</ul>
<p>这两种情形是多任务编程中遇到的最基本问题，也是多任务编程中的核心问题，同步和互斥就是用于解决这两个问题的。</p>
<p>**互斥：**是指散步在不同任务之间的若干程序片段，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之间的任意程序片段，只能等到该任务完成这个程序片段后才可以运行。最基本的场景就是：一个公共资源同一时间只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</p>
<p>**同步：**是指散步在不同任务之间的若干程序片段，它们的运行必须严格按照规定的某种先后顺序来运行，这种先后顺序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后顺序运行。比如A任务的运行依赖于B任务产生的数据。</p>
<p>虽然，同步是一种更为复杂的互斥锁，互斥是两个任务之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但它是必须要按照某种次序来运行相应的线程（也是一种互斥），因此互斥具有唯一性和排它性，但互斥并不限制任务的运行顺序，即任务是无序的，而同步任务之间则有顺序关系</p>
<h4 id="1-2-为什么需要互斥锁"><a href="#1-2-为什么需要互斥锁" class="headerlink" title="1.2 为什么需要互斥锁"></a>1.2 为什么需要互斥锁</h4><p>在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。这个过程有点类似于公司部门里，使用打印机打印东西的同时（还没打印完），别人刚好也在此时此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。</p>
<p>下面用程序来模拟一下这个过程，线程一需要打印“hello”，线程二需要答应“word：，不加任何处理的话，打印出来的内容会混乱</p>
<p>测试程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *((<span class="type">char</span>*)argv + i));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arr1[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr1);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr2);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，打印机是有做处理的，我在打印着的时候别人是不允许打印的，只有等待我打印结束后别人才允许打印。这个过程有点类似于，把打印机放在一个房间里，给这个房间安把锁，这个锁默认是打开的。当A需要打印时，它先过来检查这把锁有没有锁着，没有的话就进去，同时上锁在房间里打印，而这时B也需要打印，B同时先检查锁，发现锁是锁住的，它就在门口等，当A打印结束后，他会开锁出来，这时B才进去上锁打印。</p>
<h4 id="1-3-互斥锁Mutex介绍"><a href="#1-3-互斥锁Mutex介绍" class="headerlink" title="1.3 互斥锁Mutex介绍"></a>1.3 互斥锁Mutex介绍</h4><p>在线程里也有这么一把锁：互斥锁（mutex），也叫互斥量，互斥锁是一种简单的加锁方式来控制对共享资源的访问，互斥锁只有两种状态，即<strong>加锁</strong>（lock）和<strong>解锁</strong>（unlock）。</p>
<p>互斥锁的操作流程如下：</p>
<p>1）在访问共享资源后临界区域前，对互斥锁进行加锁。</p>
<p>2）在访问完成后释放互斥锁导上的锁</p>
<p>3）对互斥锁进行加锁后，任何其它企图再次对互斥锁加锁的线程将会阻塞，直到锁被释放。</p>
<p>互斥锁的数据类型是pthread_mutex_t</p>
<p>安装对应帮助手册：</p>
<blockquote>
<p>sudo apt-get install manpages-posix-dev</p>
</blockquote>
<h4 id="1-4-pthread-mutex-init函数"><a href="#1-4-pthread-mutex-init函数" class="headerlink" title="1.4 pthread_mutex_init函数"></a>1.4 pthread_mutex_init函数</h4><p>初始化互斥锁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个互斥锁</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址，类型是 <span class="type">pthread_mutex_t</span></span><br><span class="line">    attr：设置互斥量的属性，通常可采用默认属性，即可将attr设为<span class="literal">NULL</span>。</span><br><span class="line">    可以使用宏PTHREAD_MUTEX_INITIALIZER静态初始化互斥锁，比如：<span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">这种方法等价于使用 <span class="literal">NULL</span> 指定的 attr 参数调用 pthread_mutex_init() 来完成动态初始化，不同之处在</span><br></pre></td></tr></table></figure>

<blockquote>
<p>restrict，C语言中的一种限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外的所有其它直接或间接的方式修改该对象的内容</p>
</blockquote>
<h4 id="1-5-pthread-mutex-destroy函数"><a href="#1-5-pthread-mutex-destroy函数" class="headerlink" title="1.5 pthread_mutex_destroy函数"></a>1.5 pthread_mutex_destroy函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁指定的一个互斥锁，互斥锁在使用完毕后，必须要对互斥锁进行销毁，以释放资源</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="1-6-pthread-mutex-lock函数"><a href="#1-6-pthread-mutex-lock函数" class="headerlink" title="1.6 pthread_mutex_lock函数"></a>1.6 pthread_mutex_lock函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对互斥锁上锁，若互斥锁已经上锁，则调用者阻塞，直到互斥锁解锁后再上锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">调用该函数时，若互斥锁未加锁，则上锁，返回<span class="number">0</span>；</span><br><span class="line">若互斥锁已加锁，则函数直接返回失败，即EBUSY</span><br></pre></td></tr></table></figure>

<h4 id="1-7-pthread-mutex-unlock函数"><a href="#1-7-pthread-mutex-unlock函数" class="headerlink" title="1.7 pthread_mutex_unlock函数"></a>1.7 pthread_mutex_unlock函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对指定的互斥锁解锁</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="1-8-测试程序"><a href="#1-8-测试程序" class="headerlink" title="1.8 测试程序"></a>1.8 测试程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">-1</span>;</span><br><span class="line">    ret = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *((<span class="type">char</span>*)argv + i));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arr1[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr1);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr2);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-9-死锁（DeadLock）"><a href="#1-9-死锁（DeadLock）" class="headerlink" title="1.9 死锁（DeadLock）"></a>1.9 死锁（DeadLock）</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%AD%BB%E9%94%81.png"></p>
<p><strong>1）什么是死锁</strong></p>
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通讯造成的一种阻塞的现象。若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁。</p>
<p><strong>2）死锁引起的原因</strong></p>
<ul>
<li>竞争不可抢占资源引起死锁</li>
</ul>
<p>​	也就是我们说的第一种情况，而这都在等待对方占有的不可抢占的资源</p>
<ul>
<li>竞争可消耗资源引起死锁</li>
</ul>
<p>​	有p1，p2，p3三个进程，p1向p2发送消息并接收p3发送的消息，p2向p3发送消息并接收p1的消息，p3向p1发送消息并接收p2的消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，这就造成了死锁。</p>
<ul>
<li>进程推进顺序不当引起死锁</li>
</ul>
<p>​	有进程p1，p2，都需要资源A，B，本来可以p1运行A—&gt;p1运行B—&gt;p2运行A—&gt;p2运行B，但是顺序换了，p1运行A时p2运行B，容易发生第一种死锁。互相抢占资源。</p>
<p><strong>3）死锁的必要条件</strong></p>
<ul>
<li>互斥条件</li>
</ul>
<p>某资源只能被一个进程使用，其它进程请求该资源时，只能等待，直到资源使用完毕后释放资源</p>
<ul>
<li>请求和保持条件</li>
</ul>
<p>程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其它进程占用，自己占用资源却保持不放。</p>
<ul>
<li>不可抢占条件</li>
</ul>
<p>进程已获得的资源没有使用完，不能被抢占</p>
<ul>
<li>循环等待条件</li>
</ul>
<p>必然存在一个循环链</p>
<p><strong>4）处理死锁的思路</strong></p>
<p>预防死锁</p>
<p>​	破坏死锁的四个必要条件中的一个或多个来预防死锁</p>
<p>避免死锁</p>
<p>​	和预防死锁的区别就是，在资源动态分配过程中，用某种方式防止系统进入不安全的状态</p>
<p>检查死锁</p>
<p>​	运行时出现死锁，能及时发现死锁，把程序解脱出来</p>
<p>解除死锁</p>
<p>​	发生死锁后，解脱进程，通常撤销进程，回收资源，再分配给正处于阻塞状态的进程</p>
<p><strong>5）预防死锁的方法</strong></p>
<p><strong>破坏请求和保持条件</strong></p>
<p>协议1：</p>
<p>所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求了，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在闲置的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生</p>
<p>协议2：</p>
<p>允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来，然后再请求新的资源</p>
<p><strong>破坏不可抢占条件</strong></p>
<p>当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请</p>
<p><strong>破坏循环等待条件</strong></p>
<p>对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放系统和更高序列号的资源后才能申请低序号的资源。多个同类资源必须一起请求</p>
<p>死锁程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义互斥变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex1;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程1请求1号资源成功...\n&quot;</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程1请求2号资源成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程2请求2号资源成功...\n&quot;</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程2请求1号资源成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1 = <span class="number">-1</span>, tid2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//初始化锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, fun1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, fun2, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭进程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//摧毁资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex1);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-读写锁"><a href="#2-读写锁" class="headerlink" title="2.读写锁"></a>2.读写锁</h3><h4 id="2-1-读写锁概述"><a href="#2-1-读写锁概述" class="headerlink" title="2.1 读写锁概述"></a>2.1 读写锁概述</h4><p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取整个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。</p>
<p>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了<strong>读写锁</strong>来实现。</p>
<p>读写锁的特点如下：</p>
<p>1）如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。<br>2）如果有其它线程写数据，则其它线程都不允许读、写操作</p>
<p>读写锁分为读锁和写锁，规则如下：</p>
<p>1）如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁</p>
<p>2）如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁。</p>
<p>POSIX定义的读写锁的数据类型是pthread_rwlock_t</p>
<h4 id="2-2-pthread-rwlock-init函数"><a href="#2-2-pthread-rwlock-init函数" class="headerlink" title="2.2 pthread_rwlock_init函数"></a>2.2 pthread_rwlock_init函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span>* <span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用来初始化rwlock所指向的读写锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock：指向要初始化的读写指针</span><br><span class="line">    attr：读写锁的属性指针。如果attr为<span class="literal">NULL</span>则会使用默认的属性初始化读写锁，否则使用指定的attr初始化读写锁</span><br><span class="line">    可以使用宏PTHREAD_RWLOCK_INITIALIZER静态初始化读写锁，比如：</span><br><span class="line">    <span class="type">pthread_rwlock_t</span> my_rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line">    这种方法等价于使用<span class="literal">NULL</span>指定的attr参数调用pthread_rwlock_init()来完成动态初始化，不同之处在于PTHREAD_RWLOCK_INITIALIZER宏不进行错误检查</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，读写锁的状态将成为已初始化和已解锁</span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="2-3-pthread-rwlock-destroy函数"><a href="#2-3-pthread-rwlock-destroy函数" class="headerlink" title="2.3 pthread_rwlock_destroy函数"></a>2.3 pthread_rwlock_destroy函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用于摧毁一个读写锁，并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init()自动申请的资源）。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="2-4-pthread-rwlock-rdlock函数"><a href="#2-4-pthread-rwlock-rdlock函数" class="headerlink" title="2.4 pthread_rwlock_rdlock函数"></a>2.4 pthread_rwlock_rdlock函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    以阻塞方式在读写锁上获取读锁（读锁定）</span><br><span class="line">    如果没有写者持有该锁，并且写者阻塞在该锁上，则调用线程会获取读锁</span><br><span class="line">    如果调用线程未获取读锁，则它将阻塞直到它获取了该锁。一个线程可以在一个读写锁上多次执行读锁定。</span><br><span class="line">    线程可以成功调用 pthread_rwlock_rdlock()函数n次，但是之后该线程必须调用 pthread_rwlock_unlock() 函数n次才能解除锁定</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">用于尝试以非阻塞的方式来在读写锁上获取读锁</span><br><span class="line">如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则立即失败返回。</span><br></pre></td></tr></table></figure>

<h4 id="2-5-pthread-rwlock-wrlock函数"><a href="#2-5-pthread-rwlock-wrlock函数" class="headerlink" title="2.5 pthread_rwlock_wrlock函数"></a>2.5 pthread_rwlock_wrlock函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    在读写锁上获取写锁（写锁定）</span><br><span class="line">    如果没有写者持有该锁，并且没有写者读者持有该锁，则调用线程会获取写锁</span><br><span class="line">    如果调用线程未获取写锁，则它将阻塞直到它获取了该锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">用于尝试以非阻塞的方式来在读写锁上获取写锁</span><br><span class="line">如果有任何的读者或者写者持有该锁，则立即失败返回</span><br></pre></td></tr></table></figure>

<h4 id="2-6-pthread-rwlock-unlock函数"><a href="#2-6-pthread-rwlock-unlock函数" class="headerlink" title="2.6 pthread_rwlock_unlock函数"></a>2.6 pthread_rwlock_unlock函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    无论是读锁或者写锁，都可以通过此函数解锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="2-7-测试程序"><a href="#2-7-测试程序" class="headerlink" title="2.7 测试程序"></a>2.7 测试程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读写锁对象</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读锁的函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">read_fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//添加读锁</span></span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程%d正在读num:%d\n&quot;</span>, (<span class="type">int</span>)(<span class="type">long</span>)argv, num);</span><br><span class="line">        <span class="comment">//随机休眠1-3秒</span></span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写锁的函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">write_fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程%d正在读num:%d\n&quot;</span>, (<span class="type">int</span>)(<span class="type">long</span>)argv, num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">//随机休眠1-3秒</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">6</span>];</span><br><span class="line">    <span class="comment">//随机数种子</span></span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化读写锁</span></span><br><span class="line">    ret = pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_rwlock_init is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建6个进程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//读数据</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;read_fun, (<span class="type">void</span>*)(<span class="type">long</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;write_fun, (<span class="type">void</span>*)(<span class="type">long</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3.条件变量"></a>3.条件变量</h3><h4 id="3-1-条件变量概述"><a href="#3-1-条件变量概述" class="headerlink" title="3.1 条件变量概述"></a>3.1 条件变量概述</h4><p>在互斥锁不同，条件变量是用来等待而不是用来上锁的，<strong>条件变量本身不是锁！</strong></p>
<p>条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</p>
<p>条件变量的两个动作：</p>
<ul>
<li>条件不满，阻塞线程</li>
<li>当条件满足，通知阻塞的线程开始工作</li>
</ul>
<p>条件变量的类型：pthread_cond_t。</p>
<h4 id="3-2-pthread-cond-init函数"><a href="#3-2-pthread-cond-init函数" class="headerlink" title="3.2 pthread_cond_init函数"></a>3.2 pthread_cond_init函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#Include &lt;pthread.h&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针。</span><br><span class="line">    attr：条件变量属性，通常为默认值，传<span class="literal">NULL</span>即可</span><br><span class="line">        也可以使用静态初始化的方法，初始化条件变量：</span><br><span class="line">        <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h4 id="3-3-pthread-cond-destroy函数"><a href="#3-3-pthread-cond-destroy函数" class="headerlink" title="3.3 pthread_cond_destroy函数"></a>3.3 pthread_cond_destroy函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    摧毁一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h4 id="3-4-pthread-cond-wait函数"><a href="#3-4-pthread-cond-wait函数" class="headerlink" title="3.4 pthread_cond_wait函数"></a>3.4 pthread_cond_wait函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    阻塞等待一个条件变量</span><br><span class="line">    a）阻塞等待条件变量cond（参<span class="number">1</span>）满足</span><br><span class="line">    b）释放已掌握的互斥锁（解锁互斥量）相当于 pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        a）b）两步为一个原子操作</span><br><span class="line">    c）当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁 pthread_mutex_lock(&amp;mutex);</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec* <span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line">功能：</span><br><span class="line">    限时等待一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">    abstime：绝对时间</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<p>abstime补充说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>&#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;<span class="comment">//秒</span></span><br><span class="line">    <span class="type">long</span> tv_nsec;<span class="comment">//纳秒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);<span class="comment">//获取当前的时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span><span class="comment">//定义timespec结构体变量t</span></span><br><span class="line">t.tv_sec = cur + <span class="number">1</span>;<span class="comment">//定义1秒</span></span><br><span class="line">pthread_cond_timedwait(&amp;cond, &amp;t);</span><br></pre></td></tr></table></figure>

<h4 id="3-5-pthread-cond-signal函数"><a href="#3-5-pthread-cond-signal函数" class="headerlink" title="3.5 pthread_cond_signal函数"></a>3.5 pthread_cond_signal函数</h4><p>唤醒至阻塞在条件变量上的线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒全部阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h4 id="3-6-生产者消费者条件变量模型"><a href="#3-6-生产者消费者条件变量模型" class="headerlink" title="3.6 生产者消费者条件变量模型"></a>3.6 生产者消费者条件变量模型</h4><p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法</p>
<p>假设有两个线程，一个模拟生产者的行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">//互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//创建一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pnew</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        <span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc is error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点初始化</span></span><br><span class="line">        pnew-&gt;data = random() % <span class="number">100</span>;</span><br><span class="line">        pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者正在生产%d\n&quot;</span>, pnew-&gt;data);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        <span class="comment">//随机休眠</span></span><br><span class="line">        sleep(random()%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pTemp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pTemp = head;</span><br><span class="line">            head = pTemp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在消费:%d\n&quot;</span>, pTemp-&gt;data);</span><br><span class="line">            <span class="built_in">free</span>(pTemp);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化互斥量</span></span><br><span class="line">    ret = pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_init is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//条件变量初始化</span></span><br><span class="line">    ret = pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_cond_init is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="comment">//摧毁互斥量</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-条件变量的优缺点"><a href="#3-7-条件变量的优缺点" class="headerlink" title="3.7 条件变量的优缺点"></a>3.7 条件变量的优缺点</h4><p>相较于mutex而言，条件变量可以减少竞争。</p>
<p>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。</p>
<p>有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p>
<h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4.信号量"></a>4.信号量</h3><h4 id="4-1-信号量概述"><a href="#4-1-信号量概述" class="headerlink" title="4.1 信号量概述"></a>4.1 信号量概述</h4><p>信号量广泛用于进程或进程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问</p>
<p>编程时可以根据操作信号量的结果判断是否对公共资源具有访问权限，当信号量值大于0时，则可以访问，负责将阻塞</p>
<p>PV原语是对信号量的操作，一次P操作使信号量减1，一次V操作使信号量加1</p>
<p>信号量主要用于进程或线程间的同步和异步两种典型情况</p>
<p>信号量数据类型为：sem_t</p>
<p>信号量用于互斥</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BA%92%E6%96%A5.png"></p>
<p>信号量用于同步：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5.png"></p>
<h4 id="4-2-sem-init函数"><a href="#4-2-sem-init函数" class="headerlink" title="4.2 sem_init函数"></a>4.2 sem_init函数</h4><p>初始化信号量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个信号量并初始化它的值。一个无名信号量在被使用前必须先初始化</span><br><span class="line">参数：</span><br><span class="line">    sem: 信号量的地址</span><br><span class="line">    pshared: 等于<span class="number">0</span>，信号量在线程间同步（常用）；不等于<span class="number">0</span>，信号量在线程间共享。</span><br><span class="line">    value: 信号量的初始值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-sem-destroy函数"><a href="#4-3-sem-destroy函数" class="headerlink" title="4.3 sem_destroy函数"></a>4.3 sem_destroy函数</h4><p>销毁信号量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">功能；</span><br><span class="line">    删除sem标识的信号量</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-4-信号量P操作（减1）"><a href="#4-4-信号量P操作（减1）" class="headerlink" title="4.4 信号量P操作（减1）"></a>4.4 信号量P操作（减1）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值减<span class="number">1</span>，操作前，先检查信号量（sem）的值是否为<span class="number">0</span>，若信号量为<span class="number">0</span>，此函数会阻塞，直到信号量大于<span class="number">0</span>时才进行减<span class="number">1</span>操作</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">以非阻塞的方式来对信号量进行减<span class="number">1</span>操作</span><br><span class="line">若操作前，信号量的值等于<span class="number">0</span>，则对信号量的操作失败，函数立即返回</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">const</span> <span class="keyword">struct</span> timespec* abs_timeout)</span>;</span><br><span class="line">限时尝试将信号量的值减<span class="number">1</span></span><br><span class="line">abs_timeout：绝对时间</span><br></pre></td></tr></table></figure>

<p>abs_timeout补充说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>&#123;</span></span><br><span class="line">  <span class="type">time_t</span> tv_sec;	<span class="comment">//秒</span></span><br><span class="line">  <span class="type">long</span> tv_nsec;		<span class="comment">//纳秒  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);	<span class="comment">//获取当前的时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span>	<span class="comment">//定义timespec结构体变量t</span></span><br><span class="line">t.tv_sec = cur + <span class="number">1</span>;	<span class="comment">//定时1秒</span></span><br><span class="line">sem_timedwait(&amp;cond, &amp;t);</span><br></pre></td></tr></table></figure>

<h4 id="4-5-信号量V操作（加1）"><a href="#4-5-信号量V操作（加1）" class="headerlink" title="4.5 信号量V操作（加1）"></a>4.5 信号量V操作（加1）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值加<span class="number">1</span>并发出信号唤醒等待线程（ sem_wait()）。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-6-获取信号量的值"><a href="#4-6-获取信号量的值" class="headerlink" title="4.6 获取信号量的值"></a>4.6 获取信号量的值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span>* sval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取sem标识的信号量的值，保存在sval中</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量地址</span><br><span class="line">    sval：保存信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-7-示例程序"><a href="#4-7-示例程序" class="headerlink" title="4.7 示例程序"></a>4.7 示例程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//占用后P操作</span></span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放后执行V操作</span></span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    sem_init(&amp;sem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//释放线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-消费者模式更改"><a href="#4-8-消费者模式更改" class="headerlink" title="4.8 消费者模式更改"></a>4.8 消费者模式更改</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//创建一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pnew</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        <span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc is error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点初始化</span></span><br><span class="line">        pnew-&gt;data = random() % <span class="number">100</span>;</span><br><span class="line">        pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者正在生产%d\n&quot;</span>, pnew-&gt;data);</span><br><span class="line">        sem_post(&amp;sem_consumer);</span><br><span class="line">        sem_wait(&amp;sem_bearer);</span><br><span class="line">        <span class="comment">//随机休眠</span></span><br><span class="line">        sleep(random()%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pTemp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pTemp = head;</span><br><span class="line">            head = pTemp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在消费:%d\n&quot;</span>, pTemp-&gt;data);</span><br><span class="line">            <span class="built_in">free</span>(pTemp);</span><br><span class="line">            sem_post(&amp;sem_bearer);</span><br><span class="line">            sem_wait(&amp;sem_consumer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    sem_init(&amp;sem_bearer, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    sem_init(&amp;sem_consumer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem_bearer);</span><br><span class="line">    sem_destroy(&amp;sem_consumer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-9-多信号量生产者模式"><a href="#4-9-多信号量生产者模式" class="headerlink" title="4.9 多信号量生产者模式"></a>4.9 多信号量生产者模式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//创建一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pnew</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        <span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc is error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点初始化</span></span><br><span class="line">        pnew-&gt;data = random() % <span class="number">100</span>;</span><br><span class="line">        pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者正在生产%d\n&quot;</span>, pnew-&gt;data);</span><br><span class="line">        sem_post(&amp;sem_consumer);</span><br><span class="line">        sem_wait(&amp;sem_bearer);</span><br><span class="line">        <span class="comment">//随机休眠</span></span><br><span class="line">        sleep(random()%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pTemp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pTemp = head;</span><br><span class="line">            head = pTemp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在消费:%d\n&quot;</span>, pTemp-&gt;data);</span><br><span class="line">            <span class="built_in">free</span>(pTemp);</span><br><span class="line">            sem_post(&amp;sem_bearer);</span><br><span class="line">            sem_wait(&amp;sem_consumer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">6</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>, i;</span><br><span class="line">    <span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    sem_init(&amp;sem_bearer, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    sem_init(&amp;sem_consumer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem_bearer);</span><br><span class="line">    sem_destroy(&amp;sem_consumer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2025/03/07/19e651a75115/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这一节开始学习线性结构的知识，线性结构是指数据元素之间存在一对一的线性关系。</p>
<p>线性表是一个简单的线性结构，可以通过这一个数据结构了解更多的数据结构是实现。</p>
<h1 id="一、逻辑结构"><a href="#一、逻辑结构" class="headerlink" title="一、逻辑结构"></a>一、逻辑结构</h1><p>线性表是一个若干个数据元素的一个线性序列，它是一个有限序列，其中每个元素都是一个数据元素，每个元素都有一个前驱和一个后继，除了第一个元素没有前驱，最后一个元素没有后继。</p>
<p>可以了解线性表在存储结构中可以使用数组或者列表来进行存放，因为这个线性表是一个连续的序列。</p>
<h1 id="二、存储结构"><a href="#二、存储结构" class="headerlink" title="二、存储结构"></a>二、存储结构</h1><p>从逻辑结构那分析出来知道这个线性表可以用顺序存储，也可以用非顺序结构，这里两个存储方式都不会分别实现。</p>
<h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><p>在开始存储前先介绍一下存储的结构，这里的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">data_t</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; SqList, *SqListPtr;</span><br></pre></td></tr></table></figure>

<p>data是存放数据的数组，length是存放数据的长度。</p>
<p>data_t是一个数据类型，这里可以使用int类型来进行存放。</p>
<p>MaxSize是数组的大小，这里可以使用宏定义来进行定义。</p>
<h2 id="2-顺序存储"><a href="#2-顺序存储" class="headerlink" title="2.顺序存储"></a>2.顺序存储</h2><p>前面说过顺序存储是存放在一块地址连续的空间，我们可以用数组来进行存放，但是直接使用数组来进行存放就会有一个问题，直接使用数组那它开辟的空间是在栈上的，栈在程序结束时就会被释放，所以我们需要使用动态内存分配来进行存放，这样就会开辟到堆区上。</p>
<p>在堆区上会一直存放的，直到调用free函数来释放内存。</p>
<p>然后了解了使用过程后，我们可以开始实现顺序存储了。</p>
<p>在实现的时候先了解一下我们需要实现的功能，这里列出一些操作类型，等后面会一一实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SqListPtr <span class="title function_">InitList</span><span class="params">()</span>;   <span class="comment">// 初始化线性表</span></span><br><span class="line">Status <span class="title function_">DestroyList</span><span class="params">(SqListPtr* <span class="built_in">list</span>)</span>;      <span class="comment">// 销毁线性表</span></span><br><span class="line">Status <span class="title function_">ClearList</span><span class="params">(SqListPtr <span class="built_in">list</span>)</span>;         <span class="comment">// 清空线性表</span></span><br><span class="line">Status <span class="title function_">ListEmpty</span><span class="params">(SqListPtr <span class="built_in">list</span>)</span>;         <span class="comment">// 判断线性表是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(SqListPtr <span class="built_in">list</span>)</span>;           <span class="comment">// 获取线性表的长度</span></span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(SqListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> *elem)</span>;   <span class="comment">// 获取线性表中指定位置的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqListPtr <span class="built_in">list</span>, <span class="type">data_t</span> elem)</span>;   <span class="comment">// 获取线性表中指定元素的位置</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(SqListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> elem)</span>;   <span class="comment">// 在线性表中指定位置插入元素</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(SqListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> *elem)</span>;   <span class="comment">// 在线性表中指定位置删除元素</span></span><br></pre></td></tr></table></figure>

<p>然后还有一些宏定义和类型的重命名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_NOT_NULL 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br></pre></td></tr></table></figure>

<p>然后就可以开始写代码了。</p>
<h3 id="2-1-初始化线性表"><a href="#2-1-初始化线性表" class="headerlink" title="2.1 初始化线性表"></a>2.1 初始化线性表</h3><p>实现需要初始化一下线性表，前面说过，需要使用动态内存分配来进行存放，所以需要使用malloc函数来进行分配内存，然后直接创建结构体即可。</p>
<p>然后给结构体中的length赋值为0即可，这个length是用来记录线性表中元素的个数的，有些喜欢从-1，然后这个代表最后一个元素的下标。而我们这记录的是元素个数，所以从0开始。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SqListPtr <span class="title function_">InitList</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SqListPtr <span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span> = (SqListPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-销毁线性表"><a href="#2-2-销毁线性表" class="headerlink" title="2.2 销毁线性表"></a>2.2 销毁线性表</h3><p>对于顺序结构来说，销毁直接就释放那个结构体就可以了，因为是连续的空间，不需要释放每个元素。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DestroyList</span><span class="params">(SqListPtr* <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(*<span class="built_in">list</span>);</span><br><span class="line">    *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK； </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的参数指针不解释，其实就是二级指针的问题，大家有兴趣可以看我前面介绍的二级指针的内容。</p>
<h3 id="2-3-清空线性表"><a href="#2-3-清空线性表" class="headerlink" title="2.3 清空线性表"></a>2.3 清空线性表</h3><p>清空其实就是将里面的元素全部清除，但是这里不需要这么麻烦，我们在使用这个线性表的时候是通过<code>length</code>的记录来记录线性表中的个数，当这个<code>length</code>为0的时候，就代表这个线性表中没有元素了，所以我们只需要将<code>length</code>赋值为0即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ClearList</span><span class="params">(SqListPtr <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-判断线性表是否为空"><a href="#2-4-判断线性表是否为空" class="headerlink" title="2.4 判断线性表是否为空"></a>2.4 判断线性表是否为空</h3><p>判断线性表是否为空，只需要判断<code>length</code>是否为0即可，为0就代表这个线性表中没有元素，不为0就代表这个线性表中有元素。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListEmpty</span><span class="params">(SqListPtr <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> IS_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> IS_NOT_NULL; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-获取线性表的长度"><a href="#2-5-获取线性表的长度" class="headerlink" title="2.5 获取线性表的长度"></a>2.5 获取线性表的长度</h3><p>获取线性表的长度，只需要返回<code>length</code>的值即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(SqListPtr <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-获取线性表中指定位置的元素"><a href="#2-6-获取线性表中指定位置的元素" class="headerlink" title="2.6 获取线性表中指定位置的元素"></a>2.6 获取线性表中指定位置的元素</h3><p>获取线性表中指定位置的元素，只需要判断位置是否合法，然后返回指定位置的元素即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetElem</span><span class="params">(SqListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> *elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span> || elem == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= <span class="built_in">list</span>-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *elem = <span class="built_in">list</span>-&gt;data[pos];</span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-获取线性表中指定元素的位置"><a href="#2-7-获取线性表中指定元素的位置" class="headerlink" title="2.7 获取线性表中指定元素的位置"></a>2.7 获取线性表中指定元素的位置</h3><p>获取线性表中指定元素的位置，只需要遍历线性表，然后判断元素是否相等，相等就返回位置，不相等就返回-1。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqListPtr <span class="built_in">list</span>, <span class="type">data_t</span> elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data[i] == elem)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-在线性表中指定位置插入元素"><a href="#2-8-在线性表中指定位置插入元素" class="headerlink" title="2.8 在线性表中指定位置插入元素"></a>2.8 在线性表中指定位置插入元素</h3><p>在线性表中指定位置插入元素，只需要判断位置是否合法，然后将指定位置后面的元素都向后移动一位，然后将元素插入到指定位置即可。</p>
<p>这里用一个图来演示这个过程：</p>
<p>这里分为两个情况，一个是在最后插入数据，这种情况不需要移动，另一种是在中间插入数据，这种情况需要移动：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE1.png"></p>
<p>首先有一个线性表，这里需要在位置2插入一个元素value，然后需要先找到一下这个线性表中的最后一个元素的下标，用一个指针进行存放，存放后比较一下这个指针存放的下标是否是需要插入的位置，如果是直接插入，如果不是需要让这个指针指向的内容向后移动：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE2.png"></p>
<p>然后指针又往前移动，再次比较是不是插入的位置，如果不是将这个指针存放的下标的内容向后移动：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE3.png"></p>
<p>如果这个指针指向的下标就是需要插入的位置，那先移动元素，移动完成后将指插入即可：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE4.png"></p>
<p>知道这个过程后我们就可以写一下代码了</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(SqListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">list</span>-&gt;length - <span class="number">1</span>;   <span class="comment">// 因为存放的是元素个数，所以需要减1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt; <span class="built_in">list</span>-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i &gt;= pos; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>] = <span class="built_in">list</span>-&gt;data[i];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">list</span>-&gt;data[pos] = elem;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;         <span class="comment">// 里面的元素增加</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-9-在线性表中指定位置删除元素"><a href="#2-9-在线性表中指定位置删除元素" class="headerlink" title="2.9 在线性表中指定位置删除元素"></a>2.9 在线性表中指定位置删除元素</h3><p>删除和插入一样，也是需要移动元素进行删除，前面插入是往后移动元素，而删除是往前移动，直接覆盖住需要删除的元素，然后让<code>length</code>减1即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(SqListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> *elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt; <span class="built_in">list</span>-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *elem = <span class="built_in">list</span>-&gt;data[pos];</span><br><span class="line">    <span class="keyword">for</span> (i = pos; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i] = <span class="built_in">list</span>-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-10-打印线性表"><a href="#2-10-打印线性表" class="headerlink" title="2.10 打印线性表"></a>2.10 打印线性表</h3><p>打印线性表，只需要遍历线性表，然后打印每个元素即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(SqListPtr <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样线性表的基本操作都做完了，下面来介绍一下链式存储，也就是非顺序存储。</p>
<h2 id="3-链式存储"><a href="#3-链式存储" class="headerlink" title="3.链式存储"></a>3.链式存储</h2><p>链式存储是指用一组任意的存储单元存储线性表中的数据元素，这组存储单元可以是连续的，也可以是不连续的。</p>
<p>链式存储是通过指针来进行连接的，每个元素都有一个指针，指向下一个元素，这样就可以通过指针来进行连接，这样就可以实现链式存储，链式存储的长度其实是根据堆区的大小来的，如果堆区空间还有内存，则可以创建结点。</p>
<p>所以在这里的链式存储结构就没有长度这个属性了，如果要判断这个线性表的长度，可以通过遍历链表来获取长度。</p>
<p>链式存储的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">data_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>      <span class="comment">// 下一个结点的地址</span></span><br><span class="line">&#125;ListNode, *ListPtr;</span><br></pre></td></tr></table></figure>

<p>data是存放数据的，next是指向下一个结点的地址。</p>
<p>下面是链式存储的有些函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListPtr <span class="title function_">InitList</span><span class="params">()</span>;   <span class="comment">// 初始化线性表</span></span><br><span class="line">Status <span class="title function_">DestroyList</span><span class="params">(ListPtr* <span class="built_in">list</span>)</span>;      <span class="comment">// 销毁线性表</span></span><br><span class="line">Status <span class="title function_">ClearList</span><span class="params">(ListPtr <span class="built_in">list</span>)</span>;         <span class="comment">// 清空线性表</span></span><br><span class="line">Status <span class="title function_">ListEmpty</span><span class="params">(ListPtr <span class="built_in">list</span>)</span>;         <span class="comment">// 判断线性表是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(ListPtr <span class="built_in">list</span>)</span>;           <span class="comment">// 获取线性表的长度</span></span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(ListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> *elem)</span>;   <span class="comment">// 获取线性表中指定位置的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(ListPtr <span class="built_in">list</span>, <span class="type">data_t</span> elem)</span>;   <span class="comment">// 获取线性表中指定元素的位置</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(ListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> elem)</span>;   <span class="comment">// 在线性表中指定位置插入元素</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(ListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> *elem)</span>;   <span class="comment">// 在线性表中指定位置删除元素</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-初始化线性表"><a href="#3-1-初始化线性表" class="headerlink" title="3.1 初始化线性表"></a>3.1 初始化线性表</h3><p>初始化线性表，只需要创建一个头结点，然后将头结点的指针指向NULL即可，这个头节点不需要任何的数据，相当于是一个指示的结点。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListPtr <span class="title function_">InitList</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ListPtr <span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span> = (ListPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;data = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-销毁线性表"><a href="#3-2-销毁线性表" class="headerlink" title="3.2 销毁线性表"></a>3.2 销毁线性表</h3><p>销毁线性表，只需要遍历链表，然后释放每个结点即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DestroyList</span><span class="params">(ListPtr* <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ListPtr p = *<span class="built_in">list</span>;</span><br><span class="line">    ListPtr q = (*<span class="built_in">list</span>)-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">free</span>(p); </span><br><span class="line">       p = q;</span><br><span class="line">       q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-清空线性表"><a href="#3-3-清空线性表" class="headerlink" title="3.3 清空线性表"></a>3.3 清空线性表</h3><p>这里可以直接让头节点的<code>next</code>指向<code>NULL</code>即可，但是后面的结点还是在的，如果不进行释放，那可能会导致内存溢出，所以这里需要先将后面的结点释放掉，然后再将头节点的<code>next</code>指向<code>NULL</code>即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ClearList</span><span class="params">(ListPtr <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里让p指针领先q指针一个结点</span></span><br><span class="line">    ListPtr p = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    ListPtr q = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-判断线性表是否为空"><a href="#3-4-判断线性表是否为空" class="headerlink" title="3.4 判断线性表是否为空"></a>3.4 判断线性表是否为空</h3><p>判断线性表是否为空，只需要判断头节点的<code>next</code>是否为<code>NULL</code>即可，为<code>NULL</code>就代表这个线性表中没有元素，不为<code>NULL</code>就代表这个线性表中有元素。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListEmpty</span><span class="params">(ListPtr <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> IS_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> IS_NOT_NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-获取线性表的长度"><a href="#3-5-获取线性表的长度" class="headerlink" title="3.5 获取线性表的长度"></a>3.5 获取线性表的长度</h3><p>获取线性表的长度，只需要遍历链表，然后记录链表的长度即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(ListPtr <span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    ListPtr p = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        length++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-获取线性表中指定位置的元素"><a href="#3-6-获取线性表中指定位置的元素" class="headerlink" title="3.6 获取线性表中指定位置的元素"></a>3.6 获取线性表中指定位置的元素</h3><p>获取线性表中指定位置的元素，只需要遍历链表，然后找到指定位置的元素即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetElem</span><span class="params">(ListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> *elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt; ListLength(<span class="built_in">list</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    ListPtr p = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pos; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    *elem = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-获取线性表中指定元素的位置"><a href="#3-7-获取线性表中指定元素的位置" class="headerlink" title="3.7 获取线性表中指定元素的位置"></a>3.7 获取线性表中指定元素的位置</h3><p>获取线性表中指定元素的位置，只需要遍历链表，然后找到指定元素的位置即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(ListPtr <span class="built_in">list</span>, <span class="type">data_t</span> elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR; </span><br><span class="line">    &#125;</span><br><span class="line">    ListPtr p = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == elem)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-在线性表中指定位置插入元素"><a href="#3-8-在线性表中指定位置插入元素" class="headerlink" title="3.8 在线性表中指定位置插入元素"></a>3.8 在线性表中指定位置插入元素</h3><p>对于链表中，插入元素其实很简单，它不需要移动全部元素，只需要在对应的位置移动指针即可，让插入的结点的<code>next</code>获得前面的那个结点的<code>next</code>，然后让前面的那个结点的<code>next</code>指向这个新插入的结点。</p>
<p>图示如下：</p>
<p>有一个链表，第一个是头结点，头节点不算在内，现在需要插入到第1的位置</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE.png"></p>
<p>先找到要插入位置的结点的前面，相当于是0这个位置，然后让新插入的结点的<code>next</code>指向前面那个结点的<code>next</code></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE2.png"></p>
<p>然后让前面那个结点的<code>next</code>指向插入的这个结点</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE3.png"></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(ListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    linkList pNext = <span class="literal">NULL</span>;</span><br><span class="line">    linkList pHead = <span class="built_in">list</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pHead &amp;&amp; pos - <span class="number">1</span> &gt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        pHead = pHead-&gt;pNext;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; pos - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果找不到那个位置的内容</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    pNext = (linkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linkNode));</span><br><span class="line">    <span class="keyword">if</span> (pNext == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    pNext-&gt;pNext = pHead-&gt;pNext;</span><br><span class="line">    pNext-&gt;data = elem;</span><br><span class="line">    pHead-&gt;pNext = pNext;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-删除元素"><a href="#3-9-删除元素" class="headerlink" title="3.9 删除元素"></a>3.9 删除元素</h3><p>删除是比较简单的，其实就是找到想要删除的元素的前一个元素，然后让这个结点的<code>next</code>指向想要删除的结点的<code>next</code>，然后释放需要删除的结点就可以删除成功了。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.png"></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(ListPtr <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">data_t</span> *elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> value = ERROR;</span><br><span class="line">    linklist pNext, pEnd;</span><br><span class="line">    pNext = link-&gt;pNext;</span><br><span class="line">    pEnd = link;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LinkList_ListEmpty(*link) == IS_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pNext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 删除内容</span></span><br><span class="line">            pEnd-&gt;pNext = pNext-&gt;pNext;</span><br><span class="line">            value = pNext-&gt;data;</span><br><span class="line">            <span class="built_in">free</span>(pNext);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        pEnd = pNext;</span><br><span class="line">        pNext = pNext-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>线性表还是比较简单的一个数据结构，后面还会介绍栈、队列和树这些数据结构。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-3b系统安装和使用vscode进行远程连接</title>
    <url>/2025/01/17/c9e1bc87adc3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前研究中断的时候一直出现问题，我怀疑是因为<code>zero 3</code>不支持，所以一狠心就花钱买了一块3b。然后那几天在看Linux系统的时候看到很多人都推荐使用<code>debian</code>系统，所以我准备在这块板子上安装一下debian系统来试试，以前我是玩<code>Ubuntu</code>的，所以有些地方我还是不太懂。然后今天下载debian的时候出现了有些问题，我写这篇文章来记录一下这些问题。</p>
<h1 id="一、下载镜像和安装系统"><a href="#一、下载镜像和安装系统" class="headerlink" title="一、下载镜像和安装系统"></a>一、下载镜像和安装系统</h1><p>首先我们需要下载一个自己喜欢的系统，我这选择的是debian这个系统了。打开<a href="http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-3B.html">orangepi 3b</a>资料下载页面，然后再官方镜像中选择你喜欢的镜像进行下载</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223173307268-1192738437.png" alt="img"></p>
<p>这里推荐大家使用官方的镜像，兼容性和一些设置还有一些软件官方都为我们弄好了，当然，也可以去系统官网下载，我这因为没有屏幕所以直接就省事了，等有屏幕了我再给大家出一起使用官方Ubuntu的安装。</p>
<p>然后选择完镜像后就可以进行下载了，我这是直接下载好的</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223173629915-772612857.png" alt="img"></p>
<p>你们下载好的debian系统绝对不是这个样子的，因为我删除了一些镜像，然后选择你想安装的镜像安装包，因为我这没有屏幕，所以选择了<code>server</code>版，也就是服务器版，然后用解压软件进行解压，解压出来的内容有一个<code>.img</code>和一个<code>.img.sha</code>，然后打开<code>win32磁盘下载工具</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223174348141-2027926739.png" alt="img"></p>
<p>然后选择刚才解压的<code>.img</code>文件</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223174439930-422150623.png" alt="img"></p>
<p>然后点击写入，将镜像文件写入进SD卡中，然后就插入到香橙派中，这就不配图了，这步不会的可以看我的其他文章。</p>
<p>后面就可以给电和使用串口来进行调试了。</p>
<h1 id="二、使用串口助手进行调试"><a href="#二、使用串口助手进行调试" class="headerlink" title="二、使用串口助手进行调试"></a>二、使用串口助手进行调试</h1><p>这里还是和之前zero一样的插法，但这里有坑，我也是搞了半天都没搞明白，后面看了官方手册才明白。</p>
<p>我按照正常的串口和波特率进行设置，波特率是和zero一样的<code>115200</code>，然后进入到串口助手中，结果全是乱码</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223174825338-862440467.png" alt="img"></p>
<p>我以为正常执行，结果等了半天还是没显示出命令输入，我就蒙了，以为我安装错系统了，安成图形化界面了，后面我又重新的安装了几次，发现还是不行，然后我就开始看官方手册，手册上说，要使用<code>1500000</code>的波特率，我人傻了，这么大的波特率，我这个串口助手只有<code>1382400</code>，我就硬着头皮试了一下，结果成功了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223175156296-697933520.png" alt="img"></p>
<p>这点非常的不同，大家一定要注意一下这个问题。</p>
<h1 id="三、查看系统的ip地址"><a href="#三、查看系统的ip地址" class="headerlink" title="三、查看系统的ip地址"></a>三、查看系统的ip地址</h1><p>当我连接网线后使用<code>ifconfig</code>命令，结果显示</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223181502631-285496944.png" alt="img"></p>
<p>提示我权限低，没办法使用，我就纳闷了，我这个账户应该也可以使用的啊，后面我百度了一下，发现新版本的Linux已经弃用了，但是系统里面还有这个工具，网上都推荐使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure>

<p>这个工具也可以查看本机IP地址</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223181828559-1645712507.png" alt="img"></p>
<p>但是我还是喜欢使用<code>ifconfig</code>，所以我就在网上找了很多教程，终于找到了一个，这个方法很简单，首先在家目录中使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>

<p>查看所有文件</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223182005172-1898147463.png" alt="img"></p>
<p>可以看到有一个<code>.profile</code>的文件，我们使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim .profile</span><br></pre></td></tr></table></figure>

<p>打开后在最后添加一条</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/sbin</span><br></pre></td></tr></table></figure>

<p>然后保存退出，使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .profile</span><br></pre></td></tr></table></figure>

<p>进行重启后就可以不用<code>sudo</code>就可以使用<code>ifconfig</code>命令了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223182317838-598596224.png" alt="img"></p>
<h1 id="四、使用vscode连接香橙派"><a href="#四、使用vscode连接香橙派" class="headerlink" title="四、使用vscode连接香橙派"></a>四、使用vscode连接香橙派</h1><p>vscode非常好用，非常推荐，用这个连接香橙派后就可以不用xshell远程连接，写代码就可以不用<code>vim</code>了。</p>
<p>我很喜欢用vim的，但是vim对于多文件的不太好，那天写自闭了，就换vscode了。</p>
<p>首先需要在vscode中下载一个插件</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223182724026-1804353554.png" alt="img"></p>
<p>这些都下载，然后下载后左边就会出现这个图标</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223182806683-869148961.png" alt="img"></p>
<p>然后点击进去</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223182846328-1556356973.png" alt="img"></p>
<p>然后把鼠标移动到SSH上，就会出现一个加号，点击这个加号，就会出现一个框，让我们输入连接命令</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183221447-1630539573.png" alt="img"></p>
<p>这里输入的命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh 账户名称@IP地址</span><br></pre></td></tr></table></figure>
<p>比如我这要连接的账户名是<code>orangepi</code>，ip地址是<code>192.168.1.31</code>，那我的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh orangepi@192.168.1.31</span><br></pre></td></tr></table></figure>

<p>然后按下回车就会让我们选择配置文件的路径</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183416704-399977591.png" alt="img"></p>
<p>我这喜欢使用第一个默认的，然后回车，就会说明配置文件已经创建成功</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183504867-2185775.png" alt="img"></p>
<p>然后我们打开配置</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183526447-4198095.png" alt="img"></p>
<p>在这里我们需要找到我们刚才设置的IP地址，然后添加一条端口地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Port 22</span><br></pre></td></tr></table></figure>

<p>如果你想显示的名称不是IP地址，你可以修改<code>HostName</code>的值，然后就保存并关闭这个页面，回到远程连接中就会发现有一条新的</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183729699-465489138.png" alt="img"></p>
<p>然后点击<code>-&gt;</code>就可以进入。</p>
<p>点击后会出现下面的界面</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183827213-2050871139.png" alt="img"></p>
<p>这个就是让我们选择连接的目标是什么系统，这是Linux，所以选择第一个，按回车即可。</p>
<p>然后问我们是否继续</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183956612-955294382.png" alt="img"></p>
<p>直接回车，得快，要不然又得重新连接。</p>
<p>然后就开始让我们输入密码</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223184032119-1529628545.png" alt="img"></p>
<p>这里输入密码即可，然后就进入等待页面，就等就可以了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223184055947-842177833.png" alt="img"></p>
<p>等一会左下角不转圈了，我们就可以新建一个终端，在上面的工具栏的三个点，点击后有一个终端，点进去就有一个新建终端。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223184243639-342060684.png" alt="img"></p>
<p>这样我们就配置好了，可以在里面打开香橙派的目录和其他东西。非常好用，还可以配置一些插件来辅助。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>vscode非常好用，非常好用，有了vscode可以提高我们的开发效率。</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-中断？不！中断！</title>
    <url>/2025/01/17/d57535b42630/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>中断这个在很多单片机中都是比较常见的，像什么51单片机，stm32单片机都是可以通过自己的设置来实现中断的。在香橙派这种比较高级的单片机上也是有中断的，但是呢，这里的中断和51或者stm的单片机有点不同。</p>
<h1 id="一、什么是中断"><a href="#一、什么是中断" class="headerlink" title="一、什么是中断"></a>一、什么是中断</h1><p>中断这个概念老生常谈了，学过单片机的都应该知道这个，也就是说，你在这打游戏，有一个电话过来了，你就得先停止手上的游戏，然后去处理一下那件事，这个就是中断。这里就不细说中断的概念了，毕竟和香橙派上的中断不太一样。</p>
<h1 id="二、普通单片机和系统单片机的区别"><a href="#二、普通单片机和系统单片机的区别" class="headerlink" title="二、普通单片机和系统单片机的区别"></a>二、普通单片机和系统单片机的区别</h1><p>这里要划分一下概念，我分为普通单片机和系统单片机两种，普通单片机就是指像51和stm32那种单核单片机，就是按照一定顺序执行的单片机，然后系统单片机就是指这种能在里面运行操作系统的单片机。</p>
<p>这两种类型的单片机有什么不同呢？</p>
<p>做过单片机开发的都知道，这种单片机只能单步执行，比如你写的这些程序，它只能一条一条的执行，没办法引出一些线程或者进程的概念，这种单片机的中断我们可以自己配置的，因为我们可以接触到底层环境来直接配置。</p>
<p>而这种系统单片机，因为有一层系统，所以底层的一些操作都被一层叫做<code>HAL</code>的抽象包给封装了，我们可以使用这个抽象包给的一些接口来对底层进行一些操作，而且这种单片机的芯片都是比较强的，可以支持像什么线程和进程的操作。</p>
<h1 id="三、中断的区别"><a href="#三、中断的区别" class="headerlink" title="三、中断的区别"></a>三、中断的区别</h1><p>在普通单片机中，我们设置好中断后，满足了中断的条件了，它就会打断它现在正在执行的操作，转向到中断处理函数中去执行中断，就如同这张图一样</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220182909889-2141115484.png" alt="img"></p>
<p>就如图一样，每次执行中断的时候就会打断当前执行的内容。</p>
<p>而在系统单片机中就不一样了，因为系统单片机中它是可以支持多线程和多进程的，所以就可以不用打断当前的系统执行，而是分裂出一个进程或者线程来处理这个中断请求，就如下面这张图</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220183519029-1979238536.png" alt="img"></p>
<p>可以看到这种就是这个过程不会影响着我们现在执行的程序，而我们的香橙派就是用到这种方式的中断。</p>
<h1 id="四、配置香橙派的中断"><a href="#四、配置香橙派的中断" class="headerlink" title="四、配置香橙派的中断"></a>四、配置香橙派的中断</h1><h2 id="1-进程版"><a href="#1-进程版" class="headerlink" title="1.进程版"></a>1.进程版</h2><p>我们配置香橙派的中断其实就可以不用像配置stm32的那种一样复杂了，直接分裂一个线程一直判断是否按下或者是其他内容即可实现这个过程。</p>
<p>比如在stm32中我们要一个按键按下了后就会执行中断处理函数实现一些内容，这里我们就可以使用一个进程一直去读取这个按键的引脚，当按键按下了，我们就让标志位置为1或者0，然后父进程就读取这个标志位，点亮一个LED灯。</p>
<p>代码就可以这么写：</p>
<p>1.先将引脚进行初始化，这里使用的是<code>PC10</code>作为输入引脚，<code>PC7</code>作为输出引脚，然后进行配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();      <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);   <span class="comment">// PC10输入</span></span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);  <span class="comment">// PC7作为输入</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);    <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.设置完成后就开始创建进程和匿名通道。这里因为要实现进程之间的数据交换，所以使用了一个匿名通道进行信息交换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;       <span class="comment">// 接收返回值</span></span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];     <span class="comment">// 管道描述符</span></span><br><span class="line">    <span class="type">int</span> pid;       <span class="comment">// 进程ID</span></span><br><span class="line">    wiringPiSetup();      <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);   <span class="comment">// PC10输入</span></span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);  <span class="comment">// PC7作为输入</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);    <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="comment">// 创建匿名管道</span></span><br><span class="line">    ret = pipe(pd);      <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;     <span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    pid = fort();    <span class="comment">// 创建进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);      <span class="comment">// 关闭管道读</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);      <span class="comment">// 关闭管道写</span></span><br><span class="line">        perror(<span class="string">&quot;fort&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程处理</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.在子进程中写入判断函数并将标志位发送到父进程中，并让LED灯亮起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;       <span class="comment">// 接收返回值</span></span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];     <span class="comment">// 管道描述符</span></span><br><span class="line">    <span class="type">int</span> pid;       <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;  <span class="comment">// 标志位</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];   <span class="comment">// 发送的字符串</span></span><br><span class="line">    wiringPiSetup();      <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);   <span class="comment">// PC10输入</span></span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);  <span class="comment">// PC7作为输入</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);    <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="comment">// 创建匿名管道</span></span><br><span class="line">    ret = pipe(pd);      <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;     <span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    pid = fort();    <span class="comment">// 创建进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);      <span class="comment">// 关闭管道读</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);      <span class="comment">// 关闭管道写</span></span><br><span class="line">        perror(<span class="string">&quot;fort&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程处理</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);     <span class="comment">// 关闭读端，因为子进程只需要写入数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 按键按下</span></span><br><span class="line">                delay(<span class="number">20</span>);</span><br><span class="line">                <span class="keyword">while</span>(digitalRead(<span class="number">16</span>) == <span class="number">0</span>);   <span class="comment">// 消抖</span></span><br><span class="line">                flag = !flag;</span><br><span class="line">                <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d&quot;</span>, flag); <span class="comment">// 拼接发送的字符串</span></span><br><span class="line">                write(pd[<span class="number">1</span>], buf, <span class="number">2</span>);     <span class="comment">// 向管道写入数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程处理</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);     <span class="comment">// 关闭写端，因为只用读取内容</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            read(pd[<span class="number">0</span>], buf, <span class="number">2</span>);   <span class="comment">// 读取数据</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;1&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 高电平</span></span><br><span class="line">                digitalWrite(<span class="number">13</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 低电平</span></span><br><span class="line">                digitalWrite(<span class="number">13</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以执行一下查看一下效果了：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220192448068-2133076134.jpg" alt="img"></p>
<p>然后再按下按钮</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220192511244-251167665.jpg" alt="img"></p>
<p>为了让大家看得更清楚这个过程我特意添加了一下输出语句来给大家查看一下效果</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220192554739-1728047936.png" alt="img"></p>
<p>这种方法就和中断一样，系统的主执行内容不会被影响，毕竟是有另一个进程在读取按键的按下和松开。</p>
<h2 id="2-wiringPi库函数版"><a href="#2-wiringPi库函数版" class="headerlink" title="2.wiringPi库函数版"></a>2.wiringPi库函数版</h2><p>这种方法是使用<code>wiringPi</code>中的函数来进行实现的，但是我这一直都搞不了，我还在研究这个方法，为了弄这个我今天买了块3b来进行测试，我看看是不是因为zero的不支持还是什么原因，这里后面再补全，先介绍一下这个方法的代码如何写，这里使用的函数是<code>wiringPiISR</code>，函数的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wiringPiISR</span> <span class="params">(<span class="type">int</span> pin, <span class="type">int</span> mode, <span class="type">void</span> (*function)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>功能：该函数会在指定管脚注册一个中断事件的函数，当指定管脚发生中断事件时，会自动调用该函数。</p>
<p>第一个参数是你要让哪个引脚注册位中断，比如说<code>PC7</code>，那这就填写13。</p>
<p>第二个参数是触发模式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>INT_EDGE_FALLING</td>
<td>下降沿触发</td>
</tr>
<tr>
<td>INT_EDGE_RISING</td>
<td>上升沿触发</td>
</tr>
<tr>
<td>INT_EDGE_BOTH</td>
<td>上升沿或下降沿触发</td>
</tr>
<tr>
<td>INT_EDGE_SETUP</td>
<td>不初始化</td>
</tr>
</tbody></table>
<p>当使用最后的一种方法时，这个函数不会初始化这个引脚，它会默认是在其他敌法进行了初始化。</p>
<p>第三个参数是中断函数，就是当注册的引脚触发了就会触发这个函数进行执行。</p>
<p>返回值如果不成功就会返回一个小于0的数，可以用这个返回值来判断一下初始化是否成功。</p>
<p>知道了这个我们就可以利用这个函数来实现中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myinterrinput</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 中断处理函数</span></span><br><span class="line">    flag = !flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);</span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);</span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);    <span class="comment">// 上拉输入</span></span><br><span class="line">    wiringPiISR(<span class="number">16</span>, INT_EDGE_FALLING, &amp;myinterrinput);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        digitalWrite(<span class="number">13</span>, flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后，当按键按下后就会执行中断函数，但是我这一执行后就会出现下面的问题</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220194408929-87332833.png" alt="img"></p>
<p>这个问题我还在研究到底是为什么，网上也没找到合适的答案，这里我先空着，等3b到了我再试试。</p>
<h2 id="3-线程版"><a href="#3-线程版" class="headerlink" title="3.线程版"></a>3.线程版</h2><p>这个版本就可以分为Linux内核线程和wiringPi库函数版的线程了。</p>
<p>这里先使用Linux内核的线程</p>
<h3 id="3-1-Linux内核的线程"><a href="#3-1-Linux内核的线程" class="headerlink" title="3.1 Linux内核的线程"></a>3.1 Linux内核的线程</h3><p>其实这个也不能称为Linux内核线程，因为之前的linux最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调用度的实体。然后就将线程进行了改写，由NPTL进行接手，我们现在用的线程是NPTL。</p>
<p>我们可以通过下面的指令来下载NPTL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install manpages-posix-posix-dev</span><br></pre></td></tr></table></figure>

<p>通过下面的指令来查看一下NPTL的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getconf GNU_LIBPTHREAD_VERSION</span><br></pre></td></tr></table></figure>

<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220201337192-1530467255.png" alt="img"></p>
<p>我这里的版本是<code>2.35</code>，只要有这个即可。</p>
<p>这里不过多介绍线程的概念，如果大家对线程感兴趣我后面会出有关于线程的文章给大家介绍一下的。</p>
<p>现在开始编程</p>
<p>1.初始化需要的引脚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();      <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);   <span class="comment">// PC10输入</span></span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);  <span class="comment">// PC7作为输入</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);    <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建管道和线程，这里线程之间的内容是独立的，和上面的进程一样，需要我们创建一个管道来实现进程间的通讯，所以需要创建一个管道。</p>
<p>在写之前，我们需要了解一下线程的创建函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthred_create</span><span class="params">(<span class="type">pthread_t</span>* thread, <span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* (*start_routine)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个线程</span><br><span class="line">参数：</span><br><span class="line">    thread：线程标识符地址。</span><br><span class="line">    attr：线程属性结构体地址，通常设置为<span class="literal">NULL</span>。</span><br><span class="line">    start_routine：线程函数的入口地址。</span><br><span class="line">    arg：传入线程函数的参数。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>然后就可以开始写代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">myinterrinput</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="comment">// 进程执行函数</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">pthread_t</span> tid;       <span class="comment">// 线程标识符</span></span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    wiringPiSetup();     <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);</span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);</span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    ret = pipe(pd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;myinterrinput, (<span class="type">void</span>*)&amp;pd[<span class="number">1</span>]);       <span class="comment">// 创建进程的函数 这里将管道的描述符传递给线程处理函数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        close(pd[<span class="number">0</span>]);      <span class="comment">// 关闭管道读</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);      <span class="comment">// 关闭管道写</span></span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 主进程处理一些非中断的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.然后开始完善处理代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">myinterrinput</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(digitalRead(<span class="number">16</span>) == <span class="number">0</span>);</span><br><span class="line">            flag = !flag;</span><br><span class="line">            <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d&quot;</span>, flag);</span><br><span class="line">            <span class="comment">// 下面的代码需要注意一下，非常重要，用了两次强转，因为传递过来的参数是void类型的，长度不够，所以这里使用了两次强转将长度匹配到4</span></span><br><span class="line">            <span class="keyword">if</span> (write(*(<span class="type">int</span>*)(<span class="type">long</span>*)arg, buf, <span class="number">2</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">pthread_t</span> tid;       <span class="comment">// 线程标识符</span></span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    wiringPiSetup();     <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);</span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);</span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    ret = pipe(pd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;myinterrinput, (<span class="type">void</span>*)&amp;pd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        close(pd[<span class="number">0</span>]);      <span class="comment">// 关闭管道读</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);      <span class="comment">// 关闭管道写</span></span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        read(pd[<span class="number">0</span>], buf, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;1&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            digitalWrite(<span class="number">13</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf, <span class="string">&quot;0&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            digitalWrite(<span class="number">13</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后开始编译，这里编译的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc threadButton.c -o threadButton -lwiringPi -lpthread</span><br></pre></td></tr></table></figure>

<p>因为<code>pthread</code>是属于外部库，需要使用<code>-l</code>进行连接。</p>
<p>运行后也是一样的效果，我就懒得拍照了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>中断其实很有用的，但是对于这种多线程的开发板可以用一些其他的方式来实现这个方法，比如软中断，后面我研究一下如何通过底层实现外中断，毕竟上面的这些方法消耗的资源有点大，而且反应比直接中断要慢。</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-使用蓝牙和手机进行信息的交换</title>
    <url>/2025/01/17/feaf0486f5af/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>隔了这么久我准备再玩一下香橙派，最近这段时间还是比较的忙，我搭建了个论坛和博客，经常被网络攻击，所以我也是一直在弄网络去了，然后今天比较空闲就想着把单子做一下，这个单子需要使用到HC05蓝牙模块，所以我准备写一篇博客来使用香橙派控制HC05蓝牙模块。</p>
<h1 id="一、HC05蓝牙模块"><a href="#一、HC05蓝牙模块" class="headerlink" title="一、HC05蓝牙模块"></a>一、HC05蓝牙模块</h1><p>这个模块是非常经典的一个蓝牙模块，我之前有一单也是使用到这个模块，可以看一下我的这个视频<a href="https://www.bilibili.com/video/BV1PH4y117oV/?share_source=copy_web&vd_source=4bb508bdc624514980a5500e28ea3819">【作息控制系统使用说明】</a>，这个项目也是使用到蓝牙模块的，只不过当时时间紧任务重所以就没有写一篇博客来好好记录一下这个项目，等后面我会单独拿一个模块来介绍一下我做的这些小项目。</p>
<h2 id="1-HC05概述"><a href="#1-HC05概述" class="headerlink" title="1.HC05概述"></a>1.HC05概述</h2><p>HC05是嵌入式蓝牙串口通讯模块，也就是使用串口就可以和HC05进行通讯并发送信息给蓝牙的接收端，这个模块有两种工作方式：</p>
<p>1 命令响应工作模式</p>
<p>2 自动连接工作模式</p>
<p>在自动连接的工作模式下又可以分为主、从、回环这三种模式，当传输数据时，根据事先设定的方式连接并传输数据。</p>
<p>在命令模式下，用户可以使用串口连接模块，并发送<code>AT</code>指令对模块进行设置。</p>
<h2 id="2-HC05的连接图"><a href="#2-HC05的连接图" class="headerlink" title="2.HC05的连接图"></a>2.HC05的连接图</h2><p>这里我直接使用<code>TTL to USB</code>进行连接，因为我要设置一下这个模块的一些传输和内容。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131222614043-381623405.jpg" alt="img"></p>
<p>这里和串口连接的模式一样</p>
<table>
<thead>
<tr>
<th>HC05</th>
<th>TTL</th>
</tr>
</thead>
<tbody><tr>
<td>3.3</td>
<td>VCC</td>
</tr>
<tr>
<td>TXD</td>
<td>RXD</td>
</tr>
<tr>
<td>RXD</td>
<td>TXD</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
</tbody></table>
<h2 id="3-进入HC05的命令模式"><a href="#3-进入HC05的命令模式" class="headerlink" title="3.进入HC05的命令模式"></a>3.进入HC05的命令模式</h2><p>首先我们需要通过<code>AT</code>指令来设置模块的一些内容，然后我们才好进入下面的一些操作，首先在这个模块上有一个按钮</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131222952266-1526676184.jpg" alt="img"></p>
<p>在上电之前需要长按这个按键，然后再上电就可以进入命令模式，在进入命令模式后，模块上的LED等会缓慢的闪烁，如果没有进入就会闪得很快。</p>
<h2 id="4-常用的AT指令"><a href="#4-常用的AT指令" class="headerlink" title="4.常用的AT指令"></a>4.常用的AT指令</h2><p>AT指令列表已经烂大街了，所以这里不全部说明，我只拿出一些常用的来说明即可。</p>
<h3 id="4-1-检查AT是否上线"><a href="#4-1-检查AT是否上线" class="headerlink" title="4.1 检查AT是否上线"></a>4.1 检查AT是否上线</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT\r\n</span><br></pre></td></tr></table></figure>

<p>如果模块在就会返回<code>OK</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131223407901-1242056721.png" alt="img"></p>
<h3 id="4-2-重启模块"><a href="#4-2-重启模块" class="headerlink" title="4.2 重启模块"></a>4.2 重启模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+RESET\r\n</span><br></pre></td></tr></table></figure>

<p>如果执行成功就会返回<code>OK</code>，并进入自动连接模式</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131223545021-2054088621.png" alt="img"></p>
<h3 id="4-3-获取软件版本号"><a href="#4-3-获取软件版本号" class="headerlink" title="4.3 获取软件版本号"></a>4.3 获取软件版本号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT_VERSION?\r\n</span><br></pre></td></tr></table></figure>

<p>执行完成后会返回版本信息和<code>OK</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131223713062-1270983779.png" alt="img"></p>
<h3 id="4-4-恢复默认状态"><a href="#4-4-恢复默认状态" class="headerlink" title="4.4 恢复默认状态"></a>4.4 恢复默认状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+ORGL\r\n</span><br></pre></td></tr></table></figure>

<p>执行完成后会返回<code>OK</code>，并将模块恢复为出厂设置。</p>
<h3 id="4-5-获取蓝牙的名称"><a href="#4-5-获取蓝牙的名称" class="headerlink" title="4.5 获取蓝牙的名称"></a>4.5 获取蓝牙的名称</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+NAME?\r\n</span><br></pre></td></tr></table></figure>

<p>执行完成后会返回蓝牙名称并返回<code>OK</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131224015613-183098500.png" alt="img"></p>
<h3 id="4-6-设置蓝牙模块的波特率"><a href="#4-6-设置蓝牙模块的波特率" class="headerlink" title="4.6 设置蓝牙模块的波特率"></a>4.6 设置蓝牙模块的波特率</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+UART=波特率,停止位,校验位\r\n</span><br></pre></td></tr></table></figure>

<p>这里我们设置一个比较常见的，波特率9600，停止位1位，无校验位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+UART=9600,1,0</span><br></pre></td></tr></table></figure>

<p>这样就可以了。</p>
<h3 id="4-7-查询蓝牙的连接模式"><a href="#4-7-查询蓝牙的连接模式" class="headerlink" title="4.7 查询蓝牙的连接模式"></a>4.7 查询蓝牙的连接模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+CMODE?\r\n</span><br></pre></td></tr></table></figure>

<p>返回当前模式，1代表任意模式，也就是蓝牙名称和蓝牙地址都可以连接，这里就不多说了，一般默认是1就可以了。</p>
<h3 id="4-8-查询模块角色"><a href="#4-8-查询模块角色" class="headerlink" title="4.8 查询模块角色"></a>4.8 查询模块角色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+ROLE?</span><br></pre></td></tr></table></figure>

<p>这里默认的是<code>Slave</code>从角色，也就是被动连接，不用动。</p>
<h2 id="5-连接电脑"><a href="#5-连接电脑" class="headerlink" title="5.连接电脑"></a>5.连接电脑</h2><p>这里我踩了个大坑，因为我之前的设置是将波特率改为9600了，所以在串口的时候我就用9600进行连接，结果没有任何的反应，后面查了一下手册才发现它默认的波特率是<code>38400</code>，就很尴尬。</p>
<p>这里连接好电脑后先发送个<code>AT</code>指令来查看一下是否返回OK，如果没返回有可能是因为坏了或者是你没长按按键进入命令模式。</p>
<p>然后修改一下波特率，因为我们后面初始化串口不想给那么大的波特率</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131225350954-637982947.png" alt="img"></p>
<p>初始化完成后要记得重启一下模块，然后模块的波特率就设置好看，但是AT指令模式下还是那个波特率（又踩坑了，当不想改文章）。</p>
<h2 id="6-通过HC05发送消息"><a href="#6-通过HC05发送消息" class="headerlink" title="6.通过HC05发送消息"></a>6.通过HC05发送消息</h2><p>这里我先用stm32来演示，因为我还在做单子所以先拿这个演示。</p>
<p>首先先写串口的初始化函数，这里我使用的是<code>USART1</code>，初始化代码就不展示了，因为今天的主题不是stm32，然后在main函数中我们使用重写的<code>printf</code>来通过串口发送数据。不知道的可以看我这篇博客<a href="https://www.cnblogs.com/Lavender-edgar/p/17591746.html">异步通讯点灯</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    OLED_Init();</span><br><span class="line">    MX_Init_KEY();</span><br><span class="line">    MX_Init_HC05();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\r\n&quot;</span>);</span><br><span class="line">        OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要在手机上下载<code>蓝牙调试宝</code>，在应用商城都可以下载，这我就不给你们压缩包了，要不然我老喜欢挂码。</p>
<p>首先要把蓝牙模块连接到面包板上，然后就用手机连接好蓝牙</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131232923132-1431987147.jpg" alt="img"></p>
<p>记住串口反接并且要接地即可。</p>
<p>然后打开蓝牙助手的界面</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131233636527-494670284.jpg" alt="img"></p>
<p>找到里面有一个<code>HC-05</code>，然后连接即可，第一次连接需要你输入一个配对码，这里输入1234或者0000都可以</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131233741588-579644404.jpg" alt="img"></p>
<p>然后给单片机上电后就会显示出hello来</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131233820799-2037271568.jpg" alt="img"></p>
<p>学到这你已经会使用蓝牙进行发送信息了，stm32就先不再出现了，后面就是香橙派的内容了。</p>
<h2 id="7-stm32完整代码"><a href="#7-stm32完整代码" class="headerlink" title="7.stm32完整代码"></a>7.stm32完整代码</h2><p>usart.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hc05.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_Init_HC05</span><span class="params">()</span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    USART_InitTypeDef USART_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">    </span><br><span class="line">    USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">    USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">    USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class="line">    USART_InitStruct.USART_Parity = USART_Parity_No;</span><br><span class="line">    USART_InitStruct.USART_StopBits = USART_StopBits_1;</span><br><span class="line">    USART_InitStruct.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">    USART_Init(USART1, &amp;USART_InitStruct);</span><br><span class="line">    USART_Cmd(USART1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;      </span><br><span class="line">	<span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);  </span><br><span class="line">    USART1-&gt;DR = (u8) ch;      </span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、香橙派串口通讯"><a href="#二、香橙派串口通讯" class="headerlink" title="二、香橙派串口通讯"></a>二、香橙派串口通讯</h1><p>在介绍使用香橙派使用HC05模块前先介绍一下串口通讯，并如何配置串口通讯。</p>
<h2 id="1-打开串口设备"><a href="#1-打开串口设备" class="headerlink" title="1.打开串口设备"></a>1.打开串口设备</h2><p>在香橙派中，串口通讯是使用设备来进行传输的， 所以我们需要在系统设置中将串口进行打开。</p>
<p>在打开之前先了解一下香橙派的串口引脚分布</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201004955316-115234185.png" alt="img"></p>
<p>在3b中有3个串口可供选择，然后通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo orangepi-config</span><br></pre></td></tr></table></figure>

<p>来开启设备，进入到设置页面</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201005302098-113983016.png" alt="img"></p>
<p>然后选择第一个，按一下回车即可，然后在下面的页面中选择<code>Hardware</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201005337757-1243728913.png" alt="img"></p>
<p>然后找到你要开启的串口</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201005401317-2122540859.png" alt="img"></p>
<p>我这选择的是<code>UART7</code>，使用方向键移动到那后按一下空格就选中，然后按一下回车保存，之后会提示是否重启，然后按一下回车就可以重启了。</p>
<p>重启完成后使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /dev/ ttyS*</span><br></pre></td></tr></table></figure>

<p>来查看可操作的设备文件，这里只会显示你开启的设备</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201005541612-792900492.png" alt="img"></p>
<p>我们刚才选择了<code>UART7</code>后它这里就会有相应的设备，那个<code>ttyS1</code>是默认开启的，我们不用理他。</p>
<h2 id="2-接线"><a href="#2-接线" class="headerlink" title="2.接线"></a>2.接线</h2><p>这里就需要非常非常注意了，我在测试的时候就是这里没有弄好，线接反了，导致一直发送不了。</p>
<p>按照前面给的那张图进行接线后我们就可以写代码了。</p>
<p><strong>注意：这里很重要，很多人玩51单片机来玩这个会忽略一个问题就是GND必须要和单片机的GND接在一起，很多人会单独给这个引脚接GND是错误的。</strong></p>
<h2 id="3-串口函数"><a href="#3-串口函数" class="headerlink" title="3.串口函数"></a>3.串口函数</h2><p>这里使用的串口函数库是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-打开串口文件"><a href="#3-1-打开串口文件" class="headerlink" title="3.1 打开串口文件"></a>3.1 打开串口文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serialOpen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">int</span> butrl)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是设备的路径，比如说我们这需要使用到<code>UART1</code>，那设备地址就是<code>/dev/ttyS7</code>。</p>
<p>第二个参数是波特率，比如9600。</p>
<p>这个函数的返回值是一个文件描述符，我们使用一个变量来接收就可以了。</p>
<h3 id="3-2-关闭串口文件"><a href="#3-2-关闭串口文件" class="headerlink" title="3.2 关闭串口文件"></a>3.2 关闭串口文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serialClose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>参数是打开的设备描述符。</p>
<h3 id="3-3-发送一个字符"><a href="#3-3-发送一个字符" class="headerlink" title="3.3 发送一个字符"></a>3.3 发送一个字符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serialPutchar</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> c)</span>;</span><br></pre></td></tr></table></figure>

<p>将一个字符发送到打开的文件描述符fd所对应的设备文件。</p>
<h3 id="3-4-发送一个规定好的字符串"><a href="#3-4-发送一个规定好的字符串" class="headerlink" title="3.4 发送一个规定好的字符串"></a>3.4 发送一个规定好的字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serialPuts</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* s)</span>;</span><br></pre></td></tr></table></figure>

<p>发送一个规定好的字符串，然后以0结尾。</p>
<h3 id="3-5-printf"><a href="#3-5-printf" class="headerlink" title="3.5 printf"></a>3.5 printf</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serialPrintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* message, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>这个和printf的用法类似。</p>
<h3 id="3-6-返回等待读取的字符数"><a href="#3-6-返回等待读取的字符数" class="headerlink" title="3.6 返回等待读取的字符数"></a>3.6 返回等待读取的字符数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serialDataAvail</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>返回的是等待读取的字符数。</p>
<h3 id="3-7-读取字符"><a href="#3-7-读取字符" class="headerlink" title="3.7 读取字符"></a>3.7 读取字符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serialGetChar</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>返回下一个待读取的字符，如果这个在10s内没有读取到字符就会返回-1。</p>
<h3 id="3-8-缓冲区函数"><a href="#3-8-缓冲区函数" class="headerlink" title="3.8 缓冲区函数"></a>3.8 缓冲区函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serialFlush</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>抛弃所有接收的数据或者等待写入设备完成。</p>
<h2 id="4-输出内容"><a href="#4-输出内容" class="headerlink" title="4.输出内容"></a>4.输出内容</h2><p>通过学习了上面的内容后我们可以简单写一个输出字符的代码来输出0~9</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>, i;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);    <span class="comment">// 设置串口设备和波特率</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 设备打开失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设备打开失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serialFlush(fd);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        serialPutchar(fd, i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    serialClose(fd);     <span class="comment">// 关闭设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201011437761-796252053.png" alt="img"></p>
<p>然后也可以使用printf来个高级一点的输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>, i;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);    <span class="comment">// 设置串口设备和波特率</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 设备打开失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设备打开失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serialFlush(fd);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        serialPrintf(fd, <span class="string">&quot;this is%d\r\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    serialClose(fd);     <span class="comment">// 关闭设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的内容如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201011632150-2099482164.png" alt="img"></p>
<h2 id="5-接收内容"><a href="#5-接收内容" class="headerlink" title="5.接收内容"></a>5.接收内容</h2><p>我们可以通过串口来接收一下用户输入的内容，并判断输入的字符是不是我们需要的，然后通过串口返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>, i;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);    <span class="comment">// 设置串口设备和波特率</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 设备打开失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设备打开失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serialFlush(fd);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        c = serialGetchar(fd);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            serialPrintf(fd, <span class="string">&quot;this is 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    serialClose(fd);     <span class="comment">// 关闭设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的内容：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201012139484-1871459667.png" alt="img"></p>
<p>这里大家可以看到我在这个while循环中添加了一个printf，但是没有截屏给出效果，是因为在这个串口运行的过程中一直在读取的是串口的设备，没有使用输入输出流设备，所以导致我们在输入后没办法显示出内容来，这个的解决办法我还不太清楚，等我研究好了我在出一篇文章来介绍。</p>
<h2 id="6-接收字符串"><a href="#6-接收字符串" class="headerlink" title="6.接收字符串"></a>6.接收字符串</h2><p>做串口最让人沉醉的就是读取字符串的操作了,在<code>wiringSerial</code>中有一个函数可以获取缓冲区的长度，我们可以判断这个来读取输入的数据的长度，然后使用一个<code>for</code>循环来循环读取和放置在一个数组中，之后进行输出即可，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i, ch, j = <span class="number">0</span>, len;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开设备文件失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        len = serialDataAvail(fd);     <span class="comment">// 获取缓冲区的长度</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 超时退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            serialPrintf(fd, <span class="string">&quot;%d\n&quot;</span>, len);    <span class="comment">// 这一行是测试的</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len;  i++)&#123;</span><br><span class="line">                ch = serialGetchar(fd);       <span class="comment">// 读取字符</span></span><br><span class="line">                str[j++] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    str[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    serialClose(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、使用hc05连接香橙派"><a href="#三、使用hc05连接香橙派" class="headerlink" title="三、使用hc05连接香橙派"></a>三、使用hc05连接香橙派</h1><p>学会了上面的操作后我们就可以来用香橙派连接hc05了，这个操作也非常非常的简单，和单片机的连接一致，注意不要连错就行了。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201222725359-170013347.jpg" alt="img"></p>
<h2 id="1-通过蓝牙发送字符串给手机"><a href="#1-通过蓝牙发送字符串给手机" class="headerlink" title="1.通过蓝牙发送字符串给手机"></a>1.通过蓝牙发送字符串给手机</h2><p>本质的思路还是一样的，就是使用串口是输入输出就可以搞定，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>, i;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);    <span class="comment">// 设置串口设备和波特率</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 设备打开失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设备打开失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serialFlush(fd);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        serialPrintf(fd, <span class="string">&quot;hello\r\n&quot;</span>);</span><br><span class="line">        delayMicroseconds(<span class="number">30000</span>);     <span class="comment">// 延时函数，免得发送得过快</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    serialClose(fd);     <span class="comment">// 关闭设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在调试助手中就可以看到蓝牙模块发送的内容了：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201222924734-1412345816.jpg" alt="img"></p>
<h2 id="2-手机发送内容给香橙派"><a href="#2-手机发送内容给香橙派" class="headerlink" title="2.手机发送内容给香橙派"></a>2.手机发送内容给香橙派</h2><p>这里可以使用刚才我们测试的接收字符串，只不过这里有一个问题就是这个工具只能发送字符所对应的ascii码，不能正常的输入字符进行输出。</p>
<p>比如我们手机输入字符0，那就得输入ascii码的30</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201223956644-1830750314.jpg" alt="img"></p>
<p>然后在香橙派中就会显示：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201224021569-740821848.png" alt="img"></p>
<p>然后我们还可以用这个来输入0~9</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201224151378-596771392.jpg" alt="img"></p>
<p>然后显示</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201224204795-1231226835.png" alt="img"></p>
<p>学会了这个后我们就可以编写一个用蓝牙点灯的程序了，其实就是使用蓝牙接收到关键字后给LED灯高低电平，这里就直接给代码了，不展示图片了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i, ch, j = <span class="number">0</span>, len;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开设备文件失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        len = serialDataAvail(fd);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            serialPrintf(fd, <span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len;  i++)&#123;</span><br><span class="line">                ch = serialGetchar(fd);</span><br><span class="line">                str[j++] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    str[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str, <span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// 点灯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 灭灯</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serialClose(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>串口很好玩，蓝牙模块也好玩，学会了这一节我们就可以使用蓝牙做一个简单的远程开关灯的项目了，当然拿香橙派做这个项目就很浪费，毕竟香橙派可以直接使用网络来实现，做一个网页，然后内网穿透，这样可以很容易的在远程进行控制了，等我最近忙完有时间我做一个。</p>
<p>大家可以关注一下我的论坛和博客，有不懂的或者有趣的问题可以放在我的论坛中进行提问</p>
<p><a href="https://bbs.lavenderedgar.asia/">马桶论坛</a></p>
<p><a href="https://blog.lavenderedgar.asia/">马桶博客</a></p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-使用wiringPi控制26个引脚</title>
    <url>/2025/01/17/833700e426b2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不管是对什么开发板来说，开发需要使用到一些包，像stm32就需要用到一些包，香橙派也是一样的，也是需要使用到一些软件包才能进行开发。</p>
<h1 id="一、香橙派使用的包"><a href="#一、香橙派使用的包" class="headerlink" title="一、香橙派使用的包"></a>一、香橙派使用的包</h1><p>香橙派这里使用的包是<code>wiringOP</code>，这个包有python版，所以用python进行开发要方便一点，但是呢，毕竟我是学嵌入式的，开发单片机都是使用C语言，让我使用python确实不太好，所以我昨天就研究了一下，在<code>/usr/src/</code>目录下有两个<code>wiringOP</code>文件夹</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203135514360-197611242.png" alt="img"></p>
<p>这有一个<code>wiringOP</code>和一个<code>wiringOP-Python</code>，有一个是C语言的，有一个是Python的，这里我看了一下<code>wiringOP</code>下的文件，发现它是由<code>wiringPi</code>这个包进行改写的，但是还是可以使用<code>wiringPi</code>中的函数进行开发</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203135740924-939769433.png" alt="img"></p>
<p>知道了这个就可以开始开发了，所以我花了点时间对<code>wiringPi</code>中的函数进行了一下学习，随便写了这篇文章。</p>
<h1 id="二、使用wiringPi包的命令"><a href="#二、使用wiringPi包的命令" class="headerlink" title="二、使用wiringPi包的命令"></a>二、使用<code>wiringPi</code>包的命令</h1><p>学过树莓派的应该对这个包比较熟悉，没有学过的就跟着我一起来学习吧。</p>
<p>首先使用得先获得这个包，如果你是在香橙派官网中下载的<code>ubuntu</code>或者是其他系统的话，这个包是会在里面的，所以可以不用下载。如果你不是从官网上下载的，需要下载一下这个包。</p>
<h2 id="1-下载wiringOP"><a href="#1-下载wiringOP" class="headerlink" title="1.下载wiringOP"></a>1.下载<code>wiringOP</code></h2><p>首先需要更新一下软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>然后下载一下<code>git</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install -y git</span><br></pre></td></tr></table></figure>

<p>下载完成后就可以用<code>git</code>从<code>github</code>上拉取<code>wiringOP</code>软件包了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone  https://github.com/orangepi-xunlong/wiringOP.git -b next</span><br></pre></td></tr></table></figure>

<p>然后编译一下这个软件包，先到<code>wiringOP</code>这个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd wiringOP</span><br></pre></td></tr></table></figure>

<p>然后编译一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./build clean</span><br></pre></td></tr></table></figure>

<p>然后运行进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./build</span><br></pre></td></tr></table></figure>

<p>安装好后检查一下这个包是否安装成功，这里使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpio readall</span><br></pre></td></tr></table></figure>

<p>进行查看，如果出现下面的界面就证明安装成功了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203140724436-1605733595.png" alt="img"></p>
<p>这个界面是可以查看你这个香橙派所对应的引脚和状态的界面。</p>
<h2 id="2-gpio-readall信息分析"><a href="#2-gpio-readall信息分析" class="headerlink" title="2.gpio readall信息分析"></a>2.<code>gpio readall</code>信息分析</h2><p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203140724436-1605733595.png" alt="img"></p>
<p>这里可以看到有很多信息，首先就是芯片的型号<code>H616</code>，然后表格里面有<code>GPIO</code>、<code>wPi</code>、<code>Name</code>、<code>Mode</code>、<code>V</code>、<code>Physical</code>。下面我那个表给大家说明一下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GPIO</td>
<td>引脚在寄存器中的地址</td>
</tr>
<tr>
<td>wPi</td>
<td>在<code>wiringPi</code>中所对应的值</td>
</tr>
<tr>
<td>Name</td>
<td>引脚的名称</td>
</tr>
<tr>
<td>Mode</td>
<td>引脚的状态</td>
</tr>
<tr>
<td>V</td>
<td>改引脚的电平值</td>
</tr>
<tr>
<td>Physical</td>
<td>引脚的位置</td>
</tr>
</tbody></table>
<p>这里的<code>wPi</code>是在后面会经常使用的一个值，这个需要经常查看一下。</p>
<p><code>Mode</code>的状态可以看下面的表</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OFF</td>
<td>关闭</td>
</tr>
<tr>
<td>OUT</td>
<td>输出</td>
</tr>
<tr>
<td>IN</td>
<td>输入&#x2F;上拉输入&#x2F;下拉输入</td>
</tr>
</tbody></table>
<h2 id="3-设置gpio的模式"><a href="#3-设置gpio的模式" class="headerlink" title="3.设置gpio的模式"></a>3.设置<code>gpio</code>的模式</h2><p>学过32的应该知道，要对引脚操作首先需要打开时钟，然后配置引脚的模式，但是在香橙派中就不用这么麻烦，因为底层和用户层之间有一个<code>HAL</code>板件支持包，所以操作起来就非常的简单，只需要设置一下引脚模式即可，这里我设置一下<code>PC10</code>（因为这个引脚好插杜邦线），首先用命令的模式来进行设置。</p>
<p>这里先将<code>PC10</code>设置为输出模式<code>out</code>，首先找到<code>PC10</code>的<code>wPi</code>值，这里通过前面说的<code>gpio readall</code>就可以查找到，它的<code>wPi</code>值是16，就可以使用下面的命令来进行设置了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpio mode 16 out</span><br></pre></td></tr></table></figure>

<p>设置完成后可以用<code>gpio readall</code>查看一下状态</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203143901252-752924145.png" alt="img"></p>
<p>可以看到<code>PC10</code>的<code>mode</code>变成了<code>OUT</code>。</p>
<p>输出模式就是输出一些电平，比如说一开始电平<code>V</code>是0，那么变成了输出模式后这个引脚就会输出低电平。</p>
<h2 id="4-设置gpio输出的电平"><a href="#4-设置gpio输出的电平" class="headerlink" title="4.设置gpio输出的电平"></a>4.设置<code>gpio</code>输出的电平</h2><p>学过单片机的都知道，在单片机中输出的只有高电平和低电平，这个在程序中的表达是：1表示高电平，0表示低电平，所以我们可以通过程序来控制单片机引脚输出高电平和低电平。</p>
<p>控制操作也是比较简单，使用的是下面的指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpio write wPi 电平</span><br></pre></td></tr></table></figure>

<p><code>wPi</code>不用多说了，电平是0和1来表示，比如说我让刚才的<code>PC10</code>变成高电平，使用的命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpio write 16 1</span><br></pre></td></tr></table></figure>

<p>执行完成后就会让<code>PC10</code>变成高电平了，这里还是使用<code>gpio readall</code>来进行查看</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203144600467-596083947.png" alt="img"></p>
<p>可以看到这个引脚的电平变成了高电平，如果对这个概念还是不明白的话，我用面包板搭建一个简单的电路展示一下</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203144731250-545095097.jpg" alt="img"></p>
<p>这里我将LED的负极连接到<code>PC10</code>这个引脚上，然后正极连接到单片机上的3.3V位置，可以看到现在的LED没有亮，是因为<code>PC10</code>这个引脚是高电平，两端都是高电平是不会通的。</p>
<p>现在我将<code>PC10</code>改成低电平再来看看效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpio write 16 0</span><br></pre></td></tr></table></figure>

<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203143901252-752924145.png" alt="img"></p>
<p>效果如下</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203145056097-1083247880.jpg" alt="img"></p>
<p>可以看到这个已经亮了，这个就是改变引脚的电平的指令，并且讲一下电平的概念。</p>
<h1 id="三、wiringPi软件实现"><a href="#三、wiringPi软件实现" class="headerlink" title="三、wiringPi软件实现"></a>三、<code>wiringPi</code>软件实现</h1><p>前面讲的都是命令行的实现，但是咱不可能一直用命令来写一个复杂的功能，最重要的还是要落实在程序方面，所以现在来给大家介绍一下软件怎么写。</p>
<h2 id="1-初始化函数"><a href="#1-初始化函数" class="headerlink" title="1.初始化函数"></a>1.初始化函数</h2><p>首先在软件中需要初始化一下引脚，使用的函数是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">wiringPiSetup</span> <span class="params">(<span class="type">void</span>)</span> ;</span><br></pre></td></tr></table></figure>

<p>这个函数会初始化一下引脚，但是你调用这个函数的话，在执行的时候需要提升一下权限或者使用<code>root</code>才可以执行，当然这个初始化函数有一个替代的函数，这个替代的函数不需要提权</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wiringPiSetupSys</span> <span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>这个函数不是使用操作系统来进行初始化，而是使用<code>/sys/class/gpio</code>接口来进行初始化的，在此种模式下的管脚号是 Broadcom 的 GPIO 管脚号，这种方法我们不考虑。</p>
<p>我们首先用一下第一个函数来进行一下初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以进行一下初始化的操作，然后就可以进行后面的操作了。</p>
<h2 id="2-设置gpio的模式"><a href="#2-设置gpio的模式" class="headerlink" title="2.设置gpio的模式"></a>2.设置<code>gpio</code>的模式</h2><p>这里使用的是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pinMode</span> <span class="params">(<span class="type">int</span> pin, <span class="type">int</span> mode)</span></span><br></pre></td></tr></table></figure>

<p>这个函数需要配合上面说的<code>wiringPiSetup</code>函数进行初始化，否则使用不了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203151426419-193473249.png" alt="img"></p>
<p>第一个参数是<code>wPi</code>的值，第二个参数是设置的模式，可以有下面的几种模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OUTPUT</td>
<td>输出模式</td>
</tr>
<tr>
<td>INPUT</td>
<td>输入模式</td>
</tr>
<tr>
<td>PWM_OUTPUT</td>
<td>脉冲输出</td>
</tr>
<tr>
<td>GPIO_CLOCK</td>
<td>GPIO时钟</td>
</tr>
</tbody></table>
<p>这些模式都是用宏定义定义了的，直接写即可。</p>
<p>然后我们将<code>PC10</code>的模式设置为输出模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();  <span class="comment">// 记得初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, OUTPUT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以将<code>PC10</code>设置为输出模式了。</p>
<h2 id="3-输出电平"><a href="#3-输出电平" class="headerlink" title="3.输出电平"></a>3.输出电平</h2><p>然后我们就可以通过代码来输出电平了，这里我们可以按照32的写法，写一个死循环，但是毕竟这个是高级的单片机，所以我们就不写死循环了，毕竟你一个香橙派不止可以跑一个程序，所以这里直接写到循环外面。</p>
<p>使用的函数是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">digitalWrite</span> <span class="params">(<span class="type">int</span> pin, <span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure>

<p>这个函数的参数和上面的一样，只不过要说一下<code>value</code>，这个就是电平值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>高电平</td>
</tr>
<tr>
<td>0</td>
<td>低电平</td>
</tr>
</tbody></table>
<p>然后添加进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();  <span class="comment">// 记得初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, OUTPUT);</span><br><span class="line">    digitalWrite(<span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完后我们就可以执行一下这个代码了。</p>
<h2 id="4-执行代码"><a href="#4-执行代码" class="headerlink" title="4.执行代码"></a>4.执行代码</h2><p>这里执行代码需要先进行一下编译，编译使用<code>gcc</code>这个工具，没有这个工具的可以下载一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure>

<p>然后就可以开始编译了，这里不写<code>Makefile</code>文件，直接用命令进行编译，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o 编译出来的文件名 需要编译的文件.c -lwiringPi</span><br></pre></td></tr></table></figure>

<p>这里如果不写<code>-o</code>和<code>编译出来的文件名</code>，编译出来的可执行文件是<code>a.out</code>。</p>
<p>需要注意一下，最后的<code>-lwiringPi</code>是必须要加上的，如果不加上就会出现下面的问题</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203152809718-1765650140.png" alt="img"></p>
<p>这个就像你用<code>pthread</code>线程一样，在编译的时候不加<code>-pthread</code>，所以需要加上。</p>
<p>编译完成后如果没有出问题就可以用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure>

<p>来执行了。</p>
<p>如果你用<code>-o</code>来规定了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203153117748-1504941427.png" alt="img"></p>
<p>可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./别名</span><br></pre></td></tr></table></figure>

<p>来运行，我这是<code>openLED</code>，所以是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./openLED</span><br></pre></td></tr></table></figure>

<p>执行了LED灯就会亮了。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>学会了如何操作<code>gpio</code>后就可以控制一些传感器或者元器件了，所以先得把<code>gpio</code>的操作学好就可以控制一些复杂的东西了，后面香橙派还有很多功能我还没有研究完成，等需要用到什么就使用什么即可。</p>
<p>下一章我会介绍一下输入模式，毕竟在读传感器的时候不能只输出，还得输入呢</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-无屏幕使用香橙派</title>
    <url>/2025/01/17/27a3b7954e84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学单片机之前我就接触到树莓派这个掌间电脑，之前买了一块但是一直放在家里面吃灰，然后这几天突然感觉树莓派很好玩，准备买一块来玩一下，但是树莓派的价格实在是太高了，我还只是个学生没那么多钱，然后呢我在网上找到了一个平替的板子就是这个系列的主题–香橙派，我买了个比较便宜的<code>orange-zero-3</code>，内存是1.5G的，因为我只拿来做Linux的练习不用图形化界面，所以不需要太大的运行内存，但是我还是对电脑的了解还是太少了，我以为可以用一根HDMI线连接到我的笔记本的HDMI口进行操作的，但是电脑上的HDMI口只能输出所以就没办法了，在我这几天逛互联网的时候我找到了一个方法就是使用串口来设置这个板子，正好我有一个<code>USB to TTL</code>，就试了一下，随便写了个笔记。</p>
<h1 id="一、使用的东西"><a href="#一、使用的东西" class="headerlink" title="一、使用的东西"></a>一、使用的东西</h1><p>先准备一个香橙派<code>zero 3</code>的板子</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202185932657-1174425800.jpg" alt="img"></p>
<p>然后准备一张SD卡用来下载系统</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202190107442-27730457.jpg" alt="img"></p>
<p>然后准备一个读卡器，这个读卡器可以去借别人的，我这个就是借的</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202190157802-1495712197.jpg" alt="img"></p>
<p>准备一个<code>USB转TTL</code>的下载器</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202190259947-1652784241.jpg" alt="img"></p>
<p>然后准备一根type线，这里我拿的是我的充电线</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202190353525-1044573884.jpg" alt="img"></p>
<p>准备完成后就可以开始操作了。</p>
<h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="1-下载系统到SD卡中"><a href="#1-下载系统到SD卡中" class="headerlink" title="1.下载系统到SD卡中"></a>1.下载系统到SD卡中</h2><p>首先先将一个系统下载到SD卡中，这里我使用的是Ubuntu的服务器系统，这个系统是没有图形化界面的，因为我只有1.5G的运行内存。</p>
<p>系统我是在香橙派官网中的资料下载中下载的，这里我把链接放在这，<a href="http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-Zero-3.html">Orange-Pi-Zero-3资料下载</a>。当然我也把这些资料放在我的网盘中的。</p>
<p>下载了操作系统镜像后把SD卡插到下载器上，下载器连接到电脑，然后使用<code>Win32DiskImager</code>软件将镜像文件下载到SD卡中，这里需要注意一下，<strong>这个过程会将SD卡中的内容全部清除，所以要先把这个SD卡中的内容备份一下。</strong> 然后打开<code>Win32DiskImager</code>软件</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202191236851-2026055802.png" alt="img"></p>
<p>在<code>映像文件</code>那打开你要下载的系统，然后点击写入即可，等待写入完成后将SD卡插到香橙派上</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202191518835-1953636756.jpg" alt="img"></p>
<p>然后就可以进入下一步了。</p>
<h2 id="2-上电连接串口"><a href="#2-上电连接串口" class="headerlink" title="2.上电连接串口"></a>2.上电连接串口</h2><p>这里先用<code>USB转TTL</code>连接到香橙派上，如何连接呢？这里可以看看引脚图</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202191657105-1133119272.png" alt="img"></p>
<p>可以看到最上面的那三个引脚就是我们需要使用的串口引脚<code>TX</code>、<code>RX</code>、<code>GND</code>，然后我们用<code>USB转TTL</code>进行连接，这里的连接如下表格：</p>
<table>
<thead>
<tr>
<th>USB转TTL</th>
<th>香橙派</th>
</tr>
</thead>
<tbody><tr>
<td>TX</td>
<td>RX</td>
</tr>
<tr>
<td>RX</td>
<td>TX</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
</tbody></table>
<p>连接完成图</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202192010341-1482300985.jpg" alt="img"></p>
<p>然后把这一端连接到电脑上</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202192041874-1420115892.jpg" alt="img"></p>
<p>然后将Type线连接到电脑上为其供电</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202192132329-104615943.jpg" alt="img"></p>
<p>然后打开<code>串口助手</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202192212336-247609896.png" alt="img"></p>
<p>这里需要注意一下串口的波特率为<code>115200</code>，如果说你波特率调错了得到的内容就都是乱码，然后给香橙派上电，并且打开串口就会收到香橙派的启动信息</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202194830248-458441528.png" alt="img"></p>
<p>这个就是收到的信息，然后等待一会就可以进入到输入内容了，首先查看一下它的IP地址</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202194938276-1204902720.png" alt="img"></p>
<p>在输入框中输入命令后需要按一下回车，然后再点击发送，这样就可以发送命令了，发送完后会有一个反馈</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202195121194-610970373.png" alt="img"></p>
<p>这个就是查看的内容了。</p>
<h2 id="3-打开ssh"><a href="#3-打开ssh" class="headerlink" title="3.打开ssh"></a>3.打开ssh</h2><p>一直使用串口助手并不是一个长久的方法，在Linux中可以使用一个远程连接的方法，这个方法是<code>ssh</code>，但是这个方法需要连接到网络得到一个IP地址，而且这个需要在同一个局域网中才可以连接。</p>
<p>实现我们先更新一下软件包</p>
<p>执行的命令是<code>sudo apt update</code>，执行这个命令需要获取<code>root</code>权限，所以加上了一个<code>sudo</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202195437672-1696146567.png" alt="img"></p>
<p>然后需要输入一下<code>root</code>的密码，这里的密码默认是<code>orangepi</code>，也是在输入指令框那发送，然后输入完后就可以开始更新</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202195545961-1882637112.png" alt="img"></p>
<p>更新完成后要下载<code>openssh</code>这个软件，服务端的系统是默认开启的，所以可以跳过这个步骤，使用的命令是<code>sudo apt-get install openssh-server</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202195647137-1137483826.png" alt="img"></p>
<p>然后下载完成后就查看一下<code>ssh</code>是否打开，使用<code>sudo ps -e |grep ssh</code>，如果出现下面的内容就证明<code>ssh</code>打开，一般都会打开的。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202200008533-1739091947.png" alt="img"></p>
<p>如果没有打开可以使用<code>sudo server ssh start</code>进行打开，然后再查看是否有该线程即可。</p>
<h2 id="4-使用xshell连接香橙派"><a href="#4-使用xshell连接香橙派" class="headerlink" title="4.使用xshell连接香橙派"></a>4.使用xshell连接香橙派</h2><p>首先需要执行<code>ifconfig</code>来查看一下香橙派的IP地址，然后打开<code>xshell</code>软件</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202200354931-1714757678.png" alt="img"></p>
<p>然后点击<code>新建</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202200429605-1610648089.png" alt="img"></p>
<p>在新建里面填一下用<code>ifconfig</code>获取的IP地址，然后点击连接，连接后需要输入一下用户名和密码，这里直接用<code>root</code>账号，因为<code>root</code>是知道密码的。</p>
<p>然后就可以进入界面了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202205858661-275336374.png" alt="img"></p>
<p>需要注意一下就是要保证你的电脑和香橙派是连接同一个局域网，否则是连接不了的。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我后面还会出一些关于香橙派的一些文章，大家感兴趣的可以关注一下我。</p>
<p>香橙派还是比较便宜的。</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-点亮OLED显示屏</title>
    <url>/2025/01/17/ef0ed158c24d/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我因为没买屏幕所以一直都是用ssh来远程连接，但是这会出现一个问题，香橙派的IP地址是动态的，它每隔一段时间就会换一下IP地址，而每次换IP地址后原来的IP地址就失效了。虽然可以固定IP地址，但是我觉得在每次开机直接通过一块OLED显示屏将IP地址显示才是最好的。</p>
<h1 id="一、IIC协议"><a href="#一、IIC协议" class="headerlink" title="一、IIC协议"></a>一、IIC协议</h1><p>我这里使用的是0.96寸OLED IIC协议的显示屏，是之前做外包剩下的，所以直接拿来用一下，在网上9块钱可以整一块</p>
<p>这块显示屏是IIC协议的，所以我们需要先了解一下IIC协议，虽然香橙派中IIC协议是有硬件程序，但我们也是需要了解一下这个协议。</p>
<h2 id="1-IIC协议的组成"><a href="#1-IIC协议的组成" class="headerlink" title="1.IIC协议的组成"></a>1.IIC协议的组成</h2><p>IIC协议要顺利运行是需要两个东西一起工作才可以实现，第一个是SDA，也就是数据引脚，这个引脚是负责传输数据信息的。第二个是SCL，时钟引脚，用来传输时钟信息的。</p>
<p>时钟引脚是按照一定的频率来进行震荡的，这样才能为从机提供时钟信息，也是为了让主机和从机按照一定的频率来进行数据交互。</p>
<p>数据引脚是可以让从机和主机进行数据交换的，这个引脚可以传输命令或者是数据。</p>
<h2 id="2-IIC的时序图"><a href="#2-IIC的时序图" class="headerlink" title="2.IIC的时序图"></a>2.IIC的时序图</h2><p>了解了这两个引脚后我们就可以看一下时序图来了解什么时候该传输什么信息。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224122254562-1734348769.png" alt="img"></p>
<p>可以看到一开始主机需要发送一个<code>start</code>信号，也就是起始信号，发送完其实信号后发送了一个控制信息<code>MSB</code>，然后由<code>MSB</code>控制信息决定是读取命令&#x2F;数据还是写入命令&#x2F;数据，然后就开始传输数据，当传输完成后主机或者从机就会发送一个<code>ACK</code>响应信号。</p>
<p>如果一开始是主机向从机发送数据或者命令，那从机会发送一个<code>ACK</code>响应信号。</p>
<p>如果一开始是从机向主机发送数据或者命令，那主机需要发送一个<code>ACK</code>响应信号。</p>
<p>然后传输完成后发送了一个<code>stop</code>结束信号，当这个信号发送了后，说明一次的IIC协议就传输完成。</p>
<p>接下来好好分析一下IIC的这些内容。</p>
<h2 id="3-IIC起始信号和结束信号"><a href="#3-IIC起始信号和结束信号" class="headerlink" title="3.IIC起始信号和结束信号"></a>3.IIC起始信号和结束信号</h2><p>先将这两个信号单独拿下来分析。</p>
<p>首先看一下起始信号</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224123309215-1732392374.png" alt="img"></p>
<p>可以看到起始信号是时序图很简单，让<code>SCL</code>时钟信号保存高电平，然后<code>SDA</code>数据信号有一个从高到低的下降沿，代码我们就可以这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">digitalWrite(SCL, <span class="number">1</span>);</span><br><span class="line">digitalWrite(SDA, <span class="number">1</span>);</span><br><span class="line">digitalWrite(SDA, <span class="number">0</span>);</span><br><span class="line">digitalWrite(SCL, <span class="number">1</span>);</span><br><span class="line">digitalWrite(SCL, <span class="number">0</span>);   <span class="comment">// 为传输数据做准备</span></span><br></pre></td></tr></table></figure>

<p>这样就可以启动IIC协议，当然，我们今天的重点不是用软件模拟IIC协议，所以上面的代码仅供参考，毕竟还有时间的问题。</p>
<p>然后再来看看结束信号</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224123737352-1167251994.png" alt="img"></p>
<p>结束信号也是很简单，让<code>SDA</code>从低到高有一个上升沿，<code>SCL</code>一直保持高电平即可，代码就可以这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">digitalWrite(SCL, <span class="number">1</span>);</span><br><span class="line">digitalWrite(SDA, <span class="number">0</span>);</span><br><span class="line">digitalWrite(SDA, <span class="number">1</span>);</span><br><span class="line">digitalWrite(SCL, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这样就可以结束这一次的IIC协议。</p>
<h2 id="4-控制信息"><a href="#4-控制信息" class="headerlink" title="4.控制信息"></a>4.控制信息</h2><p>控制信息是主机来选择控制的从机是发送数据还是接收数据的一个操作信息，因为IIC可以支持多从机并联，这个时候就得用地址来区分控制的设备了。</p>
<p>控制信息由两个部分组成：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224124431639-1547011114.png" alt="img"></p>
<p>一个是从机地址，另一个是传输的数据模式，从机地址是这个设备生产的时候就已经写入进去了，如果你需要多个不同的从机地址，你可以去找厂商去更改一下，OLED显示屏的地址是<code>0x78</code>。</p>
<p>数据模式就是在控制信息后是读取命令数据还是写入数据命令，如下表：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>读取</td>
</tr>
<tr>
<td>0</td>
<td>写</td>
</tr>
</tbody></table>
<p>比如说我们这写入数据，那代码就如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readDataStart</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> address = <span class="number">0x78</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        digitalWrite(SCL, <span class="number">0</span>);</span><br><span class="line">        digitalWrite(SDA, (address &lt;&lt; i &amp; <span class="number">0x80</span>));    <span class="comment">// 从高位开始传递</span></span><br><span class="line">        digitalWrite(SCL, <span class="number">1</span>);</span><br><span class="line">        digitalWrite(SCL, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是需要读的话，地址就改为<code>0x79</code>。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224135130308-2037944183.png" alt="img"></p>
<p>这个就是传输数据的时序图，当<code>SCL</code>上升沿后，就会把<code>SDA</code>的数据传输过去。</p>
<h2 id="5-传输数据或者命令"><a href="#5-传输数据或者命令" class="headerlink" title="5.传输数据或者命令"></a>5.传输数据或者命令</h2><p>在传输帧中，因为要区分命令或者数据，所以一开始需要传输一个标志来区分出后面的数据是命令还是地址，这个传输帧如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224135427282-900446650.png" alt="img"></p>
<p>如果我们要传输数据，那这先得传输一个<code>0x40</code>，如果是一个命令，那传输<code>0x00</code>，传输完成后就可以传输要传递的数据了。</p>
<p>根据这个就可以写出传递数据的函数了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sendData</span><span class="params">()</span>&#123;</span><br><span class="line">    OLED_I2C_Start();</span><br><span class="line">    OLED_I2C_SendByte(<span class="number">0x78</span>);		<span class="comment">//从机地址</span></span><br><span class="line">    OLED_I2C_SendByte(<span class="number">0x40</span>);		<span class="comment">//写数据</span></span><br><span class="line">    OLED_I2C_SendByte(Data);        <span class="comment">// 要传输的数据</span></span><br><span class="line">    OLED_I2C_Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些是封装好了的函数，等后面会写的。</p>
<h1 id="二、香橙派的硬件IIC"><a href="#二、香橙派的硬件IIC" class="headerlink" title="二、香橙派的硬件IIC"></a>二、香橙派的硬件IIC</h1><p>在香橙派中是有IIC这个硬件协议的，并且在<code>wiringPi</code>库中也是有对应的函数的，所以我们可以直接使用硬件的IIC来完成我们的项目，但是要使用IIC就需要在设置中将其打开，打开的方式很简单。</p>
<p>首先在命令行中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo orangepi-config</span><br></pre></td></tr></table></figure>

<p>然后就进入到设置页面，在这个页面只能用键盘来进行操作，回车是确定，空格是选择</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224140414908-1646415316.png" alt="img"></p>
<p>然后选择<code>System</code>后按下回车，就进入下面的界面</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224140509216-22980975.png" alt="img"></p>
<p>然后用方向键移动到<code>Hardare</code>后按下回车，就可以进入一些功能设置界面了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224140612493-1580241930.png" alt="img"></p>
<p>可以看到有很多的功能，这里我们需要使用到<code>IIC</code>所以就只打开<code>IIC</code>，需要注意一下，这里有3个<code>IIC</code>，这3个对应着不同的引脚，下面的引脚图可以参考</p>
<p>Pi3的GPIO引脚</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224140757699-1722401549.png" alt="img"></p>
<p>zero 3的GPIO引脚</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224141015298-1009303537.png" alt="img"></p>
<p>我们着选择<code>m1</code>就行了，选择完成后就可以回车了，然后让我们重启一下，当重启完成后再按照上面的办法进行打开来查看一下是否打开成功。</p>
<h1 id="三、Pi3的OLED驱动代码"><a href="#三、Pi3的OLED驱动代码" class="headerlink" title="三、Pi3的OLED驱动代码"></a>三、Pi3的OLED驱动代码</h1><p>这里说一下如何编写OLED的驱动代码。</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-超声波测量距离</title>
    <url>/2025/01/17/a33915e7d886/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>超声波模块是非常简单也非常好用的一个模块，不需要你会多少概念，你只需要会IO口的控制和定时器的操作就可以就行操作了。这一篇文章我会从stm32和香橙派一直来讲解这个超声波测距怎么玩。</p>
<h1 id="一、HC-SR04芯片"><a href="#一、HC-SR04芯片" class="headerlink" title="一、HC-SR04芯片"></a>一、HC-SR04芯片</h1><p>这个是我们超声波模块使用的芯片，我们就对它就行IO操作就可以了。</p>
<p>超声波模块有4个引脚，分别是</p>
<ul>
<li>VCC</li>
<li>GND</li>
<li>Trig</li>
<li>Echo</li>
</ul>
<p><img src="https://www.freeimg.cn/i/2024/02/11/65c88edf46803.jpg"></p>
<p>然后这个模块的时序图如下：</p>
<p>当向Trig发送一个高电平，这个高电平要持续10~20us才可以，然后Echo就会发送一个高电平回来就代表着超声波已经发送，当超声波碰到物体后就会反弹，反弹回来后Echo引脚就会变成一个低电平来告诉用户已经发送来回了。</p>
<p>我们知道这个的时序图后我们就可以知道如何通过这个超声波来进行测距了，我们可以在它发送超声波后开启定时，当接送到超声波后就停止定时，然后通过获取的时间去除以340m&#x2F;s并再除以2就可以得到距离了。</p>
<h1 id="二、stm32代码编写"><a href="#二、stm32代码编写" class="headerlink" title="二、stm32代码编写"></a>二、stm32代码编写</h1><p>我们知道上面讲的内容后我们就可以开始编写代码了，首先我们要初始化GPIO口，让其能进行接收和发送数据，然后再初始化一个计数器来获取超声波在过程中经过的时间。</p>
<p>首先是IO口的初始化代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理解Tiger引脚</span></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接Echo引脚</span></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_0);</span><br></pre></td></tr></table></figure>

<p>然后我们开始初始化Timer定时器，使用的是定时器2，你也可以用其它的标准定时器或者基础定时器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseStruct.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseStruct.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseStruct.TIM_Period = <span class="number">1000</span> - <span class="number">1</span>;   <span class="comment">// 重装值</span></span><br><span class="line">TIM_TimeBaseStruct.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;  <span class="comment">// 预重装系数</span></span><br><span class="line">TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStruct);</span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">TIM_Cmd(TIM2, DISABLE);</span><br></pre></td></tr></table></figure>

<p>这里我们设置的定时器是1us的，然后我们就可以写一下中断处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update))&#123;</span><br><span class="line">        count++;</span><br><span class="line">        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-输入模式和上拉下拉</title>
    <url>/2025/01/17/10bcd339aa70/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面说了一下输出模式，这一章说一下输入模式，学完输入模式后我们就可以用一个软件模拟IIC让OLED0.96寸的显示屏显示内容了。</p>
<h1 id="一、设置输入模式"><a href="#一、设置输入模式" class="headerlink" title="一、设置输入模式"></a>一、设置输入模式</h1><p>前面说过设置<code>gpio</code>的模式的函数是<code>pinMode</code>，这个也可以设置<code>gpio</code>为输入模式。</p>
<p>这里还是使用<code>PC10</code>这个引脚（就是插线比较方便），然后还是和之前的一样的配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以将<code>PC10</code>设置为输入模式了，然后我们就来读一下这个端口的电平。</p>
<h1 id="二、读取端口电平"><a href="#二、读取端口电平" class="headerlink" title="二、读取端口电平"></a>二、读取端口电平</h1><p>这里使用的函数是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">digitalRead</span><span class="params">(<span class="type">int</span> pin)</span></span><br></pre></td></tr></table></figure>

<p>这个函数可以读取指定引脚的电平，通过返回值进行返回。</p>
<p>这里的返回值就是0和1，然后将代码写一下，这里需要一直等待输入，所以这里需要使用一个死循环讲读取放入，这样就可以使其一直在接收状态，而不直接结束，这里如果读取到按键按下后就输出一句话。</p>
<p>在写之前需要分析一下电路，要不然不知道到底读取低电平还是高电平，这里我简单搭建了一个按键电路，按键的另一端接到了地，另一端接到<code>PC10</code>，所以当按键按下后<code>PC10</code>的电平就为低电平了。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203205928009-1532501103.jpg" alt="img"></p>
<p>知道了接线图就可以开始写代码了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 死循环进行读取内容</span></span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;按键按下了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编译执行一下代码</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203210158852-1036398294.png" alt="img"></p>
<p>会发现没有按下就会输出这句话，为什么会这样呢？</p>
<p>其实这个本质上和stm32的输入一样。</p>
<h1 id="三、配置上拉下拉电平"><a href="#三、配置上拉下拉电平" class="headerlink" title="三、配置上拉下拉电平"></a>三、配置上拉下拉电平</h1><p>在stm32中，在设置引脚输入的时候会选择一个输入模式，有一个上拉输入还有一个下拉输入然后还有一个无上拉下拉模式，这几个模式在香橙派中也是有的。</p>
<p>我们使用<code>pinMode</code>设置为输入模式的时候会默认讲这个引脚变成无上拉下拉的输入，也就是一个中间态，这个状态非常的不稳定，一点风吹草动都会时输入的状态发生改变，就像上面的那种情况一样，你没有按下按键，但是它波动了就会导致电平变成了低电平。</p>
<p>为了解决这个问题，我们需要设置一下这个引脚为上拉输入还是下拉输入。</p>
<h2 id="1-上拉输入"><a href="#1-上拉输入" class="headerlink" title="1.上拉输入"></a>1.上拉输入</h2><p>上拉输入其实是在内部有一个上拉电阻，也就是有一个接电源的电阻和引脚相连，使得这个引脚一开始就是高电平，我们可以将引脚设置为上拉输入后获取低电平的变化。</p>
<h2 id="2-下拉输入"><a href="#2-下拉输入" class="headerlink" title="2.下拉输入"></a>2.下拉输入</h2><p>下拉输入和上拉是反的，下拉是有一个下拉电阻，其实就是这个引脚有一个接地的电阻和它连接，所以这个引脚一开始就是低电平，我们可以将引脚设置为下拉输入来获取高电平的变化。</p>
<h2 id="3-设置函数"><a href="#3-设置函数" class="headerlink" title="3.设置函数"></a>3.设置函数</h2><p>设置的函数是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pullUpDnControl</span><span class="params">(<span class="type">int</span> pin, <span class="type">int</span> mode)</span></span><br></pre></td></tr></table></figure>

<p>其中mode有下面几种选择</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PUD_OFF</td>
<td>无上拉无下拉</td>
</tr>
<tr>
<td>PUD_UP</td>
<td>上拉输入</td>
</tr>
<tr>
<td>PUD_DOWN</td>
<td>下拉输入</td>
</tr>
</tbody></table>
<p>这里我们需要设置为上拉输入，因为要获取低电平的输入。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);   <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 死循环进行读取内容</span></span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;按键按下了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编译运行一下，然后运行</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231204154759382-2087838547.png" alt="img"></p>
<p>会发现进入了死循环，然后但我们按下后就会有语句输出</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231204154817885-607915705.png" alt="img"></p>
<p>会发现这个出现了很多语句，怎么样来实现按一下输出一条语句呢？这里可以在循环里面再加上一个循环判断一下这个按键是不是一直为低电平，如果一直为低电平就一直在循环中出不来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);   <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 死循环进行读取内容</span></span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(digitalRead(<span class="number">116</span>) == <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;按键按下了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231204155256080-708166452.png" alt="img"></p>
<p>这个就叫做消抖，当然有一些是使用延时函数进行消抖的，这里也说一下，使用<code>delay</code>函数来延时去除抖动即可，一般按键的抖动都在20ms到30ms之间，这个可以进行微调</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);   <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 死循环进行读取内容</span></span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            delay(<span class="number">20</span>);     <span class="comment">// 延时消抖</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;按键按下了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个也不是很精准，一般情况下对按键的消抖是用延时函数配合着循环进行判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);   <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 死循环进行读取内容</span></span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            delay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">while</span>(digitalRead(<span class="number">16</span>) == <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;按键按下了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的消抖要准确一点。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>输入还是非常的简单，大家多多练习即可，后面也会经常使用到这个输入函数的。</p>
<p>大家有什么问题可以私信或者在文章下面留言，我都会看的。</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
</search>
