<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言基础</title>
    <url>/2025/01/16/96d0a083572a/</url>
    <content><![CDATA[<h1 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>和所有编程语言一样，要认识一个语言的结构得从”hello,world”开始，我们使用C语言来输出”hello,world”吧。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们初识C语言了，下面是分析。</p>
<p>**分析：**第一行是调用头文件，<code>#include</code>是C语言调用标准头文件的标准方法。<code>stdio.h</code>是标准库，调用了这个库我们才可以使用<code>printf()</code>函数</p>
<p>第二行是主函数，在C语言中可以有好多个函数，当时只能有一个<code>main</code>函数，<code>main</code>函数是程序的入口。<code>main</code>前面的是返回值类型，在好多大学中，教C语言的老师喜欢把前面的类型省略，这个叫缺省（xing），但在C语言标准里，前面的<code>int</code>是不可以去掉的。</p>
<p>第三行是函数内执行的语句，这个是一个输出函数<code>printf()</code>，它的作用是将括号里的数据输出到显示屏中，给用户查看。(具体看第一章)</p>
<p>第四行是返回值。（具体内容在函数那一章再细讲）</p>
<p>**细节：**C语言对语法要求不是那么的高，不像python一样需要严格遵循缩进，C语言需要在函数内执行的语句只需要在 <code>&#123;&#125;</code> 中即可，一行语句执行完加 <code>;</code> 即可。</p>
<p>要执行C语言的程序必须得进行编译，编译完之后才能运行，简单解释一下为什么要这么做：</p>
<p>计算机它能认识0和1这种低级语言，而我们写代码是用C语言这种高级语言来写的，但计算机不认识，必须需要一个编译器来将高级语言转换为低级语言，这样计算机就可以执行。</p>
<p>C语言编译出来的后缀为： <code>.obj</code> </p>
<p>可运行的程序的后缀为： <code>.exe</code></p>
<p><strong>这只是一个笔记，笔记主要是将重要的内容记下来，所以好多不重要的内容或者是一看就会的内容我就省略了</strong></p>
<h2 id="一、输出函数"><a href="#一、输出函数" class="headerlink" title="一、输出函数"></a>一、输出函数</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>在C语言中是没有自带的输出函数的，而是必须通过调用标准库文件才能使用输出语句，先对输入输出函数进行了解，会使你对C语言有更好的兴趣。</p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf();"></a><code>printf();</code></h3><ul>
<li>头文件：<code>stdio.h</code></li>
</ul>
<ul>
<li><p><code>printf</code>函数的功能：</p>
<p><strong>格式化输出函数</strong>，用于向标准输出设备<strong>按规定格式</strong>输出信息。 </p>
</li>
<li><p>printf函数的调用格式：</p>
<p><code>printf(&quot;格式控制字符串&quot;,输出项清单);</code></p>
<p>格式控制字符串：用于指定输出格式；由格式字符串和非格式字符串两种组成。格式字符串是以%开头的字符串。</p>
<p>输出项清单：</p>
<ul>
<li>输出项可以是常量、变量或表达式</li>
<li>要求格式字符串和各输出项在数量和类型上应该一一对应</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> m=<span class="number">123</span>,n=<span class="number">12345</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;m=%5d,n= %3d\n&quot;</span>,m,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; 变量;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>对于整形数而言，当格式控制字符规定的长度比数据本身长度还大时，则左侧补空格；若个数控制字符规定的长度比数据本身长度小时，则数据按照其本身长度进行输出。</p>
<ul>
<li><p>格式化字符串  </p>
<table>
<thead>
<tr>
<th>表示方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>以十进制形式带符号整数（正数不输出符号）</td>
</tr>
<tr>
<td>%o</td>
<td>以八进制形式输出无符号整数（默认不输出前缀0，%#o输出前缀0）</td>
</tr>
<tr>
<td>%x</td>
<td>以十六进制形式输出无符号整数（默认不输出前缀0x，%#x输出前缀0x）</td>
</tr>
<tr>
<td>%u</td>
<td>以十进制形式输出无符号整数</td>
</tr>
<tr>
<td>%f</td>
<td>以小数形式输出单、双精度实数，默认保留6位小数<br>双精度型可用%lf或%le</td>
</tr>
<tr>
<td>%e</td>
<td>以指数形式输出单、双精度实数。<strong>格式是m.ddddddexxx</strong>，默认小数精度为6，指数精度为3，不足补零（明白即可）</td>
</tr>
<tr>
<td>%g</td>
<td>以%f或%e中较短的输出单、双精度实数</td>
</tr>
<tr>
<td>%c</td>
<td>输出单个字符</td>
</tr>
<tr>
<td>%s</td>
<td>输出字符串，直到遇到\0，若<strong>字符串长度超过指定的精度则自动突破，不截断</strong></td>
</tr>
<tr>
<td>%p</td>
<td>输出变量的内存地址</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="putchar"><a href="#putchar" class="headerlink" title="putchar();"></a><code>putchar();</code></h3><h4 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h4><p>主要是用于输出字符的函数</p>
<h4 id="2-格式"><a href="#2-格式" class="headerlink" title="2.格式"></a>2.格式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> x = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//一定是字符型变量</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&quot;%c&quot;</span>, x);<span class="comment">//格式化字符串一定要%c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、输入函数"><a href="#二、输入函数" class="headerlink" title="二、输入函数"></a>二、输入函数</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf();"></a><code>scanf();</code></h3><h4 id="1-调用格式"><a href="#1-调用格式" class="headerlink" title="1.调用格式"></a>1.调用格式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//调用头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须要加取值符 <code>&amp;</code> </p>
<h4 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h4><p>将用户输入的值赋值给取值符后的变量</p>
<h3 id="getchar"><a href="#getchar" class="headerlink" title="getchar();"></a><code>getchar();</code></h3><h4 id="1-用法-1"><a href="#1-用法-1" class="headerlink" title="1.用法"></a>1.用法</h4><p>输入字符</p>
<h4 id="2-格式-1"><a href="#2-格式-1" class="headerlink" title="2.格式"></a>2.格式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    getchar(<span class="string">&quot;%c&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h2><p>在C语言中有局部变量和全局变量</p>
<h3 id="1-变量的类型"><a href="#1-变量的类型" class="headerlink" title="1.变量的类型"></a>1.变量的类型</h3><h5 id="1-整型变量"><a href="#1-整型变量" class="headerlink" title="(1)整型变量"></a>(1)整型变量</h5><table>
<thead>
<tr>
<th>类型</th>
<th>储存大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td>2-4个字节</td>
<td>整型</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2字节</td>
<td>短整型</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8字节</td>
<td>长整型</td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td>2字节</td>
<td>无符号短整型</td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td>2-4字节</td>
<td>无符号整型</td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td>8字节</td>
<td>无符号长整型</td>
</tr>
</tbody></table>
<h5 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="(2)浮点型"></a>(2)浮点型</h5><table>
<thead>
<tr>
<th>类型</th>
<th>储存大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>long double</td>
<td>16字节</td>
<td>长双</td>
</tr>
</tbody></table>
<h5 id="3-字符型"><a href="#3-字符型" class="headerlink" title="(3)字符型"></a>(3)字符型</h5><table>
<thead>
<tr>
<th>类型</th>
<th>储存大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1字节</td>
<td>字符型</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1字节</td>
<td>无符号字符型</td>
</tr>
</tbody></table>
<p>说明：字符型也可以存放数字类型</p>
<h3 id="2-变量的定义"><a href="#2-变量的定义" class="headerlink" title="2.变量的定义"></a>2.变量的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">类型名 变量名 = 赋的值;</span><br><span class="line">类型名 变量名;</span><br></pre></td></tr></table></figure>

<p>两个都可以定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)变量名不能是保留字</span><br><span class="line"><span class="number">2</span>)变量名不能由数字开头</span><br><span class="line"><span class="number">3</span>)变量名只能由下划线，数字，单词组成</span><br></pre></td></tr></table></figure>



<p>注：每次定义后储存的变量一定是同种类型，负责会报错，C语言并没有字符串这个类型，如果要定义字符串需要定义字符型数组</p>
<h3 id="3-变量的转换"><a href="#3-变量的转换" class="headerlink" title="3.变量的转换"></a>3.变量的转换</h3><p>例子1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> num1 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">char</span> num2 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> num3 = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个样子是可以转的，因为 <code>char</code> 类型是1个字节，而 <code>int</code> 为4个字节是可以装的</p>
<p>例子2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">5</span>,a;</span><br><span class="line">    </span><br><span class="line">    a=<span class="number">6</span>;</span><br><span class="line">    f=a/i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,f); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果存储计算后的结果为整型，则会抛弃小数点后的数。</p>
<p>如果为浮点型，则会输出小数点后的数</p>
<h3 id="4-变量的强制转换"><a href="#4-变量的强制转换" class="headerlink" title="4.变量的强制转换"></a>4.变量的强制转换</h3><p>有些时候无法通过赋值来进行类型转换</p>
<p>所以这个时候就需要使用强制转换</p>
<h4 id="1-语法"><a href="#1-语法" class="headerlink" title="(1)语法"></a>(1)语法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(数据类型) 变量；</span><br></pre></td></tr></table></figure>

<h3 id="5-全局变量和局部变量"><a href="#5-全局变量和局部变量" class="headerlink" title="5.全局变量和局部变量"></a>5.全局变量和局部变量</h3><h4 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="(1)全局变量"></a>(1)全局变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局变量是定义在函数体外的，在函数体中没办法修改全局变量</p>
<h4 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="(2)局部变量"></a>(2)局部变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;<span class="comment">//局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、常量"><a href="#四、常量" class="headerlink" title="四、常量"></a>四、常量</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><h4 id="1-define定义"><a href="#1-define定义" class="headerlink" title="(1)define定义"></a>(1)define定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 变量名 值</span></span><br></pre></td></tr></table></figure>

<h4 id="2-const关键字"><a href="#2-const关键字" class="headerlink" title="(2)const关键字"></a>(2)<code>const</code>关键字</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> 数据类型 变量名 = 值;</span><br></pre></td></tr></table></figure>

<p>重点在存储类中</p>
<h2 id="五、存储类"><a href="#五、存储类" class="headerlink" title="五、存储类"></a>五、存储类</h2><h3 id="1-auto"><a href="#1-auto" class="headerlink" title="1.auto"></a>1.<code>auto</code></h3><p>默认类，就是用完就释放</p>
<p>可写可不写</p>
<h3 id="2-register"><a href="#2-register" class="headerlink" title="2.register"></a>2.<code>register</code></h3><p>感觉没什么用</p>
<p>官方解释说是可以提高运算速度，但现在的CPU运算速度都很快，所以没什么用</p>
<h3 id="3-static"><a href="#3-static" class="headerlink" title="3.static"></a>3.<code>static</code></h3><p>和 <code>auto</code> 是反过来的，使用完它并不会释放</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    count();</span><br><span class="line">    count();</span><br><span class="line">    count();</span><br><span class="line">    count();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-const"><a href="#4-const" class="headerlink" title="4.const"></a>4.<code>const</code><a name="con_type"></a></h3><p>const 是将变量中的值固定，使得变量无法被修改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/const%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E4%BF%AE%E6%94%B9%E5%80%BC.png"></p>
<p>但是在vs编辑器中是可以通过指针来修改被const修改的值的</p>
<p>如下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/vs2019%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E6%9D%A5%E4%BF%AE%E6%94%B9%E8%A2%ABconst%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%80%BC.png"></p>
<p>运行结果</p>
<p><img src="/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="运行结果"></p>
<p>在dev-c++中就无法使用这个办法进行修改</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<h2 id="六、C语言编程结构"><a href="#六、C语言编程结构" class="headerlink" title="六、C语言编程结构"></a>六、C语言编程结构</h2><p>在所有编程语言中有着三种结构：顺序结构，选择结构，循环结构，循序结构</p>
<h3 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1.顺序结构"></a>1.顺序结构</h3><p>顺序结构是编程语言中最基础的一种结构，计算机不像人的思维，它得到代码后它没有办法自己行进跳转(有选择和分支除外)，它只能一条一条的执行，一条一条执行的情况就是顺序结构，如下代码</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81.png"></p>
<p>它的执行情况如下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6这样执行的。</p>
<p>这种执行是非常简单也很基础，但没有办法做一些逻辑很强的程序，所以我们引入了选择结构。</p>
<h3 id="2-选择结构"><a href="#2-选择结构" class="headerlink" title="2.选择结构"></a>2.选择结构</h3><p>在介绍选择结构前先介绍逻辑判断语句。</p>
<h4 id="2-1-逻辑判断"><a href="#2-1-逻辑判断" class="headerlink" title="2.1 逻辑判断"></a>2.1 逻辑判断</h4><p>在C语言中0表示假，1表示真</p>
<table>
<thead>
<tr>
<th>关系符</th>
<th>a1</th>
<th>a2</th>
<th>结果(a1)  (a2)</th>
</tr>
</thead>
<tbody><tr>
<td>||  逻辑或 or</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>||</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>||</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>&amp;&amp;   逻辑与  and</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>然后还有一个逻辑是 <code>!</code> 逻辑非</p>
<table>
<thead>
<tr>
<th>a1</th>
<th>a1!</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>补充</strong>：在c语言中还有一个对于二进制的逻辑表达式</p>
<p><code>|</code> ：二进制或</p>
<p><code>&amp;</code> ：二进制与</p>
<p><code>^</code> ：二进制异或</p>
<p><code>~</code>：二进制非</p>
<h4 id="2-2-逻辑判断"><a href="#2-2-逻辑判断" class="headerlink" title="2.2 逻辑判断"></a>2.2 逻辑判断</h4><p>两个数之间判断大小，如果成立则值等于1，如果不成立则等于0。</p>
<p>但在C语言中，只能两个数之间相比，不能多个</p>
<p>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a &gt; b;</span><br></pre></td></tr></table></figure>

<p>是可以的，但下面的是绝对不可以</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a &gt; b &gt; c;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-1-三元运算符"><a href="#2-3-1-三元运算符" class="headerlink" title="2.3.1 三元运算符"></a>2.3.1 三元运算符</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> max = (a&gt;b)?a:b;</span><br></pre></td></tr></table></figure>

<p>如果a&gt;b成立，则结果为a，否则返回b</p>
<h4 id="2-3-判断语句"><a href="#2-3-判断语句" class="headerlink" title="2.3 判断语句"></a>2.3 判断语句</h4><h5 id="2-3-1-if语句"><a href="#2-3-1-if语句" class="headerlink" title="2.3.1 if语句"></a>2.3.1 if语句</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">    <span class="comment">//成立后执行花括号里的语句</span></span><br><span class="line">    执行<span class="number">1</span>;</span><br><span class="line">    执行<span class="number">2</span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-else语句"><a href="#2-3-2-else语句" class="headerlink" title="2.3.2 else语句"></a>2.3.2 else语句</h5><p>else语句是可以没有判断条件的，但必须有执行语句</p>
<h5 id="2-3-3-else-if"><a href="#2-3-3-else-if" class="headerlink" title="2.3.3 else if"></a>2.3.3 else if</h5><p>用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">    <span class="comment">//成立后执行花括号里的语句</span></span><br><span class="line">    执行<span class="number">1</span>;</span><br><span class="line">    执行<span class="number">2</span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (判断条件)&#123;</span><br><span class="line">    <span class="comment">//成立后执行花括号里的语句</span></span><br><span class="line">    执行<span class="number">1</span>;</span><br><span class="line">    执行<span class="number">2</span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-4-注意"><a href="#2-3-4-注意" class="headerlink" title="2.3.4 注意"></a>2.3.4 注意</h5><p>在if语句里可以有也可以没有else、else if语句，但必须要有if语句</p>
<h5 id="2-3-5-switch"><a href="#2-3-5-switch" class="headerlink" title="2.3.5 switch"></a>2.3.5 switch</h5><p>switch是单个判断的语句</p>
<p>语法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:语句<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>:语句<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">3</span>:语句<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">default</span> : 语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这个语句执行会一直</p>
<p>例如</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/switch%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81.png"></p>
<p>然后输出的结果如下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/switch%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>它第一个条件判断成功了，但它却继续执行下面的输出代码。</p>
<p>所以我们会在后面添加一个 <code>break</code> 使它判断成功后执行玩就结束。</p>
<p>如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A0%E4%BA%86break%E7%9A%84switch%E8%AF%AD%E5%8F%A5.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png"></p>
<h5 id="2-3-6-switch判断范围问题"><a href="#2-3-6-switch判断范围问题" class="headerlink" title="2.3.6 switch判断范围问题"></a>2.3.6 switch判断范围问题</h5><p>在C语言中，一些时候可以用if-else来判断范围问题，有些时候也可以使用switch来判断范围问题。</p>
<p>使用switch的思路是将个个范围的数化为一个特定的数，然后使用switch语句进行判断。</p>
<p>例如：我们需要计算每个销售数段获得的提成的题目</p>
<p>我们使用if-else语句的写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你总共销售额(单位:万):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">100</span> &lt; a &amp;&amp; a &lt;=<span class="number">120</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.02</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">120</span> &lt; a &amp;&amp; a &lt;= <span class="number">140</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.05</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">140</span> &lt; a &amp;&amp; a &lt;= <span class="number">190</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.08</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">190</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有提成&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if-else的写法是非常的简单，但是，如果使用switch来改写这个if-else就有点困难，所以我们要有将范围变成具体的数的思路，然后通过数来进行判断。</p>
<p>switch改写的第一种方法：</p>
<p>我们知道，在C语言中进行的是逻辑判断，通过逻辑判断的出来的只能是或则是，所以我们可以在外部对输入的数进行逻辑判断，然后再乘以具体的1，2，3，因为如果成立则为1，不成立则为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, max;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    max = ((a &gt; <span class="number">100</span>)&amp;&amp;(a&lt;=<span class="number">120</span>)) + <span class="number">2</span>*((a&gt;<span class="number">120</span>)&amp;&amp;(a&lt;=<span class="number">140</span>)) + <span class="number">3</span>*((a&gt;<span class="number">140</span>)&amp;&amp;(a&lt;=<span class="number">190</span>)) + <span class="number">4</span>*(a&gt;<span class="number">190</span>);</span><br><span class="line">    <span class="keyword">switch</span>(max)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.02</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.05</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.08</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;提成:%.2f万&quot;</span>, a*<span class="number">0.1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有提成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-循环结构"><a href="#2-4-循环结构" class="headerlink" title="2.4 循环结构"></a>2.4 循环结构</h4><p>循环结构可以让你完成一件重复的事情而不写多条代码</p>
<p>例如，我们要输出100次“hello，world”，完成这件事需要写100次printf函数和100次“hello，world”，这样子是很麻烦的，但如果有循环结构，那我们就可以很轻松的完成这个程序了。</p>
<h5 id="2-4-1-for循环"><a href="#2-4-1-for循环" class="headerlink" title="2.4.1 for循环"></a>2.4.1 for循环</h5><p>for循环是编程语言中最简单的循环了，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化值; 循环条件; 值的操作)&#123;</span><br><span class="line">    循环体<span class="number">1</span>;</span><br><span class="line">    循环体<span class="number">2</span>;</span><br><span class="line">    循环体<span class="number">3</span>;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入for循环先初始化值，然后判断循环条件，满足条件后运行循环体中的值，运行完之后执行值的操作。重复运行直到不满足循环条件为止。</p>
<p>注意：学过Java的可能会这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fot(<span class="type">int</span> i = <span class="number">0</span>; ;)</span><br></pre></td></tr></table></figure>

<p>虽然C99可以这样写，但是在C语言中并不能这样写</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-012.png"></p>
<p>这个标准只能在C++文件中这么使用</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-013.png"></p>
<h5 id="2-4-2-while循环"><a href="#2-4-2-while循环" class="headerlink" title="2.4.2 while循环"></a>2.4.2 while循环</h5><p>while循环相对于for循环要简单一点，因为只有一个判断条件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (判断条件)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入循环然后判断是否满足判断条件，如果满足则加入循环体内。</p>
<h5 id="2-4-3-do-while循环"><a href="#2-4-3-do-while循环" class="headerlink" title="2.4.3 do while循环"></a>2.4.3 do while循环</h5><p>do while循环增加了一个do语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;执行语句&#125;</span><br><span class="line"><span class="keyword">while</span>(判断条件);</span><br></pre></td></tr></table></figure>

<p>先执行do语句内，然后判断是否满足条件，如果满足则继续执行do中的语句。</p>
<p>如果不满足则跳出。</p>
<p>相比于while循环，do while是可以执行一次的。</p>
<h5 id="2-4-4-嵌套循环"><a href="#2-4-4-嵌套循环" class="headerlink" title="2.4.4 嵌套循环"></a>2.4.4 嵌套循环</h5><p>简单来说就是循环里套循环，这里借用菜鸟教程的流程图</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%8F%9C%E9%B8%9F%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h5 id="2-4-5-break和continue"><a href="#2-4-5-break和continue" class="headerlink" title="2.4.5 break和continue"></a>2.4.5 break和continue</h5><h6 id="break"><a href="#break" class="headerlink" title="break"></a>break</h6><p>break是直接跳出当前循环体</p>
<h6 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h6><p>continue是跳过一次</p>
<h2 id="七、数组"><a href="#七、数组" class="headerlink" title="七、数组"></a>七、数组</h2><h3 id="1-一维数组的创建和初始化"><a href="#1-一维数组的创建和初始化" class="headerlink" title="1.一维数组的创建和初始化"></a>1.一维数组的创建和初始化</h3><h4 id="1-1-数组的创建"><a href="#1-1-数组的创建" class="headerlink" title="1.1 数组的创建"></a>1.1 数组的创建</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态创建</span></span><br><span class="line">类型 变量名[数组的长度(必须是常量)];</span><br><span class="line"><span class="comment">//静态创建</span></span><br><span class="line">类型 变量名[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//不完全初始化</span></span><br><span class="line">类型 变量名[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>不完全初始化，剩下的元素默认为0</p>
<h4 id="1-2-数组的索引取值"><a href="#1-2-数组的索引取值" class="headerlink" title="1.2 数组的索引取值"></a>1.2 数组的索引取值</h4><p>下标从0开始</p>
<p>例子1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> x[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(x); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(str)/<span class="keyword">sizeof</span>(str[<span class="number">0</span>])); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-二维数组的创建和初始化"><a href="#2-二维数组的创建和初始化" class="headerlink" title="2.二维数组的创建和初始化"></a>2.二维数组的创建和初始化</h3><h4 id="2-1数组的创建"><a href="#2-1数组的创建" class="headerlink" title="2.1数组的创建"></a>2.1数组的创建</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x[][数组的长度(必须是常量)] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[数组的长度(必须是常量)][数组的长度(必须是常量)];</span><br></pre></td></tr></table></figure>

<p>二维数组必须初始化行，可以省略列</p>
<h4 id="2-2-二维数组的使用"><a href="#2-2-二维数组的使用" class="headerlink" title="2.2 二维数组的使用"></a>2.2 二维数组的使用</h4><p>一样使用索引值</p>
<h4 id="2-3-数组的地址"><a href="#2-3-数组的地址" class="headerlink" title="2.3 数组的地址"></a>2.3 数组的地址</h4><p>数组的地址一般都是第一个元素的地址值，之后的地址就是首地址加字节数</p>
<p>注意：有两种情况不是数组的首地址</p>
<p>1.sizeof(数组名) - 数组名表示整个数组，sizeof(数组名)计算的是整个数组的大小，单位是字节</p>
<p>2.&amp;数组名，数组名代表的是整个数组。&amp;数组名，取出的是整个数组的地址</p>
<h3 id="3-数组传入函数中"><a href="#3-数组传入函数中" class="headerlink" title="3.数组传入函数中"></a>3.数组传入函数中</h3><p>我们在使用数组的时候，可能会把数组放入函数中进行数据清洗，所以数组如何传入函数就需要说明一下。</p>
<h4 id="3-1-将整个函数复制到函数中使用"><a href="#3-1-将整个函数复制到函数中使用" class="headerlink" title="3.1 将整个函数复制到函数中使用"></a>3.1 将整个函数复制到函数中使用</h4><p>第一种传参的方式是将数组中的所有元素拷贝一份到函数中使用</p>
<p>写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是将数组的地址放入函数中定义的数组中，然后使用里面的元素</p>
<h4 id="3-2-将数组的地址传入函数中使用"><a href="#3-2-将数组的地址传入函数中使用" class="headerlink" title="3.2 将数组的地址传入函数中使用"></a>3.2 将数组的地址传入函数中使用</h4><p>这种方式是将数组的地址传入函数中提供，这种方式需要的内存小，推荐使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(pa + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法相对于只是把数组的地址传入到函数中使用，没有额外创建新的空间。</p>
<h4 id="3-3-数组指针来使用"><a href="#3-3-数组指针来使用" class="headerlink" title="3.3 数组指针来使用"></a>3.3 数组指针来使用</h4><p>这个需要等到C语言进阶中才会学到</p>
<h2 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h2><p>在C语言中，有一个或多个函数，我们最熟悉的main()就是一个函数。</p>
<p>函数的作用是将需要反复使用的代码包含在一起，使我们使用更方便。</p>
<h3 id="1-函数的定义"><a href="#1-函数的定义" class="headerlink" title="1.函数的定义"></a>1.函数的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_type <span class="title function_">def_name</span> <span class="params">(value1, value2,...)</span>&#123;</span><br><span class="line">    body of the function;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return_type：返回值的类型</p>
<p>def_name：函数名</p>
<p>value1：形参，如果有多个用英文逗号分开</p>
<p>body of the function：函数体，函数中执行的内容</p>
<p>value：返回值</p>
<h4 id="1-1-返回指针类型的函数"><a href="#1-1-返回指针类型的函数" class="headerlink" title="1.1 返回指针类型的函数"></a>1.1 返回指针类型的函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_type* <span class="title function_">def_name</span><span class="params">(value1, value2,...)</span>&#123;</span><br><span class="line">    body of the function;</span><br><span class="line">    <span class="keyword">return</span> value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value1：为返回的地址</p>
<h3 id="2-函数的使用"><a href="#2-函数的使用" class="headerlink" title="2.函数的使用"></a>2.函数的使用</h3><h4 id="2-1-有返回值的函数的使用"><a href="#2-1-有返回值的函数的使用" class="headerlink" title="2.1 有返回值的函数的使用"></a>2.1 有返回值的函数的使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type variable = def_name(user_value1,user_value2,...);</span><br></pre></td></tr></table></figure>

<p>type：数据类型</p>
<p>variable：变量</p>
<p>user_value1：传入的参数，如果有多个用英文逗号隔开</p>
<h4 id="2-2-无返回值的函数的使用"><a href="#2-2-无返回值的函数的使用" class="headerlink" title="2.2 无返回值的函数的使用"></a>2.2 无返回值的函数的使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def_name(user_value1,user_value2,...);</span><br></pre></td></tr></table></figure>

<p>variable：变量</p>
<p>user_value1：传入的参数，如果有多个用英文逗号隔开</p>
<h3 id="3-函数的形参和实参"><a href="#3-函数的形参和实参" class="headerlink" title="3.函数的形参和实参"></a>3.函数的形参和实参</h3><p>函数的形参可以传入变量和指针，而两种方式需要的内存是不一样的</p>
<h4 id="3-1-函数的形参传入的是变量"><a href="#3-1-函数的形参传入的是变量" class="headerlink" title="3.1 函数的形参传入的是变量"></a>3.1 函数的形参传入的是变量</h4><p>这个很容易理解，就是在调用的时候传入的是变量的形式，如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    test(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是把a和b的变量传入到函数test中，然后在test中将传入进来的a，b拷贝下来，这样的话需要更多的空间给a，b，非常的消耗空间。</p>
<h4 id="3-2-函数的形参传入的是指针"><a href="#3-2-函数的形参传入的是指针" class="headerlink" title="3.2 函数的形参传入的是指针"></a>3.2 函数的形参传入的是指针</h4><p>这个是给函数传入指针变量，如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    test(&amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是直接把地址传入到函数里，在函数里只使用传入进去的地址，这样对内存的使用比较小，推荐使用。</p>
<h3 id="4-函数的返回值"><a href="#4-函数的返回值" class="headerlink" title="4.函数的返回值"></a>4.函数的返回值</h3><p>我们在使用函数的时候，有些时候是需要返回一些特定的值的，这个时候我们就需要让函数有返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> 返回的值;</span><br></pre></td></tr></table></figure>

<p>返回的值一定要和对应的类型相同，这样是规范的写法，如果不同，只要储存的大小合适则还是能运行的。</p>
<p>返回的值也可以是指针类型的</p>
<h2 id="九、指针"><a href="#九、指针" class="headerlink" title="九、指针"></a>九、指针</h2><h3 id="1-什么是指针"><a href="#1-什么是指针" class="headerlink" title="1.什么是指针"></a>1.什么是指针</h3><p>指针是编程语言中的一个对象，是将内存的地址赋值给指针变量。</p>
<p>它的值直接指向存在电脑存储器中另一个储存单元</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指针其实是地址</span><br><span class="line">地址就是变量</span><br><span class="line">指针就是变量</span><br><span class="line">存放地址的变量</span><br></pre></td></tr></table></figure>

<ul>
<li>指针是用于存放地址的，地址是唯一表示一块地址空间的</li>
<li>指针的大小在32位平台是4个字节，在64位平台上是8个字节</li>
</ul>
<p>指针类型决定了指针进行解引用操作的时候，能够访问空间的大小</p>
<p><code>int *p</code> 能够访问4个字节</p>
<p><code>char *p</code> 能够访问1个字节</p>
<p><code>double *p</code> 能够访问8个字节</p>
<p>指针类型决定了：指针走一步走多远（指针的步长）</p>
<p><code>int *p; --&gt; 4</code></p>
<p><code>char *p; --&gt; 1 </code></p>
<p><code>double *p; --&gt; 8</code></p>
<p>总结：指针的类型决定了指针向前或向后走一步有多大（距离）</p>
<h3 id="2-指针的使用"><a href="#2-指针的使用" class="headerlink" title="2.指针的使用"></a>2.指针的使用</h3><h4 id="（1）指针的定义"><a href="#（1）指针的定义" class="headerlink" title="（1）指针的定义"></a>（1）指针的定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(指针类型) *(指针名);</span><br><span class="line"><span class="comment">//变量方式</span></span><br><span class="line">(指针类型) *(指针名) = &amp;变量名;</span><br><span class="line"><span class="comment">//数组方式</span></span><br><span class="line">(指针类型) *(指针名) = 数组名;</span><br></pre></td></tr></table></figure>

<h4 id="（2）指针的赋值"><a href="#（2）指针的赋值" class="headerlink" title="（2）指针的赋值"></a>（2）指针的赋值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指针名 = &amp;变量名;</span><br></pre></td></tr></table></figure>

<h4 id="（3）指针类型"><a href="#（3）指针类型" class="headerlink" title="（3）指针类型"></a>（3）指针类型</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="type">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="type">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="type">char</span>   *ch;    <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* 访问<span class="number">4</span>个字节</span><br><span class="line"><span class="type">float</span>* 访问<span class="number">4</span>个字节</span><br><span class="line"><span class="type">char</span>* 访问<span class="number">1</span>个字节</span><br><span class="line"><span class="type">double</span>* 访问<span class="number">8</span>个字节</span><br></pre></td></tr></table></figure>

<h4 id="（4）如何使用指针"><a href="#（4）如何使用指针" class="headerlink" title="（4）如何使用指针"></a>（4）如何使用指针</h4><h3 id="3-野指针"><a href="#3-野指针" class="headerlink" title="3.野指针"></a>3.野指针</h3><p>概念：野指针就是指向的位置不可知的</p>
<h4 id="（1）导致野指针的原因"><a href="#（1）导致野指针的原因" class="headerlink" title="（1）导致野指针的原因"></a>（1）导致野指针的原因</h4><p>① 未初始化指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②指针越界访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *p = arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//当指针指向的范围超出数组arr的范围时，p就是野指针</span></span><br><span class="line">        *(p + i) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③指针指向的空间释放</p>
<h4 id="（2）如何避免野指针"><a href="#（2）如何避免野指针" class="headerlink" title="（2）如何避免野指针"></a>（2）如何避免野指针</h4><p>①指针初始化</p>
<p>②小心指针越界</p>
<p>③指针指向空间释放即用null占位</p>
<p>④指针使用之前检查有效性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// int a = 10;</span></span><br><span class="line">    <span class="comment">// int *p = &amp;a;//初始化</span></span><br><span class="line">    <span class="comment">// int *pa = NULL;//NULL - 用来初始化指针的，给指针赋值</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *pa = &amp;a;</span><br><span class="line">    *pa = <span class="number">20</span>;</span><br><span class="line">    pa = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pa != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *pa = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-指针运算"><a href="#4-指针运算" class="headerlink" title="4.指针运算"></a>4.指针运算</h3><ul>
<li>指针+-整数</li>
<li>指针-指针</li>
<li>指针的关系运算</li>
</ul>
<h4 id="指针-整数"><a href="#指针-整数" class="headerlink" title="指针+-整数"></a>指针+-整数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> *p = &amp;arr[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">        p--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针-指针"><a href="#指针-指针" class="headerlink" title="指针-指针"></a>指针-指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *start = str;</span><br><span class="line">    <span class="type">char</span> *end = str;</span><br><span class="line">    <span class="keyword">while</span> (*end != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end - start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//strlen - 求字符串长度</span></span><br><span class="line">    <span class="type">char</span> arr[] = <span class="string">&quot;bit&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = my_strlen(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针-指针可以得到这个数组的长度 - 1 </p>
<h3 id="5-指针和数组"><a href="#5-指针和数组" class="headerlink" title="5.指针和数组"></a>5.指针和数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);<span class="comment">//地址-首元素的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr);<span class="comment">//整个数组的地址</span></span><br><span class="line">    <span class="comment">//1.&amp;arr - &amp;数组名不是首元素的地址-数组名表示整个数组 - &amp;数组名 取出的是整个数组的地址</span></span><br><span class="line">    <span class="comment">//2.sizeof(arr) - sizeof(数组名) - 数组名表示的整个数组 - sizeof(数组名)计算的是整个数组的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：数组名表示的是数组首元素的地址</p>
<p><strong>注意：数组可以使用[]来修饰，但是指针使用[]来修饰</strong></p>
<h3 id="6-指针的关系运算"><a href="#6-指针的关系运算" class="headerlink" title="6.指针的关系运算"></a>6.指针的关系运算</h3><h4 id="（1）指针数组-数组指针"><a href="#（1）指针数组-数组指针" class="headerlink" title="（1）指针数组 &amp;&amp; 数组指针"></a>（1）指针数组 &amp;&amp; 数组指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指针数组 - 数组 - 存放指针的数组</span></span><br><span class="line"><span class="comment">//数组指针 - 指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b =<span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// int *pa = &amp;a;</span></span><br><span class="line">    <span class="comment">// int *pb = &amp;b;</span></span><br><span class="line">    <span class="comment">// int *pc = &amp;c;</span></span><br><span class="line">    <span class="comment">//整型数组 - 存放整型</span></span><br><span class="line">    <span class="comment">//字符数组 - 存放字符</span></span><br><span class="line">    <span class="comment">//指针数组 - 存放指针</span></span><br><span class="line">    <span class="type">int</span> *arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;<span class="comment">//指针数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-二级指针"><a href="#7-二级指针" class="headerlink" title="7.二级指针"></a>7.二级指针</h3><h4 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *pa = &amp;a;</span><br><span class="line">    <span class="type">int</span> **ppa = &amp;pa;<span class="comment">//ppa就是二级指针</span></span><br><span class="line">    <span class="comment">//int ***pppa = &amp;ppa;//pppa是三级指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）使用"><a href="#（2）使用" class="headerlink" title="（2）使用"></a>（2）使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *pa = &amp;a;</span><br><span class="line">    <span class="type">int</span> **ppa = &amp;pa;<span class="comment">//ppa就是二级指针</span></span><br><span class="line">    <span class="comment">//int ***pppa = &amp;ppa;//pppa是三级指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *ppa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, **ppa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）总结"><a href="#（3）总结" class="headerlink" title="（3）总结"></a>（3）总结</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>这句话的意思是将a的地址给p，然后*p得到的是a中的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ppa = &amp;pa;</span><br></pre></td></tr></table></figure>

<p><em>ppa存放的是pa指针中的地址，然后**ppa是</em>pa</p>
<h3 id="8-const修饰指针（一级指针）"><a href="#8-const修饰指针（一级指针）" class="headerlink" title="8.const修饰指针（一级指针）"></a>8.const修饰指针（一级指针）</h3><p>通常，我们的指针变量是可以随便使用的，但如果我们想让指针变量或者解引用的指针的内容不改变，那我们就需要使用 <code>const</code> 来修饰指针。</p>
<h4 id="8-1-const-在-左边"><a href="#8-1-const-在-左边" class="headerlink" title="8.1 const 在 * 左边"></a>8.1 const 在 * 左边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> * p;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p;</span><br></pre></td></tr></table></figure>

<p>const 在* 左边是修饰 *p的，通过这样修饰后，*p就不能再重新赋值了，*p的值是被固定了，但是指针变量p中的地址是可以重新赋值的。</p>
<h4 id="8-2-const-在-右边"><a href="#8-2-const-在-右边" class="headerlink" title="8.2 const 在 * 右边"></a>8.2 const 在 * 右边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<p>const 在* 右边是修饰 p的，通过这样修饰后，p就不能再重新赋值了，\p的值是被固定了，但是解引用*p中的值是可以重新赋值的。</p>
<h3 id="9-const修饰指针（二级指针）"><a href="#9-const修饰指针（二级指针）" class="headerlink" title="9.const修饰指针（二级指针）"></a>9.const修饰指针（二级指针）</h3><p>在二级指针中有三个位置可以加const修饰符</p>
<h4 id="9-1-在-的左边"><a href="#9-1-在-的左边" class="headerlink" title="9.1 在**的左边"></a>9.1 在**的左边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* *p;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * *p;</span><br></pre></td></tr></table></figure>

<p>const在**的左边是修饰**p的，但*p和p的值是可以改变的</p>
<h4 id="9-2-在-中间"><a href="#9-2-在-中间" class="headerlink" title="9.2 在**中间"></a>9.2 在**中间</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> *p;</span><br></pre></td></tr></table></figure>

<p>const在**的中间是修饰*p的，但**p和p的值是可以改变的</p>
<h4 id="9-3-在-的右边"><a href="#9-3-在-的右边" class="headerlink" title="9.3 在**的右边"></a>9.3 在**的右边</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* *<span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<p>const在**的右边是修饰p的，但**p和*p的值是可以改变的</p>
<h4 id="9-4-通过二级指针修改被const修饰的一级指针"><a href="#9-4-通过二级指针修改被const修饰的一级指针" class="headerlink" title="9.4 通过二级指针修改被const修饰的一级指针"></a>9.4 通过二级指针修改被const修饰的一级指针</h4><p>我们回顾上面讲const修饰符中，别const修饰的变量中的值能被一级指针所修改，那如果别const修改的一级指针能否别二级指针修改呢。</p>
<p>我们来试试：</p>
<p>我们有以下的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">5</span>, n = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p = &amp;m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个语句中，const是修饰指针变量p的，所以我们无法对p变量进行修改。（如下图）</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E8%A2%ABconst%E4%BF%AE%E9%A5%B0%E7%9A%84%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88.png"></p>
<p>但是如果我们通过二级指针来间接修改呢？</p>
<p>如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">5</span>, n = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p = &amp;m;</span><br><span class="line">    <span class="type">int</span>* *pp = &amp;pm;</span><br><span class="line">    *pp = &amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>我们声明了一个二级指针，然后给这个二级指针赋值一级指针的地址，然后我们对二级指针变量重新赋n的地址值，然后输出*p里面的内容。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9C%A8vs%E9%87%8C%E9%80%9A%E8%BF%87%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9const%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E4%BB%A3%E7%A0%81.png"></p>
<p>然后运行的结果：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9C%A8vs%E9%87%8C%E9%80%9A%E8%BF%87%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9const%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>我们可以看到，我们输出*p的结果已经改变，所以可以通过二级指针来修改被const修饰的一级指针的值。但是，这个方法只能在vs中才能运行成功，在dev-C++中就不能成功。如下图：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9C%A8dev%E9%87%8C%E9%80%9A%E8%BF%87%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9const%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E4%BB%A3%E7%A0%81.png"></p>
<p>可以看到这个直接就报错了，无法通过编译。</p>
<h2 id="十、结构体"><a href="#十、结构体" class="headerlink" title="十、结构体"></a>十、结构体</h2><p>在C语言中，结构是另一种用户自定义的可用数据类型，它允许您存储不同的数据类型，结构体是属于自定义数据结构。</p>
<h3 id="1-结构体的创建"><a href="#1-结构体的创建" class="headerlink" title="1.结构体的创建"></a>1.结构体的创建</h3><h4 id="1-1-第一种方法"><a href="#1-1-第一种方法" class="headerlink" title="1.1 第一种方法"></a>1.1 第一种方法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span></span><br><span class="line">    type name;</span><br><span class="line">    type name;</span><br><span class="line">    .........</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>tag</strong> 是结构体标签</p>
<p><strong>type</strong> 数据类型</p>
<p><strong>name</strong> 类型名字</p>
<h4 id="1-2-第二种方法"><a href="#1-2-第二种方法" class="headerlink" title="1.2 第二种方法"></a>1.2 第二种方法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span></span><br><span class="line">    type name;</span><br><span class="line">    type name;</span><br><span class="line">    .........</span><br><span class="line">&#125;tags;</span><br></pre></td></tr></table></figure>

<p>结尾后的<strong>tags</strong> 是结构的变量，是全局变量，也可以多指很多结构变量。</p>
<h4 id="1-3-全局结构体和局部结构体的声明"><a href="#1-3-全局结构体和局部结构体的声明" class="headerlink" title="1.3 全局结构体和局部结构体的声明"></a>1.3 全局结构体和局部结构体的声明</h4><p>全局结构体的声明是声明在函数外，局部结构体是声明在函数内。</p>
<h3 id="2-结构体的使用"><a href="#2-结构体的使用" class="headerlink" title="2.结构体的使用"></a>2.结构体的使用</h3><h4 id="2-1-局部结构体的声明-初始化"><a href="#2-1-局部结构体的声明-初始化" class="headerlink" title="2.1 局部结构体的声明 &amp; 初始化"></a>2.1 局部结构体的声明 &amp; 初始化</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> <span class="title">new_name</span> =</span> &#123;value1, value2, &#123;value3, value4&#125;, .....&#125;;  </span><br></pre></td></tr></table></figure>

<p><code>new_name</code> 声明的新名字</p>
<p><code>value</code> 声明的值，如果有多个值，需要使用{}括起来</p>
<p>value前面要有类型</p>
<h5 id="2-1-1-指针方法"><a href="#2-1-1-指针方法" class="headerlink" title="2.1.1 指针方法"></a>2.1.1 指针方法</h5><p>指针声明方法必须先对结构体进行声明，然后才能用指针声明</p>
<p>例一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> arr1[<span class="number">5</span>];</span><br><span class="line">        <span class="type">char</span> arr2[<span class="number">5</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span> =</span> &#123;<span class="number">1</span>, &#123;<span class="number">4</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>* <span class="title">pb</span> =</span> &amp;book;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>struct Books book &#x3D; {1, {4, 3}, {‘g’, ‘a’}}; </p>
<p>struct Books* pb &#x3D; &book; </p>
</blockquote>
<p>这个就是结构体的声明指针方法</p>
<h4 id="2-2-全局结构体全局的使用-初始化"><a href="#2-2-全局结构体全局的使用-初始化" class="headerlink" title="2.2 全局结构体全局的使用 &amp; 初始化"></a>2.2 全局结构体全局的使用 &amp; 初始化</h4><p>和局部结构体的声明和初始化一样</p>
<h3 id="3-结构体的输出"><a href="#3-结构体的输出" class="headerlink" title="3.结构体的输出"></a>3.结构体的输出</h3><h4 id="3-1-使用结构体变量的输出"><a href="#3-1-使用结构体变量的输出" class="headerlink" title="3.1 使用结构体变量的输出"></a>3.1 使用结构体变量的输出</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">结构体声明的变量 . 结构体中的值</span><br></pre></td></tr></table></figure>

<p>使用如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span>;</span></span><br><span class="line">    book.a = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, book.a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-使用指针变量的输出"><a href="#3-2-使用指针变量的输出" class="headerlink" title="3.2 使用指针变量的输出"></a>3.2 使用指针变量的输出</h4><h5 id="3-2-1-第一种方法"><a href="#3-2-1-第一种方法" class="headerlink" title="3.2.1 第一种方法"></a>3.2.1 第一种方法</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">指针变量 -&gt; 结构体中的值</span><br></pre></td></tr></table></figure>

<p>使用如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>* <span class="title">pb</span> =</span> &amp;b;</span><br><span class="line">    pb -&gt; a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, pb -&gt; a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2第二种方法"><a href="#3-2-2第二种方法" class="headerlink" title="3.2.2第二种方法"></a>3.2.2第二种方法</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(*指针变量) . 结构体中的值</span><br></pre></td></tr></table></figure>

<p>使用如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">b</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>* <span class="title">pb</span> =</span> &amp;b;</span><br><span class="line">    (*pb).a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (*pb).a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-结构体做函数的参数-结构体指针做函数的参数"><a href="#4-结构体做函数的参数-结构体指针做函数的参数" class="headerlink" title="4.结构体做函数的参数 &amp; 结构体指针做函数的参数"></a>4.结构体做函数的参数 &amp; 结构体指针做函数的参数</h3><h4 id="4-1结构体变量做参数"><a href="#4-1结构体变量做参数" class="headerlink" title="4.1结构体变量做参数"></a>4.1结构体变量做参数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Books b)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%c&quot;</span>, b.a, b.name[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span> =</span> &#123;<span class="number">5</span>, &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;&#125;;</span><br><span class="line">    Print(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2结构体指针做参数"><a href="#4-2结构体指针做参数" class="headerlink" title="4.2结构体指针做参数"></a>4.2结构体指针做参数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Books* b)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%c&quot;</span>, b-&gt;a, b-&gt;name[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">book</span> =</span> &#123;<span class="number">5</span>, &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;&#125;;</span><br><span class="line">    Print(&amp;book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-两种定义在内存中的模式"><a href="#4-3-两种定义在内存中的模式" class="headerlink" title="4.3 两种定义在内存中的模式"></a>4.3 两种定义在内存中的模式</h4><p>4.1的方式是在函数中将变量又重新拷贝一份，占用更多的空间，而且用完就会被释放，不能修改结构体内的值；而4.2的方法是将结构体的地址放入函数里，函数操作地址，内存的占用非常的少，能直接修改函数体内的值。</p>
<h2 id="十一、debug和release方法"><a href="#十一、debug和release方法" class="headerlink" title="十一、debug和release方法"></a>十一、debug和release方法</h2><h3 id="1-debug"><a href="#1-debug" class="headerlink" title="1.debug"></a>1.debug</h3><p>debug方法是提供给程序员调试的方法。调试时会生成很多配置文件。不会做任何优化</p>
<h3 id="2-release"><a href="#2-release" class="headerlink" title="2.release"></a>2.release</h3><p>release是提供用户使用的</p>
<h2 id="十二、文件操作"><a href="#十二、文件操作" class="headerlink" title="十二、文件操作"></a>十二、文件操作</h2><p>在C语言中可以很简单的打开文件进行一些操作，这里主要是在Windows环境下使用标准输入输出库函数的对文件操作。</p>
<h3 id="1-文件打开"><a href="#1-文件打开" class="headerlink" title="1.文件打开"></a>1.文件打开</h3><p>对文件操作的基础是将文件打开，如果不打开文件就没办法对文件中的内容进行操作。</p>
<p>文件打开的方法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* <span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * __restrict__ _Filename,<span class="type">const</span> <span class="type">char</span> * __restrict__ _Mode)</span></span><br></pre></td></tr></table></figure>

<p>第一个参数是你需要打开文件的路径，这里的路径可以是绝对路径或者是相对路径。</p>
<p>第二个参数是打开文件的方式，有下面几种方式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>只读方式</td>
</tr>
<tr>
<td>w</td>
<td>写入文件，如果文件不存在会创建出一个文件，如果文件中有内容会删除里面的内容</td>
</tr>
<tr>
<td>a</td>
<td>追加模式，如果文件不存在会创建出一个文件，如果里面有数据就往后写入</td>
</tr>
<tr>
<td>r+</td>
<td>允许读写文件</td>
</tr>
<tr>
<td>w+</td>
<td>允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件</td>
</tr>
<tr>
<td>a+</td>
<td>允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody></table>
<p>例如我打开一个文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* fd = <span class="literal">NULL</span>; <span class="comment">// 创建一个FILE类型的指针</span></span><br><span class="line">fd = fopen(<span class="string">&quot;E:\\a.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码就是打开一个文件，以追加的方式进行打开的。</p>
<h3 id="2-关闭文件"><a href="#2-关闭文件" class="headerlink" title="2.关闭文件"></a>2.关闭文件</h3><p>当我们打开文件后进行操作后是需要关闭，不关闭文件会导致文件一直处于一种打开状态，所以需要关闭文件，关闭文件的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">( FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>参数是刚才打开的文件，如果关闭文件出问题，这个函数会返回<code>EOF</code>，但是基本上关闭都是会成功的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fclose(fd);</span><br></pre></td></tr></table></figure>

<h3 id="3-写入内容"><a href="#3-写入内容" class="headerlink" title="3.写入内容"></a>3.写入内容</h3><p>打开文件后可以向文件中写入内容，写入的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> c, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数是可以向文件中光标位置处写入一个字符，比如说在文件中写入一个a字符，那代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fputc(<span class="string">&#x27;a&#x27;</span>, fd);</span><br></pre></td></tr></table></figure>

<p>如果要写入字符串也是可以的，使用下面的函数就可以写入一个字符串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>比如说我要写入一个”hello”，那语法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;hello&quot;</span>, fd);</span><br></pre></td></tr></table></figure>

<h3 id="4-读取内容"><a href="#4-读取内容" class="headerlink" title="4.读取内容"></a>4.读取内容</h3><p>使用的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">( FILE * fp )</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数可以读取文件中光标后的一个字符，读取后的内容是以返回值的方式进行输出，但是输出不了中文，它返回的只能是ASCII。</p>
<p>如果想读取中文，需要使用读取字符串的函数，函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *buf, <span class="type">int</span> n, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数是可以读取字符串，返回的就是你读取的字符串。</p>
<p>第一个参数是字符串存放的位置，需要定义一个数组进行接收。</p>
<p>第二个参数是读取字符串的个数。</p>
<p>第三个参数是文件指针。</p>
<p>比如说我读取一个文件中的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE* fd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    fd = fopen(<span class="string">&quot;E:\\a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">//以r的方式打开文件</span></span><br><span class="line">    fgets(buf, <span class="number">20</span>, fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fd);</span><br><span class="line">    fd = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-设置光标位置"><a href="#5-设置光标位置" class="headerlink" title="5.设置光标位置"></a>5.设置光标位置</h3><p>上面一直提到光标，在文件中光标的位置是非常重要的，就如同我们向一个<code>txt</code>文件中写入内容是需要设置光标位置的，光标的位置是你输入字符进入的位置。</p>
<p>设置光标位置的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE * fp, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>其中最后的一个参数是需要使用宏定义的，宏定义如下：</p>
<p><code>SEEK_SET</code>：设置光标在开头位置</p>
<p><code>SEEK_CUR</code>：设置光标在指定位置</p>
<p><code>SEEK_END</code>：设置光标在最后的位置</p>
<p>最后这个设置光标在指定位置第二个参数才有效。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言进阶</title>
    <url>/2025/01/16/9db92f684b04/</url>
    <content><![CDATA[<h1 id="C语言进阶"><a href="#C语言进阶" class="headerlink" title="C语言进阶"></a>C语言进阶</h1><h2 id="一、数据储存"><a href="#一、数据储存" class="headerlink" title="一、数据储存"></a>一、数据储存</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h3><p>C语言中，栈区是用于存放局部变量的。</p>
<p>栈区的使用习惯是：先使用高地址，再使用低地址</p>
<h3 id="2-release和debug的区别"><a href="#2-release和debug的区别" class="headerlink" title="2.release和debug的区别"></a>2.release和debug的区别</h3><p>在基础章节里说了，它们面向的对象是不一样的，但除了面向的对象不一样外还有一些地方也是不一样的，例如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道这样的写法会导致指针越界，但这串代码在debug和release中的运行结果是不一样的。</p>
<p>在debug中的运行结果如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/debug%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>可以看到这个是一个死循环了。</p>
<p>而在release中：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/release%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>他运行了几次就结束了。</p>
<p>为什么会出现上面的情况呢？这就需要介绍debug和release在内存中的储存了。</p>
<h4 id="2-1-debug的内存结构"><a href="#2-1-debug的内存结构" class="headerlink" title="2.1 debug的内存结构"></a>2.1 debug的内存结构</h4><p>我们知道，在栈中先进后用，加入我们还是使用上面的代码，我们输出一下 <code>i</code> 和 <code>arr</code>的地址。</p>
<p>代码如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8B%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%A3%E7%A0%81.png"></p>
<p>通过这一行代码我们可以输出在debug方式中局部变量的地址值</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/debug%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%80%BC.png"></p>
<p>我们可以看到，在debug方式运行后，<code>arr</code>变量的地址比<code>i</code>的地址低，在内存结构中，图是这样画的：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/debug%E5%86%85%E5%AD%98%E5%9B%BE.png"></p>
<p><code>arr</code>只有个数，所以索引的值为0-9</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/debug%E5%86%85%E5%AD%98%E5%9B%BE2.png"></p>
<p>从这个位置开始走，给它赋值为0，走着走着，到<code>arr</code>最后一个元素时，<code>i</code>的大小还没到12，<code>arr[i]</code>还要继续赋值，一直走到<code>i</code>地址的位置，然后将<code>i</code>又重新赋值为0</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/debug%E5%86%85%E5%AD%98%E5%9B%BE3.png"></p>
<p>一直重复该过程，就导致了死循环。</p>
<h4 id="2-2-release的内存结构"><a href="#2-2-release的内存结构" class="headerlink" title="2.2 release的内存结构"></a>2.2 release的内存结构</h4><p>我们还是通过上面的方法来进行分析，代码如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8B%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%A3%E7%A0%81.png"></p>
<p>然后运行的结果为：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/release%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%80%BC.png"></p>
<p>在release中，<code>arr</code>的地址要高于<code>i</code>变量的地址，所以无论我们索引是否超过数组<code>arr</code>内元素的值，所以变量<code>i</code>就不会被重新的覆盖，就不会出生死循环。</p>
<h3 id="3-数据在内存中存储"><a href="#3-数据在内存中存储" class="headerlink" title="3.数据在内存中存储"></a>3.数据在内存中存储</h3><h4 id="3-1-数据类型"><a href="#3-1-数据类型" class="headerlink" title="3.1 数据类型"></a>3.1 数据类型</h4><h5 id="3-1-1-整型"><a href="#3-1-1-整型" class="headerlink" title="3.1.1 整型"></a>3.1.1 整型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char</span><br><span class="line">    signed char</span><br><span class="line">    unsigned char</span><br><span class="line">short</span><br><span class="line">    signed short[int]</span><br><span class="line">    unsigned short[int]</span><br><span class="line">int</span><br><span class="line">    signed int</span><br><span class="line">    unsigned int</span><br><span class="line">long </span><br><span class="line">    signed long[int]</span><br><span class="line">    unsigned long[int]</span><br></pre></td></tr></table></figure>

<h5 id="3-1-2-浮点型"><a href="#3-1-2-浮点型" class="headerlink" title="3.1.2 浮点型"></a>3.1.2 浮点型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float</span><br><span class="line">double</span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-构造类型"><a href="#3-1-3-构造类型" class="headerlink" title="3.1.3 构造类型"></a>3.1.3 构造类型</h5><p>自定义类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组类型</span><br><span class="line">结构体类型 struct</span><br><span class="line">枚举类型enum</span><br><span class="line">联合体类型union</span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-指针类型"><a href="#3-1-4-指针类型" class="headerlink" title="3.1.4 指针类型"></a>3.1.4 指针类型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* p;</span><br><span class="line">char* p;</span><br><span class="line">float* p;</span><br><span class="line">void* p;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-5-空类型"><a href="#3-1-5-空类型" class="headerlink" title="3.1.5 空类型"></a>3.1.5 空类型</h5><p><code>void</code></p>
<p>用于：函数的返回类型 void test();</p>
<p>​	   函数参数 void test(void);</p>
<p>​	   指针 void* p;</p>
<h4 id="3-2-探究整型在内存中存储模式"><a href="#3-2-探究整型在内存中存储模式" class="headerlink" title="3.2 探究整型在内存中存储模式"></a>3.2 探究整型在内存中存储模式</h4><p>在探究这个问题的时候，我们拿一个代码在演示</p>
<p>如下的代码：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F1.png"></p>
<p>然后我们调用vs2019中的调试模式，注意，调试时请一定确定是在<code>debug</code> 模式下，否则调试会失败</p>
<p>打开后</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F2.png"></p>
<p>我们找到<code>调试</code>中的<code>窗口</code>，在里面找到<code>内存</code>,然后选择一个进行查看</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F3.png"></p>
<p>进去后我们可以看到，调试器并没有定位到我们创建的变量a上</p>
<p>所以我们要通过a的地址来查找a的地址，我们找到<code>&amp;a</code>能获得a的地址，所以我们在<code>查找</code>那一行输入</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F4.png"></p>
<p>然后按回车键</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F5.png"></p>
<p>我们知道，数据在内存中都以二进制的形式存储</p>
<p>对呀整数来说，整数二进制有3种表示形式</p>
<h5 id="3-2-1-原码、补码、反码"><a href="#3-2-1-原码、补码、反码" class="headerlink" title="3.2.1 原码、补码、反码"></a>3.2.1 原码、补码、反码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原码：十进制的二进制形式就是原码</span><br><span class="line">反码：符号位不变，其他的依次取反</span><br><span class="line">补码：反码加一，就可以得到反码</span><br></pre></td></tr></table></figure>

<p><strong>注：正数的原码、补码、反码相同</strong></p>
<p><code>int</code>类型的变量在内存中占4个字节，1个字节等于8个比特，所以就有32位二进制的数，为了方便我们查看，计算机转换为十六进制的数。</p>
<p>我们知道，4位二进制数等于一位十六进制数，然后32位二进制数就应该等于8个十六进制数，所以我们要将列改成4位</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F6.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8E%A2%E7%A9%B6%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%A8%A1%E5%BC%8F7.png"></p>
<p>改完之后就是这样的了</p>
<h5 id="3-2-2-原码、补码、反码-续"><a href="#3-2-2-原码、补码、反码-续" class="headerlink" title="3.2.2 原码、补码、反码(续)"></a>3.2.2 原码、补码、反码(续)</h5><p>刚刚只是简单介绍了一下原码、补码、反码，还说正数的原码、补码、反码相同，那负数呢？</p>
<p>现在我们介绍一下负数的原码、补码、反码的计算</p>
<p>例如：我们有一个a的值位-10，在<code>int</code>型中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = -10</span><br></pre></td></tr></table></figure>

<p>它的原码的形式是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 1010</span><br></pre></td></tr></table></figure>

<p>然后我们把原码转换为反码后，反码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 0101</span><br></pre></td></tr></table></figure>

<p>之后我们再将反码+1就可以得到补码，补码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 0110</span><br></pre></td></tr></table></figure>

<p>之后我们再把补码转换成十六进制的形式就得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>

<p>我们把刚刚的代码改变一下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%94%B9%E5%8F%981.png"></p>
<p>然后使用上面的方法来查看变量a中存放的数</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%94%B9%E5%8F%982.png"></p>
<p>我们可以看到，a变量中的-10存放的方式是以补码的形式存放的，所以我们就可以得出一个结论。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结论：数据在内存中是以补码的形式进行存放的</span><br></pre></td></tr></table></figure>

<p>为什么在内存中数据是以补码的形式进行存储的呢？</p>
<h5 id="3-2-3-为什么存放补码"><a href="#3-2-3-为什么存放补码" class="headerlink" title="3.2.3 为什么存放补码"></a>3.2.3 为什么存放补码</h5><p>我们知道，在CPU中只有加法器而没有减法器，我们要计算1-1其实是计算1+(-1)</p>
<p>，如果我们直接拿原码相加的话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1的原码0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-1的原码1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">结果：1000 0000 0000 0000 0000 0000 0000 0010</span><br></pre></td></tr></table></figure>

<p>上面的结果换算出来是-2，肯定是不对的，但如果我们用原码来计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1的原码0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-1的原码1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-1的补码1111 1111 1111 1111 1111 1111 1111 1110</span><br><span class="line">结果：1 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>我们发现它已经超出32位了，但是我们只能存放32位长度的数，所以33位的1要省略，所以最后的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>结果就为0。</p>
<p>补码和原码的互相转换是非常方便的，它们的电路是一样的，就比如-1的原码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>补码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>我们将补码取反再加1就能得到原码。</p>
<p>补码取反+1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>所以为什么数据在内存中存放的形式必须是补码了。</p>
<p>我们回到最上面，为什么我们自己算出来的是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>

<p>但在vs2019中的存储却是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F6 FF FF FF</span><br></pre></td></tr></table></figure>

<p>呢？</p>
<p>这个就是需要知道大端存储和小段存储了</p>
<h5 id="3-2-4-大端存储和小段存储"><a href="#3-2-4-大端存储和小段存储" class="headerlink" title="3.2.4 大端存储和小段存储"></a>3.2.4 大端存储和小段存储</h5><p>大端存储和小段存储是我们了解数据在内存中存储模式最需要了解的一个知识点</p>
<h6 id="3-2-4-1-大端和小段"><a href="#3-2-4-1-大端和小段" class="headerlink" title="3.2.4.1 大端和小段"></a>3.2.4.1 大端和小段</h6><p>在开始讲大端存储和小段存储之前，我们先了解一下数据的大端是什么，小段是什么，有微机接口原理基础的小伙伴可以跳过这一节。</p>
<p>我们先用十进制给大家说，在十进制中，数据从左到右位数越来越大，例如我们有一个数为5623，5为千位，6为百位，2为十位，3为个位，所以5就为这个数的大端，3为这个数的小段。</p>
<p>但上面的这个例子只是让大家知道大端是在左，小段是在右，在计算机内部并不是以上面那个例子来的。</p>
<p>在计算机中，数据是以二进制的形式存放的，我们这里拿两位十六进制数来举例子，如下图：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E6%AE%B5.png"></p>
<p>（2为十六进制数等于8位二进制数）</p>
<p>在这个数中，前4位为大端，后4位为小段</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E6%AE%B52.png"></p>
<p>这样我们就知道二进制的大端和小段的位在哪了。</p>
<h6 id="3-2-4-2-什么是大端存储"><a href="#3-2-4-2-什么是大端存储" class="headerlink" title="3.2.4.2 什么是大端存储"></a>3.2.4.2 什么是大端存储</h6><p>大端存储又可以叫<strong>大端字节序</strong></p>
<p>大端字节序是把数据的小段字节放在高地址处，把大端字节放在低位地址处。</p>
<p>举个例子：如果我们有一个数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1001 1100</span><br></pre></td></tr></table></figure>

<p>这个数据放在大端字节序中的存放方式是：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%A4%A7%E7%AB%AF%E5%AD%98%E5%82%A8.png"></p>
<h6 id="3-2-4-3-什么是小端存储"><a href="#3-2-4-3-什么是小端存储" class="headerlink" title="3.2.4.3 什么是小端存储"></a>3.2.4.3 什么是小端存储</h6><p>小端存储又可以叫<strong>小端字节序</strong></p>
<p>小段字节序是把数据的小端字节放在低地址处，把大端字节放在高地址处。</p>
<p>例如：我们拿-10的二进制来距离</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>

<p>用大端字节存储的话就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF FF FF F6</span><br></pre></td></tr></table></figure>
<p>我们拿大端存储的那个例子来说，在小端字节序中的存放方式是：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8.png"></p>
<h5 id="3-2-5-通过代码判断当前机器的字节序"><a href="#3-2-5-通过代码判断当前机器的字节序" class="headerlink" title="3.2.5 通过代码判断当前机器的字节序"></a>3.2.5 通过代码判断当前机器的字节序</h5><p>通过上面的内容我们了解了数据在内存中的存放形式，还有存储方式中的大端存储和小端存储，通过这些我们可以通过代码来判断，一个数的存放方式为大端还是小端了。</p>
<p><strong>补充：在调试的情况下，一般在左边的为低地址，右边为高地址</strong></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%B0%83%E8%AF%95.png"></p>
<p>接下来我们要写代码对大端和小端进行判断了。</p>
<p>我们现在有一个<code>int</code>型变量a，它里面的值为1（这里我们拿1来举例子）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>int</code>类型的数在内存中占4个字节，也就是32位，8个十六进制数，在内存中的存放为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 01</span><br></pre></td></tr></table></figure>

<p>如果它在小端存储的话，写法应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01 00 00 00</span><br></pre></td></tr></table></figure>

<p>如果是大端存储的话，写法应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 01</span><br></pre></td></tr></table></figure>

<p>所以我们要进行判断就需要判断第一个2位十六进制数即可。</p>
<p>问题又来了，我们该如何判断第一个2位十六进制数呢？我们知道<code>char</code>类型占一个字节，也就是8位，再换就是2个十六进制数，但我们要专门指向该用什么呢？</p>
<p>没错，就是使用指针，指针是指向地址的首地址值，如果指向的第一个数是1，那就证明是小端存储，而如果第一个数是0，则证明是大端存储。</p>
<p>所以我们代码就可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*)&amp;a;</span><br><span class="line">    <span class="keyword">if</span> ((*p) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端存储&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端存储&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一定要强制转换一下类型，虽然不会报错，但还是养成规范写法吧。</p>
<h5 id="3-2-6-练习"><a href="#3-2-6-练习" class="headerlink" title="3.2.6 练习"></a>3.2.6 练习</h5><h6 id="3-2-6-1-练习1"><a href="#3-2-6-1-练习1" class="headerlink" title="3.2.6.1 练习1"></a>3.2.6.1 练习1</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> b = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d,b = %d,c=%d&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**分析：**这道题考察的是原码补码的转换，还有不同类型的位数，和整型提升</p>
<p>-1的原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>然后转换为补码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>因为a是<code>char</code>类型的，所以要阶段，留8位，所以为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111</span><br></pre></td></tr></table></figure>

<p>但是输出需要整型提升，整型提升看有无符号位，如果有符号位，补1，没符号位补0，</p>
<p><code>char</code>类型有符号位，所以我们将<code>char</code>类型的-1补位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>然后计算它的原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>

<p>所以输出-1，<code>signed char</code>类型也是一样的。</p>
<p>但<code>unsigned char</code>整型提升是提升0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 1111 1111</span><br></pre></td></tr></table></figure>

<p>因为最高位是0，是正数，原码就等于补码，所以输出为：255</p>
<h6 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h6><h6 id="1-char-是-signed-char-还是-unsigned-char"><a href="#1-char-是-signed-char-还是-unsigned-char" class="headerlink" title="1.char 是 signed char 还是 unsigned char"></a>1.<code>char</code> 是 <code>signed char</code> 还是 <code>unsigned char</code></h6><p>C语言中是没有规定的，取决于编译器</p>
<h6 id="2-int-是signed-int-还是-unsigned-int"><a href="#2-int-是signed-int-还是-unsigned-int" class="headerlink" title="2.int 是signed int 还是 unsigned int"></a>2.<code>int</code> 是<code>signed int</code> 还是 <code>unsigned int</code></h6><p><code>int</code> 就是 <code>signed int</code></p>
<p><code>short</code> 默认 <code>signed short</code></p>
<h6 id="3-2-6-2-练习2"><a href="#3-2-6-2-练习2" class="headerlink" title="3.2.6.2 练习2"></a>3.2.6.2 练习2</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">-128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a);<span class="comment">//%u输出的是无符号的十进制数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>-128的二进制数为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 1000 0000</span><br></pre></td></tr></table></figure>

<p>补码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1000 0000</span><br></pre></td></tr></table></figure>

<p>因为是 <code>char</code> 类型进行存放的，所以只保留后8位，所以保存的形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000</span><br></pre></td></tr></table></figure>

<p>到输出位时，要求的是打印一个无符号的整数，所以要整型提升，整型提升时看存放的类型，在编译器中默认存储的是 <code>signed char</code> 类型的，所以前面补1，就得：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1000 0000</span><br></pre></td></tr></table></figure>

<p>因为需要打印的无符号数，所以最高位不是符号位，答案就为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4294967168</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE-%E7%BB%83%E4%B9%A02.png"></p>
<h6 id="3-2-6-3-练习3"><a href="#3-2-6-3-练习3" class="headerlink" title="3.2.6.3 练习3"></a>3.2.6.3 练习3</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题和练习2的答案一样。</p>
<p>128在内存中的存放是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 1000 0000</span><br></pre></td></tr></table></figure>

<p>但 <code>char</code> 只能存放8位，所以是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0000</span><br></pre></td></tr></table></figure>

<p>然后进行整型提升：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1000 0000</span><br></pre></td></tr></table></figure>

<p>所以答案是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4294967168</span><br></pre></td></tr></table></figure>

<h6 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h6><p>探讨char类型的取值范围</p>
<p>在char类型中可以存放8位比特位，所以在内存中可以取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char 0000 0000</span><br><span class="line">     0000 0001</span><br><span class="line">     0000 0010</span><br><span class="line">     0111 1111</span><br><span class="line">     1000 0000</span><br><span class="line">     1000 0001</span><br><span class="line">     ....</span><br><span class="line">     1111 1110</span><br><span class="line">     1111 1111</span><br></pre></td></tr></table></figure>

<p>前面0开头的都是正数，1开头的是负数，因为正数的原补码相同，所以前面存储的是0~127。</p>
<p>在负数中，我们要将补码变成原码，例如1111 1111的原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111</span><br></pre></td></tr></table></figure>

<p>然后取反加一就得原码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 0001</span><br></pre></td></tr></table></figure>

<p>我们转换一下这个数是不是等于-1。</p>
<p>一直这样算，1000 0001的原码是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111</span><br></pre></td></tr></table></figure>

<p>转换一下就是-127。</p>
<p>1000 0000这个数没有办法再进行计算了，它默认为-128</p>
<p>如果我们在 <code>char</code> 类型中存放128，它会默认为是-128。</p>
<h6 id="3-2-6-4-练习4"><a href="#3-2-6-4-练习4" class="headerlink" title="3.2.6.4 练习4"></a>3.2.6.4 练习4</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-20</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i + j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题非常的简单，重点就是二进制的加法，答案是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-10</span><br></pre></td></tr></table></figure>

<h6 id="3-2-6-5-练习5"><a href="#3-2-6-5-练习5" class="headerlink" title="3.2.6.5 练习5"></a>3.2.6.5 练习5</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是死循环，因为 <code>i</code> 是无符号数据，所以最小的是0。</p>
<h6 id="3-2-6-6-练习6"><a href="#3-2-6-6-练习6" class="headerlink" title="3.2.6.6 练习6"></a>3.2.6.6 练习6</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">-1</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">strlen</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong><code>char</code>类型有一个存储数据值的图：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/char%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE.png"></p>
<p>正常进行 <code>char</code> 类型加法的话，图应该是这样走的：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/char%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE1.png"></p>
<p>但是我们现在是进行减法，所以这幅图要倒着计算：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/char%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE2.png"></p>
<p>程序开始，整型-1-0，得到的结果为-1，-1-1，得到的结果为-2…..然后到-1-128，得到的结果为127。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/-128-1%E7%9A%84%E7%BB%93%E6%9E%9C.png"></p>
<p>继续相减，-1 - 254 &#x3D; 1，-1 - 255 &#x3D; 0，-1 - 256 &#x3D; -1….一直重复，直到不满足条件为止，然后执行 <code>strlen()</code> ，</p>
<p>这个函数是遇见 <code>\0</code> 就结束，我们知道 <code>\0</code> 就是 <code>0</code> ，所以就128 + 127 &#x3D; 255，结果就为255。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BB%83%E4%B9%A06%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<h6 id="3-2-6-7-练习7"><a href="#3-2-6-7-练习7" class="headerlink" title="3.2.6.7 练习7"></a>3.2.6.7 练习7</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**答案 **：死循环</p>
<p>**分析：**变量 <code>i</code> 的类型为 <code>unsigned char</code> ，最大值为255，当 <code>i</code> 到最大数后再加1就得0了，就变成了死循环了。</p>
<h4 id="3-3-探究浮点型在内存中存储模式"><a href="#3-3-探究浮点型在内存中存储模式" class="headerlink" title="3.3 探究浮点型在内存中存储模式"></a>3.3 探究浮点型在内存中存储模式</h4><p>在开始仔细研究浮点数在内存中的存储模式之前，我们先看下面的这一道练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">float</span>* pFloat = (<span class="type">float</span>*) &amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    </span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题很容易就会写错，大家可能觉得输出的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n的值为:9</span><br><span class="line">pFloat的值为:9.0</span><br><span class="line">n的值为:9</span><br><span class="line">pFloat的值为:9.0</span><br></pre></td></tr></table></figure>

<p>那这样就错了，我们拿到dev-c++中进行一下验证：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F.png"></p>
<p>是不是跟我们自己想的输出不一样，为什么会出现这种情况？这就要介绍一下浮点型数据在内存中存储模式了。</p>
<h5 id="3-3-1-在内存中浮点数的存储"><a href="#3-3-1-在内存中浮点数的存储" class="headerlink" title="3.3.1 在内存中浮点数的存储"></a>3.3.1 在内存中浮点数的存储</h5><p>在C语言中存储浮点数是按照IEEE 754的规则进行存储的。</p>
<p>IEEE 754规定存储浮点数的方式为：<code>S E M</code>。</p>
<ul>
<li><p>S：符号位，正数写0，负数为1.</p>
</li>
<li><p>E：指数。</p>
<p>对于指数E的情况是比较复杂的，因为一些时候指数为正数，而有些时候指数为负数，所以就找一个中间数，让指数在存储前需要加上中间数。对于8位E(也就是float数据)，中间数为127，而对于11位E(double型数据)，中间数为1023。</p>
</li>
<li><p>M：有效数字。</p>
<p>在存储时会省略小数点前的一个数，因为前面的那个数默认为1，因此可以被省略，拿出时只需要加上1即可。</p>
<p>留给M的位数：</p>
<p>float：23位</p>
<p>double：52位</p>
</li>
</ul>
<p>例如浮点数5.5f用二进制的形式转换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0101.1</span><br></pre></td></tr></table></figure>

<p>然后我们把它移动一下变为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.011 * 2^2</span><br></pre></td></tr></table></figure>

<p>s &#x3D; 0</p>
<p>M &#x3D; 1.011</p>
<p>E &#x3D; 2</p>
<p>因为是存在float中，所以E位要加127，在内存中的存储就应该为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0100 0000 1011 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>转换为十六进制为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40 B0 00 00</span><br></pre></td></tr></table></figure>

<p>我们在程序中走一下看看结果是不是一样</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/5.5f%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8.png"></p>
<p>倒着读，是不是和我们计算的一样呀。所以浮点数在内存中存储的方式也是分大小端的。</p>
<h5 id="3-3-2-从内存中读浮点数"><a href="#3-3-2-从内存中读浮点数" class="headerlink" title="3.3.2 从内存中读浮点数"></a>3.3.2 从内存中读浮点数</h5><p>从内存中读取浮点数的方法是需要具体分析的</p>
<h6 id="E不全为0或不全为1"><a href="#E不全为0或不全为1" class="headerlink" title="E不全为0或不全为1"></a>E不全为0或不全为1</h6><p>就那我们上面的5.5f举例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0100 0000 1011 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>这样子看有点复杂，我们把它写成<code>SEM</code>形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 10000001 01100000000000000000000</span><br></pre></td></tr></table></figure>

<p>我们将E减去刚才加的127，然后就得：0.011*2^2，之后我们把1加上去，就得1.011*2^2。转换一下就得101.1</p>
<h6 id="E为全0"><a href="#E为全0" class="headerlink" title="E为全0"></a>E为全0</h6><p>如果E为全0，那有效数字M前面不再加1。这样做是为表示+-0，以及接近0的数</p>
<h6 id="E为全1"><a href="#E为全1" class="headerlink" title="E为全1"></a>E为全1</h6><p>表示+-无穷大(正负有S决定)</p>
<p>我们知道浮点数在内存中的存储模式后，我们就可以分析最开始的那个题目了</p>
<h5 id="3-3-3-分析最开始的例子"><a href="#3-3-3-分析最开始的例子" class="headerlink" title="3.3.3 分析最开始的例子"></a>3.3.3 分析最开始的例子</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">float</span>* pFloat = (<span class="type">float</span>*) &amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    </span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pFloat的值为:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始时有一个<code>int</code>型变量n，n中的值为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 1001</span><br></pre></td></tr></table></figure>

<p>之后<code>float*</code>获取的直接是n变量的值，它默认上面n的二进制数为浮点数的形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 00000000 00000000000000000001001</span><br><span class="line">s = 0</span><br><span class="line">E = -127</span><br><span class="line">M = 00000000000000000001001</span><br></pre></td></tr></table></figure>

<p><code>printf(&quot;n的值为:%d\n&quot;, n);</code>这个输出没什么问题，只要是<code>printf(&quot;pFloat的值为:%f\n&quot;, *pFloat);</code>的输出</p>
<p>因为它默认为浮点数的存储方式，所以要输出出来就是要把上面二进制转换为十进制数，而上面这种情况是我们<code>E为全0</code>的形式，所以M位前面不+1。</p>
<p>转换的结果就为：1.001 * 2^-127，这个数接近为0，我们又知道，<code>%f</code>只能输出小数点后6位的数，所以第二个输出就为：0.000000</p>
<p>之后我们将指针变量<code>pFloat</code>中的内容修改为9.0，9.0的二进制为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1001.0</span><br></pre></td></tr></table></figure>

<p>在内存中的存储形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 10000010 00100000000000000000000</span><br></pre></td></tr></table></figure>

<p>执行代码<code>printf(&quot;n的值为:%d\n&quot;, n);</code>，输出是以<code>%d</code>整型的输出方式，直接将上面的二进制看成整型的二进制，最高位为0，所以是正数直接输出出来，答案就为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1091567616</span><br></pre></td></tr></table></figure>

<p>和我们执行代码输出的结果一样。</p>
<p>执行代码<code>printf(&quot;pFloat的值为:%f\n&quot;, *pFloat);</code>就将浮点型的二进制转换成十进制的浮点型。</p>
<h2 id="二、指针进阶"><a href="#二、指针进阶" class="headerlink" title="二、指针进阶"></a>二、指针进阶</h2><p>之前我们学了基础的指针，现在我们要对指针进行更深入的讲解。</p>
<p>我们知道</p>
<ul>
<li>指针就是个变量，用于存放地址的变量。</li>
<li>指针的大小是固定的4&#x2F;8个字节(32位&#x2F;64位)</li>
</ul>
<p>这些是比较基础的概念，我们讲指针进阶先从字符指针开始讲</p>
<h3 id="1-字符指针"><a href="#1-字符指针" class="headerlink" title="1.字符指针"></a>1.字符指针</h3><p>我们知道，在C语言中我们可以通过数组的方式来存储字符和字符串，但其实指针也可以存储字符串的。</p>
<p>例如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>* p = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个字符型指针<code>p</code>，但我们知道指针变量最高只能存放8个字节，但我们给<code>p</code> 赋值的变量有12个字节(最后的<code>\0</code>)，指针应该是存不下的，那为什么我们说指针可以存放字符串呢？</p>
<blockquote>
<p>是因为指针并不是存放这个字符串，而是存放字符串的首元素地址</p>
</blockquote>
<p>我们可以验证一下这个说法，我们将<code>*p</code>进行输出，如果输出的结果为<code>h</code>，则指针就是存放字符串的首元素地址。</p>
<p>我们在dev-c++中将代码写好</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88.png"></p>
<p>然后运行：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88/1-2.png"></p>
<p>看，结果是不是和我们猜想的一样</p>
<blockquote>
<p>字符指针存放的其实是字符串的首元素值</p>
</blockquote>
<p>可能有些同学会说是不是和数组一样的存放方式呀？</p>
<p>其实是不一样的，在数组中存放的是整个字符串，但是指针存放不了整个字符串，所以只能存放首元素的地址。</p>
<p>还有一点就是指针储存的字符串是不能修改里面的值的</p>
<p>例如：我们将首元素的地址中的元素修改</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-3.png"></p>
<p>运行的结果：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-4.png"></p>
<p>可以看出，我们使用指针方式是不能修改字符串中的字符的。</p>
<h4 id="1-1-面试题"><a href="#1-1-面试题" class="headerlink" title="1.1 面试题"></a>1.1 面试题</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* str3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* str4 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str1 == str2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 == str2&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 != str2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str3 == str4)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一道题会输出什么结果呢？</p>
<p>我们知道，数组是单独开辟一个空间来存放内容，但指针是使用的是共用的地址</p>
<p>我们从内存的角度进行分析，在内存中变量是存放在栈中</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-5.png"></p>
<p>我们创建了一个 <code>str1</code> 的数组，在栈中的存放：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-6.png"></p>
<p>然后在里面存放的值为”hello,world”， <code>str1</code> 指向就为：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-7.png"></p>
<p>之后我们又创建了一个变量 <code>str2</code> ，给它的值也为”hello,world”，但在数组变量中就算是相同的值也会重新开辟空间来存放</p>
<p>存放情况：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-8.png"></p>
<p>所以在数组变量中，我们在不同的数值中存放相同的值，它们的地址指向绝对不可能是相同的。</p>
<p>之后我们创建了一个 <code>char</code> 型的指针 <code>str3</code> ，创建完后在内存中会创建一个字符串”hello,world”</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-9.png"></p>
<p>然后指针 <code>str3</code> 就会指向创建出来的字符串的首元素地址</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-10.png"></p>
<p>之后又创建了一个 <code>char</code> 型的指针 <code>str4</code> ，这个指针指向的也是字符串”hello,world”，内存中已经存在字符串”hello,world”，所以就不需要再重新创建，指针 <code>str4</code> 直接指向创建出来的字符串”hello,world”了</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-11.png"></p>
<p>这两个指针都指向的是同一个字符串的首元素地址，所以它们的地址相同。</p>
<h3 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2.指针数组"></a>2.指针数组</h3><p>在前面我们知道，指针数组就是存放指针的数组，它的使用方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* arr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>上面的代码是一个数组中可以存放2个 <code>int</code> 型的指针变量。</p>
<p>使用的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="type">int</span>* arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;</span><br><span class="line">    <span class="comment">//输出内容</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个用法基本上没什么人使用。</p>
<p>一般指针数组的使用是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">5</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> c[<span class="number">5</span>] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* arr[<span class="number">3</span>] = &#123;a, b, c&#125;;</span><br><span class="line">    <span class="comment">//输出内容</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr[i] + j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将多个数组的地址存入一个数组中，方便使用。</p>
<p>上面那个代码的输出其实也可以写成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr[i][j]));</span><br></pre></td></tr></table></figure>

<p>使用解引用 <code>[]</code> 意思也是和+j一样的，只不过写法不一样。</p>
<p>在进阶内容中我们重点不是指针数组，指针数组在基础部分已经讲完了，现在的重点是我们在基础没有讲的一个知识，就是数组指针。</p>
<h3 id="3-数组指针"><a href="#3-数组指针" class="headerlink" title="3.数组指针"></a>3.数组指针</h3><p>我们前面学习了整型指针，浮点数正整，字符型指针，这些都是指针，数组指针也是一个指针</p>
<p>整型指针就是操作整型的指针，数组指针就是操作数组的指针。</p>
<h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><p>我们前面学过，数组名就是首元素的地址，我们 <code>&amp;数组名</code> 得到的是整个数组的地址，我们可以使用 <code>&amp;数组名</code> 来获取数组的地址然后存入指针中。</p>
<p>但这个数组指针如何定义？</p>
<p>数组指针的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> (*pa)[<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<p>怎么理解呢？</p>
<p>我们一步一步来</p>
<p>首先我们先写 <code>&amp;arr</code> ，这个获取的是 <code>arr</code> 的地址值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;arr;</span><br></pre></td></tr></table></figure>

<p>我们取了地址后需要一个指针来存放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*pa = &amp;arr;</span><br></pre></td></tr></table></figure>

<p>指针<code>pa</code>是需要有类型的，<code>pa</code>的类型是数组，而在C语言中要表示数组类型是用<code>type [number]</code>来表示的，所以我们可以按照这样来进行写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pa [<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<p>但是我们看，如果这样写，计算机会先将</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pa[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>结合在一起，然后就变成了指针数组，但我们 <code>*pa</code> 是在一起的，所以我们需要用括号将 <code>*pa</code></p>
<p>结合在一起</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*pa) [<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<p><strong>注：解引用<code>[]</code>中的值是该数组中的长度，要定义哪一个数组的指针，里面的值就为该数组的长度</strong></p>
<h4 id="3-2-指针数组和数组名"><a href="#3-2-指针数组和数组名" class="headerlink" title="3.2 指针数组和数组名"></a>3.2 指针数组和数组名</h4><p>在定义中说到，数组名就是首元素的地址，指针数组获取数组的地址是整个数组的地址，我们可以通过下面的程序来说明</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-014.png"></p>
<p>数组名和指针数组的地址都相同，那我们为什么还有指针数组这个东西呢？</p>
<p>我们用数组进行移位+1，得到的就是下一个元素的值</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-015.png"></p>
<p>我们使用一下数组指针进行一下位移看看会发生什么</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-016.png"></p>
<p>我们发现，通过数组指针+1后它直接就跳过20个字节，也就是一个数组</p>
<p>我们可以总结</p>
<blockquote>
<p>数组指针前进是跳过这个数组</p>
</blockquote>
<p>数组名就是首元素地址，但是有两个例外：</p>
<blockquote>
<p><code>sizeof</code>后的数组名代表的是整个数组，单位是字节</p>
<p>&amp;数组名表示的是整个数组，取出的是整个数组的地址</p>
</blockquote>
<h4 id="3-3-数组指针的使用"><a href="#3-3-数组指针的使用" class="headerlink" title="3.3 数组指针的使用"></a>3.3 数组指针的使用</h4><h5 id="3-3-1-一维数组中的使用"><a href="#3-3-1-一维数组中的使用" class="headerlink" title="3.3.1 一维数组中的使用"></a>3.3.1 一维数组中的使用</h5><p>数组指针<code>pa</code>中的地址是整个数组的地址，<code>*pa</code>就为数组本身</p>
<p>例如我们有一个数组名，我们需要使用数组指针将它全部打印出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*pa)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*pa)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>*pa</code>+<code>i</code>得出下一个位置的地址出来，然后再进行解引用输出出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*pa)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *((*pa) + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个的输出是一样的</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-017.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-018.png"></p>
<p>我们也可以把输出的功能放在函数中使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *((*pa) + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    print1(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在函数中的形参中定义的是数组指针，输出的结果和上面的结果一样</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-021.png"></p>
<p>但是一维数组基本上用不到数组指针，只有在二维数组中才能很好的使用</p>
<h5 id="3-3-2-二维数组中的使用"><a href="#3-3-2-二维数组中的使用" class="headerlink" title="3.3.2 二维数组中的使用"></a>3.3.2 二维数组中的使用</h5><p>一般使用二维数组的时候我们都是通过下面的代码来实现的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line">    print(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们使用一下数组指针的方式来输出一下二维数组中的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*(pa + i)) + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line">    print(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*(pa + i))[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line">    print(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组的数组名表示的是首元素的地址，二维数组首元素的地址是第一行，就比如我们上面的那个例子中的数组</p>
<p>二维数组的首元素的地址就是</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-019.png"></p>
<p>所以我们的数组指针其实指向的是二维数组中的第一行，如果我们用这一行的地址加1就直接跳过第一行的所有元素，然后到第二行</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-020.png"></p>
<p>所以我们的数组指针的正确指向其实是该数组每一行的长度。</p>
<p>输出的解释参考一维数组的输出即可，重点是二维数组的定义和指针到底指向的是哪一个地址。</p>
<h5 id="3-3-3-使用函数输出数组传入加-该怎么用"><a href="#3-3-3-使用函数输出数组传入加-该怎么用" class="headerlink" title="3.3.3 使用函数输出数组传入加&amp;该怎么用"></a>3.3.3 使用函数输出数组传入加<code>&amp;</code>该怎么用</h5><p>数组传入函数是传的地址值，我们可以在函数中使用指针或者数组来接受，一般都不使用 <code>&amp;</code> 取址符来获取数组的地址，但如果你偏要使用 <code>&amp;数组名</code> 那函数中该怎么写呢？</p>
<h6 id="3-3-3-1-一维数组中"><a href="#3-3-3-1-一维数组中" class="headerlink" title="3.3.3.1 一维数组中"></a>3.3.3.1 一维数组中</h6><p>如果是一维数组的话，传的数组参数必须加上 <code>&amp;</code></p>
<p>看下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">(<span class="type">int</span> (*pa) [<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*pa)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    print3(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还是用数组指针进行接受，在上面代码中数组指针 <code>pa</code> 接受的是整个数组的地址，我们没有办法对它进行+1的操作，操作后就会跳过整个数组。</p>
<p>在上面说到， <code>pa</code> 是数组地址， <code>*pa</code> 就是整个数组，所以我们可以直接通过<code>数组名[索引]</code> 来转换成指针的形式 <code>(*pa)[索引值]</code></p>
<p>当然我们也可以用下面的输出办法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">(<span class="type">int</span> (*pa) [<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *((*pa) + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    print3(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个原理也和上面的差不多，就是把 <code>[]</code> 转换为+了。</p>
<h6 id="3-3-3-2-二维数组中"><a href="#3-3-3-2-二维数组中" class="headerlink" title="3.3.3.2 二维数组中"></a>3.3.3.2 二维数组中</h6><p>在传二维数组的参数时我们一般都不添加 <code>&amp;</code> 符号</p>
<p>如果传入函数中我们传 <code>&amp;数组名</code> 那函数的形参该如何写呢？</p>
<p>用我们之前的那个函数的形参可以吗</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-022.png"></p>
<p>很显然这个方法是不行的</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-023.png"></p>
<p>我们可以通过上面学到的知识来说明这个问题</p>
<p>讲数组指针操作二维数组中说过，它获取的是二维数组的地址，二维数组的地址就是第一行的地址，我们其实是在对二维数组的行进行操作，也指定了操作的行的长度</p>
<p>而如果直接 <code>&amp;arr</code> ，其实是将整个二维数组的地址传到这个函数中，我们要对整个二维数组进行操作就需要定义数组指针的长度，因为是二维数组，所以是需要有两个长度的。所以我们定义就需要这样定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">3</span>][<span class="number">5</span>])</span></span><br></pre></td></tr></table></figure>

<p>这样才是对整个二维数组的操作的方式。</p>
<p>我们现在知道函数的形参如何定义的了，那该如何对整个二维数组进行操作呢？</p>
<p>其实也和一维数组的操作差不多</p>
<p>第一种方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">3</span>][<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*pa)[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    print2(&amp;arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们传入的是整个二维数组的地址，所以 <code>*pa</code> 直接就是二维数组 <code>arr</code> </p>
<p>我们可以通过 <code>*pa[][]</code> 来获取值</p>
<p>这个办法是很简单的，但还有一个办法，有点复杂，需要仔细想想</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">3</span>][<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*((*pa) + i) + j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    print2(&amp;arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个办法我们在3.3.2中说过，只不过那种直接加得到的就是该元素的值，而我们这里得到的其实是地址，所以还需要使用<code>*</code>来转义一下 ，才能得到值。</p>
<h5 id="3-3-4-分析几个例子"><a href="#3-3-4-分析几个例子" class="headerlink" title="3.3.4 分析几个例子"></a>3.3.4 分析几个例子</h5><p>我们先看下面的几个定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> parr1[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* parr2[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> (*parr3)[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> (*parr4[<span class="number">10</span>])[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>parr1很简单这就是数组</p>
</li>
<li><p>parr2也容易理解，是一个指针数组</p>
</li>
<li><p>parr3我们也学过，是一个数组指针</p>
</li>
<li><p>parr4有点复杂，我们之前没有见过。</p>
<p>我们可以一个一个的分析，看到<code>(*)</code>的就可以理解为一个数组指针，然后<code>parr4[10]</code>就是一个数组，这就是一个存储数组指针的数组，该数组存放的长度为10，每个数组指针能指向一个数组，然后指向的数组的长度是5</p>
</li>
</ul>
<h3 id="4-数组参数、指针参数"><a href="#4-数组参数、指针参数" class="headerlink" title="4.数组参数、指针参数"></a>4.数组参数、指针参数</h3><h4 id="4-1-一维数组传参"><a href="#4-1-一维数组传参" class="headerlink" title="4.1 一维数组传参"></a>4.1 一维数组传参</h4><p>在一维数组中，传参有几种方法是可以的</p>
<h5 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h5><p>形参是数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h5><p>形参是指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h5><p>形参是数组指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(&amp;arr, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h5><p>形参是指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* arr[<span class="number">20</span>], <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第五种"><a href="#第五种" class="headerlink" title="第五种"></a>第五种</h5><p>形参是二级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* *ppa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-二维数组传输"><a href="#4-2-二维数组传输" class="headerlink" title="4.2 二维数组传输"></a>4.2 二维数组传输</h4><h5 id="第一种-1"><a href="#第一种-1" class="headerlink" title="第一种"></a>第一种</h5><p>形参是二维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[][<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test(arr, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二种-1"><a href="#第二种-1" class="headerlink" title="第二种"></a>第二种</h5><p>形参是数组指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test1(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> (*pa)[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; left; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; right; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ((*pa) + i)[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不能写的"><a href="#不能写的" class="headerlink" title="不能写的"></a>不能写的</h5><p>形参为一级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* arr)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参为二级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> **pa, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test1(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> **pa, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参为指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span>* pa[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test1(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span>* pa[<span class="number">5</span>], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参为二维数组，但第二个 <code>[]</code> 中的数值省略</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[<span class="number">3</span>][])</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一定要看好传入的是什么类型的，要用相同的类型去接收</strong></p>
<h4 id="4-3-一级指针传参"><a href="#4-3-一级指针传参" class="headerlink" title="4.3 一级指针传参"></a>4.3 一级指针传参</h4><p>我们写一个程序的时候，一般是先写main函数里的东西，如果要传参数给函数也是规定好函数的形参是是什么形式的</p>
<p>例如我们下面写好了一个main函数，我们也规定函数test2中的形参为一个指针和一个整数来接受</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* p = arr;</span><br><span class="line">    test2(p, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们的函数的写法就如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(pa + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果我们有一个写好的函数，我们需要使用，能给这个函数传什么值进去呢？</p>
<p>例如下面的这个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span>* pa)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看，我们有一个函数，形参是一个指针，我们需要给这个函数传参数，只能选择传地址。</p>
<p>主函数main中有一个 <code>char</code> 类型的变量a</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要把这个值传入函数中其实有两种写法</p>
<p>第一种直接就是把a的地址传入函数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    print(&amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种写法就是用一个指针来接收a的地址，然后再传入函数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="type">char</span>* pa = &amp;a;</span><br><span class="line">    print(pa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式都要明白，传一级指针用什么接收，形参为一级指针该传什么值我们需要明白。</p>
<h4 id="4-4-二级指针传参"><a href="#4-4-二级指针传参" class="headerlink" title="4.4 二级指针传参"></a>4.4 二级指针传参</h4><p>当有一个二级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* pa = &amp;a;</span><br><span class="line">    <span class="type">int</span>** ppa = &amp;pa;</span><br><span class="line">    print(ppa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要将这个二级指针传给一个函数中使用，函数的形参的写法可以是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>** ppa)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, **ppa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那反过来，如果这个函数写好了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>** ppa)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**ppa)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该传什么值呢？有两种办法</p>
<p>第一种：</p>
<p>我们直接将定义的一级指针的地址传进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* pa = &amp;a;</span><br><span class="line">    print(&amp;pa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式是定义二级指针，然后把二级指针传进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* pa = &amp;a;</span><br><span class="line">    <span class="type">int</span>** ppa = &amp;pa;</span><br><span class="line">    print(ppa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种方式是把指针数组传进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    print(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组中是存放一级指针，所以可以使用二级指针的方式来接收，但尽量不要使用该方法，有可能会出现野指针的情况。</p>
<p>内容不是很难，重点是要将这些方法记住，并且能熟练的使用。</p>
<h3 id="5-函数指针"><a href="#5-函数指针" class="headerlink" title="5.函数指针"></a>5.函数指针</h3><p>在C语言中，所有的数据都有它的地址，整型变量、数组等都有地址，在函数中，函数也是有地址的，比如我们创建一个函数来输出它的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;Add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-024.png"></p>
<p>所以函数是有地址的，只要有地址就可以使用指针来进行接收</p>
<h4 id="5-1-函数指针的定义"><a href="#5-1-函数指针的定义" class="headerlink" title="5.1 函数指针的定义"></a>5.1 函数指针的定义</h4><p>可以结合数组指针的定义来互相推</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数返回值类型 (*指针名)(形参类型) = &amp;函数名</span><br></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初学的时候，可能会写成下面这个样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *<span class="title function_">pa</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> = &amp;Add;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个写法是错误的，因为 <code>*</code> 的结合优先级低，会让 <code>pa(int x, int y)</code> 先进行结合，然后再和 <code>*</code> 结合。</p>
<h4 id="5-2-函数指针的使用"><a href="#5-2-函数指针的使用" class="headerlink" title="5.2 函数指针的使用"></a>5.2 函数指针的使用</h4><p>定义就是为了使用，定义好之后该如何进行使用，是需要知道的重点。</p>
<p>从上面定义知道， <code>pa</code> 是函数 <code>Add</code> 的地址，在前面如果加上 <code>*</code> 就直接是函数了，所以可以这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> sum = (*pa)(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-025.png"></p>
<p>答案是没有问题的。</p>
<h4 id="5-3-探究函数的地址"><a href="#5-3-探究函数的地址" class="headerlink" title="5.3 探究函数的地址"></a>5.3 探究函数的地址</h4><p>在数组前面说过输出数组的地址可以用 <code>&amp;数组名</code> ，也可以直接使用 <code>数组名</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-026.png"></p>
<p>带入函数中，<code>&amp;函数名</code> 是函数的地址，那直接输出 <code>函数名</code> 得到的是不是函数的地址呢？</p>
<p>测试一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;Add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, Add);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-027.png"></p>
<p>通过上面的运行结果，可以发现，使用 <code>&amp;函数名</code> 和 <code>函数名</code> 的输出结果是一样的，所以可以总结为</p>
<blockquote>
<p>函数名是函数的地址</p>
</blockquote>
<p>在使用的时候是直接通过</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数名();</span><br></pre></td></tr></table></figure>

<p>进行调用的</p>
<p>可以尝试直接使用指针名来调用函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> sum = pa(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-028.png"></p>
<p>可以看出，直接用指针名也可以调用函数，所以可以总结</p>
<blockquote>
<p>可以使用函数指针直接调用函数</p>
<p>但不能使用数组指针直接调用数组</p>
</blockquote>
<p>当然，将函数的地址传给函数指针的时候也可以不添加 <code>&amp;</code> 就可以获得函数的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>) = Add;</span><br><span class="line">    <span class="type">int</span> x = pa(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-033.png"></p>
<h4 id="5-4-阅读代码"><a href="#5-4-阅读代码" class="headerlink" title="5.4 阅读代码"></a>5.4 阅读代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*(<span class="type">void</span> (*)())<span class="number">0</span>)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>出处：C陷阱和缺陷</p>
</blockquote>
<p>这段代码得一步一步分析，<code>void (*)()</code> 是一个函数指针类型，它将 <code>0</code> 强制类型转换成一个函数指针的地址</p>
<p>然后对其解引用 <code>*(void (*)()0)</code> 后进行了调用</p>
<p><code>(*(void (*)()0))()</code> 。</p>
<p>也就是调用了地址为0处的函数，它的返回值为0，无形参。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (* signal(<span class="type">int</span>, <span class="type">void</span>(*)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数其实就是指针函数套一个指针函数</p>
<p>先看 <code>signal(int, void(*)(int))</code> 这是一个函数，第一个参数是 <code>int</code> 第二个参数是指向返回值为 <code>void</code> 形参为 <code>int</code> 的函数。</p>
<p>而这个函数它的返回值为一个函数指针。这个函数指针是指向返回值为 <code>void</code> ，形参为 <code>int</code> 的函数。</p>
<p>简化一下这个代码就能能看懂了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*) (<span class="type">int</span>) signal(<span class="type">int</span>, <span class="type">void</span> (*)(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>这个函数的返回类型是一个函数指针类型，但是这种写法在C语言中是不能支持的，如果一个函数的返回类型是函数指针类型，那它的写法只能是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (* (signal(<span class="type">int</span>, <span class="type">void</span> (*)(<span class="type">int</span>)))) (<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-029.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-030.png"></p>
<p>如果真的要简化其实也是可以的，可以使用 <code>typedef</code> 对类型重命名</p>
<p>在讲用 <code>typedef</code> 简化前，先把前面漏的东西补充一下</p>
<h5 id="5-4-1-typedef"><a href="#5-4-1-typedef" class="headerlink" title="5.4.1 typedef"></a>5.4.1 <code>typedef</code></h5><p><code>typedef</code> 的作用就是对类型进行重新命名</p>
<p>比如要将 <code>unsigned int</code> 类型名字变成 <code>ui</code> 来使用，就需要在程序中这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line">    ui i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行的结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-031.png"></p>
<p>如果你要将一个函数指针重新命名使用下面的代码是不行的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span> <span class="type">pfun_t</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-032.png"></p>
<blockquote>
<p>这个和5.4中的不能简化的那个一样</p>
</blockquote>
<p>如果要给函数指针重新命名只能写成下面的样子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* <span class="type">pfun_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写成这样就不会出现问题了</p>
<p>现在就可以进行简化了，将函数指针类型重新命名，然后再使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* <span class="type">pfun_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">pfun_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> (*)(<span class="type">int</span>))</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看是不是更好的就明白这个代码的意思了。</p>
<h3 id="6-函数指针数组"><a href="#6-函数指针数组" class="headerlink" title="6.函数指针数组"></a>6.函数指针数组</h3><p>之前学过指针数组，指针数组就是存放指针的数组</p>
<p>例如需要有一个数组来存放5个整型指针，那代码可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* pa[<span class="number">5</span>]; </span><br></pre></td></tr></table></figure>

<p>那函数指针数组不就是存放函数指针的一个数组吗，按照上面的写法改一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*)() pa[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>但是从上面知道，不能这样写的，虽然 <code>int(*)()</code> 是函数指针类型，但是不能放在前面，数组名放在后面，而是要把数组名和 <code>*</code> 放在一起</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* pa[<span class="number">5</span>])();</span><br></pre></td></tr></table></figure>

<h4 id="6-1-使用例子"><a href="#6-1-使用例子" class="headerlink" title="6.1 使用例子"></a>6.1 使用例子</h4><p>例如有两个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这两个函数的返回值类型和形参类型都一样，可以直接使用一个函数指针数组将它存放在里面</p>
<p>main函数就可以这么写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;Add, Sub&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接写的是函数的名字，因为在5.3中讲到，函数名就是函数的地址，所以这直接可以将函数名存储在函数指针中。</p>
<p>也可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pA)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> (*pS)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Sub;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;pA, pS&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-函数指针数组的使用"><a href="#6-2-函数指针数组的使用" class="headerlink" title="6.2 函数指针数组的使用"></a>6.2 函数指针数组的使用</h4><p>和查找数组中元素的方法一样，通过数组的索引来查找，只不过这里得到的是函数的地址，但前面说过，函数名就是函数地址，可以直接通过函数地址来调函数</p>
<p>还是用上面那个例子，已经将函数指针存放在函数指针数组中后，进行调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*pA)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Add;</span><br><span class="line">    <span class="type">int</span> (*pS)(<span class="type">int</span>, <span class="type">int</span>) = &amp;Sub;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;pA, pS&#125;;</span><br><span class="line">    <span class="type">int</span> x = pa[<span class="number">0</span>](<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-034.png"></p>
<p>知道函数指针数组的使用后，就可以找一个项目来练习了。</p>
<h4 id="6-3-计数器项目"><a href="#6-3-计数器项目" class="headerlink" title="6.3 计数器项目"></a>6.3 计数器项目</h4><p>需要写一个程序，这个程序能做整型的加减乘除。</p>
<p>在没有学会函数指针数组前，写的程序应该是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">switch</span>(input)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Add(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Sub(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Mul(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:	</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Div(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这个程序可以执行，但是有很多地方有冗余(rong yu)，重复得太多是不好的，可以使用函数指针数组来代替，因为这些函数都是同样的返回类型和同样的形参，所以可以使用函数指针数组来替代</p>
<p>替代之后的程序就为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> (*pa[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;Add, Sub, Mul, Div&#125;;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> arr_size = <span class="keyword">sizeof</span>(pa) / <span class="keyword">sizeof</span>(pa[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">if</span> (input &lt; (arr_size - <span class="number">1</span>) &amp;&amp; input != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">            res = (pa[input - <span class="number">1</span>])(num1, num2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;res = %d\n&quot;</span>, res);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(input &gt; (arr_size - <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉上面的代码比之前的代码要简单且没造成冗余，这个使用了函数指针数组，通过函数指针数组存放函数地址，然后再通过函数指针数组的索引调用函数，这样就不用一直用 <code>switch</code> 和 <code>case</code> 进行反复判断，而且在后面需要增加新功能时也能很好的添加。</p>
<p>这种方法用专业的说法就是：转义表</p>
<blockquote>
<p>在《C和指针》中提到</p>
</blockquote>
<h4 id="6-4-取函数指针数组的地址"><a href="#6-4-取函数指针数组的地址" class="headerlink" title="6.4 取函数指针数组的地址"></a>6.4 取函数指针数组的地址</h4><p>之前学数组的时候知道，数组名就是数组地址，只要是地址就可以用指针来接收</p>
<p>比如说有一个整型变量 <code>a</code> ，可以使用一个整型指针来进行接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* pa = &amp;a;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向【整型】的指针</p>
</blockquote>
<p>比如说现在有一个数组，需要获得这个数组的地址，可以使用数组指针来进行接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> (*pa)[<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向【数组】的指针</p>
</blockquote>
<p>再比如说有一个指针数组，需要获取指针数组的地址，可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* arr[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* (*pa)[<span class="number">5</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向【整型指针的数组】的指针</p>
</blockquote>
<p>那现在有一个函数指针，取它的地址值，用函数指针数组来接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (* pa[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) = &amp;pa</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pa是指向函数指针的数组</p>
</blockquote>
<p>那现在需要将函数指针数组的地址取出来，用一个指针来接收地址，那这个类型该如何写呢？</p>
<p>现在一步一步进行分析</p>
<p>有一个函数指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* pa[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>取这个数组的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;pa;</span><br></pre></td></tr></table></figure>

<p>用一个指针进行接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*ppa = &amp;pa;</span><br></pre></td></tr></table></figure>

<p>但这个类型应该为函数指针的数组，所以类型应该为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* [<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>如果直接把指针名加到后面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* [<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) (*ppa);</span><br></pre></td></tr></table></figure>

<p>是不可以的，可以参考5.4，所以应该写为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (* (*ppa)[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">int</span>) = &amp;pa;</span><br></pre></td></tr></table></figure>

<p><strong>本节内容了解即可</strong></p>
<h3 id="7-回调函数"><a href="#7-回调函数" class="headerlink" title="7.回调函数"></a>7.回调函数</h3><h4 id="7-1-什么是回调函数"><a href="#7-1-什么是回调函数" class="headerlink" title="7.1 什么是回调函数"></a>7.1 什么是回调函数</h4><p>回调函数可以理解为函数的形参是函数指针，并且在函数中调用函数指针。</p>
<p>例如有一个a函数，需要它在b函数中使用</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-035.png"></p>
<p>它的传送就是这个样子。</p>
<h4 id="7-2-计算器-回调函数"><a href="#7-2-计算器-回调函数" class="headerlink" title="7.2 计算器(回调函数)"></a>7.2 计算器(回调函数)</h4><p>继续使用6.3的计数器的例子，这里使用的是没有进行优化的版本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">switch</span>(input)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Add(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Sub(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Mul(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:	</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">                res = Div(num1, num2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有用函数指针数值进行优化的例子中有好多地方冗余，其实可以把冗余的部分放在一个函数中，使用的时候直接调用函数即可。</p>
<p>但在每一行都调了不同的函数，所以就需要使用回调函数在重新定义的函数中调用</p>
<p>优化后的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***1.Add   2.Sub***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;***3.Mul   4.Div***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****** 0.exit *****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*******************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Cope</span><span class="params">(<span class="type">int</span> (*pa)(<span class="type">int</span>, <span class="type">int</span>))</span>&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input two number-&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">    <span class="keyword">return</span> pa(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please input-&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">switch</span>(input)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                res = Cope(&amp;Add);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                res = Cope(&amp;Sub);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                res = Cope(&amp;Mul);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:	</span><br><span class="line">                res = Cope(&amp;Div);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;end in = %d\n&quot;</span>, res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;process exit&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;resume load\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-快速排序函数"><a href="#8-快速排序函数" class="headerlink" title="8.快速排序函数"></a>8.快速排序函数</h3><p>在讲数值的时候讲到了一个冒泡排序的算法，但这种方法只能对整型数组进行排序，无法对其他类型进行排序，所以要介绍一种可以对任意类型进行排序的函数 <code>qsort</code></p>
<h4 id="8-1-qsort-的结构"><a href="#8-1-qsort-的结构" class="headerlink" title="8.1 qsort 的结构"></a>8.1 <code>qsort</code> 的结构</h4><p>在学习一个函数时，需要了解这个函数的形参和返回值。</p>
<p>可以通过 <code>cplusplus</code> 网站来查找这个函数的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span> <span class="params">(<span class="type">void</span>* base, <span class="type">size_t</span> num, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span>*,<span class="type">const</span> <span class="type">void</span>*))</span>;</span><br></pre></td></tr></table></figure>

<p>上面的就是 <code>qsort</code> 函数的形参，现在一步一步分析，等后面就可以自己仿照写一个 <code>qsort</code> 函数了。</p>
<p>首先看第一个形参 <code>base</code>，是一个无类型的指针，因为函数一开始的设计者考虑到使用者可能会使用其他类型的值，所以直接就使用无类型的指针来接收。而这个接收的是需要排序的数组&#x2F;结构体的地址</p>
<p>再看第二个形参 <code>num</code>，这个参数的功能是接收数组的长度的，之前在写冒泡排序的时候也有这一个参数。</p>
<p>第三个形参 <code>size</code>，这个函数的第一个形参接收的是一个无类型的指针，不是指定形式的指针，没办法通过+1来查找下一个数，所以需要用户提交一下这个数组类型的大小。</p>
<p>最后一个形参是一个函数指针，指向的函数的返回值为 <code>int</code>，两个形参都为无符号的指针。这个是需要用户自己写一个函数然后传进去，这个函数的功能主要是提供一个判断数，用这个判断数来决定是用升序还是降序，而返回的值要么大于1(&gt;1)，要么等于1(&#x3D;1)，要么小于1(&lt;1)。</p>
<p>上面的内容可以会容易迷糊，所以举个使用例子</p>
<h4 id="8-2-qsort-的使用-数组"><a href="#8-2-qsort-的使用-数组" class="headerlink" title="8.2 qsort 的使用(数组)"></a>8.2 <code>qsort</code> 的使用(数组)</h4><p>先拿一个<code>int</code>型的数组来进行一下排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中调用一下 <code>qsort</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    qsort();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就需要传函数的参数了，第一个参数是一个指针，所以需要把数组名传入，第二个是数组的长度，所以需要使用 <code>sizeof</code> 来计算，并传进去，第三个参数是类型的大小，也可以用 <code>sizeof</code> 来计算，所以前3个参数可以这么写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最难写的是第四个参数，需要使用者自己写一个判断函数，在官方文档中的写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">int</span>*)pa) - *((<span class="type">int</span>*)pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下，因为无类型的指针没有办法取得对应位置的值，所以需要强制类型转换一下，把类型转换成数组的类型进行计算，计算完后需要取到返回值，得到返回值后就可以进行排序了。</p>
<p>完善一下写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">int</span>*)pa) - *((<span class="type">int</span>*)pb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在dev++中演示一下运行的结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-036.png"></p>
<p>如果这个函数只能对整型或者浮点型进行排序的话，就没有必要花时间来说了。</p>
<p>现在来对字符数组进行一下排序</p>
<h4 id="8-3-qsort-的使用-字符数组"><a href="#8-3-qsort-的使用-字符数组" class="headerlink" title="8.3 qsort 的使用(字符数组)"></a>8.3 <code>qsort</code> 的使用(字符数组)</h4><p>在C语言中，存放字符其实是存放该字符的ASCII码，所以字符也是可以比较大小的，还是按照上面的写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">char</span>*)pa - *(<span class="type">char</span>*)pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[] = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), i;</span><br><span class="line">    qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-037.png"></p>
<p>现在来测试一下结构体中的数组的排序</p>
<h4 id="8-4-qsort-的使用-结构体"><a href="#8-4-qsort-的使用-结构体" class="headerlink" title="8.4 qsort 的使用(结构体)"></a>8.4 <code>qsort</code> 的使用(结构体)</h4><p>结构体中的数组的排列和上面的一样，先创建出一个记录学生消息的结构体 <code>Stu</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>name</code> 用于存放学生的名字</p>
<p><code>age</code> 用来存放年龄</p>
<p>之后写主函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&#x27;b&#x27;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>&#125;&#125;;<span class="comment">//1</span></span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);<span class="comment">//2</span></span><br><span class="line">    qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %d\n&quot;</span>, stu[i].name, stu[i].age);<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个语句是创建一个结构体类型的数组 <code>stu</code> 并赋值</p>
<p>第二条语句是获取结构体数组的长度。</p>
<p>第三条语句就是调用一下 <code>qsort</code> 函数来进行排序，其中 <code>cmp</code> 函数的内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa)-&gt;age - ((<span class="keyword">struct</span> Stu*)pb)-&gt;age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为传入的是结构体，所以要按照结构体的写法来进行书写，需要对年龄进行排序，就调用 <code>age</code> ，如果需要对名字进行排序就调用  <code>name</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa)-&gt;name - ((<span class="keyword">struct</span> Stu*)pb)-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到上面，第四条语句是将结果打印出来，方便观察数据是否被修改。</p>
<p>上面的名字只是一个字符，如果按照真实的情况下，名字是一个字符串，如果要对字符串名字进行排序，那该如何写呢？</p>
<h4 id="8-5-qsort-的使用-结构体更改"><a href="#8-5-qsort-的使用-结构体更改" class="headerlink" title="8.5 qsort 的使用(结构体更改)"></a>8.5 <code>qsort</code> 的使用(结构体更改)</h4><p>现在需要结构体中的 <code>name</code> 存放字符串，所以要对结构体进行一下修改，只需要把它变成一个数组即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要介绍一个比较字符串大小的一个函数 <code>strcmp</code></p>
<h5 id="8-5-1-strcmp"><a href="#8-5-1-strcmp" class="headerlink" title="8.5.1 strcmp"></a>8.5.1 <code>strcmp</code></h5><p>比较字符的内核就是比较它们之间的ASCII码值，而比较字符串的办法也是一样的，只不过比较繁琐，不适合在开发中花时间写，所以C语言的工程师很贴心的写好了比较字符串的函数，用户可以直接使用</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-068.png"></p>
<p>继续回到上面，现在已经学会了 <code>strcmp</code> 函数后，可以使用三种办法来解决上面的问题</p>
<h5 id="8-5-2-第一种办法"><a href="#8-5-2-第一种办法" class="headerlink" title="8.5.2 第一种办法"></a>8.5.2 第一种办法</h5><p>第一种办法就是直接调用 <code>strcmp</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(((<span class="keyword">struct</span> Stu*)pa)-&gt;name, ((<span class="keyword">struct</span> Stu*)pb) -&gt; name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&quot;aike&quot;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&quot;js&quot;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&quot;sjd&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);</span><br><span class="line">    qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, stu[i].name, stu[i].age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>strcmp</code> 的返回值是1，-1，0，所以直接就可以返回。</p>
<h5 id="8-5-3-第二种方法"><a href="#8-5-3-第二种方法" class="headerlink" title="8.5.3 第二种方法"></a>8.5.3 第二种方法</h5><p>直接使用 <code>-</code> 来获得</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa)-&gt;name - ((<span class="keyword">struct</span> Stu*)pb)-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&quot;aike&quot;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&quot;js&quot;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&quot;sjd&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);</span><br><span class="line">    qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, stu[i].name, stu[i].age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法也可以得到排序的结果。</p>
<h5 id="8-5-4-第三种方法"><a href="#8-5-4-第三种方法" class="headerlink" title="8.5.4 第三种方法"></a>8.5.4 第三种方法</h5><p>这种方法特别不推荐，这种方法主要是让自己写一个 <code>strcmp</code> 函数来使用，觉得麻烦的可以直接跳过</p>
<p><code>strcmp</code> 主要是对字符串进行比较，传入的值主要是字符型的数组，所以自己写的 <code>my_strcmp</code> 的形参为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_strcmp(<span class="type">const</span> <span class="type">char</span>* pa, <span class="type">const</span> <span class="type">char</span>* pb)</span><br></pre></td></tr></table></figure>

<p>在测试 <code>strcmp</code> 函数的时候，它的返回值只有3种情况，并且都是 <code>int</code> 型的，所以返回值的类型就应该为 <code>int</code> ，再完善一下写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa, <span class="type">const</span> <span class="type">char</span>* pb)</span></span><br></pre></td></tr></table></figure>

<p>现在要对函数内部功能开始书写</p>
<p>要模仿前先要确定一下 <code>strcmp</code> 如何判断哪一条字符串大，判断字符串的大小其实就是单个字符的比较，如果 <code>str1</code> 中有一个位置上的字符比 <code>str2</code> 同位置的字符大，则返回1，如果等于返回0。</p>
<p>还有一点就是需要找到最大的字符串来比较，如果 <code>str1</code> 终止了但 <code>str2</code> 还有字符，就会出现问题，所以需要在函数中添加一下判断长度的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, num_a = <span class="number">0</span>, num_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pa + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_a = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pb + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_b = i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这串代码很容易理解，它的本质就是遍历数组，把数组的长度获取，可以便于使用</p>
<p>有了长度之后就可以对数组进行遍历比值了，比较的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= ((num_a &gt; num_b)?num_a:num_b); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*(pa + i) &gt; *(pb + i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*(pa + i) &lt; *(pb + i))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>for</code> 循环中使用了一下三元运算符来判断最大的长度，这样可以有效的避免短的数组没有长度而结束判断了</p>
<p>在 <code>for</code> 循环中有两个判断条件，一个是大于一个是小于，如果在字符串中找到一个值如果大或者小就直接结束函数。</p>
<p>如果都相等就在外面结束函数。</p>
<p>全部代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa, <span class="type">const</span> <span class="type">char</span>* pb)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, num_a = <span class="number">0</span>, num_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pa + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_a = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *(pb + i) != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        num_b = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= ((num_a &gt; num_b)?num_a:num_b); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*(pa + i) &gt; *(pb + i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*(pa + i) &lt; *(pb + i))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>strcmp</code> 和我们写的 <code>my_strcmp</code> 进行一下比较<br><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-069.png"></p>
<p>结果一样的，自己写的 <code>my_strcmp</code> 成功了，然后把这个带进去就能得到第三种方法了</p>
<h4 id="8-6-my-qsort"><a href="#8-6-my-qsort" class="headerlink" title="8.6 my_qsort"></a>8.6 <code>my_qsort</code></h4><p>这一节从 <code>qsort</code> 函数来分析并写出一个 <code>my_qsort</code> 函数</p>
<p>回顾学过的排序算法，就只有冒泡好用，所以这里使用冒泡排序作为 <code>my_qsort</code> 的排序方法。</p>
<p>知道使用什么方法进行排序后，要确定函数的形参如何书写。第一个形参可以作为需要比较的内容的指针，但不确定传入的是什么类型的数组的地址，所以可以用 <code>void</code> 类型来接收。</p>
<p>然后再传入数组的长度和步长还有判断数即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span>(*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span></span><br></pre></td></tr></table></figure>

<p>函数的形参写好了</p>
<blockquote>
<p>加上 <code>const</code> 是为了不改变变量的值</p>
</blockquote>
<p>现在需要的是完成函数内部的功能，用冒泡排序的办法就要设计2个循环变量，一个是计循环的次数的，另一个是索引位数，所以内部写法就为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span>(*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内容的结构就完成了，现在要加上判断条件，通过判断数来决定，这里写的是 <code>&gt;0</code> ，你自己写也可以写成 <code>&lt;0</code> ，只不过用户写的判断函数就会改动一下。</p>
<p>如果把第j个元素和第j+1个元素带入到判断函数中，如果 <code>&gt;0</code> 就进行交换，否则就不进行什么操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span>(*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp((<span class="type">char</span>*)p + j * width, (<span class="type">char</span>*)p + (j+<span class="number">1</span>)*width))&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要把判断数带入用户写的判断函数中，因为不知道是什么类型的数，无法用加来查找下一个元素，所以这里就需要让数变成一个字节长度小的类型来进行加运算</p>
<p>这里现在了 <code>char</code> ，因为一个 <code>char</code> 类型只有一个字节长度，用 <code>char</code> 类型加上1再乘类型长度，这样就可以找到下一个元素的位置</p>
<p>进入循环后就要进行交换，交换代码放在一个函数 <code>Spack</code> 中，和之前冒泡一样的写法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Spack</span><span class="params">(<span class="type">char</span>* pa, <span class="type">char</span>* pb, <span class="type">int</span> width)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; width - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp = *(pa + i);</span><br><span class="line">        *(pa + i) = *(pb + i);</span><br><span class="line">        *(pb + i) = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在前面把 <code>void</code> 类型的全部强制类型转换成 <code>char</code> 了，传入交换函数的类型也为 <code>char</code> 类型的，加1只能移动1位，如果是 <code>int</code> 类型的，加1只能移动一位，但它有4个位，所以这使用循环长度，然后把所有位都交换。</p>
<p>完善一下函数的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Spack</span><span class="params">(<span class="type">char</span>* pa, <span class="type">char</span>* pb, <span class="type">int</span> width)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; width; i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp = *(pa + i);</span><br><span class="line">        *(pa + i) = *(pb + i);</span><br><span class="line">        *(pb + i) = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_qsort</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">int</span> sz, <span class="type">const</span> <span class="type">int</span> width, <span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cmp((<span class="type">char</span>*)p + j * width, (<span class="type">char</span>*)p + (j+<span class="number">1</span>) * width) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                Spack(((<span class="type">char</span>*)p + j * width), ((<span class="type">char</span>*)p + (j+<span class="number">1</span>) * width), width);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在对函数进行一下调试，用 <code>int</code> 型的数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)pa - *(<span class="type">int</span>*)pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    my_qsort(arr, sz, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-070.png"></p>
<p>测试一下结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* pa, <span class="type">const</span> <span class="type">void</span>* pb)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)pa) -&gt; age - ((<span class="keyword">struct</span> Stu*)pb) -&gt; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span>[3] =</span> &#123;&#123;<span class="string">&quot;zdw&quot;</span>, <span class="number">18</span>&#125;, &#123;<span class="string">&quot;djs&quot;</span>, <span class="number">54</span>&#125;, &#123;<span class="string">&quot;sdx&quot;</span>, <span class="number">14</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    my_qsort(stu, sz, <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, stu[i].age, stu[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-071.png"></p>
<p>试试用名字进行排序</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-072.png"></p>
<h3 id="9-指针和数组的练习题"><a href="#9-指针和数组的练习题" class="headerlink" title="9.指针和数组的练习题"></a>9.指针和数组的练习题</h3><h4 id="9-1-一维数组"><a href="#9-1-一维数组" class="headerlink" title="9.1 一维数组"></a>9.1 一维数组</h4><h5 id="9-1-1-第一题"><a href="#9-1-1-第一题" class="headerlink" title="9.1.1 第一题"></a>9.1.1 第一题</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br></pre></td></tr></table></figure>

<p>在程序中执行的结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-1.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-2.png"></p>
<p>**分析：**第一个 <code>sizeof(a)</code> 语句是输出整个数组的长度，该数组是一个长度为4的数组，每个元素的大小为4为，所以整个数组的长度就为16</p>
<p><code>sizeof(a + 0) </code> 输出的是8，在学数组的时候知道，数组的首元素是该数组的地址，现在使用地址+1，就是获取地址的长度，在32位机中，地址长为4，64位中，地址长度为8.</p>
<p><code>sizeof(*a)</code> 这个就是地址的解引用，数组的地址为首元素的地址，所以这里计算的是数组第一个元素的长度，就为4。</p>
<p><code>sizeof(a + 1)</code> 和上面的a+0一个道理</p>
<p><code>sizeof(a[1])</code> 这个就是去索引位置</p>
<h5 id="9-1-2-第二题"><a href="#9-1-2-第二题" class="headerlink" title="9.1.2 第二题"></a>9.1.2 第二题</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a));</span><br></pre></td></tr></table></figure>

<p>在电脑上执行一下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-3.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-4.png"></p>
<p><strong>分析：</strong> <code>sizeof(&amp;a)</code> 获得的是数组地址的大小，在之前学过，&amp;数组名获得的是整个数组的地址，所以这里输出的是8（在64位）</p>
<p><code>sizeof(*&amp;a)</code> 先是取数组整个的地址，然后再用 <code>*</code> 解引用，得到的就是数组第一个元素，然后再输出长度，得到的就是4</p>
<p>其他的都是一样的道理，得到的就是地址的大小</p>
<h4 id="9-2-字符数组"><a href="#9-2-字符数组" class="headerlink" title="9.2 字符数组"></a>9.2 字符数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr + <span class="number">0</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>] + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-5.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-6.png"></p>
<h4 id="9-3-字符串数组"><a href="#9-3-字符串数组" class="headerlink" title="9.3 字符串数组"></a>9.3 字符串数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr + <span class="number">0</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>] + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-7.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-8.png"></p>
<h4 id="9-4-字符指针"><a href="#9-4-字符指针" class="headerlink" title="9.4 字符指针"></a>9.4 字符指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p = <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p[<span class="number">0</span>] + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-9.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-10.png"></p>
<h4 id="9-5-二维数组"><a href="#9-5-二维数组" class="headerlink" title="9.5 二维数组"></a>9.5 二维数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(a[<span class="number">0</span>] + <span class="number">1</span>)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(a + <span class="number">1</span>)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(&amp;a[<span class="number">0</span>] + <span class="number">1</span>)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">3</span>]));</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-11.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/1-12.png"></p>
<h3 id="10、指针练习题"><a href="#10、指针练习题" class="headerlink" title="10、指针练习题"></a>10、指针练习题</h3><h4 id="10-1-一维数组"><a href="#10-1-一维数组" class="headerlink" title="10.1 一维数组"></a>10.1 一维数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)(&amp;a + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h4 id="10-2-结构体"><a href="#10-2-结构体" class="headerlink" title="10.2 结构体"></a>10.2 结构体</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span>* pcNumber;</span><br><span class="line">    <span class="type">short</span> sDate;</span><br><span class="line">    <span class="type">char</span> cha[<span class="number">2</span>];</span><br><span class="line">    <span class="type">short</span> sBa[<span class="number">4</span>];</span><br><span class="line">&#125;* p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">0x1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)p + <span class="number">0x1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>*)p + <span class="number">0x1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//设p中存放的地址为0x10000</span></span><br></pre></td></tr></table></figure>

<p>这道题考察的是指针的运算方法，先看这个结构体的大小为20个字节，指针p是结构体的指针。</p>
<p>第一步先将 <code>p + 0x1</code>，也就是让指针p跳过一个结构体，跳过20个字节，所以输出的地址就为 <code>0x10014</code></p>
<p>第二步将结构体指针p强制类型转换为 <code>unsigned long</code> 类型，现在指针p变成了整型p，整型+1，而地址不会改变</p>
<p>第三步将结构体指针p强制类型转换为无符号的整型指针类型，用无符号整型指针+1跳过的就是整个整型指针的长度，而整型指针的长度为4个字节，所以输出的地址为0x10004。</p>
<h4 id="10-3-二维数组"><a href="#10-3-二维数组" class="headerlink" title="10.3 二维数组"></a>10.3 二维数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123;(<span class="number">0</span>,<span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>,<span class="number">5</span>)&#125;;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题考察的是逗号表达式，真正存放在这二维数组中的格式为：<code>&#123;&#123;1,3&#125;,&#123;5,0&#125;,&#123;0,0&#125;&#125;</code></p>
<h4 id="10-4-复杂模式"><a href="#10-4-复杂模式" class="headerlink" title="10.4 复杂模式"></a>10.4 复杂模式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> (*p) [<span class="number">4</span>];</span><br><span class="line">    p = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %d\n&quot;</span>, &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>], &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题考察的是指针互相-和数组指针指向的关系。</p>
<h2 id="三、字符串函数和内存函数"><a href="#三、字符串函数和内存函数" class="headerlink" title="三、字符串函数和内存函数"></a>三、字符串函数和内存函数</h2><h3 id="1-模拟实现字符串函数"><a href="#1-模拟实现字符串函数" class="headerlink" title="1.模拟实现字符串函数"></a>1.模拟实现字符串函数</h3><h4 id="1-1-strlen"><a href="#1-1-strlen" class="headerlink" title="1.1 strlen"></a>1.1 strlen</h4><p>对于查看字符串长度的函数有3中模拟的写法</p>
<h5 id="第一种-2"><a href="#第一种-2" class="headerlink" title="第一种"></a>第一种</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    assert(pa != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(*pa != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        pa++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二种-2"><a href="#第二种-2" class="headerlink" title="第二种"></a>第二种</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pa)</span>&#123;</span><br><span class="line">    assert(pa != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (*pa != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + my_strlen(pa + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-内存函数"><a href="#2-内存函数" class="headerlink" title="2.内存函数"></a>2.内存函数</h3><p>其实内存函数就是对数组的拷贝，属于深拷贝的范畴，之前已经讲过深拷贝了，这里就不多说了。</p>
<h2 id="四、结构体提高"><a href="#四、结构体提高" class="headerlink" title="四、结构体提高"></a>四、结构体提高</h2><p>在之前的学习了一下结构体的基本使用，这一节主要是学习一下结构体更多的用法</p>
<h3 id="1-结构体中的数组赋值"><a href="#1-结构体中的数组赋值" class="headerlink" title="1.结构体中的数组赋值"></a>1.结构体中的数组赋值</h3><p>先看下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">60</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在一个结构体中存放着一个字符型数组，现在要对它进行赋值只能使用初始化值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span> =</span> &#123;<span class="string">&quot;tom&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果要单独对结构体中的数组进行赋值，使用 <code>=</code> 是会报错的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    p1.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这里需要使用到字符拷贝函数 <code>strcpy</code> ，在使用的时候一定要引头文件 <code>string.h</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">60</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以单独修改结构体中的数组内的元素。</p>
<h3 id="2-结构体中的深浅拷贝"><a href="#2-结构体中的深浅拷贝" class="headerlink" title="2.结构体中的深浅拷贝"></a>2.结构体中的深浅拷贝</h3><h4 id="2-1-堆区操作函数"><a href="#2-1-堆区操作函数" class="headerlink" title="2.1 堆区操作函数"></a>2.1 堆区操作函数</h4><p>在学习之前，先了解一下在C语言中将数据存放在堆区的几个函数</p>
<h5 id="2-1-1-malloc"><a href="#2-1-1-malloc" class="headerlink" title="2.1.1 malloc"></a>2.1.1 malloc</h5><p>这个函数是属于 <code>stdlib.h</code> 头文件的函数，函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态的开辟一块size大小的空间，并返回该内存的地址，如果出现错误则会返回NULL。</p>
<h5 id="2-1-2-calloc"><a href="#2-1-2-calloc" class="headerlink" title="2.1.2 calloc"></a>2.1.2 calloc</h5><p>该函数所属的头文件也是 <code>stdlib.h</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> n, <span class="type">unsigned</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态分配n个长度为size的内存空间，并返回开辟空间的首地址，如果发生错误，则返回NULL。</p>
<h5 id="2-1-3-free"><a href="#2-1-3-free" class="headerlink" title="2.1.3 free"></a>2.1.3 free</h5><p>该函数也是属于 <code>stdlib.h</code> 头文件中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数是将指针ptr指向的内存释放出来。</p>
<h4 id="2-2-结构体的浅拷贝"><a href="#2-2-结构体的浅拷贝" class="headerlink" title="2.2 结构体的浅拷贝"></a>2.2 结构体的浅拷贝</h4><p>比如下面的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">60</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span> =</span> &#123;<span class="string">&quot;tom&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span> =</span> &#123;<span class="string">&quot;alax&quot;</span>, <span class="number">19</span>&#125;;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\n&quot;</span>, p1.name, p1.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\n&quot;</span>, p2.name, p2.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种是将p2中的内容逐字逐句的拷贝到p1中</p>
<p>而如果将结构体中的name开辟到堆区，然后再使用 <code>=</code> 进行拷贝，然后使用完再将堆区的内容释放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>;</span></span><br><span class="line">    p1.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p1.name)*<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    p1.age = <span class="number">18</span>;</span><br><span class="line">    p2.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2.name)*<span class="number">120</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p2.name, <span class="string">&quot;alax&quot;</span>);</span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    <span class="keyword">if</span> (p1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1.name);</span><br><span class="line">        p1.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p2.name);</span><br><span class="line">        p2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码会导致程序崩溃，为什么会导致整个情况，原因就是深拷贝和浅拷贝的问题</p>
<h4 id="2-3-结构体的深拷贝"><a href="#2-3-结构体的深拷贝" class="headerlink" title="2.3 结构体的深拷贝"></a>2.3 结构体的深拷贝</h4><p>在上一节讲到了直接使用 <code>=</code> 将p1中的内容浅拷贝到p2中，这种是结构体中的内容存放到栈区才能使用这种拷贝方法，但如果是在堆区的内容使用浅拷贝就会导致报错</p>
<p>拿上面的代码来说：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>;</span></span><br><span class="line">    p1.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p1.name)*<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    p1.age = <span class="number">18</span>;</span><br><span class="line">    p2.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2.name)*<span class="number">120</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p2.name, <span class="string">&quot;alax&quot;</span>);</span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    <span class="keyword">if</span> (p1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1.name);</span><br><span class="line">        p1.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p2.name);</span><br><span class="line">        p2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先分配出 <code>sizeof(p1.name)*60</code> 的空间到堆区，执行完语句之后会返回出该堆区的地址，然后将返回的地址放在 <code>p1.name</code> 中，p2也是，只不过存放的是 <code>sizeof(p2.name)*120</code> 大小的堆空间中。</p>
<p>接下来执行 <code>p1 = p2</code> ，是将p2中的内容逐条放入p1中，这里也包括开辟的堆区空间，后面就进入释放堆区内存了，因为p1中的name存放的是p2中name存储的地址，在释放时p1先释放了那块区域，p2后面又释放了那块区域的地址，导致重复释放了。</p>
<p>为了解决这个问题，就需要使用到深拷贝的方法了，这种方法就是先将p1中的name中存放的地址释放，然后再开辟一块空间，将p2 name中存放的值放到那块新开辟的空间，然后把那块空间的地址存放到p1.name中，这样就可以避免重复释放的问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deep_copy</span><span class="params">(<span class="keyword">struct</span> Person* p1, <span class="keyword">struct</span> Person* p2)</span>&#123;</span><br><span class="line">    <span class="comment">//深拷贝函数</span></span><br><span class="line">    <span class="keyword">if</span> (p1-&gt;name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1-&gt;name); <span class="comment">//先释放原来p1中堆区地址</span></span><br><span class="line">        p1-&gt;name = <span class="literal">NULL</span>; <span class="comment">//避免空指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    p1-&gt;name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2-&gt;name)*<span class="number">120</span>);<span class="comment">//重新开辟空间</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1-&gt;name, p2-&gt;name);</span><br><span class="line">    p1-&gt;age = p2-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p2</span>;</span></span><br><span class="line">    p1.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p1.name)*<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    p1.age = <span class="number">18</span>;</span><br><span class="line">    p2.name = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(p2.name)*<span class="number">120</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p2.name, <span class="string">&quot;alax&quot;</span>);</span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    deep_copy(&amp;p1, &amp;p2);</span><br><span class="line">    <span class="keyword">if</span> (p1.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p1.name);</span><br><span class="line">        p1.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2.name != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p2.name);</span><br><span class="line">        p2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码运行后就会达到指定的效果且不会崩。</p>
<h2 id="五、结构体和共用体"><a href="#五、结构体和共用体" class="headerlink" title="五、结构体和共用体"></a>五、结构体和共用体</h2><h3 id="1-结构体的嵌套"><a href="#1-结构体的嵌套" class="headerlink" title="1.结构体的嵌套"></a>1.结构体的嵌套</h3><p>这里是对结构体的一个补充，在一个结构体中又有一个结构体，这个就叫做结构体的嵌套。</p>
<p>比如说有一个物品它是由零件1、零件2、零件3、零件4组成，但在零件4中又包含着小零件1、小零件2、小零件3，用代码表示出来为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> short_part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_3[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">goods</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_3[<span class="number">10</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> <span class="title">p4</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化值的写法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> short_part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_3[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">goods</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_3[<span class="number">10</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">part_4</span> <span class="title">p4</span>;</span></span><br><span class="line">&#125; g = &#123; <span class="string">&quot;luosi&quot;</span>, <span class="string">&quot;jigai&quot;</span>, <span class="string">&quot;suiji&quot;</span>, &#123;<span class="string">&quot;xiao&quot;</span>, <span class="string">&quot;da&quot;</span>, <span class="string">&quot;op&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>如果要给 <code>part_4</code> 中的内容重新赋值是不可以的，只能使用字符串函数 <code>strcpy</code> 但是这个在不同的编译器上可以执行操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">part_4</span> &#123;</span><br><span class="line">    <span class="type">char</span> short_part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> short_part_3[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">goods</span> &#123;</span><br><span class="line">    <span class="type">char</span> part_1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_2[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> part_3[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">part_4</span> p4;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">goods</span> g = &#123; <span class="string">&quot;luosi&quot;</span>, <span class="string">&quot;jigai&quot;</span>, <span class="string">&quot;suiji&quot;</span>, &#123;<span class="string">&quot;xiao&quot;</span>, <span class="string">&quot;da&quot;</span>, <span class="string">&quot;op&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(g.part_1, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, g.part_1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><p>在之前学数组的时候知道，在定义数组时需要先固定好数组的长度，这样会面临着一个问题就是如果该数组定义的长度不够存储的数据长度，会导致多出来的内容无法存储。如果存储的数据少于数组的长度，就会导致内存浪费。</p>
<p>这个时候就可以使用链表来解决这些问题。</p>
<h4 id="2-1-链表概述"><a href="#2-1-链表概述" class="headerlink" title="2.1 链表概述"></a>2.1 链表概述</h4><p>链表的本质是结构体，它里面包含一个尾指针来指向下一块链表的内容，还包含一块区域来存储内容。</p>
<p>简单的链表示意图：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%93%BE%E8%A1%A8%E6%A6%82%E8%BF%B0%E7%A4%BA%E6%84%8F%E5%9B%BE1.png"></p>
<p>就像是一堆小朋友手拉着手一样，第一个就是老师做指向。</p>
<p>下面简单创建一个班级的链表，而这个链表的每个节点是学生</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> cName[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span><span class="comment">//用于指向下一个节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>链表就不用担心长度会超范围了。</p>
<h4 id="2-2-静态链表"><a href="#2-2-静态链表" class="headerlink" title="2.2 静态链表"></a>2.2 静态链表</h4><p>静态链表和上面的一样，每个节点后跟着下一个节点的地址，而这个节点的地址需要手动去添加，最后一个节点的地址为NULL是为了避免空指针的产生。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s5</span> =</span> &#123;<span class="number">10</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s4</span> =</span> &#123; <span class="number">20</span>, &amp;s5 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s3</span> =</span> &#123; <span class="number">30</span>, &amp;s4 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s2</span> =</span> &#123; <span class="number">40</span>, &amp;s3 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span> =</span> &#123; <span class="number">50</span>, &amp;s2 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是实现了静态的链表，但拿到第一个节点的地址就能得到整个链表了，如何将静态链表输出出来，就是需要靠另外一个指针来辅助输出出来</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s5</span> =</span> &#123;<span class="number">10</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s4</span> =</span> &#123; <span class="number">20</span>, &amp;s5 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s3</span> =</span> &#123; <span class="number">30</span>, &amp;s4 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s2</span> =</span> &#123; <span class="number">40</span>, &amp;s3 &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span> =</span> &#123; <span class="number">50</span>, &amp;s2 &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pCount</span> =</span> &amp;s1;</span><br><span class="line">    <span class="keyword">while</span> (pCount != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pCount-&gt;iNumber);</span><br><span class="line">        pCount = pCount-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现先创建一个指针用于存储第一条节点的地址，在每次变量完之后该指针又指向下一条节点的地址，直到最后一个节点，最后一个节点没有任何指向，所以地址为 <code>NULL</code> ，这样就实现了静态指针的输出。</p>
<h4 id="2-3-动态链表"><a href="#2-3-动态链表" class="headerlink" title="2.3 动态链表"></a>2.3 动态链表</h4><p>动态链表并不是像静态链表一样，每次添加元素就是用声明的方式，非常的麻烦，而动态链表是每次存入数据时使用语句开辟空间，再将数据存放链表中</p>
<p>这里先了解一下分配内存空间的三个函数</p>
<p>1.malloc</p>
<p>这个函数是属于 <code>stdlib.h</code> 头文件的函数，函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态的开辟一块size大小的空间，并返回该内存的地址，如果出现错误则会返回NULL。</p>
<p>2.calloc</p>
<p>该函数所属的头文件也是 <code>stdlib.h</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> n, <span class="type">unsigned</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在内存中动态分配n个长度为size的内存空间，并返回开辟空间的首地址，如果发生错误，则返回NULL。</p>
<p>3.free</p>
<p>该函数也是属于 <code>stdlib.h</code> 头文件中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数是将指针ptr指向的内存释放出来。</p>
<p>如何创建动态的链表，其实和前面静态链表的一样，在一个链表中有节点，节点中一部分是存放数据的，另一部分是存放下一个节点的地址，创建动态链表也是依靠的是这个，而和静态不同的是，动态链表是在函数中动态分配一块内存给下一个节点，而不是我们使用声明静态的分配内存</p>
<p>动态链表的写法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student* <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNew</span>, *<span class="title">pEnd</span>;</span></span><br><span class="line">    pNew = pEnd = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Place input number\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    <span class="keyword">while</span> (pNew-&gt;iNumber != <span class="number">-1</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">            pHead = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">            pEnd-&gt;pNext = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Place input number\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Student</code> 是每个节点的结构</p>
<p>而 <code>Create</code> 为创建动态节点，首先需要创建出一个头链，头链固定不动，如果后面的节点要增加和删除只需要改变它前面一个节点中指向下一个节点的地址即可。</p>
<p>这里创建了两个指针，分别是 <code>pNew</code> 和 <code>pEnd</code> </p>
<p><code>pNew</code> 是创建出内存的指针，当每次在链表中增加一个节点时， <code>pNew</code> 就是为了接受到这一个新节点的地址。</p>
<p><code>pEnd</code> 是指向增加的节点，避免每次添加节点后又重新遍历一遍链表元素后再在最后添加，所以每一次增加都会用 <code>pEnd</code> 来记录最后一个节点的地址。</p>
<p>输出链表的方法和静态输出的方法一致</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">p</span> =</span> create();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;iNumber);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-1-链表练习1"><a href="#2-3-1-链表练习1" class="headerlink" title="2.3.1 链表练习1"></a>2.3.1 链表练习1</h5><p>新建一个班级类，每一个学生作为一个节点，每个节点的内容有学生名字和学号。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> cName[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> iNumber;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">struct</span> Student* <span class="title function_">Create</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pEnd</span>, *<span class="title">pNew</span>;</span></span><br><span class="line">    pEnd = pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Place input name and number\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;(pNew-&gt;cName));</span><br><span class="line">    <span class="keyword">while</span> (pNew-&gt;iNumber != <span class="number">-1</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            pNew-&gt;pNext = pHead;</span><br><span class="line">            pHead = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">            pEnd-&gt;pNext = pNew;</span><br><span class="line">            pEnd = pNew;</span><br><span class="line">        &#125;</span><br><span class="line">        pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Place input name and number\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;(pNew-&gt;cName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="keyword">struct</span> Student* ph)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (ph != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, ph-&gt;iNumber, ph-&gt;cName);</span><br><span class="line">        ph = ph-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">ph</span> =</span> Create();</span><br><span class="line">    Print(ph);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-增加节点"><a href="#2-4-增加节点" class="headerlink" title="2.4 增加节点"></a>2.4 增加节点</h4><p>节点的增加其实是将该节点前的指针的地址指向该节点，并让该节点的指针指向原来是一个节点的地址给它重新赋值过去即可。</p>
<h5 id="2-4-1-在头节点增加"><a href="#2-4-1-在头节点增加" class="headerlink" title="2.4.1 在头节点增加"></a>2.4.1 在头节点增加</h5><p>在头节点增加节点是一种非常简单的方法传入的参数就只需要传入一个头节点即可。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student* <span class="title function_">insert</span><span class="params">(<span class="keyword">struct</span> Student* pHead)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">pNew</span>;</span></span><br><span class="line">    pNew = (<span class="keyword">struct</span> Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pNew-&gt;iNumber));</span><br><span class="line">    pNew-&gt;pNext = pHead;</span><br><span class="line">    pHead = pNew;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程</title>
    <url>/2025/01/17/5f463418ae32/</url>
    <content><![CDATA[<h1 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h1><h2 id="一、网络编程概念"><a href="#一、网络编程概念" class="headerlink" title="一、网络编程概念"></a>一、网络编程概念</h2><h3 id="1-mac地址"><a href="#1-mac地址" class="headerlink" title="1.mac地址"></a>1.mac地址</h3><p>标识网卡的id，理论上这个id全球唯一</p>
<p>mac地址一般用来标识主机的id，这个id是物理地址，不会改变</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8Bmac.png"></p>
<h3 id="2-IP地址"><a href="#2-IP地址" class="headerlink" title="2. IP地址"></a>2. IP地址</h3><p>IP地址是标识主机的id，这个id是虚拟的，会改变的。</p>
<p>一个IP将其分为子网id和主机id，子网id和主机id需要和子网掩码一起看，比如说下面有一个IP地址和子网掩码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.1.1.2</span><br><span class="line">255.255.255.0</span><br></pre></td></tr></table></figure>

<p>上面的192.168.11.23是IP地址，而下面的255.255.255.0是子网掩码，查看时需要看下面的子网掩码。</p>
<p>IP中被连续的1覆盖的位就是子网id</p>
<p>IP中被连续的0覆盖的位就是主机id</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8B%E5%AD%90%E7%BD%91id.png"></p>
<p>所以子网id是：10.1.1</p>
<p>主机id是：2</p>
<p>网段地址：10.1.1.0</p>
<p>广播地址：10.1.1.255</p>
<p>主机id分配的范围：10.1.1.1-&gt;10.1.1.254</p>
<p>ping：这是一个用来测试两台主机的网络联通性的命令</p>
<p>ens33是网络名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.131.133 设置的ip</span><br><span class="line">netmask子网掩码255.255.255.0</span><br></pre></td></tr></table></figure>

<h3 id="3-端口"><a href="#3-端口" class="headerlink" title="3.端口"></a>3.端口</h3><p>作用：用来标识应用程序（进程）</p>
<p>port：2个字节 0-65535</p>
<p>0-1023知名端口</p>
<p>自定义端口1024-65535</p>
<h3 id="4-OSI七层模型"><a href="#4-OSI七层模型" class="headerlink" title="4.OSI七层模型"></a>4.OSI七层模型</h3><p>物理层：双绞线接口类型，光纤的传输速率等等</p>
<p>数据链路层：mac 负责收发数据</p>
<p>网络层：IP 给两台提供路径选择</p>
<p>传输层：port 区分数据递送到哪一个应用程序</p>
<p>会话层：建立连接</p>
<p>表示层：解码</p>
<p>应用层：应用程序，拿到数据</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/7%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<p>TCP&#x2F;IP四层协议</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/4%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<h3 id="5-协议"><a href="#5-协议" class="headerlink" title="5.协议"></a>5.协议</h3><p>规定了数据传输的方法和格式</p>
<p>应用层协议：<br>FTP：文本传输协议</p>
<p>HTTP：超文本传输协议</p>
<p>NFS：网络文件系统</p>
<p>传输层协议：</p>
<p>TCP：传输控制协议</p>
<p>UDP：用户数据包协议</p>
<p>网络层协议：</p>
<p>IP：因特网互联协议</p>
<p>ICMP：因特网控制报文协议，比如ping</p>
<p>IGMP：因特网组管理协议</p>
<p>链路层协议：<br>ARP：地址解析协议 通过IP找mac地址</p>
<p>RARP：反向地址解析协议，通过mac找IP</p>
<p>mac头部：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/mac%E5%A4%B4%E9%83%A8.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/mac%E5%A4%B4%E9%83%A82.png"></p>
<h3 id="6-网络通讯过程"><a href="#6-网络通讯过程" class="headerlink" title="6.网络通讯过程"></a>6.网络通讯过程</h3><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BB%84%E5%8C%85%E8%BF%87%E7%A8%8B.png"></p>
<h3 id="7-arp"><a href="#7-arp" class="headerlink" title="7.arp"></a>7.arp</h3><p>地址解析协议：通过IP找mac地址</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/arp%E8%AF%B7%E6%B1%82.png"></p>
<p>arp请求包：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/arp%E5%A4%B4%E9%83%A8.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/arp%E9%80%9A%E8%AE%AF.png"></p>
<h3 id="8-网络设计模式"><a href="#8-网络设计模式" class="headerlink" title="8.网络设计模式"></a>8.网络设计模式</h3><p>有两种设计模式</p>
<p>B&#x2F;S browser&#x2F;server 使用服务器进行计算</p>
<p>优点：客户端安全，开发周期短</p>
<p>缺点：性能低</p>
<p>C&#x2F;S cilent&#x2F;server 使用客户端就行计算</p>
<p>优点：性能好</p>
<p>缺点：客户端容易篡改数据，开发周期较长</p>
<h3 id="9-进程间通讯"><a href="#9-进程间通讯" class="headerlink" title="9.进程间通讯"></a>9.进程间通讯</h3><p>之前学习了一些进程间的通讯，比如无名管道、有名管道、mmap、文件、信号、消息队列、共享内存，但这些通讯都存在一个问题就是只能用于本机的进程间通讯。</p>
<p>如果我们想让不同的主机之间进行通讯，我们需要使用到 socket。</p>
<h3 id="10-三次握手"><a href="#10-三次握手" class="headerlink" title="10.三次握手"></a>10.三次握手</h3><p>在TCP通讯的时候会需要进行三次握手，当上次握手结束后就会建立TCP的通讯。一般使用在连接。</p>
<p>这个过程和我们打电话的过程是一样的，当你打了一个电话给对方首先需要确定一下对方是不是接通了，就得先说一声喂，对方收到你的喂后也会回复一个喂，接收到这个喂之后再进行一个确认就可以与对方进行通话了。</p>
<p>三次握手的示意图如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>当客户端连接服务器的时候会先发送一个数据包，数据包中的<code>SYN</code>位会置为1，当服务器接收到这个数据包后也会发送一个数据包给客户端，告诉客户端我已经接收到你的连接，而这个数据包中的<code>ACK</code>会置为1，当客户端接收到这个服务器的数据包后又会再发送一个数据包，这个数据包中的<code>SYN</code>会置为0，发送完这个数据包后就可以开始通讯了。</p>
<p>而每个数据包中都有一个序列号<code>seq</code>和确定序列号<code>ack</code>，序列号是拿来表示发送的数据包的序号的，而确定序列号的含义有两条：</p>
<ul>
<li>确定收到对方的数据包</li>
<li>期待下一次对方的序列号为我的确定序列号</li>
</ul>
<p>这里的握手必须得是三次，因为在传输的过程中很有可能会发生传输了一个数据包但是延迟比较高的情况，如果是只握两次手，那么第一次扔包过去的时候可能时间会很长，那么客户端又会扔一个数据包，这个数据包一下子就扔到了服务器上，然后服务器马上就返回一个确定数据包，然后客户端就开始通讯了，在通讯的时候，第一次扔的包成功的给到了服务器，服务器又以为要建立一个行的连接，这个时候就会产生另外一个连接队列，但本质上两个队列都是一样的。</p>
<p>而如果是三次握手，客户端已经确定好连接了，当那个包又回来时，服务器就会自动忽略那个数据包，就不会再创建一个连接队列了。</p>
<h3 id="11-四次挥手"><a href="#11-四次挥手" class="headerlink" title="11.四次挥手"></a>11.四次挥手</h3><p>四次挥手一般出现在关闭连接的时候。</p>
<p>这个过程可以理解为你和别人打电话结束后要挂电话的情况，你要挂电话你就得说我要挂了，对方会回复说好的，然后就会说我也要挂掉电话了，然后你回复好的，就可以把电话挂了。</p>
<p>四次挥手的示意图如下：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p>
<p>主动方执行<code>close</code>时，就会给被动方一个数据包，这个数据包中<code>FIN</code>置为1，然后被动方接收到这个关闭数据包后也会回复一个数据包，这个数据包中<code>ACK</code>为1，<code>FIN</code>为0，紧接着再发送一个挂掉的数据包，也就是<code>close</code>，这个数据包和主动方第一次发送的包一样，然后等待主动方发送挂掉的数据包，接收到这个数据包后就可以结束连接了。</p>
<p>而这个主动和被动可以是客户端主动，服务器被动，也可以是服务器主动，客户端被动，这个无所谓的</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p>
<p>而最大报文生存时间是被动方需要等待的，不管被动方是哪一个。</p>
<p>在这个过程中虽然调用了close，但是还是可以收发数据的，这个过程叫做半关闭，半关闭的函数后面会说</p>
<h3 id="12-mss"><a href="#12-mss" class="headerlink" title="12.mss"></a>12.mss</h3><p>mss是最大报文长度，一般出现在三次握手的前两次，用来告诉对方发送数据的最大长度。</p>
<h3 id="13-MTU"><a href="#13-MTU" class="headerlink" title="13.MTU"></a>13.MTU</h3><p>网卡的最大传输单元</p>
<h3 id="14-2MSL"><a href="#14-2MSL" class="headerlink" title="14.2MSL"></a>14.2MSL</h3><p>为了让4次握手关闭流程更加可靠。还有其它功能，但这里只了解这个问题即可。</p>
<h3 id="14-滑动窗口"><a href="#14-滑动窗口" class="headerlink" title="14.滑动窗口"></a>14.滑动窗口</h3><p>每一次读取数据之后，回ack报文，报文中携带当前缓冲区大小，用来告知对方我缓冲区的空间。</p>
<h3 id="15-TCP转换图"><a href="#15-TCP转换图" class="headerlink" title="15.TCP转换图"></a>15.TCP转换图</h3><p>TCP转换图其实如下</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/TCP%E8%BD%AC%E6%8D%A2%E5%9B%BE.png"></p>
<p>本质上就是在建立连接和断开连接的过程中主动方和被动方的一些标志位</p>
<h2 id="二、Socket编程"><a href="#二、Socket编程" class="headerlink" title="二、Socket编程"></a>二、Socket编程</h2><h3 id="1-套接字概念"><a href="#1-套接字概念" class="headerlink" title="1.套接字概念"></a>1.套接字概念</h3><p>套接字其实就是一个插座，是计算机之间进行通讯的一种约定或一种方法。</p>
<h3 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2.预备知识"></a>2.预备知识</h3><h4 id="2-1-网络字节序"><a href="#2-1-网络字节序" class="headerlink" title="2.1 网络字节序"></a>2.1 网络字节序</h4><p>这里需要重新回忆一下C语言中的大端存储和小端存储了。其实也就是每个人的计算机的字节序存储方式不一样，有些是大端存储，而有些是小端存储，如果直接进行通讯就像中国人和英语人交流信笺一样，两边的人都看不懂对象书写的内容，这个时候如果在写信的时候将自己写的内容转换成对方看得懂的内容是不是就能很好的解决看不懂的问题了。</p>
<p>为了使网络程序具有可移植性，使同样的C代码在大端计算机和小端计算机上编译后都能正常运行，就可以使用以下库函数做网络字节序和主机字节序的转换</p>
<p>主机字节序转换为网络字节序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将无符号整数hostlong从主机字节序转换为网络字节序</span><br><span class="line">参数：</span><br><span class="line">    hostlong：需要转换的主机字节序</span><br><span class="line">返回值：</span><br><span class="line">    转换后的网络字节序</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将无符号短整型hostshort从主机字节序转换为网络字节序</span><br><span class="line">参数：</span><br><span class="line">    hostshort：需要转换的主机字节序</span><br><span class="line">返回值：</span><br><span class="line">    转换后的网络字节序    </span><br></pre></td></tr></table></figure>

<p>网络字节序转换成主机字节序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将无符号短整数netlong转换为主机字节序</span><br><span class="line">参数：</span><br><span class="line">    netlong：需要转换的网络字节序</span><br><span class="line">返回值：</span><br><span class="line">    转换后的主机字节序</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将无符号短整数netshort转换为主机字节序</span><br><span class="line">参数：</span><br><span class="line">    netshort：需要转换的网络字节序</span><br><span class="line">返回值：</span><br><span class="line">    转换后的主机字节序</span><br></pre></td></tr></table></figure>

<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将长主机字节序转换为网络字节序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = *((<span class="type">unsigned</span> <span class="type">int</span>*)buf);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sum = htonl(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d.%d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//将短主机字节序转换为网络字节序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = htons(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, b);</span><br><span class="line">    <span class="comment">//将长网络字节序转换为主机字节序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c = ntohl(sum);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* pc = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d.%d\n&quot;</span>, *pc, *(pc+<span class="number">1</span>), *(pc+<span class="number">2</span>), *(pc+<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//将短网络字节序转换为主机字节序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d = htons(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-IP地址转换函数"><a href="#2-2-IP地址转换函数" class="headerlink" title="2.2 IP地址转换函数"></a>2.2 IP地址转换函数</h4><p>当你选择已经有一个需要发送的IP：192.168.1.2，你如果直接发送，网络是没办法知道你这个是什么内容的，需要进行一次转换将192.168.1.2转换为192，168，1，2这种使用数组存放的形式。而网络传给主机的IP地址为192，168，1，2这种使用数组的IP地址，所以需要经过转换变成192.168.1.2的形式。</p>
<p>在C语言中提供了两个函数来处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">void</span>* dst)</span>;</span><br><span class="line">功能；</span><br><span class="line">    将点分十进制串转成<span class="number">32</span>位网络大端的数据</span><br><span class="line">参数：</span><br><span class="line">    af：</span><br><span class="line">        AF_INET	IPV4</span><br><span class="line">        AF_INET6 IPV6</span><br><span class="line">    src：点分十进制串的首地址</span><br><span class="line">    dst：<span class="number">32</span>位网络数据的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回<span class="number">1</span>（网络地址已成功连接）</span><br><span class="line">    失败：<span class="number">0</span>（src 不包含表示指定地址系列中有效网络地址的字符串）</span><br><span class="line">        <span class="number">-1</span>（af 不包含有效的地址系列）</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">char</span>* dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将<span class="number">32</span>位大端的网络数据转成点分十进制</span><br><span class="line">参数：</span><br><span class="line">    af：</span><br><span class="line">        AF_INET	IPV4</span><br><span class="line">        AF_INET6 IPV6</span><br><span class="line">    src：<span class="number">32</span>位大端网络数地址</span><br><span class="line">    dst：存储点分十进制串地址</span><br><span class="line">    size：存储点分制串数组的大小</span><br><span class="line">返回值：</span><br><span class="line">    存储点分制串数组首地址</span><br></pre></td></tr></table></figure>

<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;192.168.1.2&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    inet_pton(AF_INET, buf, &amp;number);</span><br><span class="line">    p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;number;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p + <span class="number">2</span>), *(p + <span class="number">3</span>));</span><br><span class="line">    inet_ntop(AF_INET, &amp;number, ip, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-sockaddr数据结构"><a href="#2-3-sockaddr数据结构" class="headerlink" title="2.3 sockaddr数据结构"></a>2.3 sockaddr数据结构</h4><p>ipv4套接字结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">/* 地址族: AF_INET */</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port; <span class="comment">/* 按网络字节次序的端口 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* internet地址 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet地址. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">u_int32_t</span> s_addr; <span class="comment">/* 按网络字节次序的地址 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ipv6套接字结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="type">in_port_t</span>       sin6_port;     <span class="comment">/* port number */</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_scope_id; <span class="comment">/* Scope ID (new in 2.4) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   s6_addr[<span class="number">16</span>];   <span class="comment">/* IPv6 address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通用套接字结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; <span class="comment">/*AF_xxx*/</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];	<span class="comment">/*通用的地址*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-网络套接字函数"><a href="#3-网络套接字函数" class="headerlink" title="3.网络套接字函数"></a>3.网络套接字函数</h3><h4 id="3-1-socket模型创建流程图"><a href="#3-1-socket模型创建流程图" class="headerlink" title="3.1 socket模型创建流程图"></a>3.1 socket模型创建流程图</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/socket%E6%A8%A1%E5%9E%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h4 id="3-2-socket函数"><a href="#3-2-socket函数" class="headerlink" title="3.2 socket函数"></a>3.2 socket函数</h4><p>创建套接字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">功能：</span><br><span class="line">    建立一个用于交流的端点并且返回一个描述符</span><br><span class="line">参数：</span><br><span class="line">    domain：AF_INET</span><br><span class="line">    type：确定通信语句</span><br><span class="line">        SOCK_STREAM 提供有序的，可靠的，双向的，基于字节流的通讯。可能支持带外传输。</span><br><span class="line">        SOCK_DGRAM 提供数据报（不面向连接的, 不可靠的固定最大长度的信息）。</span><br><span class="line">        SOCK_SEQPACKET 提供有序的，可靠的，双向的，基于固定最大长度的数据报传输路径；需要一个读取整个伴有输入系统调用的包的用户。</span><br><span class="line">        SOCK_RAW 提供未加工(raw)的网络协议通道。</span><br><span class="line">        SOCK_RDM 提供可靠的数据报层，但是不保证顺序。</span><br><span class="line">        SOCK_NONBLOCK 设置  O_NONBLOCK 的标志于新打开的文件描述符。 通过这个标志可以不用调用 fcntl(<span class="number">2</span>) 来达到相同的结果。</span><br><span class="line">        SOCK_CLOEXEC 设置 close-on-exec  (FD_CLOEXEC)  的标志于新打开的文件描述符。参见 open(<span class="number">2</span>) 中关于 O_CLOEXEC 的描述，因为一些原因这个标志很有用。</span><br><span class="line">    protocol：指定一个协议用于套接字，一般为<span class="number">0</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-connect函数"><a href="#3-3-connect函数" class="headerlink" title="3.3 connect函数"></a>3.3 connect函数</h4><p>连接服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    连接服务器的函数</span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字文件描述符</span><br><span class="line">    addr：ipv4或者ipv6的结构体，但需要转换为通用结构体</span><br><span class="line">    addrlen：结构体的大小。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sock_fd, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    sock_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//连接主机</span></span><br><span class="line">    sa.sin_family = AF_INET;</span><br><span class="line">    sa.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.160.1&quot;</span>, &amp;sa.sin_addr.s_addr);</span><br><span class="line">    connect(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="comment">//发送内容</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(sock_fd, buf, <span class="keyword">sizeof</span>(buf));<span class="comment">//发送数据给服务器</span></span><br><span class="line">        n = read(sock_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDIN_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-tcp服务器通信流程"><a href="#3-4-tcp服务器通信流程" class="headerlink" title="3.4 tcp服务器通信流程"></a>3.4 tcp服务器通信流程</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/tcp%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B1.png"></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/tcp%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png"></p>
<h4 id="3-5-bind绑定"><a href="#3-5-bind绑定" class="headerlink" title="3.5 bind绑定"></a>3.5 bind绑定</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    给套接字绑定端口和ip</span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字</span><br><span class="line">    addr：ipv4套接字结构体地址</span><br><span class="line">    addrlen：ipv4套接字结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">    成功<span class="number">0</span></span><br><span class="line">    失败<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="3-6-listen"><a href="#3-6-listen" class="headerlink" title="3.6 listen"></a>3.6 listen</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> backlog)</span>;</span><br><span class="line">功能：</span><br><span class="line">    在一个套接字上设置倾听连接</span><br><span class="line">参数：</span><br><span class="line">    s：套接字</span><br><span class="line">    backlog：已完成连接队列和未完成连接队列数值和的最大值 <span class="number">128</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span>，并设置相应错误代码</span><br></pre></td></tr></table></figure>

<h4 id="3-7-accept"><a href="#3-7-accept" class="headerlink" title="3.7 accept"></a>3.7 accept</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> socket, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    在一个套接字上接收一个连接,如果连接队列没有新的连接，accept回阻塞</span><br><span class="line">参数：</span><br><span class="line">    socket：套接字</span><br><span class="line">    address：获取客户端的ip和端口信息 ipv4套接字结构体地址</span><br><span class="line">    addrlen：IPv4套接字结构体的大小的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：新的已连接套接字的文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>这里要说明一下，accept很任意被系统的中断给关闭，所以在使用accept的时候我们需要添加一个判断，并且要过滤系统中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">agare:</span><br><span class="line">ret = accept(sock, &amp;ipv4, &amp;ipv4_len);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))&#123;</span><br><span class="line">        <span class="keyword">goto</span> agare;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-tcp服务器通信步骤"><a href="#3-8-tcp服务器通信步骤" class="headerlink" title="3.8 tcp服务器通信步骤"></a>3.8 tcp服务器通信步骤</h4><p>1.创建套接字 socket</p>
<p>2.绑定 bind</p>
<p>3.监听 listen</p>
<p>4.提取 accept</p>
<p>5.读写</p>
<p>6.关闭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sock_fd, new_sock_fd, ret = <span class="number">-1</span>, size, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    sa.sin_family = AF_INET;</span><br><span class="line">    sa.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line">    <span class="comment">//inet_pton(AF_INET, &quot;192.168.160.132&quot;, &amp;sa.sin_addr.s_addr);</span></span><br><span class="line">    sa.sin_addr.s_addr = INADDR_ANY;<span class="comment">//绑定的是通配地址</span></span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    sock_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock_fd == SO_ERROR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.绑定bind</span></span><br><span class="line">    ret = bind(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="keyword">if</span> (ret == SO_ERROR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.监听listen</span></span><br><span class="line">    ret = listen(sock_fd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == SO_ERROR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(sa);</span><br><span class="line">    <span class="comment">//4.提取accept</span></span><br><span class="line">    new_sock_fd = accept(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;sa, &amp;size);</span><br><span class="line">    <span class="keyword">if</span> (new_sock_fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, word\n&quot;</span>);</span><br><span class="line">    <span class="comment">//5.读写</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        n = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(new_sock_fd, buf, SIZE);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, SIZE);</span><br><span class="line">        n = read(new_sock_fd, buf, SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;He speak:%s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.关闭</span></span><br><span class="line">    close(new_sock_fd);</span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以利用read读取客户端发送的数据长度来判断客户端是否关闭，当read读取的内容为0，就可以判断客户端关闭。</p>
<h4 id="3-9-tcp服务器多客户端连接（进程版）"><a href="#3-9-tcp服务器多客户端连接（进程版）" class="headerlink" title="3.9 tcp服务器多客户端连接（进程版）"></a>3.9 tcp服务器多客户端连接（进程版）</h4><p>3.8中的只能连接一个客户端，但如果我们这个服务端要连接多个客户端，这个时候就需要使用到之前学过的进程方面的知识点了，过程如下：</p>
<p>主进程连接队列，子进程处理进入已连接队列的套接字</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF.png"></p>
<p>按照这样设计，那么主进程中就可以不需要已连接队列的操作，子进程就可以不需要未连接队列。</p>
<p>代码设计如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">1.创建套接字</span><br><span class="line">2.绑定端口</span><br><span class="line">3.监听</span><br><span class="line">4.提取连接</span><br><span class="line">5.创建进程</span><br><span class="line">6.关闭</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signum, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* context)</span>&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        p = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有子进程要退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;信号为:%d\n子进程退出\n&quot;</span>, signum);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="number">-1</span>, ret = <span class="number">-1</span>, forkNumber = <span class="number">-1</span>, new_sock = <span class="number">-1</span>, ipv4_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ipv4</span>, <span class="title">client_ipv4</span>;</span></span><br><span class="line">    <span class="comment">//设置一个阻塞集，避免在接收信号之前就有这个信号</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//1.创建套接字</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.绑定端口</span></span><br><span class="line">    ipv4.sin_family = AF_INET;</span><br><span class="line">    ipv4.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.40.131&quot;</span>, &amp;ipv4.sin_addr.s_addr);</span><br><span class="line">    ret = bind(sock, (<span class="keyword">struct</span> sockaddr*)&amp;ipv4, <span class="keyword">sizeof</span>(ipv4));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.监听</span></span><br><span class="line">    ret = listen(sock, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.提取连接</span></span><br><span class="line">        <span class="type">char</span> ip[<span class="number">16</span>];</span><br><span class="line">        ipv4_len = <span class="keyword">sizeof</span>(ipv4);</span><br><span class="line">        again:</span><br><span class="line">        new_sock = accept(sock, (<span class="keyword">struct</span> sockaddr*)&amp;ipv4, &amp;ipv4_len);</span><br><span class="line">        <span class="keyword">if</span> (new_sock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))&#123;</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;new client ip:%s port:%d\n&quot;</span>, inet_ntop(AF_INET, &amp;ipv4.sin_addr.s_addr, ip, <span class="number">16</span>), ntohs(ipv4.sin_port));</span><br><span class="line">        <span class="keyword">if</span> (new_sock == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.创建进程</span></span><br><span class="line">        forkNumber = fork();</span><br><span class="line">        <span class="keyword">if</span> (forkNumber == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (forkNumber == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//关闭等待队列</span></span><br><span class="line">            <span class="type">char</span> buf[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            ret = close(sock);</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="comment">//对就绪的套接字进行操作</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                n = read(new_sock, buf, <span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;new client ip:%s port:%d is close!\n&quot;</span>, inet_ntop(AF_INET, &amp;ipv4.sin_addr.s_addr, ip, <span class="number">16</span>), ntohs(ipv4.sin_port));</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//客户端退出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;new client ip:%s port:%d is close!\n&quot;</span>, inet_ntop(AF_INET, &amp;ipv4.sin_addr.s_addr, ip, <span class="number">16</span>), ntohs(ipv4.sin_port));</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">                    write(new_sock, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//父进程</span></span><br><span class="line">            <span class="comment">//关闭就绪队列</span></span><br><span class="line">            ret = close(new_sock);</span><br><span class="line">            <span class="keyword">while</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">                ret = close(new_sock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当子进程结束后，会产生一个信号</span></span><br><span class="line">            <span class="comment">//6.关闭</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">            act.sa_sigaction = fun1;</span><br><span class="line">            act.sa_flags = <span class="number">0</span>;</span><br><span class="line">            sigemptyset(&amp;act.sa_mask);</span><br><span class="line">            sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-10-tcp服务器多客户端连接（线程版）"><a href="#3-10-tcp服务器多客户端连接（线程版）" class="headerlink" title="3.10 tcp服务器多客户端连接（线程版）"></a>3.10 tcp服务器多客户端连接（线程版）</h4><p>其实设计的逻辑和进程的差不多</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP <span class="string">&quot;192.168.18.128&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockMessage</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">recvThread</span><span class="params">(<span class="type">void</span>* sockfd)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SockMessage</span> <span class="title">message</span> =</span> *((<span class="keyword">struct</span> SockMessage*)sockfd);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 用来接收客户端传过来的信息</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        n = recv(message.sockfd, buf, SIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fail not recv\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The client quited\n&quot;</span>);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s %d] is exit\n&quot;</span>, inet_ntoa(message.clientaddr.sin_addr), ntohs(message.clientaddr.sin_port));</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s %d]:%s\n&quot;</span>, inet_ntoa(message.clientaddr.sin_addr), ntohs(message.clientaddr.sin_port), buf);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    <span class="type">int</span> new_sockfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail not socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = htons(PORT);</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail not bind&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd, <span class="number">8</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail not listen&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">pthread_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockMessage</span> <span class="title">message</span>;</span></span><br><span class="line">        <span class="comment">// 接收连接</span></span><br><span class="line">        new_sockfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (new_sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fail not accept&quot;</span>);</span><br><span class="line">            close(sockfd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Get new link:[%s %d]\n&quot;</span>, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line">        message.sockfd = new_sockfd;</span><br><span class="line">        message.clientaddr = clientaddr;</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;pid, <span class="literal">NULL</span>, recvThread, (<span class="type">void</span>*)&amp;message) != <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to pthread_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_detach(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-半关闭"><a href="#4-半关闭" class="headerlink" title="4.半关闭"></a>4.半关闭</h3><p>在讲四次握手的时候说了，当调用了close后，并没有完全关闭，而会处于一种半关闭的情况，也就是主动方发生在<code>FIN_WAIT_2</code>状态时，主动方不可以在应用层发送数据，但是应用层还可以接收数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line">sockfd:需要关闭的socket的描述符</span><br><span class="line">how:允许为shutdown操作选择一下几种方法：</span><br><span class="line">    SHUT_RD(<span class="number">0</span>):关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字**不再接收数据**，任何当前在套接字接收缓冲区的数据将被无声丢弃掉</span><br><span class="line">    SHUT_WR(<span class="number">1</span>):关闭sockfd的写功能，此选项将不允许sockfd进行写操作，进程不能在对此套接字发出写操作</span><br><span class="line">    SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD，然后是SHUT_WR。</span><br></pre></td></tr></table></figure>

<h3 id="5-心跳包"><a href="#5-心跳包" class="headerlink" title="5.心跳包"></a>5.心跳包</h3><p>如果对方异常断开，本机检测不到，一直等待会浪费资源</p>
<p>所以这里可以设置一个心跳包来检测对方是不是断开了，这里的原理其实就是每隔一定的时间间隔就发送一个探测分节，如果连续发送多个探测分节对方未回，就将次连接断开</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> keepAlive = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="type">void</span>*)&amp;keepAlive, <span class="keyword">sizeof</span>(keepAlive));</span><br></pre></td></tr></table></figure>

<h3 id="6-设置端口复用"><a href="#6-设置端口复用" class="headerlink" title="6.设置端口复用"></a>6.设置端口复用</h3><p>在有些时候操作服务端时，服务端强制退出了，这个时候还没有反应过来就会导致这个端口还在占用，需要再过一段时间才会释放调这个端口的资源，那如果我们还想继续使用这个端口就得等这个端口的释放，但是我们可以设置端口的复用来解决这个问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

<p>注意：程序中设置某个端口重新使用，在这之前的其它网络程序将不能使用这个端口</p>
<h2 id="三、高并发服务器"><a href="#三、高并发服务器" class="headerlink" title="三、高并发服务器"></a>三、高并发服务器</h2><p>之前学会写了一个服务器，但之前写的服务器只是阻塞等待的服务器，也就是说来了一个客户端，服务器就需要创建一个进程或者线程去连接那个服务器，这样是很消耗资源的。</p>
<p>而还有一种服务器是非阻塞忙轮服务器，这个服务器是创建出一些进程，然后CPU就会去遍历这些进程，看看这些进程有没有空闲的，如果有客户端需要连接，CPU就会让没有连接的线程去连接，这种方法比较消耗CPU。</p>
<p>最后一种就是我们要讲的了，就是多路IO，多路IO这种方法是利用这内核的中断，当一个线程空闲后，内核就会产生一个信号给CPU，让CPU知道有进程空闲。</p>
<p>多路IO有三种监听的方式：<code>poll</code>、<code>epoll</code>、<code>select</code></p>
<p>它是用内核监听多个文件描述符的属性（读写缓冲区）变化，如果某个文件描述符的读缓冲区变化了，这个时候就是可以读了，将这个事件告知应用层。</p>
<h3 id="1-select"><a href="#1-select" class="headerlink" title="1.select"></a>1.select</h3><p>在Windows中比较采用，而且能跨平台</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, <span class="keyword">struct</span> timeval* timeout)</span>;</span><br><span class="line">功能：监听多个文件描述符的属性变化（读写异常）</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set* <span class="built_in">set</span>)</span>;  <span class="comment">// 将fd文件描述符从set集合中删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set* <span class="built_in">set</span>)</span>; <span class="comment">// 判断fd文件描述符是否在set集合中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set* <span class="built_in">set</span>)</span>; <span class="comment">// 将fd描述符添加到set集合中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set* <span class="built_in">set</span>)</span>;  <span class="comment">// 将set集合中的文件描述符清空</span></span><br><span class="line">参数：</span><br><span class="line">    nfds：最大文件描述符+<span class="number">1</span></span><br><span class="line">    readfds：需要监听的读的文件描述符存放集合</span><br><span class="line">    writefds：需要监听的写的文件描述符存放集合 <span class="literal">NULL</span></span><br><span class="line">    exceptfds：需要监听的异常的文件描述符存放集合 <span class="literal">NULL</span></span><br><span class="line">    timeout：多长时间监听一次 固定的时间，限时等待 <span class="literal">NULL</span> 永久监听</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">        <span class="type">long</span> tv_sec:<span class="comment">//秒</span></span><br><span class="line">        <span class="type">long</span> tv_usec;<span class="comment">//微秒</span></span><br><span class="line">    &#125;</span><br><span class="line">返回值：</span><br><span class="line">    返回的是变化的文件描述符的个数</span><br><span class="line">注意：变化的文件描述符会存放在监听的集合中，未变化的文件描述符会从集合中删除</span><br></pre></td></tr></table></figure>

<h4 id="1-1-使用select写TCP服务器"><a href="#1-1-使用select写TCP服务器" class="headerlink" title="1.1 使用select写TCP服务器"></a>1.1 使用select写TCP服务器</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8888     <span class="comment">// 绑定的端口</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span>    <span class="comment">// 链接的客户端</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> maxfd;</span><br><span class="line">    fd_set oldset, reset;</span><br><span class="line">    <span class="type">int</span> lenfd;     <span class="comment">// 存放变化的个数</span></span><br><span class="line">    <span class="type">int</span> cfd;</span><br><span class="line">    <span class="type">int</span> clientlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;server, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxfd = lfd;</span><br><span class="line">    <span class="comment">// 将集合中的内容清空</span></span><br><span class="line">    FD_ZERO(&amp;oldset);</span><br><span class="line">    FD_ZERO(&amp;reset);</span><br><span class="line">    <span class="comment">// 将lfd放进oldset中</span></span><br><span class="line">    FD_SET(lfd, &amp;oldset);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        reset = oldset;</span><br><span class="line">        lenfd = select(maxfd + <span class="number">1</span>, &amp;reset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (lenfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lenfd == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(lfd, &amp;reset))&#123;</span><br><span class="line">                <span class="comment">// lfd变化了，接受cfd</span></span><br><span class="line">                clientlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;clientlen);</span><br><span class="line">                <span class="keyword">if</span> (cfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 接收失败</span></span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;    <span class="comment">// 跳过这次接收</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;link!client IP:%s port:%d\n&quot;</span>, inet_ntoa(client.sin_addr), ntohs(client.sin_port));</span><br><span class="line">                <span class="comment">// 接收成功将这个文件描述符添加到oldset中</span></span><br><span class="line">                FD_SET(cfd, &amp;oldset);</span><br><span class="line">                <span class="comment">// 判断一下这个描述符是否大于最大文件描述符</span></span><br><span class="line">                <span class="keyword">if</span> (cfd &gt; maxfd)&#123;</span><br><span class="line">                    maxfd = cfd;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果只有lfd变化那就跳过这次</span></span><br><span class="line">                <span class="keyword">if</span> (--lenfd == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i++)&#123;</span><br><span class="line">                <span class="comment">// 判断哪个文件描述符在变化集合中</span></span><br><span class="line">                <span class="keyword">if</span> (FD_ISSET(i, &amp;reset))&#123;</span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1500</span>];</span><br><span class="line">                    ret = read(i, buf, <span class="number">1500</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 这个文件描述符有问题</span></span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="comment">// 关闭这个文件描述符</span></span><br><span class="line">                        close(i);</span><br><span class="line">                        <span class="comment">// 然后把这个文件描述符从中删除</span></span><br><span class="line">                        FD_CLR(i, &amp;oldset);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 这个文件描述符已经关闭</span></span><br><span class="line">                        close(i);</span><br><span class="line">                        FD_CLR(i, &amp;oldset);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 正常输出</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">                        write(i, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">                        bzero(buf, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-select的优缺点"><a href="#1-2-select的优缺点" class="headerlink" title="1.2 select的优缺点"></a>1.2 select的优缺点</h4><p>优点：跨平台</p>
<p>缺点：</p>
<p>文件描述符1024的限制，由于<code>FD_SETSIZE</code>的限制，只能返回变化的文件描述符的个数，具体哪个变化需要遍历，每次都需要将需要监听的文件描述符集合由应用层拷贝到内核。</p>
<p>大量并发，少活跃，select效率低。</p>
<p>假设现在有4-1023个文件描述符需要监听，但是5-1000这些文件描述符关闭了。</p>
<h4 id="1-3-解决缺点中的问题"><a href="#1-3-解决缺点中的问题" class="headerlink" title="1.3 解决缺点中的问题"></a>1.3 解决缺点中的问题</h4><p>这里使用到数组来进行解决。</p>
<h3 id="2-poll"><a href="#2-poll" class="headerlink" title="2.poll"></a>2.poll</h3><p>用得比较少</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">功能：监听多个文件描述符的首元素地址的属性变化</span><br><span class="line">参数：</span><br><span class="line">    fds:监听的数组的首元素地址</span><br><span class="line">    nfds:数组有效元素的最大下标+<span class="number">1</span></span><br><span class="line">    timeout:超时时间，<span class="number">-1</span>是永久监听，&gt;=<span class="number">0</span>限时等待</span><br><span class="line">数组元素：</span><br><span class="line">    <span class="keyword">struct</span> pollfd&#123;</span><br><span class="line">        <span class="type">int</span> fd;   <span class="comment">// 需要监听的文件描述符，如果是-1就不监听</span></span><br><span class="line">        <span class="type">short</span> events;   <span class="comment">// 需要监听的文件描述符什么事件 EPOLLIN 读事件  EPOLLOUT 写事件</span></span><br><span class="line">        <span class="type">short</span> revents;  <span class="comment">// 返回监听到的事件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3.epoll"></a>3.epoll</h3><p>用得比较多，在Linux中使用得比较多</p>
<p>特点：</p>
<p>没有文件描述符1024的限制，以后每次监听都不需要在此将需要监听的文件描述符拷贝到内核，返回的是变化的文件描述符，不需要遍历树。</p>
<p>工作原理：</p>
<p>1.创建红黑树</p>
<p>2.将需要监听的文件描述符上树</p>
<p>3.监听</p>
<h4 id="3-1-创建红黑树"><a href="#3-1-创建红黑树" class="headerlink" title="3.1 创建红黑树"></a>3.1 创建红黑树</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">参数:</span><br><span class="line">    size:监听的文件描述符的上限，<span class="number">2.6</span>版本之后写<span class="number">1</span>即可</span><br><span class="line">返回值:返回树的句柄</span><br></pre></td></tr></table></figure>

<h4 id="3-2-上树、下树、修改节点"><a href="#3-2-上树、下树、修改节点" class="headerlink" title="3.2 上树、下树、修改节点"></a>3.2 上树、下树、修改节点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event* event)</span>;</span><br><span class="line">参数:</span><br><span class="line">    epfd:树的句柄</span><br><span class="line">    op:</span><br><span class="line">        EPOLL_CTL_ADD 上树</span><br><span class="line">        EPOLL_CTL_DEL 下树</span><br><span class="line">        EPOLL_CTL_MOD 修改树</span><br><span class="line">    fd:上树、下树的文件描述符</span><br><span class="line">    event:上树的结点</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events;   <span class="comment">// 需要监听的事件</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;  <span class="comment">// 需要监听的文件描述符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-监听"><a href="#3-3-监听" class="headerlink" title="3.3 监听"></a>3.3 监听</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">参数:</span><br><span class="line">    epfd:树的句柄</span><br><span class="line">    events:接收变化的节点的数组的首地址</span><br><span class="line">    maxevents:数组元素的个数</span><br><span class="line">    timeout:<span class="number">-1</span>永久监听 大于<span class="number">0</span>限时等待</span><br></pre></td></tr></table></figure>



<h2 id="四、TFTP"><a href="#四、TFTP" class="headerlink" title="四、TFTP"></a>四、TFTP</h2><h3 id="1-TFTP概述"><a href="#1-TFTP概述" class="headerlink" title="1.TFTP概述"></a>1.TFTP概述</h3><p>TFTP是简单文件传送协议</p>
<p>最初用于引导无盘系统，被设计用来传输小文件</p>
<p>基于UDP协议实现，不进行用户有效性认证</p>
<p><strong>数据传输模式：</strong></p>
<p>octet：二进制模式</p>
<p>netascii：文本模式</p>
<p>mail：已经不再支持</p>
<h3 id="2-TFTP通讯过程"><a href="#2-TFTP通讯过程" class="headerlink" title="2.TFTP通讯过程"></a>2.TFTP通讯过程</h3><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/TFTP%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B.png"></p>
<p>1.服务器在69端口等待请求</p>
<p>2.服务器若批准此请求，则使用临时端口与客户端进行通信</p>
<p>3.每个数据包的编号都有变化（从1开始）</p>
<p>4.每个数据包都要得到ACK确认，如果出现超时，则需要重新发送最后的包（数据或ACK）</p>
<p>5.数据的长度以512Byte传输</p>
<p>6.小于512Byte的数据意味着传输结束</p>
<h3 id="3-TFTP协议分析"><a href="#3-TFTP协议分析" class="headerlink" title="3.TFTP协议分析"></a>3.TFTP协议分析</h3><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/TFTP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90.png"></p>
<p><strong>注意：</strong></p>
<p>以上0代表的是<code>\0</code></p>
<p>不同的差错码对应不同的错误信息</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/TFTP%E5%B7%AE%E9%94%99%E7%A0%81.png"></p>
<p><strong>错误码：</strong></p>
<p>0 未定义，参见错误信息</p>
<p>1 File not found</p>
<p>2 Access violation</p>
<p>3 Disk full or allocation exceeded</p>
<p>4.illegal TFTP operation</p>
<p>5.Unknown transfer ID</p>
<p>6.File already exists</p>
<p>7.No such user</p>
<p>8.Unsuppored option(s) requested</p>
<h3 id="4-TFTP客户端"><a href="#4-TFTP客户端" class="headerlink" title="4.TFTP客户端"></a>4.TFTP客户端</h3><p>使用TFTP协议下载server上的文件到本地</p>
<p><strong>思路</strong></p>
<p>1、构造请求报文，送至服务器（69号端口）</p>
<p>2、等待服务器回应</p>
<p>3、分析服务器回应</p>
<p>4、接收数据，直到接收到的数据包小于规定长度</p>
<p>代码：</p>
<h2 id="五、UDP广播"><a href="#五、UDP广播" class="headerlink" title="五、UDP广播"></a>五、UDP广播</h2><h3 id="1-广播的概念"><a href="#1-广播的概念" class="headerlink" title="1.广播的概念"></a>1.广播的概念</h3><p>广播：由一台主机向该主机所在子网内的所有主机发送数据的方式，例如192.168.3.103发送广播信息，则192.168.3.1~192.168.3.254所有主机都可以接收到数据。</p>
<p>广播只能用UDP或者原始IP实现，不能用TCP。</p>
<h3 id="2-广播的用途"><a href="#2-广播的用途" class="headerlink" title="2.广播的用途"></a>2.广播的用途</h3><p>单个服务器与多个客户主机通讯时减少分组流通，以下几个协议都用到广播：</p>
<p>1、地址解析协议（ARP）</p>
<p>2、动态主机配置协议（DHCP）</p>
<p>3、网络时间协议（NTP）</p>
<h3 id="3-广播的特点"><a href="#3-广播的特点" class="headerlink" title="3.广播的特点"></a>3.广播的特点</h3><p>1、处于同一子网的所有主机都必须处理数据</p>
<p>2、UDP数据包会沿协议栈向上一直到UDP层</p>
<p> 3、运行音视频等较高速率工作的应用，会带来很大的负担</p>
<p>4、局限于局域网内使用</p>
<h3 id="4-广播地址"><a href="#4-广播地址" class="headerlink" title="4.广播地址"></a>4.广播地址</h3><p>{网络ID，主机ID}</p>
<p>网络ID表示由子网掩码中1覆盖的连续位</p>
<p>主机ID表示由子网掩码中0覆盖的连续位</p>
<p>**定向广播地址：**主机ID全为1</p>
<p>1、例如：对192.168.200.0&#x2F;24，其定向广播地址为：192.168.200.255</p>
<p>2、通常路由器不转发该广播</p>
<p>**受限广播地址：**255.255.255.255</p>
<p>路由器从不转发该广播</p>
<h1 id="未完待续…一直鸽着的"><a href="#未完待续…一直鸽着的" class="headerlink" title="未完待续…一直鸽着的"></a>未完待续…一直鸽着的</h1>]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-3b系统安装和使用vscode进行远程连接</title>
    <url>/2025/01/17/c9e1bc87adc3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前研究中断的时候一直出现问题，我怀疑是因为<code>zero 3</code>不支持，所以一狠心就花钱买了一块3b。然后那几天在看Linux系统的时候看到很多人都推荐使用<code>debian</code>系统，所以我准备在这块板子上安装一下debian系统来试试，以前我是玩<code>Ubuntu</code>的，所以有些地方我还是不太懂。然后今天下载debian的时候出现了有些问题，我写这篇文章来记录一下这些问题。</p>
<h1 id="一、下载镜像和安装系统"><a href="#一、下载镜像和安装系统" class="headerlink" title="一、下载镜像和安装系统"></a>一、下载镜像和安装系统</h1><p>首先我们需要下载一个自己喜欢的系统，我这选择的是debian这个系统了。打开<a href="http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-3B.html">orangepi 3b</a>资料下载页面，然后再官方镜像中选择你喜欢的镜像进行下载</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223173307268-1192738437.png" alt="img"></p>
<p>这里推荐大家使用官方的镜像，兼容性和一些设置还有一些软件官方都为我们弄好了，当然，也可以去系统官网下载，我这因为没有屏幕所以直接就省事了，等有屏幕了我再给大家出一起使用官方Ubuntu的安装。</p>
<p>然后选择完镜像后就可以进行下载了，我这是直接下载好的</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223173629915-772612857.png" alt="img"></p>
<p>你们下载好的debian系统绝对不是这个样子的，因为我删除了一些镜像，然后选择你想安装的镜像安装包，因为我这没有屏幕，所以选择了<code>server</code>版，也就是服务器版，然后用解压软件进行解压，解压出来的内容有一个<code>.img</code>和一个<code>.img.sha</code>，然后打开<code>win32磁盘下载工具</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223174348141-2027926739.png" alt="img"></p>
<p>然后选择刚才解压的<code>.img</code>文件</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223174439930-422150623.png" alt="img"></p>
<p>然后点击写入，将镜像文件写入进SD卡中，然后就插入到香橙派中，这就不配图了，这步不会的可以看我的其他文章。</p>
<p>后面就可以给电和使用串口来进行调试了。</p>
<h1 id="二、使用串口助手进行调试"><a href="#二、使用串口助手进行调试" class="headerlink" title="二、使用串口助手进行调试"></a>二、使用串口助手进行调试</h1><p>这里还是和之前zero一样的插法，但这里有坑，我也是搞了半天都没搞明白，后面看了官方手册才明白。</p>
<p>我按照正常的串口和波特率进行设置，波特率是和zero一样的<code>115200</code>，然后进入到串口助手中，结果全是乱码</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223174825338-862440467.png" alt="img"></p>
<p>我以为正常执行，结果等了半天还是没显示出命令输入，我就蒙了，以为我安装错系统了，安成图形化界面了，后面我又重新的安装了几次，发现还是不行，然后我就开始看官方手册，手册上说，要使用<code>1500000</code>的波特率，我人傻了，这么大的波特率，我这个串口助手只有<code>1382400</code>，我就硬着头皮试了一下，结果成功了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223175156296-697933520.png" alt="img"></p>
<p>这点非常的不同，大家一定要注意一下这个问题。</p>
<h1 id="三、查看系统的ip地址"><a href="#三、查看系统的ip地址" class="headerlink" title="三、查看系统的ip地址"></a>三、查看系统的ip地址</h1><p>当我连接网线后使用<code>ifconfig</code>命令，结果显示</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223181502631-285496944.png" alt="img"></p>
<p>提示我权限低，没办法使用，我就纳闷了，我这个账户应该也可以使用的啊，后面我百度了一下，发现新版本的Linux已经弃用了，但是系统里面还有这个工具，网上都推荐使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure>

<p>这个工具也可以查看本机IP地址</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223181828559-1645712507.png" alt="img"></p>
<p>但是我还是喜欢使用<code>ifconfig</code>，所以我就在网上找了很多教程，终于找到了一个，这个方法很简单，首先在家目录中使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>

<p>查看所有文件</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223182005172-1898147463.png" alt="img"></p>
<p>可以看到有一个<code>.profile</code>的文件，我们使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim .profile</span><br></pre></td></tr></table></figure>

<p>打开后在最后添加一条</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/sbin</span><br></pre></td></tr></table></figure>

<p>然后保存退出，使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .profile</span><br></pre></td></tr></table></figure>

<p>进行重启后就可以不用<code>sudo</code>就可以使用<code>ifconfig</code>命令了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223182317838-598596224.png" alt="img"></p>
<h1 id="四、使用vscode连接香橙派"><a href="#四、使用vscode连接香橙派" class="headerlink" title="四、使用vscode连接香橙派"></a>四、使用vscode连接香橙派</h1><p>vscode非常好用，非常推荐，用这个连接香橙派后就可以不用xshell远程连接，写代码就可以不用<code>vim</code>了。</p>
<p>我很喜欢用vim的，但是vim对于多文件的不太好，那天写自闭了，就换vscode了。</p>
<p>首先需要在vscode中下载一个插件</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223182724026-1804353554.png" alt="img"></p>
<p>这些都下载，然后下载后左边就会出现这个图标</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223182806683-869148961.png" alt="img"></p>
<p>然后点击进去</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223182846328-1556356973.png" alt="img"></p>
<p>然后把鼠标移动到SSH上，就会出现一个加号，点击这个加号，就会出现一个框，让我们输入连接命令</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183221447-1630539573.png" alt="img"></p>
<p>这里输入的命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh 账户名称@IP地址</span><br></pre></td></tr></table></figure>
<p>比如我这要连接的账户名是<code>orangepi</code>，ip地址是<code>192.168.1.31</code>，那我的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh orangepi@192.168.1.31</span><br></pre></td></tr></table></figure>

<p>然后按下回车就会让我们选择配置文件的路径</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183416704-399977591.png" alt="img"></p>
<p>我这喜欢使用第一个默认的，然后回车，就会说明配置文件已经创建成功</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183504867-2185775.png" alt="img"></p>
<p>然后我们打开配置</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183526447-4198095.png" alt="img"></p>
<p>在这里我们需要找到我们刚才设置的IP地址，然后添加一条端口地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Port 22</span><br></pre></td></tr></table></figure>

<p>如果你想显示的名称不是IP地址，你可以修改<code>HostName</code>的值，然后就保存并关闭这个页面，回到远程连接中就会发现有一条新的</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183729699-465489138.png" alt="img"></p>
<p>然后点击<code>-&gt;</code>就可以进入。</p>
<p>点击后会出现下面的界面</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183827213-2050871139.png" alt="img"></p>
<p>这个就是让我们选择连接的目标是什么系统，这是Linux，所以选择第一个，按回车即可。</p>
<p>然后问我们是否继续</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223183956612-955294382.png" alt="img"></p>
<p>直接回车，得快，要不然又得重新连接。</p>
<p>然后就开始让我们输入密码</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223184032119-1529628545.png" alt="img"></p>
<p>这里输入密码即可，然后就进入等待页面，就等就可以了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223184055947-842177833.png" alt="img"></p>
<p>等一会左下角不转圈了，我们就可以新建一个终端，在上面的工具栏的三个点，点击后有一个终端，点进去就有一个新建终端。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231223184243639-342060684.png" alt="img"></p>
<p>这样我们就配置好了，可以在里面打开香橙派的目录和其他东西。非常好用，还可以配置一些插件来辅助。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>vscode非常好用，非常好用，有了vscode可以提高我们的开发效率。</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-使用wiringPi控制26个引脚</title>
    <url>/2025/01/17/833700e426b2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不管是对什么开发板来说，开发需要使用到一些包，像stm32就需要用到一些包，香橙派也是一样的，也是需要使用到一些软件包才能进行开发。</p>
<h1 id="一、香橙派使用的包"><a href="#一、香橙派使用的包" class="headerlink" title="一、香橙派使用的包"></a>一、香橙派使用的包</h1><p>香橙派这里使用的包是<code>wiringOP</code>，这个包有python版，所以用python进行开发要方便一点，但是呢，毕竟我是学嵌入式的，开发单片机都是使用C语言，让我使用python确实不太好，所以我昨天就研究了一下，在<code>/usr/src/</code>目录下有两个<code>wiringOP</code>文件夹</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203135514360-197611242.png" alt="img"></p>
<p>这有一个<code>wiringOP</code>和一个<code>wiringOP-Python</code>，有一个是C语言的，有一个是Python的，这里我看了一下<code>wiringOP</code>下的文件，发现它是由<code>wiringPi</code>这个包进行改写的，但是还是可以使用<code>wiringPi</code>中的函数进行开发</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203135740924-939769433.png" alt="img"></p>
<p>知道了这个就可以开始开发了，所以我花了点时间对<code>wiringPi</code>中的函数进行了一下学习，随便写了这篇文章。</p>
<h1 id="二、使用wiringPi包的命令"><a href="#二、使用wiringPi包的命令" class="headerlink" title="二、使用wiringPi包的命令"></a>二、使用<code>wiringPi</code>包的命令</h1><p>学过树莓派的应该对这个包比较熟悉，没有学过的就跟着我一起来学习吧。</p>
<p>首先使用得先获得这个包，如果你是在香橙派官网中下载的<code>ubuntu</code>或者是其他系统的话，这个包是会在里面的，所以可以不用下载。如果你不是从官网上下载的，需要下载一下这个包。</p>
<h2 id="1-下载wiringOP"><a href="#1-下载wiringOP" class="headerlink" title="1.下载wiringOP"></a>1.下载<code>wiringOP</code></h2><p>首先需要更新一下软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>然后下载一下<code>git</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install -y git</span><br></pre></td></tr></table></figure>

<p>下载完成后就可以用<code>git</code>从<code>github</code>上拉取<code>wiringOP</code>软件包了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone  https://github.com/orangepi-xunlong/wiringOP.git -b next</span><br></pre></td></tr></table></figure>

<p>然后编译一下这个软件包，先到<code>wiringOP</code>这个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd wiringOP</span><br></pre></td></tr></table></figure>

<p>然后编译一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./build clean</span><br></pre></td></tr></table></figure>

<p>然后运行进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./build</span><br></pre></td></tr></table></figure>

<p>安装好后检查一下这个包是否安装成功，这里使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpio readall</span><br></pre></td></tr></table></figure>

<p>进行查看，如果出现下面的界面就证明安装成功了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203140724436-1605733595.png" alt="img"></p>
<p>这个界面是可以查看你这个香橙派所对应的引脚和状态的界面。</p>
<h2 id="2-gpio-readall信息分析"><a href="#2-gpio-readall信息分析" class="headerlink" title="2.gpio readall信息分析"></a>2.<code>gpio readall</code>信息分析</h2><p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203140724436-1605733595.png" alt="img"></p>
<p>这里可以看到有很多信息，首先就是芯片的型号<code>H616</code>，然后表格里面有<code>GPIO</code>、<code>wPi</code>、<code>Name</code>、<code>Mode</code>、<code>V</code>、<code>Physical</code>。下面我那个表给大家说明一下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GPIO</td>
<td>引脚在寄存器中的地址</td>
</tr>
<tr>
<td>wPi</td>
<td>在<code>wiringPi</code>中所对应的值</td>
</tr>
<tr>
<td>Name</td>
<td>引脚的名称</td>
</tr>
<tr>
<td>Mode</td>
<td>引脚的状态</td>
</tr>
<tr>
<td>V</td>
<td>改引脚的电平值</td>
</tr>
<tr>
<td>Physical</td>
<td>引脚的位置</td>
</tr>
</tbody></table>
<p>这里的<code>wPi</code>是在后面会经常使用的一个值，这个需要经常查看一下。</p>
<p><code>Mode</code>的状态可以看下面的表</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OFF</td>
<td>关闭</td>
</tr>
<tr>
<td>OUT</td>
<td>输出</td>
</tr>
<tr>
<td>IN</td>
<td>输入&#x2F;上拉输入&#x2F;下拉输入</td>
</tr>
</tbody></table>
<h2 id="3-设置gpio的模式"><a href="#3-设置gpio的模式" class="headerlink" title="3.设置gpio的模式"></a>3.设置<code>gpio</code>的模式</h2><p>学过32的应该知道，要对引脚操作首先需要打开时钟，然后配置引脚的模式，但是在香橙派中就不用这么麻烦，因为底层和用户层之间有一个<code>HAL</code>板件支持包，所以操作起来就非常的简单，只需要设置一下引脚模式即可，这里我设置一下<code>PC10</code>（因为这个引脚好插杜邦线），首先用命令的模式来进行设置。</p>
<p>这里先将<code>PC10</code>设置为输出模式<code>out</code>，首先找到<code>PC10</code>的<code>wPi</code>值，这里通过前面说的<code>gpio readall</code>就可以查找到，它的<code>wPi</code>值是16，就可以使用下面的命令来进行设置了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpio mode 16 out</span><br></pre></td></tr></table></figure>

<p>设置完成后可以用<code>gpio readall</code>查看一下状态</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203143901252-752924145.png" alt="img"></p>
<p>可以看到<code>PC10</code>的<code>mode</code>变成了<code>OUT</code>。</p>
<p>输出模式就是输出一些电平，比如说一开始电平<code>V</code>是0，那么变成了输出模式后这个引脚就会输出低电平。</p>
<h2 id="4-设置gpio输出的电平"><a href="#4-设置gpio输出的电平" class="headerlink" title="4.设置gpio输出的电平"></a>4.设置<code>gpio</code>输出的电平</h2><p>学过单片机的都知道，在单片机中输出的只有高电平和低电平，这个在程序中的表达是：1表示高电平，0表示低电平，所以我们可以通过程序来控制单片机引脚输出高电平和低电平。</p>
<p>控制操作也是比较简单，使用的是下面的指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpio write wPi 电平</span><br></pre></td></tr></table></figure>

<p><code>wPi</code>不用多说了，电平是0和1来表示，比如说我让刚才的<code>PC10</code>变成高电平，使用的命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpio write 16 1</span><br></pre></td></tr></table></figure>

<p>执行完成后就会让<code>PC10</code>变成高电平了，这里还是使用<code>gpio readall</code>来进行查看</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203144600467-596083947.png" alt="img"></p>
<p>可以看到这个引脚的电平变成了高电平，如果对这个概念还是不明白的话，我用面包板搭建一个简单的电路展示一下</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203144731250-545095097.jpg" alt="img"></p>
<p>这里我将LED的负极连接到<code>PC10</code>这个引脚上，然后正极连接到单片机上的3.3V位置，可以看到现在的LED没有亮，是因为<code>PC10</code>这个引脚是高电平，两端都是高电平是不会通的。</p>
<p>现在我将<code>PC10</code>改成低电平再来看看效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpio write 16 0</span><br></pre></td></tr></table></figure>

<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203143901252-752924145.png" alt="img"></p>
<p>效果如下</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203145056097-1083247880.jpg" alt="img"></p>
<p>可以看到这个已经亮了，这个就是改变引脚的电平的指令，并且讲一下电平的概念。</p>
<h1 id="三、wiringPi软件实现"><a href="#三、wiringPi软件实现" class="headerlink" title="三、wiringPi软件实现"></a>三、<code>wiringPi</code>软件实现</h1><p>前面讲的都是命令行的实现，但是咱不可能一直用命令来写一个复杂的功能，最重要的还是要落实在程序方面，所以现在来给大家介绍一下软件怎么写。</p>
<h2 id="1-初始化函数"><a href="#1-初始化函数" class="headerlink" title="1.初始化函数"></a>1.初始化函数</h2><p>首先在软件中需要初始化一下引脚，使用的函数是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">wiringPiSetup</span> <span class="params">(<span class="type">void</span>)</span> ;</span><br></pre></td></tr></table></figure>

<p>这个函数会初始化一下引脚，但是你调用这个函数的话，在执行的时候需要提升一下权限或者使用<code>root</code>才可以执行，当然这个初始化函数有一个替代的函数，这个替代的函数不需要提权</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wiringPiSetupSys</span> <span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>这个函数不是使用操作系统来进行初始化，而是使用<code>/sys/class/gpio</code>接口来进行初始化的，在此种模式下的管脚号是 Broadcom 的 GPIO 管脚号，这种方法我们不考虑。</p>
<p>我们首先用一下第一个函数来进行一下初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以进行一下初始化的操作，然后就可以进行后面的操作了。</p>
<h2 id="2-设置gpio的模式"><a href="#2-设置gpio的模式" class="headerlink" title="2.设置gpio的模式"></a>2.设置<code>gpio</code>的模式</h2><p>这里使用的是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pinMode</span> <span class="params">(<span class="type">int</span> pin, <span class="type">int</span> mode)</span></span><br></pre></td></tr></table></figure>

<p>这个函数需要配合上面说的<code>wiringPiSetup</code>函数进行初始化，否则使用不了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203151426419-193473249.png" alt="img"></p>
<p>第一个参数是<code>wPi</code>的值，第二个参数是设置的模式，可以有下面的几种模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OUTPUT</td>
<td>输出模式</td>
</tr>
<tr>
<td>INPUT</td>
<td>输入模式</td>
</tr>
<tr>
<td>PWM_OUTPUT</td>
<td>脉冲输出</td>
</tr>
<tr>
<td>GPIO_CLOCK</td>
<td>GPIO时钟</td>
</tr>
</tbody></table>
<p>这些模式都是用宏定义定义了的，直接写即可。</p>
<p>然后我们将<code>PC10</code>的模式设置为输出模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();  <span class="comment">// 记得初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, OUTPUT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以将<code>PC10</code>设置为输出模式了。</p>
<h2 id="3-输出电平"><a href="#3-输出电平" class="headerlink" title="3.输出电平"></a>3.输出电平</h2><p>然后我们就可以通过代码来输出电平了，这里我们可以按照32的写法，写一个死循环，但是毕竟这个是高级的单片机，所以我们就不写死循环了，毕竟你一个香橙派不止可以跑一个程序，所以这里直接写到循环外面。</p>
<p>使用的函数是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">digitalWrite</span> <span class="params">(<span class="type">int</span> pin, <span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure>

<p>这个函数的参数和上面的一样，只不过要说一下<code>value</code>，这个就是电平值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>高电平</td>
</tr>
<tr>
<td>0</td>
<td>低电平</td>
</tr>
</tbody></table>
<p>然后添加进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();  <span class="comment">// 记得初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, OUTPUT);</span><br><span class="line">    digitalWrite(<span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完后我们就可以执行一下这个代码了。</p>
<h2 id="4-执行代码"><a href="#4-执行代码" class="headerlink" title="4.执行代码"></a>4.执行代码</h2><p>这里执行代码需要先进行一下编译，编译使用<code>gcc</code>这个工具，没有这个工具的可以下载一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure>

<p>然后就可以开始编译了，这里不写<code>Makefile</code>文件，直接用命令进行编译，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o 编译出来的文件名 需要编译的文件.c -lwiringPi</span><br></pre></td></tr></table></figure>

<p>这里如果不写<code>-o</code>和<code>编译出来的文件名</code>，编译出来的可执行文件是<code>a.out</code>。</p>
<p>需要注意一下，最后的<code>-lwiringPi</code>是必须要加上的，如果不加上就会出现下面的问题</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203152809718-1765650140.png" alt="img"></p>
<p>这个就像你用<code>pthread</code>线程一样，在编译的时候不加<code>-pthread</code>，所以需要加上。</p>
<p>编译完成后如果没有出问题就可以用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure>

<p>来执行了。</p>
<p>如果你用<code>-o</code>来规定了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203153117748-1504941427.png" alt="img"></p>
<p>可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./别名</span><br></pre></td></tr></table></figure>

<p>来运行，我这是<code>openLED</code>，所以是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./openLED</span><br></pre></td></tr></table></figure>

<p>执行了LED灯就会亮了。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>学会了如何操作<code>gpio</code>后就可以控制一些传感器或者元器件了，所以先得把<code>gpio</code>的操作学好就可以控制一些复杂的东西了，后面香橙派还有很多功能我还没有研究完成，等需要用到什么就使用什么即可。</p>
<p>下一章我会介绍一下输入模式，毕竟在读传感器的时候不能只输出，还得输入呢</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-中断？不！中断！</title>
    <url>/2025/01/17/d57535b42630/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>中断这个在很多单片机中都是比较常见的，像什么51单片机，stm32单片机都是可以通过自己的设置来实现中断的。在香橙派这种比较高级的单片机上也是有中断的，但是呢，这里的中断和51或者stm的单片机有点不同。</p>
<h1 id="一、什么是中断"><a href="#一、什么是中断" class="headerlink" title="一、什么是中断"></a>一、什么是中断</h1><p>中断这个概念老生常谈了，学过单片机的都应该知道这个，也就是说，你在这打游戏，有一个电话过来了，你就得先停止手上的游戏，然后去处理一下那件事，这个就是中断。这里就不细说中断的概念了，毕竟和香橙派上的中断不太一样。</p>
<h1 id="二、普通单片机和系统单片机的区别"><a href="#二、普通单片机和系统单片机的区别" class="headerlink" title="二、普通单片机和系统单片机的区别"></a>二、普通单片机和系统单片机的区别</h1><p>这里要划分一下概念，我分为普通单片机和系统单片机两种，普通单片机就是指像51和stm32那种单核单片机，就是按照一定顺序执行的单片机，然后系统单片机就是指这种能在里面运行操作系统的单片机。</p>
<p>这两种类型的单片机有什么不同呢？</p>
<p>做过单片机开发的都知道，这种单片机只能单步执行，比如你写的这些程序，它只能一条一条的执行，没办法引出一些线程或者进程的概念，这种单片机的中断我们可以自己配置的，因为我们可以接触到底层环境来直接配置。</p>
<p>而这种系统单片机，因为有一层系统，所以底层的一些操作都被一层叫做<code>HAL</code>的抽象包给封装了，我们可以使用这个抽象包给的一些接口来对底层进行一些操作，而且这种单片机的芯片都是比较强的，可以支持像什么线程和进程的操作。</p>
<h1 id="三、中断的区别"><a href="#三、中断的区别" class="headerlink" title="三、中断的区别"></a>三、中断的区别</h1><p>在普通单片机中，我们设置好中断后，满足了中断的条件了，它就会打断它现在正在执行的操作，转向到中断处理函数中去执行中断，就如同这张图一样</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220182909889-2141115484.png" alt="img"></p>
<p>就如图一样，每次执行中断的时候就会打断当前执行的内容。</p>
<p>而在系统单片机中就不一样了，因为系统单片机中它是可以支持多线程和多进程的，所以就可以不用打断当前的系统执行，而是分裂出一个进程或者线程来处理这个中断请求，就如下面这张图</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220183519029-1979238536.png" alt="img"></p>
<p>可以看到这种就是这个过程不会影响着我们现在执行的程序，而我们的香橙派就是用到这种方式的中断。</p>
<h1 id="四、配置香橙派的中断"><a href="#四、配置香橙派的中断" class="headerlink" title="四、配置香橙派的中断"></a>四、配置香橙派的中断</h1><h2 id="1-进程版"><a href="#1-进程版" class="headerlink" title="1.进程版"></a>1.进程版</h2><p>我们配置香橙派的中断其实就可以不用像配置stm32的那种一样复杂了，直接分裂一个线程一直判断是否按下或者是其他内容即可实现这个过程。</p>
<p>比如在stm32中我们要一个按键按下了后就会执行中断处理函数实现一些内容，这里我们就可以使用一个进程一直去读取这个按键的引脚，当按键按下了，我们就让标志位置为1或者0，然后父进程就读取这个标志位，点亮一个LED灯。</p>
<p>代码就可以这么写：</p>
<p>1.先将引脚进行初始化，这里使用的是<code>PC10</code>作为输入引脚，<code>PC7</code>作为输出引脚，然后进行配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();      <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);   <span class="comment">// PC10输入</span></span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);  <span class="comment">// PC7作为输入</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);    <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.设置完成后就开始创建进程和匿名通道。这里因为要实现进程之间的数据交换，所以使用了一个匿名通道进行信息交换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;       <span class="comment">// 接收返回值</span></span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];     <span class="comment">// 管道描述符</span></span><br><span class="line">    <span class="type">int</span> pid;       <span class="comment">// 进程ID</span></span><br><span class="line">    wiringPiSetup();      <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);   <span class="comment">// PC10输入</span></span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);  <span class="comment">// PC7作为输入</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);    <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="comment">// 创建匿名管道</span></span><br><span class="line">    ret = pipe(pd);      <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;     <span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    pid = fort();    <span class="comment">// 创建进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);      <span class="comment">// 关闭管道读</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);      <span class="comment">// 关闭管道写</span></span><br><span class="line">        perror(<span class="string">&quot;fort&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程处理</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.在子进程中写入判断函数并将标志位发送到父进程中，并让LED灯亮起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;       <span class="comment">// 接收返回值</span></span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];     <span class="comment">// 管道描述符</span></span><br><span class="line">    <span class="type">int</span> pid;       <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;  <span class="comment">// 标志位</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];   <span class="comment">// 发送的字符串</span></span><br><span class="line">    wiringPiSetup();      <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);   <span class="comment">// PC10输入</span></span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);  <span class="comment">// PC7作为输入</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);    <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="comment">// 创建匿名管道</span></span><br><span class="line">    ret = pipe(pd);      <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;     <span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    pid = fort();    <span class="comment">// 创建进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);      <span class="comment">// 关闭管道读</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);      <span class="comment">// 关闭管道写</span></span><br><span class="line">        perror(<span class="string">&quot;fort&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程处理</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);     <span class="comment">// 关闭读端，因为子进程只需要写入数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 按键按下</span></span><br><span class="line">                delay(<span class="number">20</span>);</span><br><span class="line">                <span class="keyword">while</span>(digitalRead(<span class="number">16</span>) == <span class="number">0</span>);   <span class="comment">// 消抖</span></span><br><span class="line">                flag = !flag;</span><br><span class="line">                <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d&quot;</span>, flag); <span class="comment">// 拼接发送的字符串</span></span><br><span class="line">                write(pd[<span class="number">1</span>], buf, <span class="number">2</span>);     <span class="comment">// 向管道写入数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程处理</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);     <span class="comment">// 关闭写端，因为只用读取内容</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            read(pd[<span class="number">0</span>], buf, <span class="number">2</span>);   <span class="comment">// 读取数据</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;1&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 高电平</span></span><br><span class="line">                digitalWrite(<span class="number">13</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 低电平</span></span><br><span class="line">                digitalWrite(<span class="number">13</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以执行一下查看一下效果了：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220192448068-2133076134.jpg" alt="img"></p>
<p>然后再按下按钮</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220192511244-251167665.jpg" alt="img"></p>
<p>为了让大家看得更清楚这个过程我特意添加了一下输出语句来给大家查看一下效果</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220192554739-1728047936.png" alt="img"></p>
<p>这种方法就和中断一样，系统的主执行内容不会被影响，毕竟是有另一个进程在读取按键的按下和松开。</p>
<h2 id="2-wiringPi库函数版"><a href="#2-wiringPi库函数版" class="headerlink" title="2.wiringPi库函数版"></a>2.wiringPi库函数版</h2><p>这种方法是使用<code>wiringPi</code>中的函数来进行实现的，但是我这一直都搞不了，我还在研究这个方法，为了弄这个我今天买了块3b来进行测试，我看看是不是因为zero的不支持还是什么原因，这里后面再补全，先介绍一下这个方法的代码如何写，这里使用的函数是<code>wiringPiISR</code>，函数的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wiringPiISR</span> <span class="params">(<span class="type">int</span> pin, <span class="type">int</span> mode, <span class="type">void</span> (*function)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>功能：该函数会在指定管脚注册一个中断事件的函数，当指定管脚发生中断事件时，会自动调用该函数。</p>
<p>第一个参数是你要让哪个引脚注册位中断，比如说<code>PC7</code>，那这就填写13。</p>
<p>第二个参数是触发模式</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>INT_EDGE_FALLING</td>
<td>下降沿触发</td>
</tr>
<tr>
<td>INT_EDGE_RISING</td>
<td>上升沿触发</td>
</tr>
<tr>
<td>INT_EDGE_BOTH</td>
<td>上升沿或下降沿触发</td>
</tr>
<tr>
<td>INT_EDGE_SETUP</td>
<td>不初始化</td>
</tr>
</tbody></table>
<p>当使用最后的一种方法时，这个函数不会初始化这个引脚，它会默认是在其他敌法进行了初始化。</p>
<p>第三个参数是中断函数，就是当注册的引脚触发了就会触发这个函数进行执行。</p>
<p>返回值如果不成功就会返回一个小于0的数，可以用这个返回值来判断一下初始化是否成功。</p>
<p>知道了这个我们就可以利用这个函数来实现中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myinterrinput</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 中断处理函数</span></span><br><span class="line">    flag = !flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);</span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);</span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);    <span class="comment">// 上拉输入</span></span><br><span class="line">    wiringPiISR(<span class="number">16</span>, INT_EDGE_FALLING, &amp;myinterrinput);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        digitalWrite(<span class="number">13</span>, flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后，当按键按下后就会执行中断函数，但是我这一执行后就会出现下面的问题</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220194408929-87332833.png" alt="img"></p>
<p>这个问题我还在研究到底是为什么，网上也没找到合适的答案，这里我先空着，等3b到了我再试试。</p>
<h2 id="3-线程版"><a href="#3-线程版" class="headerlink" title="3.线程版"></a>3.线程版</h2><p>这个版本就可以分为Linux内核线程和wiringPi库函数版的线程了。</p>
<p>这里先使用Linux内核的线程</p>
<h3 id="3-1-Linux内核的线程"><a href="#3-1-Linux内核的线程" class="headerlink" title="3.1 Linux内核的线程"></a>3.1 Linux内核的线程</h3><p>其实这个也不能称为Linux内核线程，因为之前的linux最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调用度的实体。然后就将线程进行了改写，由NPTL进行接手，我们现在用的线程是NPTL。</p>
<p>我们可以通过下面的指令来下载NPTL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install manpages-posix-posix-dev</span><br></pre></td></tr></table></figure>

<p>通过下面的指令来查看一下NPTL的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getconf GNU_LIBPTHREAD_VERSION</span><br></pre></td></tr></table></figure>

<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231220201337192-1530467255.png" alt="img"></p>
<p>我这里的版本是<code>2.35</code>，只要有这个即可。</p>
<p>这里不过多介绍线程的概念，如果大家对线程感兴趣我后面会出有关于线程的文章给大家介绍一下的。</p>
<p>现在开始编程</p>
<p>1.初始化需要的引脚</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();      <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);   <span class="comment">// PC10输入</span></span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);  <span class="comment">// PC7作为输入</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);    <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建管道和线程，这里线程之间的内容是独立的，和上面的进程一样，需要我们创建一个管道来实现进程间的通讯，所以需要创建一个管道。</p>
<p>在写之前，我们需要了解一下线程的创建函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthred_create</span><span class="params">(<span class="type">pthread_t</span>* thread, <span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* (*start_routine)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个线程</span><br><span class="line">参数：</span><br><span class="line">    thread：线程标识符地址。</span><br><span class="line">    attr：线程属性结构体地址，通常设置为<span class="literal">NULL</span>。</span><br><span class="line">    start_routine：线程函数的入口地址。</span><br><span class="line">    arg：传入线程函数的参数。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>然后就可以开始写代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">myinterrinput</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="comment">// 进程执行函数</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">pthread_t</span> tid;       <span class="comment">// 线程标识符</span></span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    wiringPiSetup();     <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);</span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);</span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    ret = pipe(pd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;myinterrinput, (<span class="type">void</span>*)&amp;pd[<span class="number">1</span>]);       <span class="comment">// 创建进程的函数 这里将管道的描述符传递给线程处理函数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        close(pd[<span class="number">0</span>]);      <span class="comment">// 关闭管道读</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);      <span class="comment">// 关闭管道写</span></span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 主进程处理一些非中断的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.然后开始完善处理代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">myinterrinput</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(digitalRead(<span class="number">16</span>) == <span class="number">0</span>);</span><br><span class="line">            flag = !flag;</span><br><span class="line">            <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d&quot;</span>, flag);</span><br><span class="line">            <span class="comment">// 下面的代码需要注意一下，非常重要，用了两次强转，因为传递过来的参数是void类型的，长度不够，所以这里使用了两次强转将长度匹配到4</span></span><br><span class="line">            <span class="keyword">if</span> (write(*(<span class="type">int</span>*)(<span class="type">long</span>*)arg, buf, <span class="number">2</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">pthread_t</span> tid;       <span class="comment">// 线程标识符</span></span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    wiringPiSetup();     <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);</span><br><span class="line">    pinMode(<span class="number">13</span>, OUTPUT);</span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    ret = pipe(pd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;myinterrinput, (<span class="type">void</span>*)&amp;pd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        close(pd[<span class="number">0</span>]);      <span class="comment">// 关闭管道读</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);      <span class="comment">// 关闭管道写</span></span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        read(pd[<span class="number">0</span>], buf, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;1&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            digitalWrite(<span class="number">13</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf, <span class="string">&quot;0&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            digitalWrite(<span class="number">13</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后开始编译，这里编译的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc threadButton.c -o threadButton -lwiringPi -lpthread</span><br></pre></td></tr></table></figure>

<p>因为<code>pthread</code>是属于外部库，需要使用<code>-l</code>进行连接。</p>
<p>运行后也是一样的效果，我就懒得拍照了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>中断其实很有用的，但是对于这种多线程的开发板可以用一些其他的方式来实现这个方法，比如软中断，后面我研究一下如何通过底层实现外中断，毕竟上面的这些方法消耗的资源有点大，而且反应比直接中断要慢。</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-点亮OLED显示屏</title>
    <url>/2025/01/17/ef0ed158c24d/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我因为没买屏幕所以一直都是用ssh来远程连接，但是这会出现一个问题，香橙派的IP地址是动态的，它每隔一段时间就会换一下IP地址，而每次换IP地址后原来的IP地址就失效了。虽然可以固定IP地址，但是我觉得在每次开机直接通过一块OLED显示屏将IP地址显示才是最好的。</p>
<h1 id="一、IIC协议"><a href="#一、IIC协议" class="headerlink" title="一、IIC协议"></a>一、IIC协议</h1><p>我这里使用的是0.96寸OLED IIC协议的显示屏，是之前做外包剩下的，所以直接拿来用一下，在网上9块钱可以整一块</p>
<p>这块显示屏是IIC协议的，所以我们需要先了解一下IIC协议，虽然香橙派中IIC协议是有硬件程序，但我们也是需要了解一下这个协议。</p>
<h2 id="1-IIC协议的组成"><a href="#1-IIC协议的组成" class="headerlink" title="1.IIC协议的组成"></a>1.IIC协议的组成</h2><p>IIC协议要顺利运行是需要两个东西一起工作才可以实现，第一个是SDA，也就是数据引脚，这个引脚是负责传输数据信息的。第二个是SCL，时钟引脚，用来传输时钟信息的。</p>
<p>时钟引脚是按照一定的频率来进行震荡的，这样才能为从机提供时钟信息，也是为了让主机和从机按照一定的频率来进行数据交互。</p>
<p>数据引脚是可以让从机和主机进行数据交换的，这个引脚可以传输命令或者是数据。</p>
<h2 id="2-IIC的时序图"><a href="#2-IIC的时序图" class="headerlink" title="2.IIC的时序图"></a>2.IIC的时序图</h2><p>了解了这两个引脚后我们就可以看一下时序图来了解什么时候该传输什么信息。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224122254562-1734348769.png" alt="img"></p>
<p>可以看到一开始主机需要发送一个<code>start</code>信号，也就是起始信号，发送完其实信号后发送了一个控制信息<code>MSB</code>，然后由<code>MSB</code>控制信息决定是读取命令&#x2F;数据还是写入命令&#x2F;数据，然后就开始传输数据，当传输完成后主机或者从机就会发送一个<code>ACK</code>响应信号。</p>
<p>如果一开始是主机向从机发送数据或者命令，那从机会发送一个<code>ACK</code>响应信号。</p>
<p>如果一开始是从机向主机发送数据或者命令，那主机需要发送一个<code>ACK</code>响应信号。</p>
<p>然后传输完成后发送了一个<code>stop</code>结束信号，当这个信号发送了后，说明一次的IIC协议就传输完成。</p>
<p>接下来好好分析一下IIC的这些内容。</p>
<h2 id="3-IIC起始信号和结束信号"><a href="#3-IIC起始信号和结束信号" class="headerlink" title="3.IIC起始信号和结束信号"></a>3.IIC起始信号和结束信号</h2><p>先将这两个信号单独拿下来分析。</p>
<p>首先看一下起始信号</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224123309215-1732392374.png" alt="img"></p>
<p>可以看到起始信号是时序图很简单，让<code>SCL</code>时钟信号保存高电平，然后<code>SDA</code>数据信号有一个从高到低的下降沿，代码我们就可以这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">digitalWrite(SCL, <span class="number">1</span>);</span><br><span class="line">digitalWrite(SDA, <span class="number">1</span>);</span><br><span class="line">digitalWrite(SDA, <span class="number">0</span>);</span><br><span class="line">digitalWrite(SCL, <span class="number">1</span>);</span><br><span class="line">digitalWrite(SCL, <span class="number">0</span>);   <span class="comment">// 为传输数据做准备</span></span><br></pre></td></tr></table></figure>

<p>这样就可以启动IIC协议，当然，我们今天的重点不是用软件模拟IIC协议，所以上面的代码仅供参考，毕竟还有时间的问题。</p>
<p>然后再来看看结束信号</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224123737352-1167251994.png" alt="img"></p>
<p>结束信号也是很简单，让<code>SDA</code>从低到高有一个上升沿，<code>SCL</code>一直保持高电平即可，代码就可以这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">digitalWrite(SCL, <span class="number">1</span>);</span><br><span class="line">digitalWrite(SDA, <span class="number">0</span>);</span><br><span class="line">digitalWrite(SDA, <span class="number">1</span>);</span><br><span class="line">digitalWrite(SCL, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这样就可以结束这一次的IIC协议。</p>
<h2 id="4-控制信息"><a href="#4-控制信息" class="headerlink" title="4.控制信息"></a>4.控制信息</h2><p>控制信息是主机来选择控制的从机是发送数据还是接收数据的一个操作信息，因为IIC可以支持多从机并联，这个时候就得用地址来区分控制的设备了。</p>
<p>控制信息由两个部分组成：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224124431639-1547011114.png" alt="img"></p>
<p>一个是从机地址，另一个是传输的数据模式，从机地址是这个设备生产的时候就已经写入进去了，如果你需要多个不同的从机地址，你可以去找厂商去更改一下，OLED显示屏的地址是<code>0x78</code>。</p>
<p>数据模式就是在控制信息后是读取命令数据还是写入数据命令，如下表：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>读取</td>
</tr>
<tr>
<td>0</td>
<td>写</td>
</tr>
</tbody></table>
<p>比如说我们这写入数据，那代码就如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readDataStart</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> address = <span class="number">0x78</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        digitalWrite(SCL, <span class="number">0</span>);</span><br><span class="line">        digitalWrite(SDA, (address &lt;&lt; i &amp; <span class="number">0x80</span>));    <span class="comment">// 从高位开始传递</span></span><br><span class="line">        digitalWrite(SCL, <span class="number">1</span>);</span><br><span class="line">        digitalWrite(SCL, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是需要读的话，地址就改为<code>0x79</code>。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224135130308-2037944183.png" alt="img"></p>
<p>这个就是传输数据的时序图，当<code>SCL</code>上升沿后，就会把<code>SDA</code>的数据传输过去。</p>
<h2 id="5-传输数据或者命令"><a href="#5-传输数据或者命令" class="headerlink" title="5.传输数据或者命令"></a>5.传输数据或者命令</h2><p>在传输帧中，因为要区分命令或者数据，所以一开始需要传输一个标志来区分出后面的数据是命令还是地址，这个传输帧如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224135427282-900446650.png" alt="img"></p>
<p>如果我们要传输数据，那这先得传输一个<code>0x40</code>，如果是一个命令，那传输<code>0x00</code>，传输完成后就可以传输要传递的数据了。</p>
<p>根据这个就可以写出传递数据的函数了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sendData</span><span class="params">()</span>&#123;</span><br><span class="line">    OLED_I2C_Start();</span><br><span class="line">    OLED_I2C_SendByte(<span class="number">0x78</span>);		<span class="comment">//从机地址</span></span><br><span class="line">    OLED_I2C_SendByte(<span class="number">0x40</span>);		<span class="comment">//写数据</span></span><br><span class="line">    OLED_I2C_SendByte(Data);        <span class="comment">// 要传输的数据</span></span><br><span class="line">    OLED_I2C_Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些是封装好了的函数，等后面会写的。</p>
<h1 id="二、香橙派的硬件IIC"><a href="#二、香橙派的硬件IIC" class="headerlink" title="二、香橙派的硬件IIC"></a>二、香橙派的硬件IIC</h1><p>在香橙派中是有IIC这个硬件协议的，并且在<code>wiringPi</code>库中也是有对应的函数的，所以我们可以直接使用硬件的IIC来完成我们的项目，但是要使用IIC就需要在设置中将其打开，打开的方式很简单。</p>
<p>首先在命令行中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo orangepi-config</span><br></pre></td></tr></table></figure>

<p>然后就进入到设置页面，在这个页面只能用键盘来进行操作，回车是确定，空格是选择</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224140414908-1646415316.png" alt="img"></p>
<p>然后选择<code>System</code>后按下回车，就进入下面的界面</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224140509216-22980975.png" alt="img"></p>
<p>然后用方向键移动到<code>Hardare</code>后按下回车，就可以进入一些功能设置界面了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224140612493-1580241930.png" alt="img"></p>
<p>可以看到有很多的功能，这里我们需要使用到<code>IIC</code>所以就只打开<code>IIC</code>，需要注意一下，这里有3个<code>IIC</code>，这3个对应着不同的引脚，下面的引脚图可以参考</p>
<p>Pi3的GPIO引脚</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224140757699-1722401549.png" alt="img"></p>
<p>zero 3的GPIO引脚</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231224141015298-1009303537.png" alt="img"></p>
<p>我们着选择<code>m1</code>就行了，选择完成后就可以回车了，然后让我们重启一下，当重启完成后再按照上面的办法进行打开来查看一下是否打开成功。</p>
<h1 id="三、Pi3的OLED驱动代码"><a href="#三、Pi3的OLED驱动代码" class="headerlink" title="三、Pi3的OLED驱动代码"></a>三、Pi3的OLED驱动代码</h1><p>这里说一下如何编写OLED的驱动代码。</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-使用蓝牙和手机进行信息的交换</title>
    <url>/2025/01/17/feaf0486f5af/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>隔了这么久我准备再玩一下香橙派，最近这段时间还是比较的忙，我搭建了个论坛和博客，经常被网络攻击，所以我也是一直在弄网络去了，然后今天比较空闲就想着把单子做一下，这个单子需要使用到HC05蓝牙模块，所以我准备写一篇博客来使用香橙派控制HC05蓝牙模块。</p>
<h1 id="一、HC05蓝牙模块"><a href="#一、HC05蓝牙模块" class="headerlink" title="一、HC05蓝牙模块"></a>一、HC05蓝牙模块</h1><p>这个模块是非常经典的一个蓝牙模块，我之前有一单也是使用到这个模块，可以看一下我的这个视频<a href="https://www.bilibili.com/video/BV1PH4y117oV/?share_source=copy_web&vd_source=4bb508bdc624514980a5500e28ea3819">【作息控制系统使用说明】</a>，这个项目也是使用到蓝牙模块的，只不过当时时间紧任务重所以就没有写一篇博客来好好记录一下这个项目，等后面我会单独拿一个模块来介绍一下我做的这些小项目。</p>
<h2 id="1-HC05概述"><a href="#1-HC05概述" class="headerlink" title="1.HC05概述"></a>1.HC05概述</h2><p>HC05是嵌入式蓝牙串口通讯模块，也就是使用串口就可以和HC05进行通讯并发送信息给蓝牙的接收端，这个模块有两种工作方式：</p>
<p>1 命令响应工作模式</p>
<p>2 自动连接工作模式</p>
<p>在自动连接的工作模式下又可以分为主、从、回环这三种模式，当传输数据时，根据事先设定的方式连接并传输数据。</p>
<p>在命令模式下，用户可以使用串口连接模块，并发送<code>AT</code>指令对模块进行设置。</p>
<h2 id="2-HC05的连接图"><a href="#2-HC05的连接图" class="headerlink" title="2.HC05的连接图"></a>2.HC05的连接图</h2><p>这里我直接使用<code>TTL to USB</code>进行连接，因为我要设置一下这个模块的一些传输和内容。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131222614043-381623405.jpg" alt="img"></p>
<p>这里和串口连接的模式一样</p>
<table>
<thead>
<tr>
<th>HC05</th>
<th>TTL</th>
</tr>
</thead>
<tbody><tr>
<td>3.3</td>
<td>VCC</td>
</tr>
<tr>
<td>TXD</td>
<td>RXD</td>
</tr>
<tr>
<td>RXD</td>
<td>TXD</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
</tbody></table>
<h2 id="3-进入HC05的命令模式"><a href="#3-进入HC05的命令模式" class="headerlink" title="3.进入HC05的命令模式"></a>3.进入HC05的命令模式</h2><p>首先我们需要通过<code>AT</code>指令来设置模块的一些内容，然后我们才好进入下面的一些操作，首先在这个模块上有一个按钮</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131222952266-1526676184.jpg" alt="img"></p>
<p>在上电之前需要长按这个按键，然后再上电就可以进入命令模式，在进入命令模式后，模块上的LED等会缓慢的闪烁，如果没有进入就会闪得很快。</p>
<h2 id="4-常用的AT指令"><a href="#4-常用的AT指令" class="headerlink" title="4.常用的AT指令"></a>4.常用的AT指令</h2><p>AT指令列表已经烂大街了，所以这里不全部说明，我只拿出一些常用的来说明即可。</p>
<h3 id="4-1-检查AT是否上线"><a href="#4-1-检查AT是否上线" class="headerlink" title="4.1 检查AT是否上线"></a>4.1 检查AT是否上线</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT\r\n</span><br></pre></td></tr></table></figure>

<p>如果模块在就会返回<code>OK</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131223407901-1242056721.png" alt="img"></p>
<h3 id="4-2-重启模块"><a href="#4-2-重启模块" class="headerlink" title="4.2 重启模块"></a>4.2 重启模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+RESET\r\n</span><br></pre></td></tr></table></figure>

<p>如果执行成功就会返回<code>OK</code>，并进入自动连接模式</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131223545021-2054088621.png" alt="img"></p>
<h3 id="4-3-获取软件版本号"><a href="#4-3-获取软件版本号" class="headerlink" title="4.3 获取软件版本号"></a>4.3 获取软件版本号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT_VERSION?\r\n</span><br></pre></td></tr></table></figure>

<p>执行完成后会返回版本信息和<code>OK</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131223713062-1270983779.png" alt="img"></p>
<h3 id="4-4-恢复默认状态"><a href="#4-4-恢复默认状态" class="headerlink" title="4.4 恢复默认状态"></a>4.4 恢复默认状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+ORGL\r\n</span><br></pre></td></tr></table></figure>

<p>执行完成后会返回<code>OK</code>，并将模块恢复为出厂设置。</p>
<h3 id="4-5-获取蓝牙的名称"><a href="#4-5-获取蓝牙的名称" class="headerlink" title="4.5 获取蓝牙的名称"></a>4.5 获取蓝牙的名称</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+NAME?\r\n</span><br></pre></td></tr></table></figure>

<p>执行完成后会返回蓝牙名称并返回<code>OK</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131224015613-183098500.png" alt="img"></p>
<h3 id="4-6-设置蓝牙模块的波特率"><a href="#4-6-设置蓝牙模块的波特率" class="headerlink" title="4.6 设置蓝牙模块的波特率"></a>4.6 设置蓝牙模块的波特率</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+UART=波特率,停止位,校验位\r\n</span><br></pre></td></tr></table></figure>

<p>这里我们设置一个比较常见的，波特率9600，停止位1位，无校验位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+UART=9600,1,0</span><br></pre></td></tr></table></figure>

<p>这样就可以了。</p>
<h3 id="4-7-查询蓝牙的连接模式"><a href="#4-7-查询蓝牙的连接模式" class="headerlink" title="4.7 查询蓝牙的连接模式"></a>4.7 查询蓝牙的连接模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+CMODE?\r\n</span><br></pre></td></tr></table></figure>

<p>返回当前模式，1代表任意模式，也就是蓝牙名称和蓝牙地址都可以连接，这里就不多说了，一般默认是1就可以了。</p>
<h3 id="4-8-查询模块角色"><a href="#4-8-查询模块角色" class="headerlink" title="4.8 查询模块角色"></a>4.8 查询模块角色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT+ROLE?</span><br></pre></td></tr></table></figure>

<p>这里默认的是<code>Slave</code>从角色，也就是被动连接，不用动。</p>
<h2 id="5-连接电脑"><a href="#5-连接电脑" class="headerlink" title="5.连接电脑"></a>5.连接电脑</h2><p>这里我踩了个大坑，因为我之前的设置是将波特率改为9600了，所以在串口的时候我就用9600进行连接，结果没有任何的反应，后面查了一下手册才发现它默认的波特率是<code>38400</code>，就很尴尬。</p>
<p>这里连接好电脑后先发送个<code>AT</code>指令来查看一下是否返回OK，如果没返回有可能是因为坏了或者是你没长按按键进入命令模式。</p>
<p>然后修改一下波特率，因为我们后面初始化串口不想给那么大的波特率</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131225350954-637982947.png" alt="img"></p>
<p>初始化完成后要记得重启一下模块，然后模块的波特率就设置好看，但是AT指令模式下还是那个波特率（又踩坑了，当不想改文章）。</p>
<h2 id="6-通过HC05发送消息"><a href="#6-通过HC05发送消息" class="headerlink" title="6.通过HC05发送消息"></a>6.通过HC05发送消息</h2><p>这里我先用stm32来演示，因为我还在做单子所以先拿这个演示。</p>
<p>首先先写串口的初始化函数，这里我使用的是<code>USART1</code>，初始化代码就不展示了，因为今天的主题不是stm32，然后在main函数中我们使用重写的<code>printf</code>来通过串口发送数据。不知道的可以看我这篇博客<a href="https://www.cnblogs.com/Lavender-edgar/p/17591746.html">异步通讯点灯</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    OLED_Init();</span><br><span class="line">    MX_Init_KEY();</span><br><span class="line">    MX_Init_HC05();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\r\n&quot;</span>);</span><br><span class="line">        OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要在手机上下载<code>蓝牙调试宝</code>，在应用商城都可以下载，这我就不给你们压缩包了，要不然我老喜欢挂码。</p>
<p>首先要把蓝牙模块连接到面包板上，然后就用手机连接好蓝牙</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131232923132-1431987147.jpg" alt="img"></p>
<p>记住串口反接并且要接地即可。</p>
<p>然后打开蓝牙助手的界面</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131233636527-494670284.jpg" alt="img"></p>
<p>找到里面有一个<code>HC-05</code>，然后连接即可，第一次连接需要你输入一个配对码，这里输入1234或者0000都可以</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131233741588-579644404.jpg" alt="img"></p>
<p>然后给单片机上电后就会显示出hello来</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202401/3083010-20240131233820799-2037271568.jpg" alt="img"></p>
<p>学到这你已经会使用蓝牙进行发送信息了，stm32就先不再出现了，后面就是香橙派的内容了。</p>
<h2 id="7-stm32完整代码"><a href="#7-stm32完整代码" class="headerlink" title="7.stm32完整代码"></a>7.stm32完整代码</h2><p>usart.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hc05.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MX_Init_HC05</span><span class="params">()</span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    USART_InitTypeDef USART_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">    </span><br><span class="line">    USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">    USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">    USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class="line">    USART_InitStruct.USART_Parity = USART_Parity_No;</span><br><span class="line">    USART_InitStruct.USART_StopBits = USART_StopBits_1;</span><br><span class="line">    USART_InitStruct.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">    USART_Init(USART1, &amp;USART_InitStruct);</span><br><span class="line">    USART_Cmd(USART1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;      </span><br><span class="line">	<span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);  </span><br><span class="line">    USART1-&gt;DR = (u8) ch;      </span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、香橙派串口通讯"><a href="#二、香橙派串口通讯" class="headerlink" title="二、香橙派串口通讯"></a>二、香橙派串口通讯</h1><p>在介绍使用香橙派使用HC05模块前先介绍一下串口通讯，并如何配置串口通讯。</p>
<h2 id="1-打开串口设备"><a href="#1-打开串口设备" class="headerlink" title="1.打开串口设备"></a>1.打开串口设备</h2><p>在香橙派中，串口通讯是使用设备来进行传输的， 所以我们需要在系统设置中将串口进行打开。</p>
<p>在打开之前先了解一下香橙派的串口引脚分布</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201004955316-115234185.png" alt="img"></p>
<p>在3b中有3个串口可供选择，然后通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo orangepi-config</span><br></pre></td></tr></table></figure>

<p>来开启设备，进入到设置页面</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201005302098-113983016.png" alt="img"></p>
<p>然后选择第一个，按一下回车即可，然后在下面的页面中选择<code>Hardware</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201005337757-1243728913.png" alt="img"></p>
<p>然后找到你要开启的串口</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201005401317-2122540859.png" alt="img"></p>
<p>我这选择的是<code>UART7</code>，使用方向键移动到那后按一下空格就选中，然后按一下回车保存，之后会提示是否重启，然后按一下回车就可以重启了。</p>
<p>重启完成后使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /dev/ ttyS*</span><br></pre></td></tr></table></figure>

<p>来查看可操作的设备文件，这里只会显示你开启的设备</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201005541612-792900492.png" alt="img"></p>
<p>我们刚才选择了<code>UART7</code>后它这里就会有相应的设备，那个<code>ttyS1</code>是默认开启的，我们不用理他。</p>
<h2 id="2-接线"><a href="#2-接线" class="headerlink" title="2.接线"></a>2.接线</h2><p>这里就需要非常非常注意了，我在测试的时候就是这里没有弄好，线接反了，导致一直发送不了。</p>
<p>按照前面给的那张图进行接线后我们就可以写代码了。</p>
<p><strong>注意：这里很重要，很多人玩51单片机来玩这个会忽略一个问题就是GND必须要和单片机的GND接在一起，很多人会单独给这个引脚接GND是错误的。</strong></p>
<h2 id="3-串口函数"><a href="#3-串口函数" class="headerlink" title="3.串口函数"></a>3.串口函数</h2><p>这里使用的串口函数库是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-打开串口文件"><a href="#3-1-打开串口文件" class="headerlink" title="3.1 打开串口文件"></a>3.1 打开串口文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serialOpen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">int</span> butrl)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是设备的路径，比如说我们这需要使用到<code>UART1</code>，那设备地址就是<code>/dev/ttyS7</code>。</p>
<p>第二个参数是波特率，比如9600。</p>
<p>这个函数的返回值是一个文件描述符，我们使用一个变量来接收就可以了。</p>
<h3 id="3-2-关闭串口文件"><a href="#3-2-关闭串口文件" class="headerlink" title="3.2 关闭串口文件"></a>3.2 关闭串口文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serialClose</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>参数是打开的设备描述符。</p>
<h3 id="3-3-发送一个字符"><a href="#3-3-发送一个字符" class="headerlink" title="3.3 发送一个字符"></a>3.3 发送一个字符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serialPutchar</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> c)</span>;</span><br></pre></td></tr></table></figure>

<p>将一个字符发送到打开的文件描述符fd所对应的设备文件。</p>
<h3 id="3-4-发送一个规定好的字符串"><a href="#3-4-发送一个规定好的字符串" class="headerlink" title="3.4 发送一个规定好的字符串"></a>3.4 发送一个规定好的字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serialPuts</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* s)</span>;</span><br></pre></td></tr></table></figure>

<p>发送一个规定好的字符串，然后以0结尾。</p>
<h3 id="3-5-printf"><a href="#3-5-printf" class="headerlink" title="3.5 printf"></a>3.5 printf</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serialPrintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* message, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>这个和printf的用法类似。</p>
<h3 id="3-6-返回等待读取的字符数"><a href="#3-6-返回等待读取的字符数" class="headerlink" title="3.6 返回等待读取的字符数"></a>3.6 返回等待读取的字符数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serialDataAvail</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>返回的是等待读取的字符数。</p>
<h3 id="3-7-读取字符"><a href="#3-7-读取字符" class="headerlink" title="3.7 读取字符"></a>3.7 读取字符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serialGetChar</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>返回下一个待读取的字符，如果这个在10s内没有读取到字符就会返回-1。</p>
<h3 id="3-8-缓冲区函数"><a href="#3-8-缓冲区函数" class="headerlink" title="3.8 缓冲区函数"></a>3.8 缓冲区函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serialFlush</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>抛弃所有接收的数据或者等待写入设备完成。</p>
<h2 id="4-输出内容"><a href="#4-输出内容" class="headerlink" title="4.输出内容"></a>4.输出内容</h2><p>通过学习了上面的内容后我们可以简单写一个输出字符的代码来输出0~9</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>, i;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);    <span class="comment">// 设置串口设备和波特率</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 设备打开失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设备打开失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serialFlush(fd);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        serialPutchar(fd, i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    serialClose(fd);     <span class="comment">// 关闭设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201011437761-796252053.png" alt="img"></p>
<p>然后也可以使用printf来个高级一点的输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>, i;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);    <span class="comment">// 设置串口设备和波特率</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 设备打开失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设备打开失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serialFlush(fd);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        serialPrintf(fd, <span class="string">&quot;this is%d\r\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    serialClose(fd);     <span class="comment">// 关闭设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的内容如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201011632150-2099482164.png" alt="img"></p>
<h2 id="5-接收内容"><a href="#5-接收内容" class="headerlink" title="5.接收内容"></a>5.接收内容</h2><p>我们可以通过串口来接收一下用户输入的内容，并判断输入的字符是不是我们需要的，然后通过串口返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>, i;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);    <span class="comment">// 设置串口设备和波特率</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 设备打开失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设备打开失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serialFlush(fd);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        c = serialGetchar(fd);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            serialPrintf(fd, <span class="string">&quot;this is 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    serialClose(fd);     <span class="comment">// 关闭设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的内容：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201012139484-1871459667.png" alt="img"></p>
<p>这里大家可以看到我在这个while循环中添加了一个printf，但是没有截屏给出效果，是因为在这个串口运行的过程中一直在读取的是串口的设备，没有使用输入输出流设备，所以导致我们在输入后没办法显示出内容来，这个的解决办法我还不太清楚，等我研究好了我在出一篇文章来介绍。</p>
<h2 id="6-接收字符串"><a href="#6-接收字符串" class="headerlink" title="6.接收字符串"></a>6.接收字符串</h2><p>做串口最让人沉醉的就是读取字符串的操作了,在<code>wiringSerial</code>中有一个函数可以获取缓冲区的长度，我们可以判断这个来读取输入的数据的长度，然后使用一个<code>for</code>循环来循环读取和放置在一个数组中，之后进行输出即可，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i, ch, j = <span class="number">0</span>, len;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开设备文件失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        len = serialDataAvail(fd);     <span class="comment">// 获取缓冲区的长度</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 超时退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            serialPrintf(fd, <span class="string">&quot;%d\n&quot;</span>, len);    <span class="comment">// 这一行是测试的</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len;  i++)&#123;</span><br><span class="line">                ch = serialGetchar(fd);       <span class="comment">// 读取字符</span></span><br><span class="line">                str[j++] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    str[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    serialClose(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、使用hc05连接香橙派"><a href="#三、使用hc05连接香橙派" class="headerlink" title="三、使用hc05连接香橙派"></a>三、使用hc05连接香橙派</h1><p>学会了上面的操作后我们就可以来用香橙派连接hc05了，这个操作也非常非常的简单，和单片机的连接一致，注意不要连错就行了。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201222725359-170013347.jpg" alt="img"></p>
<h2 id="1-通过蓝牙发送字符串给手机"><a href="#1-通过蓝牙发送字符串给手机" class="headerlink" title="1.通过蓝牙发送字符串给手机"></a>1.通过蓝牙发送字符串给手机</h2><p>本质的思路还是一样的，就是使用串口是输入输出就可以搞定，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>, i;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);    <span class="comment">// 设置串口设备和波特率</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 设备打开失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设备打开失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serialFlush(fd);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        serialPrintf(fd, <span class="string">&quot;hello\r\n&quot;</span>);</span><br><span class="line">        delayMicroseconds(<span class="number">30000</span>);     <span class="comment">// 延时函数，免得发送得过快</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    serialClose(fd);     <span class="comment">// 关闭设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在调试助手中就可以看到蓝牙模块发送的内容了：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201222924734-1412345816.jpg" alt="img"></p>
<h2 id="2-手机发送内容给香橙派"><a href="#2-手机发送内容给香橙派" class="headerlink" title="2.手机发送内容给香橙派"></a>2.手机发送内容给香橙派</h2><p>这里可以使用刚才我们测试的接收字符串，只不过这里有一个问题就是这个工具只能发送字符所对应的ascii码，不能正常的输入字符进行输出。</p>
<p>比如我们手机输入字符0，那就得输入ascii码的30</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201223956644-1830750314.jpg" alt="img"></p>
<p>然后在香橙派中就会显示：</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201224021569-740821848.png" alt="img"></p>
<p>然后我们还可以用这个来输入0~9</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201224151378-596771392.jpg" alt="img"></p>
<p>然后显示</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202402/3083010-20240201224204795-1231226835.png" alt="img"></p>
<p>学会了这个后我们就可以编写一个用蓝牙点灯的程序了，其实就是使用蓝牙接收到关键字后给LED灯高低电平，这里就直接给代码了，不展示图片了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringSerial.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i, ch, j = <span class="number">0</span>, len;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">    wiringPiSetup();</span><br><span class="line">    fd = serialOpen(<span class="string">&quot;/dev/ttyS7&quot;</span>, <span class="number">9600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开设备文件失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        len = serialDataAvail(fd);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            serialPrintf(fd, <span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len;  i++)&#123;</span><br><span class="line">                ch = serialGetchar(fd);</span><br><span class="line">                str[j++] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    str[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str, <span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// 点灯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 灭灯</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serialClose(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>串口很好玩，蓝牙模块也好玩，学会了这一节我们就可以使用蓝牙做一个简单的远程开关灯的项目了，当然拿香橙派做这个项目就很浪费，毕竟香橙派可以直接使用网络来实现，做一个网页，然后内网穿透，这样可以很容易的在远程进行控制了，等我最近忙完有时间我做一个。</p>
<p>大家可以关注一下我的论坛和博客，有不懂的或者有趣的问题可以放在我的论坛中进行提问</p>
<p><a href="https://bbs.lavenderedgar.asia/">马桶论坛</a></p>
<p><a href="https://blog.lavenderedgar.asia/">马桶博客</a></p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-无屏幕使用香橙派</title>
    <url>/2025/01/17/27a3b7954e84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学单片机之前我就接触到树莓派这个掌间电脑，之前买了一块但是一直放在家里面吃灰，然后这几天突然感觉树莓派很好玩，准备买一块来玩一下，但是树莓派的价格实在是太高了，我还只是个学生没那么多钱，然后呢我在网上找到了一个平替的板子就是这个系列的主题–香橙派，我买了个比较便宜的<code>orange-zero-3</code>，内存是1.5G的，因为我只拿来做Linux的练习不用图形化界面，所以不需要太大的运行内存，但是我还是对电脑的了解还是太少了，我以为可以用一根HDMI线连接到我的笔记本的HDMI口进行操作的，但是电脑上的HDMI口只能输出所以就没办法了，在我这几天逛互联网的时候我找到了一个方法就是使用串口来设置这个板子，正好我有一个<code>USB to TTL</code>，就试了一下，随便写了个笔记。</p>
<h1 id="一、使用的东西"><a href="#一、使用的东西" class="headerlink" title="一、使用的东西"></a>一、使用的东西</h1><p>先准备一个香橙派<code>zero 3</code>的板子</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202185932657-1174425800.jpg" alt="img"></p>
<p>然后准备一张SD卡用来下载系统</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202190107442-27730457.jpg" alt="img"></p>
<p>然后准备一个读卡器，这个读卡器可以去借别人的，我这个就是借的</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202190157802-1495712197.jpg" alt="img"></p>
<p>准备一个<code>USB转TTL</code>的下载器</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202190259947-1652784241.jpg" alt="img"></p>
<p>然后准备一根type线，这里我拿的是我的充电线</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202190353525-1044573884.jpg" alt="img"></p>
<p>准备完成后就可以开始操作了。</p>
<h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="1-下载系统到SD卡中"><a href="#1-下载系统到SD卡中" class="headerlink" title="1.下载系统到SD卡中"></a>1.下载系统到SD卡中</h2><p>首先先将一个系统下载到SD卡中，这里我使用的是Ubuntu的服务器系统，这个系统是没有图形化界面的，因为我只有1.5G的运行内存。</p>
<p>系统我是在香橙派官网中的资料下载中下载的，这里我把链接放在这，<a href="http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-Zero-3.html">Orange-Pi-Zero-3资料下载</a>。当然我也把这些资料放在我的网盘中的。</p>
<p>下载了操作系统镜像后把SD卡插到下载器上，下载器连接到电脑，然后使用<code>Win32DiskImager</code>软件将镜像文件下载到SD卡中，这里需要注意一下，<strong>这个过程会将SD卡中的内容全部清除，所以要先把这个SD卡中的内容备份一下。</strong> 然后打开<code>Win32DiskImager</code>软件</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202191236851-2026055802.png" alt="img"></p>
<p>在<code>映像文件</code>那打开你要下载的系统，然后点击写入即可，等待写入完成后将SD卡插到香橙派上</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202191518835-1953636756.jpg" alt="img"></p>
<p>然后就可以进入下一步了。</p>
<h2 id="2-上电连接串口"><a href="#2-上电连接串口" class="headerlink" title="2.上电连接串口"></a>2.上电连接串口</h2><p>这里先用<code>USB转TTL</code>连接到香橙派上，如何连接呢？这里可以看看引脚图</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202191657105-1133119272.png" alt="img"></p>
<p>可以看到最上面的那三个引脚就是我们需要使用的串口引脚<code>TX</code>、<code>RX</code>、<code>GND</code>，然后我们用<code>USB转TTL</code>进行连接，这里的连接如下表格：</p>
<table>
<thead>
<tr>
<th>USB转TTL</th>
<th>香橙派</th>
</tr>
</thead>
<tbody><tr>
<td>TX</td>
<td>RX</td>
</tr>
<tr>
<td>RX</td>
<td>TX</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
</tbody></table>
<p>连接完成图</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202192010341-1482300985.jpg" alt="img"></p>
<p>然后把这一端连接到电脑上</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202192041874-1420115892.jpg" alt="img"></p>
<p>然后将Type线连接到电脑上为其供电</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202192132329-104615943.jpg" alt="img"></p>
<p>然后打开<code>串口助手</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202192212336-247609896.png" alt="img"></p>
<p>这里需要注意一下串口的波特率为<code>115200</code>，如果说你波特率调错了得到的内容就都是乱码，然后给香橙派上电，并且打开串口就会收到香橙派的启动信息</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202194830248-458441528.png" alt="img"></p>
<p>这个就是收到的信息，然后等待一会就可以进入到输入内容了，首先查看一下它的IP地址</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202194938276-1204902720.png" alt="img"></p>
<p>在输入框中输入命令后需要按一下回车，然后再点击发送，这样就可以发送命令了，发送完后会有一个反馈</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202195121194-610970373.png" alt="img"></p>
<p>这个就是查看的内容了。</p>
<h2 id="3-打开ssh"><a href="#3-打开ssh" class="headerlink" title="3.打开ssh"></a>3.打开ssh</h2><p>一直使用串口助手并不是一个长久的方法，在Linux中可以使用一个远程连接的方法，这个方法是<code>ssh</code>，但是这个方法需要连接到网络得到一个IP地址，而且这个需要在同一个局域网中才可以连接。</p>
<p>实现我们先更新一下软件包</p>
<p>执行的命令是<code>sudo apt update</code>，执行这个命令需要获取<code>root</code>权限，所以加上了一个<code>sudo</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202195437672-1696146567.png" alt="img"></p>
<p>然后需要输入一下<code>root</code>的密码，这里的密码默认是<code>orangepi</code>，也是在输入指令框那发送，然后输入完后就可以开始更新</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202195545961-1882637112.png" alt="img"></p>
<p>更新完成后要下载<code>openssh</code>这个软件，服务端的系统是默认开启的，所以可以跳过这个步骤，使用的命令是<code>sudo apt-get install openssh-server</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202195647137-1137483826.png" alt="img"></p>
<p>然后下载完成后就查看一下<code>ssh</code>是否打开，使用<code>sudo ps -e |grep ssh</code>，如果出现下面的内容就证明<code>ssh</code>打开，一般都会打开的。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202200008533-1739091947.png" alt="img"></p>
<p>如果没有打开可以使用<code>sudo server ssh start</code>进行打开，然后再查看是否有该线程即可。</p>
<h2 id="4-使用xshell连接香橙派"><a href="#4-使用xshell连接香橙派" class="headerlink" title="4.使用xshell连接香橙派"></a>4.使用xshell连接香橙派</h2><p>首先需要执行<code>ifconfig</code>来查看一下香橙派的IP地址，然后打开<code>xshell</code>软件</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202200354931-1714757678.png" alt="img"></p>
<p>然后点击<code>新建</code></p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202200429605-1610648089.png" alt="img"></p>
<p>在新建里面填一下用<code>ifconfig</code>获取的IP地址，然后点击连接，连接后需要输入一下用户名和密码，这里直接用<code>root</code>账号，因为<code>root</code>是知道密码的。</p>
<p>然后就可以进入界面了</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231202205858661-275336374.png" alt="img"></p>
<p>需要注意一下就是要保证你的电脑和香橙派是连接同一个局域网，否则是连接不了的。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我后面还会出一些关于香橙派的一些文章，大家感兴趣的可以关注一下我。</p>
<p>香橙派还是比较便宜的。</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-超声波测量距离</title>
    <url>/2025/01/17/a33915e7d886/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>超声波模块是非常简单也非常好用的一个模块，不需要你会多少概念，你只需要会IO口的控制和定时器的操作就可以就行操作了。这一篇文章我会从stm32和香橙派一直来讲解这个超声波测距怎么玩。</p>
<h1 id="一、HC-SR04芯片"><a href="#一、HC-SR04芯片" class="headerlink" title="一、HC-SR04芯片"></a>一、HC-SR04芯片</h1><p>这个是我们超声波模块使用的芯片，我们就对它就行IO操作就可以了。</p>
<p>超声波模块有4个引脚，分别是</p>
<ul>
<li>VCC</li>
<li>GND</li>
<li>Trig</li>
<li>Echo</li>
</ul>
<p><img src="https://www.freeimg.cn/i/2024/02/11/65c88edf46803.jpg"></p>
<p>然后这个模块的时序图如下：</p>
<p>当向Trig发送一个高电平，这个高电平要持续10~20us才可以，然后Echo就会发送一个高电平回来就代表着超声波已经发送，当超声波碰到物体后就会反弹，反弹回来后Echo引脚就会变成一个低电平来告诉用户已经发送来回了。</p>
<p>我们知道这个的时序图后我们就可以知道如何通过这个超声波来进行测距了，我们可以在它发送超声波后开启定时，当接送到超声波后就停止定时，然后通过获取的时间去除以340m&#x2F;s并再除以2就可以得到距离了。</p>
<h1 id="二、stm32代码编写"><a href="#二、stm32代码编写" class="headerlink" title="二、stm32代码编写"></a>二、stm32代码编写</h1><p>我们知道上面讲的内容后我们就可以开始编写代码了，首先我们要初始化GPIO口，让其能进行接收和发送数据，然后再初始化一个计数器来获取超声波在过程中经过的时间。</p>
<p>首先是IO口的初始化代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理解Tiger引脚</span></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接Echo引脚</span></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line">GPIO_ResetBits(GPIOB, GPIO_Pin_0);</span><br></pre></td></tr></table></figure>

<p>然后我们开始初始化Timer定时器，使用的是定时器2，你也可以用其它的标准定时器或者基础定时器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseStruct.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseStruct.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseStruct.TIM_Period = <span class="number">1000</span> - <span class="number">1</span>;   <span class="comment">// 重装值</span></span><br><span class="line">TIM_TimeBaseStruct.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;  <span class="comment">// 预重装系数</span></span><br><span class="line">TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStruct);</span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">TIM_Cmd(TIM2, DISABLE);</span><br></pre></td></tr></table></figure>

<p>这里我们设置的定时器是1us的，然后我们就可以写一下中断处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update))&#123;</span><br><span class="line">        count++;</span><br><span class="line">        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程</title>
    <url>/2025/01/17/3011135ba729/</url>
    <content><![CDATA[<h1 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a>Linux系统编程</h1><h2 id="一、静态和动态"><a href="#一、静态和动态" class="headerlink" title="一、静态和动态"></a>一、静态和动态</h2><p>在linux中有两种有静态和动态的方式</p>
<h3 id="1-静态链接和动态链接"><a href="#1-静态链接和动态链接" class="headerlink" title="1.静态链接和动态链接"></a>1.静态链接和动态链接</h3><p>链接分为两种：静态链接、动态链接</p>
<h4 id="1）静态链接"><a href="#1）静态链接" class="headerlink" title="1）静态链接"></a>1）静态链接</h4><p>静态链接：由链接器在链接时将库的内容加入到可执行程序中。</p>
<p>优点：</p>
<ul>
<li>对运行环境的依赖性较小，具有较好的兼容性</li>
</ul>
<p>缺点：</p>
<ul>
<li>生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间</li>
<li>库函数有了更新，必须重新编译应用程序</li>
</ul>
<h4 id="2）动态链接"><a href="#2）动态链接" class="headerlink" title="2）动态链接"></a>2）动态链接</h4><p>动态链接：连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。</p>
<p>优点：</p>
<ul>
<li>在需要的时候才会调用对应的资源函数</li>
<li>简化程序的升级；有着较小的程序体积</li>
<li>实现进程之间的志愿共享（避免重复拷贝）</li>
</ul>
<p>缺点：</p>
<ul>
<li>依赖动态库，不能独立运行</li>
<li>动态库依赖版本问题严重</li>
</ul>
<h4 id="3）静态、动态编译对比"><a href="#3）静态、动态编译对比" class="headerlink" title="3）静态、动态编译对比"></a>3）静态、动态编译对比</h4><p>在Linux中的gcc是默认使用动态链接来生成代码。</p>
<p>如果想使用静态链接来生成代码，则需要使用下面的指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -static</span><br></pre></td></tr></table></figure>

<p>剩下的和动态链接一样</p>
<h3 id="2、静态库和动态库介绍"><a href="#2、静态库和动态库介绍" class="headerlink" title="2、静态库和动态库介绍"></a>2、静态库和动态库介绍</h3><p>所谓”程序库“，简单说，就是包含了数据和执行码的文件。其不能单独执行，可以作为出现都一部分来完成某些功能</p>
<p>库的存在可以使得程序模块化，可以加快程序的再编译，可以实现代码重用，可以使得程序便于升级</p>
<p>程序库可分 <strong>静态库</strong> 和 <strong>共享库</strong></p>
<h3 id="3-静态库制作和使用"><a href="#3-静态库制作和使用" class="headerlink" title="3.静态库制作和使用"></a>3.静态库制作和使用</h3><p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行代码中，成为执行程序的一部分。</p>
<p>按照习惯，一般以 <code>.a</code> 作为文件后缀名。静态库的命名一般分为三个部分：</p>
<ul>
<li>前缀：lib</li>
<li>库名称：自己定义即可</li>
<li>后缀： <code>.a</code></li>
</ul>
<p>所以最终的静态库的名字应该为：<code>libxxx.a</code></p>
<h4 id="3-1-静态库制作"><a href="#3-1-静态库制作" class="headerlink" title="3.1 静态库制作"></a>3.1 静态库制作</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B.png"></p>
<p>步骤1：将C源文件生成对应的<code>.o</code>文件</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8A%8A%E6%89%80%E6%9C%89h%E7%BC%96%E7%A8%8Bo.png"></p>
<p>步骤2：使用打包工具ar将准备好的.o文件打包为.a文件 libtest.a</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B0%86o%E5%85%A8%E9%83%A8%E6%89%93%E5%8C%85%E6%88%90a.png"></p>
<p>在使用ar工具是需要添加参数：rcs</p>
<ul>
<li>r更新</li>
<li>c创建</li>
<li>s建立索引</li>
</ul>
<h4 id="3-2-静态库使用"><a href="#3-2-静态库使用" class="headerlink" title="3.2 静态库使用"></a>3.2 静态库使用</h4><p>静态库制作完成后，需要将.a文件和头文件一起发布给用户。</p>
<p>假设测试文件为test.c，静态库文件为libtest.a头文件为head.h</p>
<p>编译命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -L. -I. -l test -o test</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>-L：表示要连接的库所在目录</li>
<li>-l（小写L）：指定链接时需要的库，去除前缀和后缀</li>
</ul>
<p>在执行程序的时候，程序1使用到这个静态库，就会在内存中开辟出这块空间来存放静态库，程序2执行的时候也会和程序1的过程一样，会产生大量的空间，导致程序会很大，如果执行多次那空间就会非常大</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%9D%99%E6%80%81%E5%BA%93.png"></p>
<h3 id="4-动态库制作和使用"><a href="#4-动态库制作和使用" class="headerlink" title="4.动态库制作和使用"></a>4.动态库制作和使用</h3><p>共享库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入、不同的应用程序如果调用系统的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。</p>
<p>动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布带来的麻烦。用户只需要更新动态库即可，增量更新。</p>
<p>按照习惯，一般以 <code>.so</code> 作为文件后缀名。共享库的命名一般分为三个部分：</p>
<ul>
<li>前缀：lib</li>
<li>库名称</li>
<li>后缀：.so</li>
</ul>
<p>所以最终的动态库的名字应该为：libxxx.so</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93.png"></p>
<h4 id="4-1-动态库制作"><a href="#4-1-动态库制作" class="headerlink" title="4.1 动态库制作"></a>4.1 动态库制作</h4><p>步骤一：生成目标文件，此时要加编译选项：-fpic</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93o.png"></p>
<p>参数：-fpic创建与地址无关的编译程序，是为了能够在多个应用程序间共享。</p>
<p>步骤二：生成共享库，此时要加链接器选项：-shared（指定生成动态链接库）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared *.o -o libxxx.so</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%94%9F%E6%88%90so.png"></p>
<p>步骤三：通过nm命令查看对应函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nm libtest.so | grep add</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8Badd.png"></p>
<h4 id="4-2-动态库使用"><a href="#4-2-动态库使用" class="headerlink" title="4.2 动态库使用"></a>4.2 动态库使用</h4><p>在使用的时候也是需要对其进行编译</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E5%BA%93.png"></p>
<p>编译完成后运行，会发现报错了</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99.png"></p>
<p>原因是因为在链接的时候需要用到连接器才可以使用</p>
<ul>
<li>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器。</li>
<li>对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段-环境变量LD_LIBRARY_PATH-&#x2F;etc&#x2F;ld.so.cache文件列表-&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib目录找到库文件将其载入内存</li>
</ul>
<h4 id="4-3-如何让系统找到动态库"><a href="#4-3-如何让系统找到动态库" class="headerlink" title="4.3 如何让系统找到动态库"></a>4.3 如何让系统找到动态库</h4><ul>
<li><p>将动态库放到 <code>/lib</code> 目录中即可</p>
</li>
<li><p>临时设置LD_LIBRARY_PATH:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>永久设置，把 <code>export LD_LIBRARY_PATH=&amp;LD_LIBRARY_PATH:库路径</code> ，设置到 <code>~/.bashrc</code> 或 <code>/etc/profile</code> 文件中</p>
<p>把 <code>export LD_LIBRARY_PATH=&amp;LD_LIBRARY_PATH:库路径</code> 添加到最后一行即可</p>
<p>执行下面代码让文件生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/.bashre</span><br></pre></td></tr></table></figure>
</li>
<li><p>将其添加到 <code>/etc/ld.so.conf</code> 文件中</p>
<p>编辑 <code>/etc/ld.so.conf</code> 文件，加入库文件所在目录的路径</p>
<p>运行 <code>sudo ldconfig -v</code> ，该命令会重建 <code>/etc/ld.so.cache</code> 文件</p>
</li>
<li><p>使用符号链接，但一定要使用绝对1路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/deng/test/6share_test/libtest.so /lib/libtest.so</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-GDB调试器"><a href="#5-GDB调试器" class="headerlink" title="5.GDB调试器"></a>5.GDB调试器</h3><h4 id="5-1-GDB简介"><a href="#5-1-GDB简介" class="headerlink" title="5.1 GDB简介"></a>5.1 GDB简介</h4><p>GNU工具集中的调试器是GDB，该程序是一个交互式工具，工作在字符模式。除GDB外，Linux下比较有名的调试器还有xxgdb，ddd，kgdb，ups</p>
<p>GDB主要帮助你完成下面四个方面的功能：</p>
<p>1.启动程序，可以按照你的自定义的要求随心所欲的运行程序。</p>
<p>2.可以被调试的程序在你所指定的调置的断点处停止。</p>
<p>3.当程序被停住时，可以检查此时你的程序中所发生的事</p>
<p>4.动态的改变你的程序的执行环境</p>
<h4 id="5-2-生成调试信息"><a href="#5-2-生成调试信息" class="headerlink" title="5.2 生成调试信息"></a>5.2 生成调试信息</h4><p>一般来说GDB主要调试的是C&#x2F;C++的程序。要调试C&#x2F;C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器(cc&#x2F;gcc&#x2F;g++)的-g参数可以做到这一点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g hello.c -o hello</span><br><span class="line">g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>

<p>如果没有-g，你将看不到程序的函数名、变量名，所替代的全是运行时的内存地址</p>
<h4 id="5-3-启动GDB"><a href="#5-3-启动GDB" class="headerlink" title="5.3 启动GDB"></a>5.3 启动GDB</h4><ul>
<li><p>启动GDB：gdb program</p>
<p>program 也是你的执行文件，一般在当前目录下。</p>
</li>
<li><p>设置运行参数</p>
<p>set args  可指定运行时参数。（如：set args 10 20 30 40 50）</p>
<p>show args 命令可以查看设置好的运行参数。</p>
</li>
<li><p>启动程序</p>
<p>run：程序开始执行，如果有断点，停在第一个断点处</p>
<p>start：程序向下执行一行</p>
</li>
</ul>
<h4 id="5-4-显示源代码"><a href="#5-4-显示源代码" class="headerlink" title="5.4 显示源代码"></a>5.4 显示源代码</h4><p>用list命令来打印程序的源代码。默认打印10行。</p>
<ul>
<li>list linenum：打印第linenm行的上下文内容</li>
<li>list function：显示函数名为function的函数的源程序</li>
<li>list：显示当前行后面的源程序</li>
<li>list -：显示当前行前面的源程序</li>
</ul>
<p>一般是打印当前行的上5行和下5行，如果显示的函数是上2行下8行，默认10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数</p>
<ul>
<li>set listsize count：设置一次显示源代码的行数</li>
<li>show listsize：查看当前listsize的设置。</li>
</ul>
<h4 id="5-5-断点操作"><a href="#5-5-断点操作" class="headerlink" title="5.5 断点操作"></a>5.5 断点操作</h4><h5 id="5-5-1-简单断点"><a href="#5-5-1-简单断点" class="headerlink" title="5.5.1 简单断点"></a>5.5.1 简单断点</h5><p>break设置断点，可以简写为b</p>
<ul>
<li>b 10 设置断点，在源文件第10行</li>
<li>b func 设置断点，在func函数入口处</li>
</ul>
<h5 id="5-5-2-多文件设置断点"><a href="#5-5-2-多文件设置断点" class="headerlink" title="5.5.2 多文件设置断点"></a>5.5.2 多文件设置断点</h5><p>如果有名称空间，可以使用namespace::class::function或者function(type, type) 格式来指定函数名。</p>
<ul>
<li>break filename:linenum –在源文件filename的linenum行处停住</li>
<li>break filename:function – 在源文件filename的function函数的入口处停住</li>
<li>break class::function 或 function(type, type) – 在类class的function函数入口处停住</li>
<li>break namespace::class::function – 在名称空间为namespace的类class的function函数的入口处停住</li>
</ul>
<h5 id="5-5-3-查询所有断点"><a href="#5-5-3-查询所有断点" class="headerlink" title="5.5.3 查询所有断点"></a>5.5.3 查询所有断点</h5><ul>
<li>info b</li>
<li>info break</li>
<li>i break</li>
<li>i b</li>
</ul>
<h5 id="5-5-4-条件断点"><a href="#5-5-4-条件断点" class="headerlink" title="5.5.4 条件断点"></a>5.5.4 条件断点</h5><p>一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。</p>
<p>设置一个条件断点：</p>
<blockquote>
<p>b test.c:8 if Value &#x3D;&#x3D; 5</p>
</blockquote>
<h5 id="5-5-5-维护断点"><a href="#5-5-5-维护断点" class="headerlink" title="5.5.5 维护断点"></a>5.5.5 维护断点</h5><p>1）delete [range…] 输出指定的断点，其简写命令为d。</p>
<ul>
<li>如果不指定断点号，则表示删除所有的断点。range表示断点号的范围*如：3-7）。</li>
<li>比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样</li>
</ul>
<p>2）disable [range…]使指定断点无效，简写命令是dis。</p>
<p>​		如果什么都不指定，表示disable所有的停止点无效</p>
<p>3）enable [range…] 使无效断定失效，缩写命令是ena。</p>
<p>​		如果什么都不指定，表示enable所有的停止点</p>
<h5 id="5-5-6-调试代码"><a href="#5-5-6-调试代码" class="headerlink" title="5.5.6 调试代码"></a>5.5.6 调试代码</h5><ul>
<li>run 运行程序，可简写为r</li>
<li>next 单步跟踪，函数调用当作一条简单语句执行，可简写为n</li>
<li>step 单步跟踪，函数调用进入被调用函数体内，可简写为s</li>
<li>finish 退出进入的函数</li>
<li>until 在一个循环体内单步跟踪时，这个命令可以运行直到退出循环体，可简写为u。</li>
<li>continue 继续运行程序，停在下一个断点的位置，可简写为c</li>
<li>quit 退出gdb，可简写为q</li>
</ul>
<h5 id="5-5-7-数据查看"><a href="#5-5-7-数据查看" class="headerlink" title="5.5.7 数据查看"></a>5.5.7 数据查看</h5><p>1）查看运行时数据</p>
<p>​	print 打印变量、字符串、表达式等的值，可简写为p</p>
<p>​	p count 打印count的值</p>
<h5 id="5-5-8-自动显示"><a href="#5-5-8-自动显示" class="headerlink" title="5.5.8 自动显示"></a>5.5.8 自动显示</h5><p>可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。</p>
<ul>
<li>display 变量名</li>
<li>info display  – 查看设置的自动显示的信息。</li>
<li>undisplay num （info display时显示的编号）</li>
<li>delete display dnums… – 删除自动显示，dnums意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</li>
<li>disable display dnums…</li>
<li>enable display dnums…</li>
<li>disable和enalbe不删除自动显示的设置，而只是让其失效和恢复</li>
</ul>
<h5 id="5-5-9-查看修改变量"><a href="#5-5-9-查看修改变量" class="headerlink" title="5.5.9 查看修改变量"></a>5.5.9 查看修改变量</h5><p>1）ptype width – 查看变量width的类型</p>
<p>​	type &#x3D; double</p>
<p>2）p width – 打印变量width的值</p>
<p>你可以使用set var命令告诉GDB，width不是你GDB的参数，而是程序的变量名，如：</p>
<p>​		set var width&#x3D;47 &#x2F;&#x2F;将变量var值设置为47</p>
<p><strong>在吧改变程序变量取值时，最好都使用set var格式的GDB命令</strong></p>
<h2 id="二、自动化编译"><a href="#二、自动化编译" class="headerlink" title="二、自动化编译"></a>二、自动化编译</h2><h3 id="1-Makefile"><a href="#1-Makefile" class="headerlink" title="1.Makefile"></a>1.Makefile</h3><h4 id="1-1-Makefile简介"><a href="#1-1-Makefile简介" class="headerlink" title="1.1 Makefile简介"></a>1.1 Makefile简介</h4><p>一个工程中的源文件不记其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至进行更复杂的功能操作，因为makefile就像一个shell脚本一样，其中也可以执行操作系统的命令。</p>
<p>Makefile代码来的好处就是–“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令。</p>
<p>make主要解决两个问题：</p>
<p><strong>1）大量代码的关系维护</strong></p>
<p>大项目中源代码比较多，手工维护、编译时间长而且命令复杂，难以记忆及维护</p>
<p>把代码维护命令及编译命令写在makefile文件中，然后再用make工具解析此文件自动执行相应命令，可实现代码的合理编译</p>
<p><strong>2）减少重复编译时间</strong></p>
<p>在改动其中一个文件的时候，能判断哪些文件被修改过，可以只对该文件进行重新编译，然后重新链接所有目标文件，节省编译时间</p>
<p><strong>Makefile文件命名规则</strong></p>
<p>makefile和Makefile都可以</p>
<p><strong>make工具安装</strong></p>
<blockquote>
<p>sudo apt install make</p>
</blockquote>
<h4 id="1-2-Makefile语法规则"><a href="#1-2-Makefile语法规则" class="headerlink" title="1.2 Makefile语法规则"></a>1.2 Makefile语法规则</h4><p>一条规则：</p>
<blockquote>
<p>目标：依赖文件列表</p>
<p><Tab>命令列表</p>
</blockquote>
<p>Makefile基本规则三要素：</p>
<p>1）目标：</p>
<ul>
<li>通常是要产生的文件名称，目标可以是可执行文件或其他obj文件，也可以是一个动作的名称</li>
</ul>
<p>2）依赖文件：</p>
<ul>
<li>用来输入从而产生目标的文件</li>
<li>一个目标通常有几个依赖文件（可以没有）</li>
</ul>
<p>3）命令：</p>
<ul>
<li>make执行的动作，一个规则可以含几个命令（可以没有）</li>
<li>有多个命令时，每个命令占一行</li>
</ul>
<h4 id="1-3-make命令格式"><a href="#1-3-make命令格式" class="headerlink" title="1.3 make命令格式"></a>1.3 make命令格式</h4><p>make是一个命令工具，它解释Makefile中的指令（应该说是规则）。</p>
<p>make命令格式：</p>
<p>make [-f file][options][targets]</p>
<p>1.[-f file]:</p>
<ul>
<li>make默认在工作目录中寻找名为makefile、makefile、Makefile的文件作为makefile输入文件</li>
<li>-f 可以指定以上名字以外的文件作为makefile输入文件</li>
</ul>
<p>2.[options]</p>
<ul>
<li>-v：显示make工具的版本信息</li>
<li>-w：在处理makefile之前和之后显示工作路径</li>
<li>-C dir：读取makefile之前改变工作路径至dir目录</li>
<li>-n：只打印要执行的命令但不执行</li>
<li>-s：执行但不显示执行的命令</li>
</ul>
<p>3.[targets]：</p>
<ul>
<li>若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个目标，然后退出</li>
<li>指定make工具要实现的目标，目标可以是一个或多个（多个目标间用空格隔开）。</li>
</ul>
<h4 id="1-4-Makefile实例"><a href="#1-4-Makefile实例" class="headerlink" title="1.4 Makefile实例"></a>1.4 Makefile实例</h4><p>比如要编译之前写的Add.c Sub.c Div.c Mul.c</p>
<p>在Makefile文件中的写法如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">test:Add.o Sub.o Div.o Mul.o test.o</span></span><br><span class="line">    gcc Add.o Sub.o Div.o Mul.o test.o -o test</span><br><span class="line"><span class="section">Add.o:Add.c</span></span><br><span class="line">    gcc -c Add.c -o Add.o</span><br><span class="line"><span class="section">Sub.o:Sub.c</span></span><br><span class="line">    gcc -c Sub.c -o Sub.o</span><br><span class="line"><span class="section">Div.o:Div.c</span></span><br><span class="line">    gcc -c Div.c -o Div.o</span><br><span class="line"><span class="section">Mul.o:Mul.c</span></span><br><span class="line">    gcc -c Mul.c -o Mul.o</span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">    gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure>

<p>这种写法后，在如果又修改其他文件话只需要重新编译刚写的文件</p>
<h4 id="1-5-Makefile中的变量"><a href="#1-5-Makefile中的变量" class="headerlink" title="1.5 Makefile中的变量"></a>1.5 Makefile中的变量</h4><p>在Makefile中使用变量有点类似于C语言中的宏定义，使用该变量相当于内存替换，使用变量可以使Makefile易于维护，修改内容变得简单变量定义及使用。</p>
<h5 id="1-5-1-自定义变量"><a href="#1-5-1-自定义变量" class="headerlink" title="1.5.1 自定义变量"></a>1.5.1 自定义变量</h5><p>1）定义变量方法：</p>
<p>​	变量名 &#x3D; 变量值</p>
<p>2）引用变量：</p>
<p>​	$(变量名)或${变量名}</p>
<p>3）makefile的变量名：</p>
<ul>
<li>makefile量名可以以数字开头</li>
<li>变量是大小写敏感的</li>
<li>变量一般都在makefile的头部定义</li>
<li>变量几乎可以在makefile的任何地方使用</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc $&#123;OBJS&#125; -o test</span><br><span class="line"><span class="section">Add.o:Add.c</span></span><br><span class="line">        gcc -c Add.c -o Add.o</span><br><span class="line"><span class="section">Sub.o:Sub.c</span></span><br><span class="line">        gcc -c Sub.c -o Sub.o</span><br><span class="line"><span class="section">Div.o:Div.c</span></span><br><span class="line">        gcc -c Div.c -o Div.o</span><br><span class="line"><span class="section">Mul.o:Mul.c</span></span><br><span class="line">        gcc -c Mul.c -o Mul.o</span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">        gcc -c test.c -o test.o</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户直接使用，我们可以直接对其进行赋值。</p>
<blockquote>
<p>CC&#x3D;gcc #arm-linux-gcc</p>
<p>CPPFLAGS: C预处理器的选择 如：-l</p>
<p>CFLAGS：C编译器的选择 -Wall -g -c</p>
<p>LDFLAGS：链接器选择 -L -l</p>
</blockquote>
<h5 id="1-5-2-自动变量"><a href="#1-5-2-自动变量" class="headerlink" title="1.5.2 自动变量"></a>1.5.2 自动变量</h5><ul>
<li>$@：表示规则中的目标</li>
<li>$&lt;：表示规则中的第一个依赖</li>
<li>$^：表示所有依赖</li>
<li>$?：所有目标依赖中被修改过的文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">Add.o:Add.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">Sub.o:Sub.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">Div.o:Div.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">Mul.o:Mul.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="1-5-3-规则模式"><a href="#1-5-3-规则模式" class="headerlink" title="1.5.3 规则模式"></a>1.5.3 规则模式</h5><p>模式规则示例：</p>
<blockquote>
<p>%.o:%.c</p>
<p>$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o &amp;@</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#Add.o:Add.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#Sub.o:Sub.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#Div.o:Div.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#Mul.o:Mul.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#test.o:test.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-Makefile中的函数"><a href="#1-6-Makefile中的函数" class="headerlink" title="1.6 Makefile中的函数"></a>1.6 Makefile中的函数</h4><p>makefile中的函数有很多，在这里给大家介绍两个最常用的。</p>
<blockquote>
<p>1.wildcard - 查找指定目录下的指定类型的文件</p>
<p>​	src &#x3D; $(wildcard *.c) &#x2F;&#x2F;找到当前目录下所有后缀为.c的文件，赋值	给src</p>
<p>2.patsubst - 匹配替换</p>
<p>obj &#x3D; $(patsubst %.c, %.o, $(src)) &#x2F;&#x2F;把src变量里所有后缀为.c的文件替换成.o</p>
</blockquote>
<p>在makefile中所有的函数都有返回值的。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取当前目录下所有的.c文件</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将SRC中所有出现的.c的替换成.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-7-Makefile中的伪目标"><a href="#1-7-Makefile中的伪目标" class="headerlink" title="1.7 Makefile中的伪目标"></a>1.7 Makefile中的伪目标</h4><p>clean用途：清除编译生成的中间文件.o文件和最终目标文件</p>
<p>make clean如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：</p>
<ul>
<li><p>伪目标声明：.PHONY:clean</p>
<p>声明目标为伪目标之后，makefile将不会该判断目标是否存在或者该目标是否需要更新</p>
</li>
</ul>
<p>clean命令中的特殊符号：</p>
<ul>
<li><code>-</code> 此条命令出错，make也会继续执行后续的命令。如：“-rm main.o”</li>
<li>“@”不显示命令本身，只显示结果。如：“@echo clean done”</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取当前目录下所有的.c文件</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将SRC中所有出现的.c的替换成.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        @gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        @gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        -rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-8-makefile工作原理"><a href="#1-8-makefile工作原理" class="headerlink" title="1.8 makefile工作原理"></a>1.8 makefile工作原理</h4><p>1）若想生成目标，检查规则中的依赖条件是否存在，如果不出来，则寻找是否有规则用来生成该依赖文件</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<p>2）检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任一个被更新，则目标必须更新</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p>
<p>总结：</p>
<ul>
<li>分析各个目标和依赖之间的关系</li>
<li>根据依赖关系自底向上执行命令</li>
<li>根据修改事件比目标新，确定更新</li>
<li>如果目标不依赖任何条件，则执行对应命令，以示更新</li>
</ul>
<h2 id="三、系统文件调用"><a href="#三、系统文件调用" class="headerlink" title="三、系统文件调用"></a>三、系统文件调用</h2><h3 id="1-系统文件调用简介和实现"><a href="#1-系统文件调用简介和实现" class="headerlink" title="1.系统文件调用简介和实现"></a>1.系统文件调用简介和实现</h3><h4 id="1-1-什么是系统调用"><a href="#1-1-什么是系统调用" class="headerlink" title="1.1 什么是系统调用"></a>1.1 什么是系统调用</h4><p>操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过区组“特殊“接口来获得操作系统内核提供的服务，比如说用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获取系统时间或设置定时器等。</p>
<p>从逻辑上来说，系统调用可以看成是一个内核与用户空间程序交互的接口——它好比是一个中间人，把用户进程的请求传达给内核，待内核把请求处理完后再将处理结果送回给用户空间。</p>
<h4 id="1-2-系统调用的实现"><a href="#1-2-系统调用的实现" class="headerlink" title="1.2 系统调用的实现"></a>1.2 系统调用的实现</h4><p>系统调用是属于操作系统内核的一部分的，必须以某种方式提供给进程让它们去调用。CPU可以在不同的特权级别下运行，而相应的操作系统也有不同的运行级别，用户态和内核态。运行在内核态的进程可以毫无限制的访问各种资源，而在用户态的用户进程的各种操作都有着权限，比如不能随意的访问内存、不能开闭中断以及切换运行特权。显然，属于内核的系统调用一定是运行在内核态下，但是如何切换到内核态呢？</p>
<p>答案是软件中断。软件中断和我们常说的中断（硬件中断）不同之处在于，它是通过软件指令触发而非外设引发的中断，也就是说，又是编程人员开发出的一种异常（该异常为正常的异常）。<strong>操作系统一般是通过软件中断从用户态切换到内核态。</strong></p>
<h4 id="1-3-系统调用和库函数的区别"><a href="#1-3-系统调用和库函数的区别" class="headerlink" title="1.3 系统调用和库函数的区别"></a>1.3 系统调用和库函数的区别</h4><p>Linux下对文件操作方式有两种方法：<strong>系统调用（system call）</strong> 和 <strong>库函数调用（Library functions）</strong>。</p>
<p>库函数由两类函数组成：</p>
<p>1）不需要调用系统调用</p>
<p>不需要切换到内核空间即可完成函数全部功能，并且将结果反馈给应用程序，如strcpy、bzero 等字符串操作函数</p>
<p>2）需要调用系统调用</p>
<p>需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如printf、fread等</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%B3%BB%E7%BB%9F%E5%BA%93.png"></p>
<p>系统调用是需要时间的，程序中频繁的使用系统调用会降低程序的运行效率。当运行内核代码时，CPU工作在内核态，在系统调用发生前需要保存用户态和内存环境，然后转入内核态工作。系统调用结束后，又要切换回用户态。这种环境的切换会消耗许多时间。</p>
<h4 id="1-4-C库中IO函数工作流程"><a href="#1-4-C库中IO函数工作流程" class="headerlink" title="1.4 C库中IO函数工作流程"></a>1.4 C库中IO函数工作流程</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/IO%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<p>库函数访问文件的时候需要根据需要，设置不同类型的缓冲区，从而减少了直接调用IO系统调用的次数，提高了访问效率</p>
<p>这个过程类似于快递员给某个区域（内核空间）送快递一样，快递员有两种方法送：</p>
<p>1）来一件快递马上送到目的地，来一件送一件，这样导致来回走比较频繁（系统调用）</p>
<p>2）等快递攒着差不多后（缓冲区），才一次性送到目的地（库函数调用）</p>
<h3 id="2-错误处理函数"><a href="#2-错误处理函数" class="headerlink" title="2.错误处理函数"></a>2.错误处理函数</h3><p>errno是记录系统的最后一次错误代码。代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。</p>
<p>当Linux C api函数发生异常时，一般会将errno全局变量赋一个整数值，不同的值表示不同的意义，可以通过查看该值推测出出错原因。</p>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        FILE* fp = fopen(<span class="string">&quot;txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, errno);<span class="comment">//打印错误码</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno)); <span class="comment">//把errno的数字转换成相应的文字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看错误号：</p>
<blockquote>
<p>&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno-base.h</p>
<p>&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno.h</p>
</blockquote>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%94%99%E8%AF%AF%E7%A0%81.png"></p>
<h3 id="3-虚拟地址空间"><a href="#3-虚拟地址空间" class="headerlink" title="3.虚拟地址空间"></a>3.虚拟地址空间</h3><p>每个进程都会分配虚拟地址，在32位机器上，该地址空间为4G</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png"></p>
<p>在进程里平时说的指针变量，保存的就是虚拟地址。当应用程序使用虚拟地址访问内存时，处理器（CPU）会将其转化成物理地址（MMU）。</p>
<p>MMU：将虚拟的地址转化为物理地址。</p>
<p>这样做的好处在于：</p>
<ul>
<li>进程隔离，更好的保护系统安全运行</li>
<li>屏蔽物理差异带来的麻烦，方便操作系统和编译器安排进程地址</li>
</ul>
<h3 id="4-文件描述符"><a href="#4-文件描述符" class="headerlink" title="4.文件描述符"></a>4.文件描述符</h3><p>在Linux的世界里，一切设备皆为文件。我们可以调用系统中I&#x2F;O的函数（I：input，输入；O：output，输出），对文件进行相应的操作（open()、close()、write()、read()等）。</p>
<p>打开现存文件或新建文件时，系统（内核）会返回一个文件描述符，文件描述符用来指定已经打开的文件。这个文件描述符相当于这个文件已经打开文件的符号，文件描述符是非负整数，是文件的标识，操作这个文件描述符相当于操作这个描述符所指定的文件。</p>
<p>程序运行起来后（每个进程）都有一张文件描述符的表，标准输入、标准输出、标准错误输出设备文件被打开，对应的文件描述符0、1、2记录在表中。程序运行起来后这三个文件描述符是默认打开的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STDIN_FILENO 0 <span class="comment">//标准输入的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDOUT_FILENO 1 <span class="comment">//标准输出的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDERR_FILENO 2 <span class="comment">//标准错误的文件描述</span></span></span><br></pre></td></tr></table></figure>

<p>在程序运行起来后打开其它文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png"></p>
<h4 id="最大打开的文件个数"><a href="#最大打开的文件个数" class="headerlink" title="最大打开的文件个数"></a>最大打开的文件个数</h4><p>Linux中一个进程最多只能打开 NR_OPEN_DEFAULT （即1024）个文件，故当文件不再使用时应及时调用close()函数关闭文件。</p>
<ul>
<li><p>查看当前系统允许打开最大文件个数：</p>
<blockquote>
<p>cat&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</p>
</blockquote>
</li>
<li><p>当前默认设置最大打开文件个数1024</p>
<blockquote>
<p>ulimit -a</p>
</blockquote>
</li>
<li><p>修改默认设置最大打开文件个数4096</p>
<blockquote>
<p>ulimit -n 4096</p>
</blockquote>
</li>
</ul>
<h3 id="5-常用文件IO函数"><a href="#5-常用文件IO函数" class="headerlink" title="5.常用文件IO函数"></a>5.常用文件IO函数</h3><h4 id="5-1-open函数"><a href="#5-1-open函数" class="headerlink" title="5.1 open函数"></a>5.1 open函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    打开文件，如果文件不存在则可以选择创建。</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件的路径及文件名</span><br><span class="line">    flags：打开文件的行为标志，必选项 O_RDONLY O_WRONLY O_RDWR</span><br><span class="line">    mode：这个参数，只有在文件不存在时有效，指新建文件时指定文件的权限</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回打开的文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>flags详细说明</strong></p>
<p>必选项：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_RDONLY</td>
<td>以只读的方式打开</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>以只写的方式打开</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>以可读、可写的方式打开</td>
</tr>
</tbody></table>
<p>可选项，和必选项按位或起来</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_CREAT</td>
<td>文件不存在则创建文件，使用此选项时需要使用mode说明文件的权限</td>
</tr>
<tr>
<td>O_EXCL</td>
<td>如果同时指定了O_CREAT，则文件已经存在，则会出错</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>如果文件存在，则清空文件内容</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>写文件时，数据添加到文件末尾</td>
</tr>
<tr>
<td>O_NONBLOCK</td>
<td>对于设备文件，以O_NONBLOCK方式打开可以做非阻塞I&#x2F;O</td>
</tr>
</tbody></table>
<p><strong>mode补充说明</strong></p>
<p>1）文件最终权限：mode &amp; ~umask</p>
<p>2）shell进程的umask掩码可以用umask命令查看</p>
<ul>
<li>umask：查看掩码（补码）</li>
<li>umask mode：设置掩码，mode为八进制数</li>
<li>umask -S:查看各组用户的默认操作权限</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>八进制</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>S_IRWXU</td>
<td>00700</td>
<td>文件拿使用者的读、写、可执行权限</td>
</tr>
<tr>
<td>S_IRUSR</td>
<td>00400</td>
<td>文件所有者的读权限</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>00200</td>
<td>文件所有者的写权限</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>00100</td>
<td>文件所有者的可执行权限</td>
</tr>
<tr>
<td>S_IRWXG</td>
<td>00070</td>
<td>文件所有这同组用户的读、写、可执行权限</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>00040</td>
<td>文件所有者同用户组的读权限</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>00020</td>
<td>文件所有者同组用户的写权限</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>00010</td>
<td>文件所有者同组的可执行权限</td>
</tr>
<tr>
<td>S_IRWXO</td>
<td>00007</td>
<td>其它用户的读、写、可执行权限</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>00004</td>
<td>其它用户的读权限</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>00002</td>
<td>其它用户的写权限</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>00001</td>
<td>其它用户的可执行权限</td>
</tr>
</tbody></table>
<h4 id="5-2-close函数"><a href="#5-2-close函数" class="headerlink" title="5.2 close函数"></a>5.2 close函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    关闭已打开的文件</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符，open()的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span>，并设置errno</span><br></pre></td></tr></table></figure>

<p>需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用close关闭，所有即使用用户程序不调用close，在终止时内核也会自动关闭它打开的文件。</p>
<p>但对于一个长年累月运行的程序（比如网络服务器），打开的文件描述符一定要记得关闭，负责随着打开的文件越多，会占用大量文件描述符和系统资源</p>
<h4 id="5-3-write函数"><a href="#5-3-write函数" class="headerlink" title="5.3 write函数"></a>5.3 write函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据写到文件（fd）</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    buf：数据首地址</span><br><span class="line">    count：写入数据的长度（字节）</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际写入数据的字节个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="5-4-read函数"><a href="#5-4-read函数" class="headerlink" title="5.4 read函数"></a>5.4 read函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据到内存（缓冲区）</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    buf：内存首地址</span><br><span class="line">    count：读取的字节个数</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际读取的字节个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h5 id="阻塞和非阻塞的概念"><a href="#阻塞和非阻塞的概念" class="headerlink" title="阻塞和非阻塞的概念"></a>阻塞和非阻塞的概念</h5><p>读常规文件是不会阻塞，不管读多少字节，read一定会在有限的事件内返回。</p>
<p>从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会阻塞，如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于会阻塞多少事件也是不确定的，如果一直没有数据到达就一直阻塞在那里。</p>
<p>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</p>
<p>【注意】阻塞与非阻塞是对于文件而言的，而不是指read、write等的属性。</p>
<h4 id="5-5-lseek函数"><a href="#5-5-lseek函数" class="headerlink" title="5.5 lseek函数"></a>5.5 lseek函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">功能：</span><br><span class="line">    改变文件的偏移量</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    offset：根据whence来移动的位移量（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。</span><br><span class="line">    </span><br><span class="line">    whence：其取值如下：</span><br><span class="line">        SEEK_SET: 从文件开头移动offset个字节数</span><br><span class="line">        SEEK_CUR: 从当前位置移动offset个字节数</span><br><span class="line">        SEEK_END: 从文件末尾移动offset个字节数</span><br><span class="line">返回值：</span><br><span class="line">    若lseek成功执行，则返回新的偏移量</span><br><span class="line">    如果失败，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="四、文件操作相关函数"><a href="#四、文件操作相关函数" class="headerlink" title="四、文件操作相关函数"></a>四、文件操作相关函数</h2><h3 id="1-stat函数"><a href="#1-stat函数" class="headerlink" title="1.stat函数"></a>1.stat函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取文件状态信息</span><br><span class="line">    stat和lstat的区别：</span><br><span class="line">        当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；</span><br><span class="line">        而stat返回的是该链接指向的文件的信息。</span><br><span class="line">参数：</span><br><span class="line">    path：文件名</span><br><span class="line">    buf：保存文件信息的结构体</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>struct stat结构体说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">               <span class="type">dev_t</span>     st_dev;    <span class="comment">//文件的设备编号</span></span><br><span class="line">               <span class="type">ino_t</span>     st_ino;    <span class="comment">//节点</span></span><br><span class="line">               <span class="type">mode_t</span>    st_mode;  <span class="comment">//文件的类型和存储的权限</span></span><br><span class="line">               <span class="type">nlink_t</span>   st_nlink; <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">               <span class="type">uid_t</span>     st_uid; <span class="comment">//用户ID</span></span><br><span class="line">               <span class="type">gid_t</span>     st_gid;<span class="comment">//组ID</span></span><br><span class="line">               <span class="type">dev_t</span>     st_rdev; <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">               <span class="type">off_t</span>     st_size; <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line">               <span class="type">blksize_t</span> st_blksize; <span class="comment">//块大小(文件系统I/O缓冲区大小)</span></span><br><span class="line">               <span class="type">blkcnt_t</span>  st_blocks;   <span class="comment">//块数</span></span><br><span class="line"></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-stat获得文件类型-第一个版本"><a href="#1-1-stat获得文件类型-第一个版本" class="headerlink" title="1.1 stat获得文件类型(第一个版本)"></a>1.1 stat获得文件类型(第一个版本)</h4><p>之前说stat中有一个获取文件类型和存储权限中的st_mode，其实可以通过这个类型来获取文件的类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">show_file_type</span><span class="params">(<span class="keyword">struct</span> stat* s)</span>&#123;</span><br><span class="line">     <span class="keyword">switch</span>(s-&gt;st_mode &amp; S_IFMT)&#123;</span><br><span class="line">         <span class="keyword">case</span> S_IFREG:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;普通文件\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;目录\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;字符设备\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;块文件\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;套接字\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;管道\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;符号链接\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;未知的文件类型\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//容错判断</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ./a.out filename\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的很多内容都可以在官方手册上看到</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/stat.png"></p>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;st_mode &amp; S_IFMT</span><br></pre></td></tr></table></figure>

<p>是官方手册上规定的写法</p>
<p>运行时只需要执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a.out filename</span><br></pre></td></tr></table></figure>

<p>这里采用的是默认的编译</p>
<p>如果你使用了自定义文件名的话，只需要把 a.out 改成你自定义的文件名就可以了。</p>
<h4 id="1-2-第二种写法"><a href="#1-2-第二种写法" class="headerlink" title="1.2 第二种写法"></a>1.2 第二种写法</h4><p>在官方手册上还提供了第二种写法，比第一种要简单</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/st_mode%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%99%E6%B3%95.png"></p>
<p>直接写代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">show_file_type</span><span class="params">(<span class="keyword">struct</span> stat* s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;普通文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目录\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISCHR(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符设备\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISBLK(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;块文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISSOCK(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;套接字\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;符号链接\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知文件类型\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//容错判断</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out filename\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = stat(argv[<span class="number">1</span>], &amp;s);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    show_file_type(&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-获得文件权限"><a href="#1-3-获得文件权限" class="headerlink" title="1.3 获得文件权限"></a>1.3 获得文件权限</h4><p>在stat中st_mode中提供了查看文件权限的宏定义</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/stat%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">4</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="number">5</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"> <span class="number">6</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span> <span class="type">int</span> <span class="title function_">show_file_type</span><span class="params">(<span class="keyword">struct</span> stat* s)</span>&#123;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">if</span> (s-&gt;st_mode &amp; S_IRUSR)&#123;</span><br><span class="line"><span class="number">10</span>         <span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="number">13</span>         <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span>     <span class="keyword">if</span> (s-&gt;st_mode &amp; S_IWUSR)&#123;</span><br><span class="line"><span class="number">16</span>         <span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="number">19</span>         <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="number">20</span>     &#125;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">if</span> (s-&gt;st_mode &amp; S_IXUSR)&#123;</span><br><span class="line"><span class="number">22</span>         <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span>     <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="number">25</span>         <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span>     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="number">28</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">29</span> &#125;</span><br><span class="line"><span class="number">30</span> </span><br><span class="line"><span class="number">31</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line"><span class="number">32</span>     <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="number">33</span>     <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line"><span class="number">34</span> </span><br><span class="line"><span class="number">35</span>     <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="number">36</span>         <span class="built_in">printf</span>(<span class="string">&quot;./file_3 filename\n&quot;</span>);</span><br><span class="line"><span class="number">37</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">38</span>     &#125;</span><br><span class="line"><span class="number">39</span> </span><br><span class="line"><span class="number">40</span>     ret = stat(argv[<span class="number">1</span>], &amp;s);</span><br><span class="line"><span class="number">41</span>     <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="number">42</span>         perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line"><span class="number">43</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">44</span>     &#125;</span><br><span class="line"><span class="number">45</span>     show_file_type(&amp;s);</span><br><span class="line"><span class="number">46</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">47</span> &#125;                                    </span><br></pre></td></tr></table></figure>

<h3 id="2-access函数"><a href="#2-access函数" class="headerlink" title="2.access函数"></a>2.access函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> mode)</span>;</span><br><span class="line">功能：测试指定文件是否具有某种属性</span><br><span class="line">参数：</span><br><span class="line">    pathname:文件名</span><br><span class="line">    mode:文件权限，<span class="number">4</span>种权限</span><br><span class="line">        R_OK:	是否有读写权限</span><br><span class="line">        W_OK:	是否有写权限</span><br><span class="line">        X_OK:	是否有执行权限</span><br><span class="line">        F_OK:	测试文件是否存在</span><br><span class="line">返回值：</span><br><span class="line">    <span class="number">0</span>：有某种权限，或文件存在</span><br><span class="line">    <span class="number">-1</span>：没有，或文件不存在</span><br></pre></td></tr></table></figure>

<h3 id="3-chmod函数"><a href="#3-chmod函数" class="headerlink" title="3.chmod函数"></a>3.chmod函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：修改文件权限</span><br><span class="line">参数：</span><br><span class="line">    filename:文件名</span><br><span class="line">    mode:权限(<span class="number">8</span>进制数)</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-chown函数"><a href="#4-chown函数" class="headerlink" title="4.chown函数"></a>4.chown函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">uid_t</span> owner, <span class="type">git_t</span> group)</span>;</span><br><span class="line">功能：</span><br><span class="line">    修改文件所有者和所属组</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件或目录名</span><br><span class="line">    owner：文件所有者id，通过查看 /etc/passwd 得到所有者id</span><br><span class="line">    group:文件所属组id，通过 /etc/group 得到用户组id</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="5-truncate函数"><a href="#5-truncate函数" class="headerlink" title="5.truncate函数"></a>5.truncate函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">功能：修改文件大小</span><br><span class="line">参数：</span><br><span class="line">    path：文件名字</span><br><span class="line">    length：指定的文件大小</span><br><span class="line">        a)比用来小，删除后边的部分</span><br><span class="line">        b)比原来大，向后拓展</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="6-link函数"><a href="#6-link函数" class="headerlink" title="6.link函数"></a>6.link函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* oldpath, <span class="type">const</span> <span class="type">char</span>* newpath)</span>;</span><br><span class="line">功能：创建一个硬链接</span><br><span class="line">参数：</span><br><span class="line">    oldpath：源文件名字</span><br><span class="line">    newpath：硬链接名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="7-symlink函数"><a href="#7-symlink函数" class="headerlink" title="7.symlink函数"></a>7.symlink函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* target, <span class="type">const</span> <span class="type">char</span>* linkpath)</span>;</span><br><span class="line">功能：创建一个软链接</span><br><span class="line">参数：</span><br><span class="line">    target：源文件名字</span><br><span class="line">    linkpath：软链接名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="8-readlink函数"><a href="#8-readlink函数" class="headerlink" title="8.readlink函数"></a>8.readlink函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">char</span>* buf, <span class="type">size_t</span> bufsize)</span>;</span><br><span class="line">功能：读软连接对应的文件名，不是读内容(该函数只能读软链接文件)</span><br><span class="line">参数：</span><br><span class="line">    pathname：软连接名</span><br><span class="line">    buf：存放软链接对呀的文件名</span><br><span class="line">    bufsize：缓冲区大小(第二个参数存放的最大字节数)</span><br><span class="line">返回值：</span><br><span class="line">    成功：&gt;<span class="number">0</span>，读到buf中的字符个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="9-unlink函数"><a href="#9-unlink函数" class="headerlink" title="9.unlink函数"></a>9.unlink函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname)</span>;</span><br><span class="line">功能：删除一个文件(软硬链接文件)</span><br><span class="line">参数：</span><br><span class="line">    pathname：删除的文件名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="10-rename函数"><a href="#10-rename函数" class="headerlink" title="10.rename函数"></a>10.rename函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* oldpath, <span class="type">const</span> <span class="type">char</span>* newpath)</span>;</span><br><span class="line">功能：把oldpath的文件名改成newpath</span><br><span class="line">参数：</span><br><span class="line">    oldpath：旧文件名</span><br><span class="line">    newpath：新文件名</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="五、文件描述符复制"><a href="#五、文件描述符复制" class="headerlink" title="五、文件描述符复制"></a>五、文件描述符复制</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>dup() 和dup2() 是两个非常有用的系统调用，都是用来复制一个文件的描述符，使新的文件描述符也标识旧的文件描述符所标识的文件。</p>
<p>对于dup() dup2() 也一样，通过原来的文件描述符复制出一个新的文件描述符，这样的话，原来的我加你描述符和新的文件描述符都指向同一个文件，我们操作这两个文件描述符的任何一个，都能操作它所对应的文件。</p>
<h3 id="2-dup函数"><a href="#2-dup函数" class="headerlink" title="2.dup函数"></a>2.dup函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    通过 oldfd 复制出一个新的文件描述符，新的文件描述符表中最小可用的文件描述符，最终 oldfd 和新的文件描述符都指向同一个文件</span><br><span class="line">参数：</span><br><span class="line">    oldfd：需要复制的文件描述符 oldfd</span><br><span class="line">返回值：</span><br><span class="line">    成功：新文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%BB%93%E6%9E%84.png"></p>
<h3 id="3-dup2函数"><a href="#3-dup2函数" class="headerlink" title="3.dup2函数"></a>3.dup2函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    通过 oldfd 复制出一个新的文件描述符 newfd，如果成功，newfd 和函数返回值是同一个返回值，最终 oldfd 和新的文件描述符 newfd 都指向同一个文件。</span><br><span class="line">    oldfd：需要复制的文件描述符</span><br><span class="line">    newfd：新的文件描述符，这个描述符可以人为指定一个合法数字(<span class="number">0</span><span class="number">-1023</span>)，如果指定的数字已经被占用（和某个文件有关联），此函数会自动关闭close()断开这个数字和某个文件的关联，再来使用这个合法数字。</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回 newfd</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-案例分析"><a href="#4-案例分析" class="headerlink" title="4.案例分析"></a>4.案例分析</h3><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.png"></p>
<h3 id="5-fcntl函数"><a href="#5-fcntl函数" class="headerlink" title="5.fcntl函数"></a>5.fcntl函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line">功能：改变已打开的文件性质，fcntl针对描述符提供控制。</span><br><span class="line">参数：</span><br><span class="line">    fd：操作的文件操作符</span><br><span class="line">    cmd：操作方式</span><br><span class="line">    arg：针对cmd的值，fcntl能够接受第三个参数<span class="type">int</span> arg</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回某个其他值</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>fcntl函数有5种功能：</p>
<p>1）复制一个现有的描述符（cmd &#x3D; F_DUPFD）</p>
<p>2）获得 &#x2F; 设置文件描述符标记（cmd&#x3D;F_GETFD或F_SETFD）</p>
<p>3）获得 &#x2F; 设置文件状态标记（cmd&#x3D;F_GETFL或F_SETFL）</p>
<p>4）获得 &#x2F; 设置异步I&#x2F;O所有权（cmd&#x3D;F_GETOWN或F_SETOWN）</p>
<p>5）获得 &#x2F; 设置记录锁（cmd&#x3D;F_GETLK，F_SETLK或F_SETLKW）</p>
</blockquote>
<p>示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fcntl复制文件描述符功能</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> newfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="comment">//第三个参数0 表示返回第一个最小的可用的文件描述符，并且大于或等于0</span></span><br><span class="line">    newfd = fcntl(fd, F_DUPFD, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (newfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写文件</span></span><br><span class="line">    write(fd, <span class="string">&quot;123456789&quot;</span>, <span class="number">9</span>);</span><br><span class="line">    write(newfd, <span class="string">&quot;ABCDEFG&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    close(newfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-获得文件状态表示和设置"><a href="#5-1-获得文件状态表示和设置" class="headerlink" title="5.1 获得文件状态表示和设置"></a>5.1 获得文件状态表示和设置</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fcntl复制文件描述符功能</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> newfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件状态标记</span></span><br><span class="line">    ret = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &amp; O_APPEND)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before not append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置文件状态标记</span></span><br><span class="line">    ret = ret | O_APPEND;</span><br><span class="line">    ret = fcntl(fd, F_SETFL, ret);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件状态标记</span></span><br><span class="line">    ret = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &amp; O_APPEND)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before not append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-目录习惯操作"><a href="#6-目录习惯操作" class="headerlink" title="6.目录习惯操作"></a>6.目录习惯操作</h3><h4 id="6-1-getcwd函数"><a href="#6-1-getcwd函数" class="headerlink" title="6.1 getcwd函数"></a>6.1 getcwd函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getcwd</span><span class="params">(<span class="type">char</span>* buf, <span class="type">sie_t</span> size)</span>;</span><br><span class="line">功能：获取当前进程的工作目录</span><br><span class="line">参数：</span><br><span class="line">    buf：缓冲区，存储当前的工作目录</span><br><span class="line">    size：缓冲区大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：buf中保存当前进程工作目录位置</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-chdir函数"><a href="#6-2-chdir函数" class="headerlink" title="6.2 chdir函数"></a>6.2 chdir函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span>;</span><br><span class="line">功能：修改当前进程(应用程序)的路径</span><br><span class="line">参数：</span><br><span class="line">    path：切换的路径</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-opendir函数"><a href="#6-3-opendir函数" class="headerlink" title="6.3 opendir函数"></a>6.3 opendir函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR* <span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br><span class="line">功能：打开一个目录</span><br><span class="line">参数：</span><br><span class="line">    name：目录名</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回指向该目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="6-4-closedir函数"><a href="#6-4-closedir函数" class="headerlink" title="6.4 closedir函数"></a>6.4 closedir函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR* dirp)</span>;</span><br><span class="line">功能：关闭目录</span><br><span class="line">参数：</span><br><span class="line">    dirp：opendir返回的指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="6-5-readdir函数"><a href="#6-5-readdir函数" class="headerlink" title="6.5 readdir函数"></a>6.5 readdir函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent* <span class="title function_">readdir</span><span class="params">(DIR* dirp)</span>;</span><br><span class="line">功能：读取目录</span><br><span class="line">参数：</span><br><span class="line">    dirp：opendir的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p>相关结构体说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>&#123;</span></span><br><span class="line">    <span class="type">ino_t</span> d_ino;	<span class="comment">//此目录进入点的inode</span></span><br><span class="line">    <span class="type">off_t</span> d_off;	<span class="comment">//目录文件开头至目录进入点的位移</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">short</span> <span class="type">int</span> d_reclen;	<span class="comment">//d_name的长度，不包含NULL字符</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> d_type;	<span class="comment">//d_type所指的文件类型</span></span><br><span class="line">    <span class="type">char</span> d_name[<span class="number">256</span>];	<span class="comment">//文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>d_type文件类型说明</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DT_BLK</td>
<td>块设备</td>
</tr>
<tr>
<td>DT_CHR</td>
<td>字符设备</td>
</tr>
<tr>
<td>DT_DIR</td>
<td>目录</td>
</tr>
<tr>
<td>DT_LNK</td>
<td>软链接</td>
</tr>
<tr>
<td>DT_FIFO</td>
<td>管道</td>
</tr>
<tr>
<td>DT_REG</td>
<td>普通文件</td>
</tr>
<tr>
<td>DT_SOCK</td>
<td>套接字</td>
</tr>
<tr>
<td>DT_UNKNOWN</td>
<td>未知</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//目录打开和关闭</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    DIR* dir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">d</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//打开目录</span></span><br><span class="line">    dir = opendir(<span class="string">&quot;/home/pi/student/student03&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;dir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开目录成功...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//循读取目录中的内容</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        d = readdir(dir);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file_type:%hu\tfile_name:%s\n&quot;</span>, d-&gt;d_type, d-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="六、进程"><a href="#六、进程" class="headerlink" title="六、进程"></a>六、进程</h2><h3 id="1-进程和程序"><a href="#1-进程和程序" class="headerlink" title="1.进程和程序"></a>1.进程和程序</h3><p>程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。程序是静态的，进程是动态的。</p>
<p>在linux系统中，操作系统是通过进程去完成一个一个的任务，进程是管理事务的基本单元。</p>
<p>进程拥有自己独立的处理环境（如：当前需要用到哪些环境变量，程序运行的目录在哪是，当前是哪个用户在运行此程序等）和系统资源（如：处理器CPU占用率、存储器、I&#x2F;O设备、数据、程序）。</p>
<h3 id="2-单道、多道程序设计"><a href="#2-单道、多道程序设计" class="headerlink" title="2.单道、多道程序设计"></a>2.单道、多道程序设计</h3><h4 id="2-1-单道程序设计"><a href="#2-1-单道程序设计" class="headerlink" title="2.1 单道程序设计"></a>2.1 单道程序设计</h4><p>所有进程一个一个排队执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现是必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p>
<h4 id="2-2-多道程序设计"><a href="#2-2-多道程序设计" class="headerlink" title="2.2 多道程序设计"></a>2.2 多道程序设计</h4><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p>
<p>在计算机中时钟中断即为多道程序设计模型的理论基础。并发时，任意进程在执行期间都不希望放弃CPU。因此系统需要一种强制让进程让出CPU资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。操作系统中的中断处理函数来负责调度程序执行。</p>
<p>在多道程序设计模型中，多个进程轮流使用CPU（（分时复用CPU资源）。而当下常用CPU为纳秒级，1秒可执行大约10亿条指令。由于人眼的反应是毫秒级的，所以看似同时进行。</p>
<blockquote>
<p>1s &#x3D; 1000ms</p>
<p>1ms &#x3D; 1000um</p>
<p>1um &#x3D; 1000ns</p>
<p>1s &#x3D; 1000000000ns</p>
</blockquote>
<h3 id="3-并行和并发"><a href="#3-并行和并发" class="headerlink" title="3.并行和并发"></a>3.并行和并发</h3><p>**并行(parallel):**指同一时刻，有多条指令在多个处理器上同时执行</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B9%B6%E8%A1%8C.png"></p>
<p>**并发(concurrency):**指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使得进程快速交替的执行</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B9%B6%E5%8F%91.png"></p>
<h3 id="4-MMU"><a href="#4-MMU" class="headerlink" title="4.MMU"></a>4.MMU</h3><p>MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中原来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/MMU.png"></p>
<h3 id="5-进程控制块PCB"><a href="#5-进程控制块PCB" class="headerlink" title="5.进程控制块PCB"></a>5.进程控制块PCB</h3><p>进程运行时，内核为进程每个进程分配一个PCB（进程控制块），维护相关信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>其内部成员有很多，掌握以下部分即可</p>
<ul>
<li>进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</li>
<li>进程的状态，有就绪、运行、挂起、停止等状态</li>
<li>进程切换时需要保存和恢复的一些CPU存储器</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息。</li>
<li>当前工作目录（Current Working Directory）。</li>
<li>umask掩码</li>
<li>文件描述符，包含很多指向file结构体的指针。</li>
<li>和信号相关的信息</li>
<li>用户id和组id</li>
<li>会话（Session）和进程组</li>
<li>进程可以使用的资源上限（Resource Limit）。</li>
</ul>
<h3 id="6-进程的状态"><a href="#6-进程的状态" class="headerlink" title="6.进程的状态"></a>6.进程的状态</h3><p>进程状态反应进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。</p>
<p>在三态模型中，进程状态分为三个基本状态，即<strong>运行态、就绪态、阻塞态。</strong></p>
<p>在五态模型中，进程分为<strong>新建态、终止态、运行态、就绪态、阻塞态。</strong></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png"></p>
<p>查看进程的方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>

<h4 id="6-1-ps"><a href="#6-1-ps" class="headerlink" title="6.1 ps"></a>6.1 ps</h4><p>进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。</p>
<p>ps命令可以查看进程的详细情况，常用选项(选项可以不加”-“)如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示终端上的所有进程，包括其它用户的进程</td>
</tr>
<tr>
<td>-u</td>
<td>显示进程的详细状态</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
<tr>
<td>-w</td>
<td>显示加宽，以便显示更多的信息</td>
</tr>
<tr>
<td>-r</td>
<td>只显示正在运行的进程</td>
</tr>
</tbody></table>
<h4 id="6-2-top"><a href="#6-2-top" class="headerlink" title="6.2 top"></a>6.2 top</h4><p>top命令用来动态显示运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。可以在top命令时加上-d来指定显示信息更新的时间间隔。</p>
<p>在top命令执行后，可以按下按键得到对显示的结果进行排序：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>M</td>
<td>根据内存使用量来排序</td>
</tr>
<tr>
<td>P</td>
<td>根据CPU占有率来排序</td>
</tr>
<tr>
<td>T</td>
<td>根据进程运行时间的长短来排序</td>
</tr>
<tr>
<td>U</td>
<td>可以根据后面输入的用户名筛选进程</td>
</tr>
<tr>
<td>K</td>
<td>可以根据后面输入的PID来杀死进程</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>h</td>
<td>获得帮助</td>
</tr>
</tbody></table>
<h4 id="6-3-kill"><a href="#6-3-kill" class="headerlink" title="6.3 kill"></a>6.3 kill</h4><p>kill命令指定进程号的进程，需要配合ps使用</p>
<p>使用格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill [-signal] pid</span><br></pre></td></tr></table></figure>

<p>信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。</p>
<p>有些进程没办法直接杀死，需要添加 <code>-9</code> 参数强制杀死</p>
<h4 id="6-4-killall"><a href="#6-4-killall" class="headerlink" title="6.4 killall"></a>6.4 killall</h4><p>通过名字杀死进程</p>
<h3 id="7-进程号和相关函数"><a href="#7-进程号和相关函数" class="headerlink" title="7.进程号和相关函数"></a>7.进程号和相关函数</h3><p>每个进程都由一个进程号标识，其类型为pid_t（整形），进程号的范围：0~32767.进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用。</p>
<p><strong>进程号（PID）：</strong></p>
<p>标识进程的一个非负整形数</p>
<p><strong>父进程号（PPID）：</strong></p>
<p>任何进程（除init进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。如，A进程创建了B进程，A的进程号就是B进程的父进程号。</p>
<p><strong>进程组号（PGID）：</strong></p>
<p>进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。这个过程有点类似于QQ群，各个进程相当于各个好友，把各个好友都拉入这个QQ群里，主要是方便管理，特别是通知某些事时，只要在群里吼一声，所有人都收到，简单粗暴。但是，这个进程组号和QQ群号是有区别的，默认的情况下，当前的进程号会当作当前的进程号。</p>
<h4 id="7-1-getpid函数"><a href="#7-1-getpid函数" class="headerlink" title="7.1 getpid函数"></a>7.1 getpid函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取本进程号（PID）</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    本进程号</span><br></pre></td></tr></table></figure>

<h4 id="7-2-getppid函数"><a href="#7-2-getppid函数" class="headerlink" title="7.2 getppid函数"></a>7.2 getppid函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：获取调用此函数的进程的父进程号</span><br><span class="line">参数：无</span><br><span class="line">返回值：调用此函数的进程的父进程号（PPID）</span><br></pre></td></tr></table></figure>

<h4 id="7-3-getpgid函数"><a href="#7-3-getpgid函数" class="headerlink" title="7.3 getpgid函数"></a>7.3 getpgid函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取进程组号（PGID）</span><br><span class="line">参数：</span><br><span class="line">    查询进程的进程号</span><br><span class="line">返回值：</span><br><span class="line">    进程组号（PGID）</span><br></pre></td></tr></table></figure>

<h4 id="7-4-示例"><a href="#7-4-示例" class="headerlink" title="7.4 示例"></a>7.4 示例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取进程号 父进程号 进程组号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//获取当前进程的进程号</span></span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程号:%d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前进程的父进程号</span></span><br><span class="line">    pid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父进程号:%d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前进程组号</span></span><br><span class="line">    pid = getpgid(getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程组号:%d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-进程的创建"><a href="#8-进程的创建" class="headerlink" title="8.进程的创建"></a>8.进程的创建</h3><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程呢个，形成进程树结构模型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：用于从一个已经存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程。</span><br><span class="line">参数：无</span><br><span class="line">返回值：</span><br><span class="line">    成功：子进程中返回<span class="number">0</span>，父进程中返回子进程ID。<span class="type">pid_t</span>为整形</span><br><span class="line">    失败：返回<span class="number">-1</span></span><br><span class="line">    失败的两个原因：</span><br><span class="line">        <span class="number">1</span>）当前的进程数已经达到了系统规定的上限，这时errno的值为EAGAIN。</span><br><span class="line">        <span class="number">2</span>）系统内存不足，这时errno的值被设置为ENOMEM。</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,word\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">hello,word</span><br><span class="line">hello,word</span><br></pre></td></tr></table></figure>

<h3 id="9-父子进程关系"><a href="#9-父子进程关系" class="headerlink" title="9.父子进程关系"></a>9.父子进程关系</h3><p>使用fork()函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。</p>
<p>子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用fork()函数的代价是很大的。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png"></p>
<p>简单来说，一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p>
<p>实际上，更准确来说，Linux的fork()使用是通过写时拷贝（copy-on-write）实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只要在需要写入的社会才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</p>
<p>注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件文件偏移指针。</p>
<h3 id="10-区分父子进程"><a href="#10-区分父子进程" class="headerlink" title="10.区分父子进程"></a>10.区分父子进程</h3><p>子进程是父进程的一个复制品，可以简单认为父子进程的代码一样。父进程做了什么事，子进程也做什么事，如果我们需要实现多任务的要求该如何实现呢？答案是通过fork()的返回值。</p>
<p>fork()函数被调用一次，但返回两次。两次返回的区别是：子进程的返回值是0，而父进程的返回值则是子进程的ID。</p>
<p>测试程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> child_id;</span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程创建失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id: %d  pid: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id: %d  child_id: %d\n&quot;</span>, getpid(), child_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-父子进程地址空间"><a href="#11-父子进程地址空间" class="headerlink" title="11.父子进程地址空间"></a>11.父子进程地址空间</h3><p>父进程的值是在单独的空间，子进程的值是在单独空间，两者修改不会互相影响。</p>
<p>如果是在堆区开辟的空间也不会相互受到影响，但是记住一定要释放一下开辟出来的空间，比如下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> child_id;</span><br><span class="line">    <span class="type">int</span>* num = <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *num = <span class="number">200</span>;</span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程创建失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_id == <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程:%d\n&quot;</span>, *num);</span><br><span class="line">        <span class="built_in">free</span>(num);</span><br><span class="line">        num = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程前:%d\n&quot;</span>, *num);</span><br><span class="line">        (*num)++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程后:%d\n&quot;</span>, *num);</span><br><span class="line">        <span class="built_in">free</span>(num);</span><br><span class="line">        num = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不两次释放会导致内存溢出</p>
<h3 id="12-GDB调试多进程"><a href="#12-GDB调试多进程" class="headerlink" title="12.GDB调试多进程"></a>12.GDB调试多进程</h3><p>使用GDB调试的时候，GDB只能跟踪一个进程。可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者各种子进程。默认跟踪父进程。</p>
<ul>
<li>set follow-fork-mode child	设置GDB在fork之后跟踪子进程。</li>
<li>set follow-fork-mode parent  设置跟踪父进程（默认）</li>
</ul>
<p>注意，一定要在fork函数调用之前设置才有效</p>
<h3 id="13-进程退出函数"><a href="#13-进程退出函数" class="headerlink" title="13.进程退出函数"></a>13.进程退出函数</h3><p>相关函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line">功能：</span><br><span class="line">    结束调用此函数的进程。</span><br><span class="line">参数：</span><br><span class="line">    status：返回值给父进程的参数（低<span class="number">8</span>位有效），至于这个参数是多少根据需求来写。</span><br><span class="line">返回值：</span><br><span class="line">    无</span><br></pre></td></tr></table></figure>

<p>exit() 和 _exit() 函数功能和用法是一样的，无非是所包含的头文件不一样，exit() 属于标准库函数， _exit() 属于系统调用函数。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%80%80%E5%87%BA%E8%BF%9B%E7%A8%8B%E5%87%BD%E6%95%B0.png"></p>
<h3 id="14-等待进程退出函数"><a href="#14-等待进程退出函数" class="headerlink" title="14.等待进程退出函数"></a>14.等待进程退出函数</h3><h4 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h4><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号、退出状态、允许时间等）。</p>
<p>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除这个进程。</p>
<p>wait() 和 waitpid() 函数的功能一样，区别在于， wait() 函数会阻塞， waitpid() 可以设置不阻塞， waitpid() 还可以指定等待哪个子进程结束。</p>
<p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
<h4 id="14-2-wait函数"><a href="#14-2-wait函数" class="headerlink" title="14.2 wait函数"></a>14.2 wait函数</h4><p>函数说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>* status)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    status：进程结束时的状态信息</span><br><span class="line">返回值：</span><br><span class="line">    成功：已经结束子进程的进程号</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>调用 wait() 函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号才被唤醒（相当于继续往下执行）。</p>
<p>若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。</p>
<p>所以，wait()函数的主要功能为回收已经结束子进程的资源。</p>
<p>如果参数status的值不是NULL，wait() 就会把子进程退出时的状态取出并存入其中，这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的。</p>
<p>这个退出信息在一个int中包含了多个字段，直接使用这个值是没有意义的，我们需要用宏定义取出其中的每个字段。</p>
<p><strong>宏函数可以分为如下三组：</strong></p>
<p>1）WIFEXITED(status)</p>
<p>​	为非0 进程正常结束</p>
<p>WEXITSTATUS(status)</p>
<p>​	如果宏为真，使用此宏 获取进程退出状态（exit的参数）</p>
<p>2）WIFSIGNALED(status)</p>
<p>​	为非0 进程异常终止</p>
<p>WTERMSIG(status)</p>
<p>​	如上宏为真，使用此宏 取得进程终止的那个信号的编号</p>
<p>3）WIFSTOPPED(status)</p>
<p>​	为非0 进程处于暂停状态</p>
<p>WSTOPSIG(status)</p>
<p>​	如上宏为真，使用此宏 取得使进程暂停的那个信号的编号</p>
<p>WIFCONTINUED(status)</p>
<p>​	为真 进程暂停后已经继续运行</p>
<h4 id="14-3-waitpid函数"><a href="#14-3-waitpid函数" class="headerlink" title="14.3 waitpid函数"></a>14.3 waitpid函数</h4><p>函数说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">pid_d <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* status, <span class="type">int</span> options)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    pid：参数 pid 的值有以下几种类型：</span><br><span class="line">    pid &gt; <span class="number">0</span> 等待进程 ID 等于 pid 的子进程</span><br><span class="line">    pid = <span class="number">0</span> 等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid 不会等待它。</span><br><span class="line">    pid = <span class="number">-1</span> 等待任意子进程，此时 waitpid 和 wait 作用一样。</span><br><span class="line">    pid &lt; <span class="number">-1</span> 等待指定进程组中的任何子进程，这个进程组的 ID 等于 pid 的绝对值。</span><br><span class="line">    </span><br><span class="line">    status：进程退出时的状态信息。和 wait() 用法一样。</span><br><span class="line">    </span><br><span class="line">    options：options 提供了一些额外的选项来控制 waitpid()。</span><br><span class="line">        <span class="number">0</span>：同 wait(),阻塞父进程，等待子进程退出。</span><br><span class="line">        WNOHANG:没有任何已经结束的子进程，则立刻返回</span><br><span class="line">        WUNTRACED:如果子进程暂停了则此函数马上返回，并且不予理会子进程的结束状态。（由于涉及到一些调试方面的知识，加之极少用到）</span><br><span class="line">返回值：</span><br><span class="line">    waitpid() 的返回值比 wait() 稍微复杂一些，一共有 <span class="number">3</span> 种情况：</span><br><span class="line">        <span class="number">1</span>) 当正常返回的时候，waitpid() 返回收集到的已经回收子进程的进程号；</span><br><span class="line">        <span class="number">2</span>) 如果设置了选项 WNOHANG，而调用中 waitpid() 发现没有已退出的子进程可等待，则返回 <span class="number">0</span>；</span><br><span class="line">        <span class="number">3</span>) 如果调用中出错，则返回<span class="number">-1</span>，这时 errno 会被设置成相应的值以指示错误所在，如：当 pid 所对应的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid() 就会出错返回，这时 errno 被设置为 ECHILD；</span><br></pre></td></tr></table></figure>

<h3 id="15-孤儿进程"><a href="#15-孤儿进程" class="headerlink" title="15.孤儿进程"></a>15.孤儿进程</h3><p>父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程（Orphan Process）。</p>
<p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。</p>
<p>因此孤儿进程并不会有什么危害。</p>
<h3 id="16-僵尸进程"><a href="#16-僵尸进程" class="headerlink" title="16.僵尸进程"></a>16.僵尸进程</h3><p>进程终止，父进程尚未回收子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</p>
<p>这样就会导致一个问题，如果进程不调用wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有进程号而导致系统不能产生新的进程，这就是僵尸进程的危害，应当避免。</p>
<h3 id="17-进程替换"><a href="#17-进程替换" class="headerlink" title="17.进程替换"></a>17.进程替换</h3><p><strong>概述</strong></p>
<p>在Windows平台下，我们可以通过双击运行可执行程序成为一个进程；而在Linux平台，我们可以通过 <code>./</code> 运行，让一个可执行程序成为一个进程。</p>
<p>但是，如果我们本来就运行着一个程序（进程），我们如何在这个进程内部启动一个外部程序，由内核将这个程序读入内存，使其执行起来成为一个进程呢？这里我们通过 exec 函数族实现。</p>
<p>exec 函数族，顾名思义，就是一簇函数，在Linux中，并不存在 exec() 函数，exec 指的是一组函数，一共有6个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...<span class="comment">/*(char*)NULL */</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* arg, ...<span class="comment">/*(char*)NULL */</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...<span class="comment">/*(char*)NULL char* const envp[]*/</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<p>其中只有 execve() 是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</p>
<p>exec函数族的作用是根据指定的文件名或目录名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p>
<p>进程调用一种exec函数时，该进程完全由新程序交替，而新程序则从其main函数开始执行。因为调用exec并吧创建新进程，所以前后的进程 ID （当然还有父进程号、进程组号、当前工作目录……）并未改变。exec 只是用另一个新程序替换了当前进程的正文、数据、堆和栈段（进程替换）。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2.png"></p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/home&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、进程间通讯"><a href="#七、进程间通讯" class="headerlink" title="七、进程间通讯"></a>七、进程间通讯</h2><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p>
<p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信（IPC：Inter Processes Communication）。</p>
<p>进程间通讯的目的：</p>
<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ul>
<p><strong>Linux 操作系统支持的主要进程间通信的通信机制：</strong></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E4%B8%AD%E9%80%9A%E8%AE%AF%E6%A6%82%E5%BF%B5.png"></p>
<h3 id="1-无名管道"><a href="#1-无名管道" class="headerlink" title="1.无名管道"></a>1.无名管道</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>管道也叫无名管道，它是UNIX系统IPC（进程间通信）的最古老形式，所有的UNIX系统都支持这种通信机制。</p>
<p><strong>管道有如下特点：</strong></p>
<p>1）半双工，数据在同一时刻只能在一个方向上流动。</p>
<p>2）数据只能从管道的一端写入，从另一端读出。</p>
<p>3）写入管道中的数据遵循先入后出的规则。</p>
<p>4）管道所传送的数据是无格式的，这要求管道的读出方必须事先约定好数据的格式，如多少字节算一个消息等。</p>
<p>5）管道不是普通的文件，不属于某个文件系统，其只存放于内存中。</p>
<p>6）管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。</p>
<p>7）从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据。</p>
<p>8）管道没有名字，只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</p>
<p>对于管道特点的理解，我们可以类比实现生活中管子，管子的一端塞东西，管子的另一端取东西。</p>
<p>管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93.png"></p>
<h4 id="1-2-pipe函数"><a href="#1-2-pipe函数" class="headerlink" title="1.2 pipe函数"></a>1.2 pipe函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line">功能：创建无名管道。</span><br><span class="line">    </span><br><span class="line">参数：</span><br><span class="line">    pipefd：为 <span class="type">int</span> 型数组的首地址，其存放了管道的文件描述符 pipefd[<span class="number">0</span>]、pipefd[<span class="number">1</span>]。</span><br><span class="line">    </span><br><span class="line">    当一个管道建立时，它会创建两个文件描述符 fd[<span class="number">0</span>] 和 fd[<span class="number">1</span>]。其中 fd[<span class="number">0</span>] 固定用于读管道，而 fd[<span class="number">1</span>] 固定用于写管道。一般文件 I/O的函数都可以用来操作管道(lseek() 除外)。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>例子：父子进程通过无名管道进行通讯</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父子进程通讯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> read_string[SIZE];</span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>, child_id = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> read_bool = <span class="number">-1</span>, write_bool = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建无名管道</span></span><br><span class="line">    ret = pipe(pd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子进程 读内容</span></span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//禁用写端</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取管道中的内容</span></span><br><span class="line">        read_bool = read(pd[<span class="number">0</span>], read_string, SIZE);</span><br><span class="line">        <span class="keyword">if</span> (read_bool &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child read: %s\n&quot;</span>, read_string);</span><br><span class="line">        <span class="comment">//禁用读端</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父进程 写内容</span></span><br><span class="line">    <span class="comment">//关闭读管道</span></span><br><span class="line">    close(pd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    write_bool = write(pd[<span class="number">1</span>], <span class="string">&quot;ABCDEFGHIJK&quot;</span>, SIZE);</span><br><span class="line">    <span class="keyword">if</span>(write_bool &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent process write len: %d\n&quot;</span>, write_bool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭写管道</span></span><br><span class="line">    close(pd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意一下，创建匿名管道的时候需要在创建进程前创建，如果按照下面的代码创建匿名管道：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>], ret, i;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">            ret = read(fd[<span class="number">0</span>], buf, <span class="number">20</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, ret, buf);</span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">            ret = write(fd[<span class="number">1</span>], <span class="string">&quot;abcd&quot;</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样会导致子进程读不出父进程向管道传入的数据，原因是因为在创建好子进程后，子进程后父进程分别创建了一个管道，子进程使用的管道是子进程自己创建的管道，而父进程使用的管道是父进程创建的管道，父进程向管道中传入内容，其实是向它自己创建的管道中传入内容，而子进程读取管道中的内容是读取自己管道中的内容，所以子进程读不出来内容。 </p>
<h4 id="1-3-管道的读写特点"><a href="#1-3-管道的读写特点" class="headerlink" title="1.3 管道的读写特点"></a>1.3 管道的读写特点</h4><p>使用管道需要注意一下4种特殊情况（假设都是阻塞I&#x2F;O操作，没有设置O_NONBLOCK标志）：</p>
<p>1）如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</p>
<p>2）如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</p>
<p>3）如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。</p>
<p>4）如果有指向管道读端的文件描述符没关闭（管道读端引用计数器大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p>
<p><strong>总结：</strong></p>
<p><strong>读管道：</strong></p>
<ul>
<li>管道中有数据，read返回实际读到的字节数。</li>
<li>管道中无数据：<ul>
<li>管道写端被全部关闭，read返回0（相当于读到文件结尾）</li>
<li>写端没有全部被关闭，read阻塞等待（不久的将来可能有数据递达，此时会让出CPU）</li>
</ul>
</li>
</ul>
<p><strong>写管道：</strong></p>
<ul>
<li>管道读端全部被关闭，进程异常终止（也可使用捕捉SIGPIPE信号，使进程终止）</li>
<li>管道读端没有全部关闭：<ul>
<li>管道已满，write阻塞。</li>
<li>管道未满，writr将数据写入，并返回实际写入的字节数</li>
</ul>
</li>
</ul>
<h4 id="1-4-设置为非阻塞的方法"><a href="#1-4-设置为非阻塞的方法" class="headerlink" title="1.4 设置为非阻塞的方法"></a>1.4 设置为非阻塞的方法</h4><p>设置方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取原来的flags</span></span><br><span class="line"><span class="type">int</span> flage = fcntl(fd[<span class="number">0</span>], F_GETFL);</span><br><span class="line"><span class="comment">//设置新的flags</span></span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line"><span class="comment">//flags = flags | O_NONBLOCK;</span></span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flags);</span><br></pre></td></tr></table></figure>

<p>结论：如果写端没有关闭，读端设置为非阻塞，直接返回-1。</p>
<h4 id="1-5-查看管道缓冲区命令"><a href="#1-5-查看管道缓冲区命令" class="headerlink" title="1.5 查看管道缓冲区命令"></a>1.5 查看管道缓冲区命令</h4><p>可以使用ulimit-a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小</p>
<h4 id="1-6-查看管道缓冲区函数"><a href="#1-6-查看管道缓冲区函数" class="headerlink" title="1.6 查看管道缓冲区函数"></a>1.6 查看管道缓冲区函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line">功能：该函数可以通过name参数查看不同的属性值</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    name：</span><br><span class="line">        _PC_PIPE_BUF,查看管道缓冲区大小</span><br><span class="line">        _PC_NAME_MAX,文件名字字节数的上限</span><br><span class="line">返回值：</span><br><span class="line">    成功：根据name返回的值的意义也不同。</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>], ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建无名管道</span></span><br><span class="line">    ret = pipe(pd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看管道缓冲区函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, fpathconf(pd[<span class="number">0</span>], _PC_PIPE_BUF));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, fpathconf(pd[<span class="number">0</span>], _PC_NAME_MAX));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-有名管道"><a href="#2-有名管道" class="headerlink" title="2.有名管道"></a>2.有名管道</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>无名管道由于没有名字，只能用于亲缘关系的进程间通讯。为了克服这个缺点，提出了明名管道（FIFO），也叫有民管道、FIFO文件。</p>
<p>命名管道（FIFO）不同于无名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通讯，因此，通过FIFO不相关的进程也能交换数据。</p>
<p>命名管道（FIFO）和无名管道（pipe）有一些特点是相同的，不一样的地方在于：</p>
<p>1）FIFO在文件系统中作为一个特殊的文件而存在，但FIFO中的内容却存放在内存中。</p>
<p>2）当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。</p>
<p>3）FIFO有名字，不相关的进程可以通过打开命名管道进行通讯。</p>
<h4 id="2-2-通过命令创建有名管道"><a href="#2-2-通过命令创建有名管道" class="headerlink" title="2.2 通过命令创建有名管道"></a>2.2 通过命令创建有名管道</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93.png"></p>
<h4 id="2-3-通过函数创建有名管道"><a href="#2-3-通过函数创建有名管道" class="headerlink" title="2.3 通过函数创建有名管道"></a>2.3 通过函数创建有名管道</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：</span><br><span class="line">    命名管道的创建。</span><br><span class="line">参数：</span><br><span class="line">    pathname : 普通的路径名，也就是创建后 FIFO 的名字。</span><br><span class="line">    mode : 文件的权限，与打开普通文件的 open() 函数中的 mode 参数相同。（<span class="number">0666</span>）</span><br><span class="line">返回值：</span><br><span class="line">    成功: <span class="number">0</span>	状态码</span><br><span class="line">    失败：如果文件已经存在，则会出错且返回<span class="number">-1</span>。    </span><br></pre></td></tr></table></figure>

<h4 id="2-4-有名管道读写操作"><a href="#2-4-有名管道读写操作" class="headerlink" title="2.4 有名管道读写操作"></a>2.4 有名管道读写操作</h4><p>一旦使用mkfifo创建一个FIFO，就可以使用open打开它，常见的文件I&#x2F;O函数都可用于fifo。如：close、read、write、unlink等。</p>
<p>FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始到处返回数据，对它们的写则把数据添加到末尾。<strong>它们不支持诸如lseek()等文件定位操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*write.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fp = <span class="number">-1</span>, ret = <span class="number">-1</span>, i = <span class="number">14</span>;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="comment">//打开有名管道</span></span><br><span class="line">    fp = open(<span class="string">&quot;fifo&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写内容</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, SIZE);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello itcast:%d&quot;</span>, i);</span><br><span class="line">        ret = write(fp, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write fifo : %d\n&quot;</span>, ret);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭管道</span></span><br><span class="line">    close(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*read.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd =<span class="number">-1</span>, ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;fifo&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read....\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ret = read(fd, buf, SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-有名管道注意事项"><a href="#2-5-有名管道注意事项" class="headerlink" title="2.5 有名管道注意事项"></a>2.5 有名管道注意事项</h4><p>1）一个为只读而打开一个管道的进程会阻塞直到另一个进程为只写打开该管道</p>
<p>2）一个为只写而打开一个管道的进程会阻塞直到另一个进程为只读打开管道</p>
<p><strong>读管道：</strong></p>
<ul>
<li>管道中有数据，read返回实际读到的字节数。</li>
<li>管道中无数据：<ul>
<li>管道写端被全部关闭，read返回0（相当于读到文件结尾）</li>
<li>写端没有全部被关闭，read阻塞等待</li>
</ul>
</li>
</ul>
<p><strong>写管道：</strong></p>
<ul>
<li>管道读端全部被关闭，进程异常终止（也可使用捕捉SIGPIPE信号，使进程终止）</li>
<li>管道读端没有全部关闭：<ul>
<li>管道已满，write阻塞。</li>
<li>管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ul>
</li>
</ul>
<h3 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3.消息队列"></a>3.消息队列</h3><p>在上面说了一下管道，学习完管道后发现管道是一端发送什么，另一端就只能接收什么，而且只能传递一种类型，但在实际的项目中，有些时候需要选择性的接收另一端传递过来的数据，为了解决这个问题，Linux中出现了一个叫做消息队列的东西。</p>
<h4 id="3-1-什么是消息队列"><a href="#3-1-什么是消息队列" class="headerlink" title="3.1 什么是消息队列"></a>3.1 什么是消息队列</h4><p>消息队列其实是一个在内核地址空间中的内部链表，每一个链表的内容是一个数据块，数据块中能存放的内容有很多的类型，这些可以自己去定义，而且还能选择性的进行接收数据。</p>
<h4 id="3-2-通过命令查看消息队列"><a href="#3-2-通过命令查看消息队列" class="headerlink" title="3.2 通过命令查看消息队列"></a>3.2 通过命令查看消息队列</h4><p>在Linux中可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipcs -q</span><br></pre></td></tr></table></figure>

<p>来查看一下当前系统中的消息队列的个数和每个消息队列的大小</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png"></p>
<h4 id="3-3-创建消息队列"><a href="#3-3-创建消息队列" class="headerlink" title="3.3 创建消息队列"></a>3.3 创建消息队列</h4><p>可以使用<code>msgget</code>函数创建出一个消息队列，函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgfig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    功能：创建接口队列</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        key:消息队列中的键值，通常使用ftok()函数进行创建</span></span><br><span class="line"><span class="comment">        msgfig:权限标志</span></span><br><span class="line"><span class="comment">            IPC_CREATE:如果key值所对应的消息队列不存在，那么就创建一个</span></span><br><span class="line"><span class="comment">            IPC_EXCL:</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="4-共享存储映射"><a href="#4-共享存储映射" class="headerlink" title="4.共享存储映射"></a>4.共享存储映射</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>存储映射I&#x2F;O(Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84.png"></p>
<p>于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I&#x2F;O操作。</p>
<p>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式，因为进程可以直接读写内存，而不需要任何数据的拷贝。</p>
<h4 id="4-2-存储映射函数"><a href="#4-2-存储映射函数" class="headerlink" title="4.2 存储映射函数"></a>4.2 存储映射函数</h4><h5 id="（1）mmap函数"><a href="#（1）mmap函数" class="headerlink" title="（1）mmap函数"></a>（1）mmap函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    一个文件或者其它对象映射进内存</span><br><span class="line">参数：</span><br><span class="line">    addr ： 指定映射的起始地址，通常设为<span class="literal">NULL</span>，由系统指定</span><br><span class="line">    length ： 映射到内存的文件长度</span><br><span class="line">    prot ： 映射区的保护方式，最常用的：</span><br><span class="line">        a) 读：PROT_READ</span><br><span class="line">        b) 写：PROT_WRITE</span><br><span class="line">        c) 读写：PROT_READ | PROT_WRITE</span><br><span class="line">    flags: 映射区的特性，可以是</span><br><span class="line">        a) MAP_SHARED : 写入映射区的数据会复制回文件，且允许其它映射该文件的进程共享。</span><br><span class="line">        b) MAP_PRIVATE : 对映射区的写入操作会产生一个映射区的复制(copy - on - write)，对此区域所做的修改不会写回原文件。</span><br><span class="line">    fd: 由open返回的文件描述符，代表要映射的文件。</span><br><span class="line">    offset: 以文件开始处的偏移量，必须是<span class="number">4</span>k的整数倍，通常为<span class="number">0</span>，表示从文件头开始映射</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回创建的映射区首地址</span><br><span class="line">    失败：MAP_FAILED宏</span><br></pre></td></tr></table></figure>

<p>关于mmap函数的使用总结：</p>
<p>1）第一个参数写成NULL</p>
<p>2）第二个参数要映射的文件大小 &gt;0</p>
<p>3）第三个参数：PROT_READ、PROT_WRITE</p>
<p>4）第四个参数：MAP_SHARED 或者 MAP_PRIVATE</p>
<p>5）第五个参数：打开的文件对应的文件描述符</p>
<p>6）第六个参数：4k的整数倍，通常为0</p>
<h5 id="（2）munmap函数"><a href="#（2）munmap函数" class="headerlink" title="（2）munmap函数"></a>（2）munmap函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line">功能：</span><br><span class="line">    释放内存映射区</span><br><span class="line">参数：</span><br><span class="line">    addr: 使用mmap函数创建的映射区的首地址</span><br><span class="line">    length: 映射区的大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3 注意事项"></a>4.3 注意事项</h4><p>1）创建映射区的过程中，隐含着一次对映射文件的读操作。</p>
<p>2）当MAP_SHARED时，要求映射区的权限应 &lt;&#x3D;文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</p>
<p>3）映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。</p>
<p>4）特别注意，当映射文件大小为0时，不能创建映射区。所以，用于映射的文件必须要有实际大小。mmap使用时常常会出现总线程错误，通常是由于共享文件存储空间大小引起的。</p>
<p>5）munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。</p>
<p>6）如果文件偏移量必须为4K的整数倍。</p>
<p>7）mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</p>
<h4 id="4-4-共享映射的方式操作文件"><a href="#4-4-共享映射的方式操作文件" class="headerlink" title="4.4 共享映射的方式操作文件"></a>4.4 共享映射的方式操作文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取文件成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建映射</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建映射成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;关闭文件描述符成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向映射区写内容</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr, <span class="string">&quot;123456789&quot;</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存区</span></span><br><span class="line">    ret = munmap(addr, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;释放内存成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-共享映射实现父子进程通讯"><a href="#4-5-共享映射实现父子进程通讯" class="headerlink" title="4.5 共享映射实现父子进程通讯"></a>4.5 共享映射实现父子进程通讯</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* mp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">pid_t</span> child_id = <span class="number">-1</span>; </span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建映射</span></span><br><span class="line">    mp = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mp == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">memcpy</span>(mp, <span class="string">&quot;abcdefg&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mp:%s\n&quot;</span>, (<span class="type">char</span>*)mp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放内存映射</span></span><br><span class="line">    munmap(mp, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-不同进程使用存储映射进行进程间通讯"><a href="#4-6-不同进程使用存储映射进行进程间通讯" class="headerlink" title="4.6 不同进程使用存储映射进行进程间通讯"></a>4.6 不同进程使用存储映射进行进程间通讯</h4><p>write.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加映射</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存映射添加成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">//写文件</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr, <span class="string">&quot;qwertyuiop&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放映射内存</span></span><br><span class="line">    ret = munmap(addr, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;释放映射内存成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加映射</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存映射添加成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">//读文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">void</span>*)addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放映射内存</span></span><br><span class="line">    ret = munmap(addr, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;释放映射内存成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-7-匿名映射实现父子进程通讯"><a href="#4-7-匿名映射实现父子进程通讯" class="headerlink" title="4.7 匿名映射实现父子进程通讯"></a>4.7 匿名映射实现父子进程通讯</h4><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程通讯间也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。</p>
<p>通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。可以直接使用匿名映射来代替。</p>
<p>其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定</p>
<p>使用<strong>MAO_ANONYMOUS(或MAP_ANON)</strong>。</p>
<p><code>int* p - mmap(NULL, 4, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</code></p>
<ul>
<li>4“随意举例，该位置表示映射区大小，可依实际需要填写”。</li>
<li>MAP_ANONYMOUS 和 MAP_ANON 这两个宏是Linux操作系统特有的宏。推荐使用 <strong>MAP_ANONYMOUS</strong>。</li>
</ul>
<p>程序实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* arrd = <span class="literal">NULL</span>;</span><br><span class="line">    arrd = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (arrd == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    pd = fork();</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向文件中写内容</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(arrd, <span class="string">&quot;hello,word&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读文件中的内容</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arrd:%s\n&quot;</span>, (<span class="type">char</span>*)arrd);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭映射</span></span><br><span class="line">    munmap(arrd, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、信号"><a href="#八、信号" class="headerlink" title="八、信号"></a>八、信号</h2><h3 id="1-信号的概述"><a href="#1-信号的概述" class="headerlink" title="1.信号的概述"></a>1.信号的概述</h3><p>信号是Linux进程通讯的最古老的方式。信号是软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
<p><strong>信号的特点</strong></p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特设条件才发送</li>
</ul>
<p>信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。</p>
<p>一个完整的信号周期包括三个部分：信号的产生，信号在进程中的注册，信号在进程中的注销，执行信号处理函数。如下图所示：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E8%BF%B0.jpg"></p>
<p>注意：这里信号的产生，注册，注销时信号的内部机制，而不是信号的函数实现。</p>
<h3 id="2-信号的编号"><a href="#2-信号的编号" class="headerlink" title="2.信号的编号"></a>2.信号的编号</h3><p>1）信号编号：</p>
<p>Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了修改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p>
<p>Linux 可使用命令：kill -l，查看相应的信号</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%96%E5%8F%B7.png"></p>
<p>不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。</p>
<p>2）Linux常规信号一览表</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>信号</th>
<th>对应事件</th>
<th>默认动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>用户推出shell时，由该shell启动的所有进程将收到这个信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>当用户按下了**&lt;Ctrl+C&gt;**组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>用户按下了**&lt;ctrl+\&gt;**组合键时产生了该信号，用户终端向正在运行中的由该终端启动的程序发出些信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>CPU检测到某进程执行了非法指令</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>该信号由断点指令或其他trap指令产生</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>调用abort函数时产生该信号</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS</td>
<td>非法访问内存地址，包括内存对齐出错</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的运算时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止进程。本信号不能被忽略，处理和阻塞</td>
<td>终止进程，可以杀死任何进程</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSE1</td>
<td>用户定义的信号。即程序员可以在程序中定义并使用该信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>指示进程进行了无效内存访问（段错误）</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>另外一个用户自定义信号，程序员可以在程序中定义并使用该型号</td>
<td>终止进程</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>Broken pipe向一个没有读端的管道写数据</td>
<td>终止进程</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>定时器超时，超时的时间由系统调用alarm设置</td>
<td>终止进程</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令kill时，缺省产生这个信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>16</td>
<td>SIGSTKFLT</td>
<td>Linux早期版本出现的信号，现仍保留向后兼容</td>
<td>终止进程</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>子进程结束时，父进程会收到这个信号</td>
<td>忽略这个信号</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>如果进程已停止，则使其继续运行</td>
<td>继续&#x2F;忽略</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>停止进程的执行。信号不能被忽略，处理和阻塞</td>
<td>为终止进程</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号</td>
<td>暂停进程</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>后台进程读终端控制台</td>
<td>暂停进程</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生</td>
<td>暂停进程</td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程</td>
<td>终止进程</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>超过文件的最大长度设置</td>
<td>终止进程</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTLRM</td>
<td>虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用s’j</td>
<td>终止进程</td>
</tr>
<tr>
<td>27</td>
<td>SGIPROF</td>
<td>类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间</td>
<td>终止进程</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>窗口变化大小时发出</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO</td>
<td>此信号向进程指示发出了一个异步IO事件</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>关机</td>
<td>终止进程</td>
</tr>
<tr>
<td>31</td>
<td>SIGSYS</td>
<td>无效的系统调用</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>34~64</td>
<td>SIGRTMIN~</td>
<td>Linux的实时信号，它们没有固定的含义（可以自定义）</td>
<td>终止进程</td>
</tr>
</tbody></table>
<h3 id="3-信号四要素"><a href="#3-信号四要素" class="headerlink" title="3.信号四要素"></a>3.信号四要素</h3><p>每个信号必备4要素，分别是：</p>
<p>1）编号 2）名称 3）事件 4）默认处理动作</p>
<p>可通过 <strong>man 7 signal</strong> 查看帮助文档获取：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9B%9B%E8%A6%81%E7%B4%A0.png"></p>
<p>我这个是 arm 架构的，和教程上的不一样。</p>
<p>在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他框架，最后一个应用于mips架构。一个’-‘表示在对应架构上尚未定义该信号。</p>
<p>不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号。</p>
<p>Action为默认动作：</p>
<ul>
<li>Term：终止进程</li>
<li>lgn：忽略信号（默认即使对该种信号忽略操作）</li>
<li>Core：终止进程，生成Core文件。（查验死亡原因，用于gdb调试）</li>
<li>Stop：停止（暂停）进程</li>
<li>Cont：继续运行进程</li>
</ul>
<p>注意通过 man 7 signal 命令查看帮助文档，其中可看到：The signals <strong>SIGKILL</strong> and <strong>SIGSTOP</strong> cannot be caught，blocked，or ignored。</p>
<p>这里特别强调了 <strong>SIGKILL 和 SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></p>
<p>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送（但不一定递达），不应乱发信号！！！</p>
<h3 id="4-信号的状态"><a href="#4-信号的状态" class="headerlink" title="4.信号的状态"></a>4.信号的状态</h3><p><strong>1）产生</strong></p>
<p>a）当用户按某些终端键时，将产生信号。</p>
<p>​	终端上按“ctrl+c”组合键通常产生中断信号 SIGINT</p>
<p>​	终端上按“ctrl+\”键通常产生中断信号 SIGQUIT</p>
<p>​	终端上按“ctrl+z”键通常产生中断信号 SIGSTOP等。</p>
<p>b）硬件异常将产生信号。</p>
<p>除数为0，无效的内存访问等。这些情况通常由硬件检测到，并通知内核，然后内核产生适当的信号发送给相应的进程。</p>
<p>c）软件异常将产生信号。</p>
<p>当检测到某种软件条件已发生（如：定时器alarm），并将其通知有关进程时，产生信号。</p>
<p>d）调用系统函数（如：kill、raise、abort）将发送信号。</p>
<p>注意：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。</p>
<p>e）运行 kill &#x2F; killall命令将发送信号。</p>
<p>此程序实际上是使用 kill 函数来发送信号。也常用此命令终止一个失控的后台进程。 </p>
<p><strong>2）未决状态：没有被处理</strong></p>
<p><strong>3）递达状态：信号被处理了</strong></p>
<h3 id="5-阻塞信号集和未决信号集"><a href="#5-阻塞信号集和未决信号集" class="headerlink" title="5.阻塞信号集和未决信号集"></a>5.阻塞信号集和未决信号集</h3><p>信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。</p>
<p>Linux内核的进程控制块PCB是一个结构体，task_struct，除了包含进程id、状态、工作目录、用户id、组id、文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集。</strong></p>
<h4 id="5-1-阻塞信号集（信号屏蔽字）"><a href="#5-1-阻塞信号集（信号屏蔽字）" class="headerlink" title="5.1 阻塞信号集（信号屏蔽字）"></a>5.1 阻塞信号集（信号屏蔽字）</h4><p>将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，该信号的处理将推后（处理发送在解除屏蔽后）。</p>
<h4 id="5-2-未决信号集"><a href="#5-2-未决信号集" class="headerlink" title="5.2 未决信号集"></a>5.2 未决信号集</h4><p>信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位反转回为0.这一时刻往往非常短暂。</p>
<p>信号产生后由于某些原因（主要是阻塞）不能抵达。这类信号的集合称为未决信号集。在屏蔽解除前，信号一直处于未决状态。</p>
<h3 id="6-信号产生函数"><a href="#6-信号产生函数" class="headerlink" title="6.信号产生函数"></a>6.信号产生函数</h3><h4 id="6-1-kill函数"><a href="#6-1-kill函数" class="headerlink" title="6.1 kill函数"></a>6.1 kill函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#Include &lt;sys/types.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给指定进程发送指定信息（不一定杀死）</span><br><span class="line">    </span><br><span class="line">参数：</span><br><span class="line">    pid ： 取值有<span class="number">4</span>种情况：</span><br><span class="line">        pid &gt; <span class="number">0</span>:将信号传送给进程 ID 为pid的进程</span><br><span class="line">        pid = <span class="number">0</span>:将信号传送给当前进程所在进程组中的所有进程。</span><br><span class="line">        pid = <span class="number">-1</span>:将信号传送给系统内所有的进程。</span><br><span class="line">        pid &lt; <span class="number">-1</span>:将信号传送给指定进程组的所有进程。这个进程组号等于 pid 的绝对值。</span><br><span class="line">    sig：信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill -l 进行查看。不推荐直接使用数字，应该使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</span><br><span class="line">    返回值：</span><br><span class="line">            成功： <span class="number">0</span></span><br><span class="line">            失败： <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>super用户（root）可以发送信号给容易用户，普通用户是不能向系统用户发送信号的。</p>
<p>kill -9（root用户的pid）是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号。</p>
<p>普通用户基本规则是：发送者实际或有效用户ID &#x3D;&#x3D; 接收者实际或有效用户ID</p>
<p>程序示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    pd = fork();</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pd == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child is run\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child is not good\n&quot;</span>);</span><br><span class="line">        kill(pd, SIGTERM);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-raise函数"><a href="#6-2-raise函数" class="headerlink" title="6.2 raise函数"></a>6.2 raise函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给当前进程发送指定信号（自己给自己发），等价于 kill(getpid(), sig)</span><br><span class="line">参数：</span><br><span class="line">    sig：信号编号</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>值</span><br></pre></td></tr></table></figure>

<p>程序示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;run:%d\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">4</span>)&#123;</span><br><span class="line">            raise(SIGALRM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-abort函数"><a href="#6-3-abort函数" class="headerlink" title="6.3 abort函数"></a>6.3 abort函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：给自己发送异常终止信号 SIGABRT，并产生core文件，等价于 kill(getpid(), SIGABRT);</span><br><span class="line">参数：无</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<h4 id="6-4-alarm函数-闹钟"><a href="#6-4-alarm函数-闹钟" class="headerlink" title="6.4 alarm函数(闹钟)"></a>6.4 alarm函数(闹钟)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line">功能:</span><br><span class="line">    设置定时器(闹钟)。在指定的seconds后，内核会给当前进程发送 SIGALRM 信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。</span><br><span class="line">     取消定时器alarm(<span class="number">0</span>)，返回旧闹钟余下秒数。</span><br><span class="line">参数:</span><br><span class="line">    seconds: 指定的时间，以秒为单位</span><br><span class="line">返回值:</span><br><span class="line">    返回<span class="number">0</span>或剩余的秒数</span><br></pre></td></tr></table></figure>

<p>定时，与进程状态无关（自然定时法）！就绪、运行、挂起（阻塞、暂停）、终止、僵尸….无论进程处于何种状态，alarm都计时。</p>
<p>测试程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在运行程序\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    ret = alarm(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;之前的闹钟无效了，之前还剩 %d 秒\n&quot;</span>, ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按任意键退出...&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-5-setitimer函数（定时器）"><a href="#6-5-setitimer函数（定时器）" class="headerlink" title="6.5 setitimer函数（定时器）"></a>6.5 setitimer函数（定时器）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval* new_value, <span class="keyword">struct</span> itimerval* old_value)</span>;</span><br><span class="line">功能:</span><br><span class="line">    设置定时器(闹钟)。可代替alarm函数。精度微秒us，可以实现周期定时。</span><br><span class="line">参数:</span><br><span class="line">    which: 指定定时方法</span><br><span class="line">         a) 自然定时: ITIMER_REAL → SUGALR计算自然时间</span><br><span class="line">         b) 虚拟空间计时(用户空间): ITIMER_VIRTUAL → SIGPROF计算进程占用cpu的时间</span><br><span class="line">         c) 运行时计时(用户 + 内核): ITIMER_PROF → SIGPROF计算占用cpu及执行系统调用的时间</span><br><span class="line">    new_value: </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>&#123;</span></span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_interval</span>;</span> <span class="comment">//闹钟触发周期</span></span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_value</span>;</span>   <span class="comment">//闹钟触发时间</span></span><br><span class="line">         &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">            <span class="type">long</span> tv_sec;	<span class="comment">//秒</span></span><br><span class="line">            <span class="type">long</span> tv_user;	<span class="comment">//毫秒</span></span><br><span class="line">        &#125;;</span><br><span class="line">        itimerval.it_vale: 设定一次执行function所延迟的秒数</span><br><span class="line">        itimerval.it_interval: 设定以后每几秒执行function</span><br><span class="line">    old_value: 存放旧的timeout值，一般指定为<span class="literal">NULL</span></span><br><span class="line">返回值:</span><br><span class="line">    成功: <span class="number">0</span></span><br><span class="line">    失败: <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>程序示例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">iti</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//第一次触发时间</span></span><br><span class="line">    iti.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    iti.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//触发周期</span></span><br><span class="line">    iti.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    iti.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    ret = setitimer(ITIMER_REAL, &amp;iti, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setitmer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键退出...\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-信号集"><a href="#7-信号集" class="headerlink" title="7.信号集"></a>7.信号集</h3><h4 id="7-1-信号集概述"><a href="#7-1-信号集概述" class="headerlink" title="7.1 信号集概述"></a>7.1 信号集概述</h4><p>在PCB中有两个非常重要的信号集。一个称为“阻塞信号集”，另一个称为“未决信号集”。</p>
<p>这两个信号集都是内核使用<strong>位图机制</strong>来实现的。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数对PCB中的这两个信号集进行修改。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%A6%82%E8%BF%B0.png"></p>
<h4 id="7-2-自定义信号集函数"><a href="#7-2-自定义信号集函数" class="headerlink" title="7.2 自定义信号集函数"></a>7.2 自定义信号集函数</h4><p>为了方便对多个信号进行处理，一个用户进程常常需要对多个信号做出处理，在Linux系统中引入了信号集（信号的集合）。</p>
<p>这个信号集有点类似于我们的QQ群，一个个的信号相当于QQ群里的一个个好友。</p>
<p>信号集是一个能表示多个信号的数据类型，sigset_t set，set即一个信号集。既然是一个集合，就需要对集合进行添加&#x2F;删除等操作。</p>
<p>相关函数说明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;	<span class="comment">//将set集合置空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(sigset* <span class="built_in">set</span>)</span>;	<span class="comment">//将所有信号加入set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(sigset* <span class="built_in">set</span>, <span class="type">int</span> signo)</span>;	<span class="comment">//将signo信号加入到set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signo)</span>; <span class="comment">//从set集合中移除signo信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signo)</span>; <span class="comment">//判断信号是否存在</span></span><br></pre></td></tr></table></figure>

<p>除sigismember外，其余操作函数中的set均为传出参数。sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</p>
<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印信号集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_sigset</span><span class="params">(<span class="type">sigset_t</span>* s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sigismember(s, i))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">//清空信号集</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有信号加入set集中</span></span><br><span class="line">    sigfillset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将signo信号移除</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGHUP);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将signo信号重新加入到set集合中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGHUP);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-sigprocmask函数"><a href="#7-3-sigprocmask函数" class="headerlink" title="7.3 sigprocmask函数"></a>7.3 sigprocmask函数</h4><p>信号阻塞也称信号屏蔽集、信号掩码。每个进程都有应该阻塞集，创建进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。</p>
<p>所谓阻塞并不是禁止传送信号，而是暂缓信号的传送。若将阻塞的信号从信号阻塞集中删除，且对应的信号在阻塞时发生了，进程将会收到相应的信号。</p>
<p>我们可以通过 sigprocmask() 修改当前的信号掩码来改变信号的阻塞情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改信号阻塞集，根据 how 指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由 <span class="built_in">set</span> 指定，而原先的信号阻塞集合由 oldset 保存。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    how：信号阻塞集合的修改方法，有<span class="number">3</span>种情况：</span><br><span class="line">        SIG_BLOCK:向信号阻塞集合中添加 <span class="built_in">set</span> 信号集，新的信号掩码是<span class="built_in">set</span>和旧信号掩码的并集。相当于 mask = mask|<span class="built_in">set</span>。</span><br><span class="line">        SIG_UNBLOCK:从信号阻塞集合中删除 <span class="built_in">set</span> 信号集，从当前信号掩码中去除 <span class="built_in">set</span> 中的信号。相当于 mask = mask &amp; ~ <span class="built_in">set</span>。</span><br><span class="line">        SIG_SETMASK:将信号阻塞集合设为 <span class="built_in">set</span> 信号集，相当于原来信号阻塞集的内容清空，然后按照 <span class="built_in">set</span> 中的信号重新设置信号阻塞集，相当于 mask = <span class="built_in">set</span>。</span><br><span class="line">    <span class="built_in">set</span>：要操作的信号集地址。</span><br><span class="line">            若 <span class="built_in">set</span> 为 <span class="literal">NULL</span>，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到 oldset 中。</span><br><span class="line">    oldset：保存原来信号阻塞地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span>，失败时错误代码只可能是 EINVAL，表示参数 how不合法。</span><br></pre></td></tr></table></figure>

<h4 id="7-4-sigpending函数"><a href="#7-4-sigpending函数" class="headerlink" title="7.4 sigpending函数"></a>7.4 sigpending函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;</span><br><span class="line">功能：读取当前进程的未决信号集</span><br><span class="line">参数：</span><br><span class="line">    <span class="built_in">set</span>：未决信号集</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="8-信号捕捉"><a href="#8-信号捕捉" class="headerlink" title="8.信号捕捉"></a>8.信号捕捉</h3><h4 id="8-1-信号处理方式"><a href="#8-1-信号处理方式" class="headerlink" title="8.1 信号处理方式"></a>8.1 信号处理方式</h4><p>一个进程收到一个信号的时候，可以用如下方式进行处理：</p>
<p>1）执行系统默认动作</p>
<p>对于大多数信号来说，系统默认动作是用来终止该进程。</p>
<p>2）忽略此信号（丢弃）</p>
<p>接收到此信号后没有任何动作。</p>
<p>3）执行自定义信号处理函数（捕捉）</p>
<p>用用户定义的信号处理函数处理该信号。</p>
<p>【注意】：SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。</p>
<p>内核实现信号捕捉过程：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9B%BE%E7%89%87%5C%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89.png"></p>
<h4 id="8-2-signal函数"><a href="#8-2-signal函数" class="headerlink" title="8.2 signal函数"></a>8.2 signal函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line">功能：</span><br><span class="line">    注册信号处理函数（不可用于 SIGKILL、SIGSTOP 信号），即确定收到信号后处理函数的入口地址。此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    signum：信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill -l进行相应查看。</span><br><span class="line">    handler：取值有 <span class="number">3</span> 种情况：</span><br><span class="line">        SIG_IGN:忽略该信号</span><br><span class="line">        SIG_DFL:执行系统默认动作</span><br><span class="line">        信号处理函数名：自定义信号处理函数，如：func</span><br><span class="line">        回调函数的定义如下：</span><br><span class="line">            <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">                <span class="comment">//signo 为触发的信号，为signal() 第一个参数的值</span></span><br><span class="line">            &#125;</span><br><span class="line">返回值：</span><br><span class="line">    成功：第一次返回 <span class="literal">NULL</span>，下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面先声明此函数指针的类型。</span><br><span class="line">    失败：返回 SIG_ERR</span><br></pre></td></tr></table></figure>

<p>该函数由ANSI定义，因为Unix和Linux版本的原因不推荐使用这个函数，取而代之的是sigaction函数</p>
<h4 id="8-3-sigaction函数"><a href="#8-3-sigaction函数" class="headerlink" title="8.3 sigaction函数"></a>8.3 sigaction函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oldact)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改指定信号的设置（或同时执行这两种操作）。</span><br><span class="line">参数：</span><br><span class="line">    signum：要操作的信号。</span><br><span class="line">    act：要设置的对信号的新处理方式（传入参数）。</span><br><span class="line">    oldact：原来对信号的处理方式（传入参数）。</span><br><span class="line">    如果 act 指针非空，则要改变指定信号的处理方式（设置），如果 oldact 指针非空，则系统将此前指定信号的处理方式存入 oldact。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>struct sigaction结构体：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">    <span class="type">void</span>(*sa_handler)(<span class="type">int</span>); <span class="comment">//旧的信号处理函数指针</span></span><br><span class="line">    <span class="type">void</span>(*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span>*, <span class="type">void</span>* ); <span class="comment">//新的信号处理函数指针</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;	<span class="comment">//信号阻塞集</span></span><br><span class="line">    <span class="type">int</span> sa_flags;	<span class="comment">//信号处理的方式</span></span><br><span class="line">    <span class="type">void</span>(*sa_restorer)(<span class="type">void</span>); <span class="comment">//已弃用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1）sa_handler、sa_sigaction：信号处理函数指针，如signal()里的函数指针用法一样，应根据情况给 sa_sigaction、sa_handler 两者之一赋值，其取值如下：</p>
<p>a）SIG_IGN：忽略该信号</p>
<p>b）SIG_DFL:执行系统默认动作</p>
<p>c）处理函数名：自定义信号处理函数</p>
<p>2）sa_mask：信号阻塞集，在信号处理函数执行过程中，临时屏蔽指定的信号。</p>
<p>3）sa_flags：用于指定信号处理的行为，通常设置为0，表使用默认属性。它可以是一下值的”按位或“组合：</p>
<ul>
<li>SA_RESTART：使被信号打断的系统调用自动重新发起（已经废弃）</li>
<li>SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到SIGCHLD信号。</li>
<li>SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到SIGCHLD信号，这时子进程如果退出也不会成为僵尸进程。</li>
<li>SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。</li>
<li>SA_RESETHAND：信号处理之后重新设置为默认的处理方式。</li>
<li>SA_SIGINFO：使用sa_sigaction成员而不是sa_handler作为信号处理函数。</li>
</ul>
<p><strong>信号处理函数：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*sa_sigaction)(<span class="type">int</span> signum, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* context);</span><br><span class="line">参数说明：</span><br><span class="line">    signum：信号的编号。</span><br><span class="line">    info：记录信号发送进程信号的结构体。</span><br><span class="line">    context：可以赋给指向 <span class="type">ucontext_t</span> 类型的一个对象的指针，以引用在传递信号时被中断的接收进程或线程的上下文。</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signum, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* context)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号:%d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_sigaction = fun1;</span><br><span class="line">    <span class="comment">//标志指定使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按回车退出...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-不可重入、可重入"><a href="#9-不可重入、可重入" class="headerlink" title="9.不可重入、可重入"></a>9.不可重入、可重入</h3><p>如果一个函数不幸被设计成为这样：那么不同任务调用这个函数时可能修改其它任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数。</p>
<p>满足下列条件的函数是不可重入（不安全）的：</p>
<ul>
<li>函数体内使用了静态的数据结构</li>
<li>函数体内调用了malloc() 或者 free() 函数（谨慎使用堆）</li>
<li>函数体内调用了标准 I&#x2F;O 函数</li>
</ul>
<p>相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？所谓可重入函数是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。</p>
<p>保证函数的可重入性的方法：</p>
<ul>
<li>在写函数时尽量使用局部变量（例如寄存器、栈中的变量）</li>
<li>对于要使用的全局变量要加以保护（如采取关中断、信号量等互斥方法），这样构成的函数就一定是一个可重入的函数</li>
</ul>
<p><strong>注意：信号处理函数是可重入函数</strong></p>
<h3 id="10-SIGCHLE信号"><a href="#10-SIGCHLE信号" class="headerlink" title="10.SIGCHLE信号"></a>10.SIGCHLE信号</h3><h4 id="10-1-SIGCHLD信号产生的条件"><a href="#10-1-SIGCHLD信号产生的条件" class="headerlink" title="10.1 SIGCHLD信号产生的条件"></a>10.1 SIGCHLD信号产生的条件</h4><p>1）子进程终止时</p>
<p>2）子进程接收到SIGSTOP信号停止时</p>
<p>3）子进程处在停止态，接受到SIGCONT后唤醒时</p>
<h4 id="10-2-如何避免僵尸进程"><a href="#10-2-如何避免僵尸进程" class="headerlink" title="10.2 如何避免僵尸进程"></a>10.2 如何避免僵尸进程</h4><p>1）最简单的方式，父进程通过wait()和waitpid()等待子进程结束，但是，这会导致父进程挂起。</p>
<p>2）如果父进程要处理的事情很多，不能够挂起，通过 signal() 函数人为处理信号 SIGCHLD，只要子进程退出自动调用指定好的回调函数，因为子进程结束后，父进程会收到该信号 SIGCHLD，可以在其回调函数里调用wait() 或 waitpid() 回收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signum, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* context)</span>&#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程结束了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_sigaction = fun1;</span><br><span class="line">    <span class="comment">//标志指定使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    ret = sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3）如果父进程不关心子进程什么时候结束，那么可以用signal(SIGCHLD, SIG_IGN) 通知内核，自己对子进程的结束不感兴趣，父进程忽略此信号，那么子进程结束后，内核回收，并不再给父进程发送信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程结束了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="九、守护进程-线程"><a href="#九、守护进程-线程" class="headerlink" title="九、守护进程-线程"></a>九、守护进程-线程</h2><h3 id="1-终端的概念"><a href="#1-终端的概念" class="headerlink" title="1.终端的概念"></a>1.终端的概念</h3><p>在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端（Controlling Terminal），进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。</p>
<p>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是用户的键盘输入，进程往标准输出或标准错误输出也写到显示器上。</p>
<p>信号中还讲过，在控制终端输入有些特殊的控制按键可以给前台进程发信号，例如Ctrl+C表示SIGINT，Ctrl+\表示SIGQUIT。</p>
<p>函数说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">ttyname</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line">功能：由文件描述符查出对应的文件名</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">返回值：</span><br><span class="line">    成功：终端名</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h3 id="2-进程组概念"><a href="#2-进程组概念" class="headerlink" title="2.进程组概念"></a>2.进程组概念</h3><h4 id="2-1-进程组概述"><a href="#2-1-进程组概述" class="headerlink" title="2.1 进程组概述"></a>2.1 进程组概述</h4><p>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。<strong>代表一个或多个进程的集合。</strong></p>
<p>每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。</p>
<p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID为第一个进程ID（组长进程）。所以，组长进程标识：其进程组ID为其进程ID。</p>
<p>可以使用<strong>kill -SIGKILL -进程组ID</strong>（负的）来将整个进程组内的进程全部杀死：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BB%88%E7%AB%AF%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5.png"></p>
<p>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</p>
<p>进程组生存期：进程组创建的最后一个进程离开（终止或转移到另一个进程组）。</p>
<p>一个进程可以为自己或子进程设置进程组ID。</p>
<h4 id="2-2-相关函数说明"><a href="#2-2-相关函数说明" class="headerlink" title="2.2 相关函数说明"></a>2.2 相关函数说明</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能:获取当前进程组的进程ID;</span><br><span class="line">参数:无;</span><br><span class="line">返回值:总是返回调用者的进程组ID;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能:获取指定进程的进程组ID;</span><br><span class="line">参数:</span><br><span class="line">    pid:进程号，如果pid = <span class="number">0</span>，那么该函数作用和getpgrp一样</span><br><span class="line">返回值:</span><br><span class="line">    成功：进程组ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> setpgid(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid);</span><br><span class="line">功能：</span><br><span class="line">    改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。</span><br><span class="line">参数：</span><br><span class="line">    将参<span class="number">1</span>对应的进程，加入参<span class="number">2</span>对应的进程组中</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-会话"><a href="#3-会话" class="headerlink" title="3.会话"></a>3.会话</h3><h4 id="3-1-会话概述"><a href="#3-1-会话概述" class="headerlink" title="3.1 会话概述"></a>3.1 会话概述</h4><p>会话是一个或多个进程组的集合。</p>
<ul>
<li>一个会话可以有一个控制终端。这通常是终端设备或伪终端设备；</li>
<li>建立与控制终端连接的会话首进程被称为控制进程</li>
<li>一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，其它进程组为后台进程组</li>
<li>如果终端接口检测到断开连接，则将挂断信号发送至控制进程（会话首进程）。</li>
</ul>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BC%9A%E8%AF%9D.png"></p>
<h4 id="3-2-创建会话注意事项"><a href="#3-2-创建会话注意事项" class="headerlink" title="3.2 创建会话注意事项"></a>3.2 创建会话注意事项</h4><p>1）调用进程不能是进程组组长，该进程变成新会话首进程(session header)</p>
<p>2）该调用进程是组长进程，则出错返回</p>
<p>3）该进程成为一个新进程组的组长进程</p>
<p>4）需要root权限(ubuntu不需要)</p>
<p>5）新会话丢弃原有的控制终端，该会话没有控制终端</p>
<p>6）建立新会话时，先调用fork，父进程终止，子进程调用setsid</p>
<h4 id="3-3-API函数介绍"><a href="#3-3-API函数介绍" class="headerlink" title="3.3 API函数介绍"></a>3.3 API函数介绍</h4><p>getsid函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能: 获取进程所属的会话ID</span><br><span class="line">参数: </span><br><span class="line">    pid: 进程号，pid为<span class="number">0</span>表示查看当前进程session ID</span><br><span class="line">返回值：</span><br><span class="line">    返回值：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</p>
<p>setsid函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能:</span><br><span class="line">    创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。调用了setsid函数的进程，既是新的会长，也是新的组长。</span><br><span class="line">参数: 无</span><br><span class="line">返回值: </span><br><span class="line">    成功：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-守护进程"><a href="#4-守护进程" class="headerlink" title="4.守护进程"></a>4.守护进程</h3><h4 id="4-1-守护进程介绍"><a href="#4-1-守护进程介绍" class="headerlink" title="4.1 守护进程介绍"></a>4.1 守护进程介绍</h4><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立控制终端并且周期性地执行某种任务或等待处理某些发生的时间。一般采用以d结尾的名字。</p>
<p>守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离终端是为了避免进程被任何终端产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在Linux中，每一个系统用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个字段，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。</p>
<p>Linux的大多数服务器就是用守护进程实现的。比如，Internet服务器，web服务器，http等。</p>
<h4 id="4-2-守护进程模型"><a href="#4-2-守护进程模型" class="headerlink" title="4.2 守护进程模型"></a>4.2 守护进程模型</h4><p>1）创建子进程，父进程退出（必须）</p>
<ul>
<li>所有工作在子进程中进行形式上脱离了控制终端</li>
</ul>
<p>2）在子进程中创建新会话（必须）</p>
<ul>
<li>setsid()函数</li>
<li>使子进程完全独立出来，脱离控制</li>
</ul>
<p>3）改变当前目录为根目录（不是必须）</p>
<ul>
<li>chdir()函数</li>
<li>防止占用可卸载的文件系统</li>
<li>也可以换成其它路径</li>
</ul>
<p>4）重设文件权限掩码（不是必须）</p>
<ul>
<li>umask() 函数</li>
<li>防止继承的文件创建屏蔽字拒绝某些权限</li>
<li>增加守护进程灵活性</li>
</ul>
<p>5）关闭文件描述符（不是必须）</p>
<ul>
<li>继承的打开文件不会用到，浪费系统资源，无法卸载</li>
</ul>
<p>6）开始执行守护进程核心工作（必须）</p>
<ul>
<li>守护进程退出处理程序模型</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//1.创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在子进程中创建新会话</span></span><br><span class="line">    pid = setsid();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.改变当前工作目录</span></span><br><span class="line">    ret = chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.重设文件权限掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.关闭文件描述符</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.开始执行进程核心工作</span></span><br><span class="line">    <span class="comment">//要求每隔一秒种向txt文件插入时间</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        system(<span class="string">&quot;date &gt;&gt; /home/pi/time.txt&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-线程简介"><a href="#5-线程简介" class="headerlink" title="5.线程简介"></a>5.线程简介</h3><h4 id="5-1-线程概念"><a href="#5-1-线程概念" class="headerlink" title="5.1 线程概念"></a>5.1 线程概念</h4><p>在许多经典的操作系统教科书中，总是把进程定义为程序的执行实例，它并不执行什么，只是维护引用程序所需的各种资源，而线程则是真正的执行实体。</p>
<p>所以，线程是轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。</p>
<p>为了让进程完成一定的工作，进程必须至少包含一个线程。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0.png"></p>
<p>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统，操作系统会以进程为单位，分配系统资源，所以我们也说：<strong>进程是CPU分配资源的最小单位。</strong></p>
<p>线程存在与进程当中（进程可以认为是线程的容器），是操作系统调度执行的最小单位。说通俗点，线程就是干活的。</p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运动活动，进程是系统进程资源分配和调度的一个独立单位。</p>
<p>线程是进程的一个实体，是CPU调度和分配的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其它的线程共享进程所拥有的全部资源。</p>
<p>如果说进程是一个资源管家，负责从主人哪里要资源的话，那么线程就是干活的苦力。一个管家必须完成一项工作，就需要最少一个苦力，也就是说，一个进程最少包含一个线程，也可以包含多个线程。苦力要干活，就需要依托于管家，所以说一个线程，必须属于某个进程。</p>
<p>进程有自己的地址空间，线程使用进程的地址空间，也就是说，进程里的资源，线程都是有权访问的，比如说堆，栈，静态存储区。</p>
<blockquote>
<p>进程是操作系统分配资源的最小单位</p>
<p>线程是操作系统调度的最小单位</p>
</blockquote>
<h4 id="5-2-线程函数列表安装"><a href="#5-2-线程函数列表安装" class="headerlink" title="5.2 线程函数列表安装"></a>5.2 线程函数列表安装</h4><p>命令：</p>
<blockquote>
<p>sudo apt-get install manpages-posix-posix-dev</p>
</blockquote>
<p>【说明】manpages-posix-posix-dev 包含POSIX的header files 和calls的用法</p>
<p>查看：</p>
<blockquote>
<p>man -k pthread</p>
</blockquote>
<h4 id="5-3-NPTL"><a href="#5-3-NPTL" class="headerlink" title="5.3 NPTL"></a>5.3 NPTL</h4><p>当linux最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调用度的实体。这个调用创建了调用进程（calling process）的一个拷贝，这个拷贝与调用进程共享系统的地址空间。LinuxThreads 项目使用这个调用来完全在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程同步原语方面都存在问题。另外，这个线程模式也不符合POSIX的要求。</p>
<p>要改进LinuxThreads，非常明显我们需要内核的支持，并且需要重写线程库。有两个相互竞争的项目开始来满足这些要求。一个包括IBM的开发人员的团队开展了NGPT项目。同时，Red Hat 的一些开发人员开展了NPTL项目。NGPT在2003年中期被放弃了，把这个领域完全留给了NPTL。</p>
<p>NPTL或称为Native POSIX Thread Library，是Linux线程的一个新实现，它克服了LinuxThreads的缺陷，同时也符合POSIX的需求。与LinuxThreads相比，它在性能和稳定性方面都提供了重大的改进。</p>
<p>查看当前pthread库版本：getconf GNU_LIBPTHREAD_VERSION</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC.png"></p>
<h4 id="5-4-线程的特点"><a href="#5-4-线程的特点" class="headerlink" title="5.4 线程的特点"></a>5.4 线程的特点</h4><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进制机制实现出了线程的概念。</p>
<p>因此在这类系统中，进程和线程关系密切：</p>
<p>1）线程是轻量级进程（light-weight process），也有PCB，创建线程使用的底层函数和进程一样，都是clone。</p>
<p>2）从内核里看进程和线程是一样的，都有各自不同的PCB。</p>
<p>3）进程可以蜕变成线程</p>
<p>4）在Linux下，线程是最小的执行单位；进程是最小的分配资源单位</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9.png"></p>
<p>查看指定进程的LWP号：</p>
<blockquote>
<p>ps -Lf pid</p>
</blockquote>
<p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone。</p>
<ul>
<li>如果复制对方的地址空间，那么就产出一个“线程”。</li>
<li>如果共享对方的地址空间，就会产生一个“线程”</li>
</ul>
<p>Linux内核是不区分进程和线程的，只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p>
<h4 id="5-5-线程共享资源"><a href="#5-5-线程共享资源" class="headerlink" title="5.5 线程共享资源"></a>5.5 线程共享资源</h4><p>1）文件描述符表</p>
<p>2）每种信号的处理方式</p>
<p>3）当前工作目录</p>
<p>4）用户ID和组ID</p>
<p>内存地址空间（.test&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库）</p>
<h4 id="5-6-线程非共享资源"><a href="#5-6-线程非共享资源" class="headerlink" title="5.6 线程非共享资源"></a>5.6 线程非共享资源</h4><p>1）线程id</p>
<p>2）处理器现场和栈指针（内核栈）</p>
<p>3）独立的栈空间（用户空间栈）</p>
<p>4）errno变量</p>
<p>5）信号屏蔽字</p>
<p>6）调用优先级</p>
<h4 id="5-7-线程的优缺点"><a href="#5-7-线程的优缺点" class="headerlink" title="5.7 线程的优缺点"></a>5.7 线程的优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>提高程序并发性</li>
<li>开销小</li>
<li>数据通讯、共享数据方便</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>库函数，不稳定</li>
<li>调试、编写困难、gdb不支持</li>
<li>对信号支持不好</li>
</ul>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p>
<h3 id="6-线程常用操作"><a href="#6-线程常用操作" class="headerlink" title="6.线程常用操作"></a>6.线程常用操作</h3><h4 id="6-1-线程号"><a href="#6-1-线程号" class="headerlink" title="6.1 线程号"></a>6.1 线程号</h4><p>就像每个进程都有一个进程号一样，每个线程也有一个线程号。进程号在整个系统中是唯一的，但线程号不同，线程号只在它所属的进程环境中有效。</p>
<p>进程号用 pid_t 数据类型表示，是一个非负整数。线程号则用 pthread_t 数据类型来表示，Linux 使用无符号长整型表示。</p>
<p>有的系统在实现pthread_t 的时候，用一个结构体来表示，所以在可移植的操作系统实现不能把它做为整数处理。</p>
<p>pthread_self函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取线程号。</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    调用线程的线程ID。</span><br></pre></td></tr></table></figure>

<p>因为pthread_self这个函数是一个第三方库，所以在编译的时候需要链接一下外部的动态库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-pthread</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pt;</span><br><span class="line">    pt = pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, pt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pthread_equal函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line">功能:</span><br><span class="line">    判断线程号t1和t2是否相等。为了方便移植，尽量使用函数来比较</span><br><span class="line">参数:</span><br><span class="line">    t1，t2:待判断的线程号。</span><br><span class="line">返回值：</span><br><span class="line">     相等：非<span class="number">0</span></span><br><span class="line">     不相等：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pt;</span><br><span class="line">    pt = pthread_self();</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(pt, pthread_self()))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个线程号相等\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个线程号不相等\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-线程的创建"><a href="#6-2-线程的创建" class="headerlink" title="6.2 线程的创建"></a>6.2 线程的创建</h4><p>pthread_create函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthred_create</span><span class="params">(<span class="type">pthread_t</span>* thread, <span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* (*start_routine)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个线程</span><br><span class="line">参数：</span><br><span class="line">    thread：线程标识符地址。</span><br><span class="line">    attr：线程属性结构体地址，通常设置为<span class="literal">NULL</span>。</span><br><span class="line">    start_routine：线程函数的入口地址。</span><br><span class="line">    arg：传入线程函数的参数。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p> 在一个线程中调用pthread_create()创建新的线程后，当前进程从pthread_create()返回继续在下执行，而新的线程所执行的代码由我们传给pthread_create()的函数指针start_routine决定。</p>
<p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以先用strerror()把错误码转换成错误信息再打印。</p>
<p>实例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* agv)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新的线程执行任务 tid: %lu\n 传入的参数为:%d\n&quot;</span>, pthread_self(), (<span class="type">int</span>)(<span class="type">long</span>)agv); <span class="comment">//这里因为是void*类型，直接转换为int长度不够，先让它变成long，然后再转换为int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//打印错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread... tid:%lu\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按任意键结束\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-3-线程资源回收"><a href="#6-3-线程资源回收" class="headerlink" title="6.3 线程资源回收"></a>6.3 线程资源回收</h4><p>pthread_join函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span>** retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待线程结束（此函数会阻塞），并回收线程资源，类似于进程的 wait() 函数，如果线程已经结束，那么该函数会立刻返回。</span><br><span class="line">参数：</span><br><span class="line">    thread：被等待的线程号。</span><br><span class="line">    retval：用来储存线程退出状态的指针地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0x03</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* retp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, &amp;retp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;retp:%p\n&quot;</span>, retp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;man thread exit...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程不同的方式终止，通过pthread_join得到的终止状态是不同的，总结如下：</p>
<p>1）如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</p>
<p>2）如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED</p>
<p>3）如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</p>
<h4 id="6-4-线程连写"><a href="#6-4-线程连写" class="headerlink" title="6.4 线程连写"></a>6.4 线程连写</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现线程的连写</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1执行的函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);	<span class="comment">//刷新缓冲区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ((<span class="type">char</span>*)arg)[i]);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret1 = <span class="number">-1</span>, ret2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1 = <span class="number">-1</span>, tid2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arr1[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">//创建两个进程</span></span><br><span class="line">    ret1 = pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun, (<span class="type">void</span>*)arr1);</span><br><span class="line">    <span class="keyword">if</span> (ret1 != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程1创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret2 = pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun, (<span class="type">void</span>*)arr2);</span><br><span class="line">    <span class="keyword">if</span> (ret2 != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程2创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-5-线程分离"><a href="#6-5-线程分离" class="headerlink" title="6.5 线程分离"></a>6.5 线程分离</h4><p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获得它的状态为止。但是线程也可以被置为detach（分离）状态，这样的线程一旦终止就立刻回收它所有资源，而不保留终止状态。</p>
<p>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
<p>pthread_detach函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    使调用线程与当前进程分离，分离后不代表此线程不依赖于当前进程，线程分离的目的是将线程资源的回收工作交给系统自动来完成，也就是说当被分离的线程结束之后，系统会自动回收它的资源。所以，此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    thread：线程号</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="6-6-线程退出"><a href="#6-6-线程退出" class="headerlink" title="6.6 线程退出"></a>6.6 线程退出</h4><p>在进程中我们可以调用exit函数或_exit函数来结束进程，在一个线程中我们可以通过以下三种在不中断整个进程的情况下停止它的控制流。</p>
<ul>
<li>线程从执行函数中返回</li>
<li>线程调用pthread_exit退出线程</li>
<li>线程可以被同一进程中的其它线程取消。</li>
</ul>
<p>pthread_exit函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    退出调用线程。一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源不会释放。</span><br><span class="line">参数：</span><br><span class="line">    retval：存储线程退出状态的指针</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread:%d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分离进程失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按任意键继续...&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-7-线程取消"><a href="#6-7-线程取消" class="headerlink" title="6.7 线程取消"></a>6.7 线程取消</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">thread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    杀死(取消)线程</span><br><span class="line">参数：</span><br><span class="line">    thread：目标线程ID</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：出错编号</span><br></pre></td></tr></table></figure>

<p>注意：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某一个取消点（检查点）。</p>
<p>类似于玩游戏存档，必须到达指定的场所（存档点）才能存储进度</p>
<p>杀死线程也不是立刻就能完成，必须要到达取消点。</p>
<p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write…执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。</p>
<p>可粗略认为一个系统调用（进入内核）即为一个取消点</p>
<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_detach is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    ret = pthread_cancel(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_cancel is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子线程被取消\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-线程属性（了解）"><a href="#7-线程属性（了解）" class="headerlink" title="7.线程属性（了解）"></a>7.线程属性（了解）</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><p>Linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。</p>
<p>如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> etachstate;	<span class="comment">//线程分离状态</span></span><br><span class="line">    <span class="type">int</span> schedpolicy; <span class="comment">//线程调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">schedparam</span>;</span> <span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched; <span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="type">int</span> scope; <span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="type">size_t</span> guardsize; <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="type">int</span> stackadd_set; <span class="comment">//线程的栈设置</span></span><br><span class="line">    <span class="type">void</span>* stackaddr;  <span class="comment">//线程栈的位置</span></span><br><span class="line">    <span class="type">size_t</span> stacksize; <span class="comment">//线程栈的大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>

<p>主要结构体成员：</p>
<p>1）线程分离状态</p>
<p>2）线程栈大小（默认平均分配）</p>
<p>3）线程栈警戒缓冲区大小（位于栈末尾）</p>
<p>4）线程栈最低地址</p>
<p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。之后须用pthread_attr_destroy函数来释放资源。</p>
<p>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and paraneters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p>
<h4 id="7-2-线程属性初始化和销毁"><a href="#7-2-线程属性初始化和销毁" class="headerlink" title="7.2 线程属性初始化和销毁"></a>7.2 线程属性初始化和销毁</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span>* attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化线程属性函数，注意：应先初始化线程属性，再pthread_create创建线程</span><br><span class="line">参数：</span><br><span class="line">    attr：线程属性结构体</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span>* attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁线程属性所占用的资源函数</span><br><span class="line">参数：</span><br><span class="line">    attr：线程属性结构体</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br></pre></td></tr></table></figure>

<h4 id="7-3-线程分离状态"><a href="#7-3-线程分离状态" class="headerlink" title="7.3 线程分离状态"></a>7.3 线程分离状态</h4><p>线程的分离状态决定一个线程以什么样的方式来终止自己。</p>
<ul>
<li>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</li>
<li>分离状态：分离状态没有被其它的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</li>
</ul>
<p>相关函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line">功能：设置线程分离状态</span><br><span class="line">参数：</span><br><span class="line">    attr：已初始化的线程属性</span><br><span class="line">    detachstate：分离状态</span><br><span class="line">        PTHREAD_CREATE_DETACHED（分离状态）</span><br><span class="line">        PTHREAD_CREATE_JOINABLE（非分离状态）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">int</span>* detachstate)</span>;</span><br><span class="line">功能：获得线程分离状态</span><br><span class="line">参数：</span><br><span class="line">    attr：已初始化的线程属性</span><br><span class="line">    detachstate：分离状态</span><br><span class="line">        PTHREAD_CREATE_DETACHED（分离状态）</span><br><span class="line">        PTHREAD _CREATE_JOINABLE（非分离状态）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其它的线程使用，这样调用pthread_create的线程就得到了错误的线程号。</p>
<p>要避免这种情况可以采用一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会，留出足够的时间让函数pthread_create返回。</p>
<p>设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p>
<h4 id="7-4-线程栈地址"><a href="#7-4-线程栈地址" class="headerlink" title="7.4 线程栈地址"></a>7.4 线程栈地址</h4><p>POSIX.1定义了两个常量来检查系统是否支持栈属性：</p>
<ul>
<li>_POSIX_THREAD_ATTR_STACKADDR</li>
<li>_POSIX_THREAD_ATTR_STACKSIZE</li>
</ul>
<p>也可以给sysconf函数传递来进行检测：</p>
<ul>
<li>_SC_THREAD_ATTR_STACKADDR</li>
<li>_SC_THREAD_ATTR_STACKSIZE</li>
</ul>
<p>当进程栈地址空间不够时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过pthread_attr_setstack和pthread_attr_getstack两个函数分配设置和获取线程的栈地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* stackaddr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line">功能：设置线程的栈地址</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stackaddr：内存首地址</span><br><span class="line">    stacksize：返回线程的堆栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstack</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>** stackaddr, <span class="type">size_t</span>* stacksize)</span>;</span><br><span class="line">功能：获取线程的栈地址</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stackaddr：返回获取的栈地址</span><br><span class="line">    stacksize：返回获取的栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br></pre></td></tr></table></figure>

<h4 id="7-5-线程栈大小"><a href="#7-5-线程栈大小" class="headerlink" title="7.5 线程栈大小"></a>7.5 线程栈大小</h4><p>当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用，但线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line">功能：设置线程的大小</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stacksize：线程的堆栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">size_t</span>* stacksize)</span>;</span><br><span class="line">功能：获取线程的栈大小</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stacksize：返回线程的堆栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br></pre></td></tr></table></figure>

<h4 id="7-6-线程使用注意事项"><a href="#7-6-线程使用注意事项" class="headerlink" title="7.6 线程使用注意事项"></a>7.6 线程使用注意事项</h4><p>1）主线程退出其它线程不退出，主线程应该调用pthread_exit</p>
<p>2）避免僵尸线程</p>
<p>​	a）pthread_join</p>
<p>​	b）pthread_detach</p>
<p>​	c）pthread_create指定分离属性</p>
<p>​	被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值；</p>
<p>3）malloc和mmap申请的内存可以被其它线程释放</p>
<p>4）应避免在多线程模型中调用fork，除非马上exec，子进程中只有调用fork的线程存在，其它线程在子进程中均pthread_exit</p>
<p>5）信号的复杂语义很难和多线程共享，应避免在多线程中引用信号机制。</p>
<h2 id="十、线程同步"><a href="#十、线程同步" class="headerlink" title="十、线程同步"></a>十、线程同步</h2><h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1.互斥锁"></a>1.互斥锁</h3><h4 id="1-1-同步与互斥概述"><a href="#1-1-同步与互斥概述" class="headerlink" title="1.1 同步与互斥概述"></a>1.1 同步与互斥概述</h4><p>现代操作系统基本上都是多任务操作系统，即同时有大量可调度实体在运行。在多任务操作系统中，同时运行的多个任务可能：</p>
<ul>
<li>都需要访问&#x2F;使用同一种资源</li>
<li>多任务之间有依赖关系，某个任务的运行依赖于另一个任务</li>
</ul>
<p>这两种情形是多任务编程中遇到的最基本问题，也是多任务编程中的核心问题，同步和互斥就是用于解决这两个问题的。</p>
<p>**互斥：**是指散步在不同任务之间的若干程序片段，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之间的任意程序片段，只能等到该任务完成这个程序片段后才可以运行。最基本的场景就是：一个公共资源同一时间只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</p>
<p>**同步：**是指散步在不同任务之间的若干程序片段，它们的运行必须严格按照规定的某种先后顺序来运行，这种先后顺序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后顺序运行。比如A任务的运行依赖于B任务产生的数据。</p>
<p>虽然，同步是一种更为复杂的互斥锁，互斥是两个任务之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但它是必须要按照某种次序来运行相应的线程（也是一种互斥），因此互斥具有唯一性和排它性，但互斥并不限制任务的运行顺序，即任务是无序的，而同步任务之间则有顺序关系</p>
<h4 id="1-2-为什么需要互斥锁"><a href="#1-2-为什么需要互斥锁" class="headerlink" title="1.2 为什么需要互斥锁"></a>1.2 为什么需要互斥锁</h4><p>在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。这个过程有点类似于公司部门里，使用打印机打印东西的同时（还没打印完），别人刚好也在此时此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。</p>
<p>下面用程序来模拟一下这个过程，线程一需要打印“hello”，线程二需要答应“word：，不加任何处理的话，打印出来的内容会混乱</p>
<p>测试程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *((<span class="type">char</span>*)argv + i));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arr1[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr1);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr2);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，打印机是有做处理的，我在打印着的时候别人是不允许打印的，只有等待我打印结束后别人才允许打印。这个过程有点类似于，把打印机放在一个房间里，给这个房间安把锁，这个锁默认是打开的。当A需要打印时，它先过来检查这把锁有没有锁着，没有的话就进去，同时上锁在房间里打印，而这时B也需要打印，B同时先检查锁，发现锁是锁住的，它就在门口等，当A打印结束后，他会开锁出来，这时B才进去上锁打印。</p>
<h4 id="1-3-互斥锁Mutex介绍"><a href="#1-3-互斥锁Mutex介绍" class="headerlink" title="1.3 互斥锁Mutex介绍"></a>1.3 互斥锁Mutex介绍</h4><p>在线程里也有这么一把锁：互斥锁（mutex），也叫互斥量，互斥锁是一种简单的加锁方式来控制对共享资源的访问，互斥锁只有两种状态，即<strong>加锁</strong>（lock）和<strong>解锁</strong>（unlock）。</p>
<p>互斥锁的操作流程如下：</p>
<p>1）在访问共享资源后临界区域前，对互斥锁进行加锁。</p>
<p>2）在访问完成后释放互斥锁导上的锁</p>
<p>3）对互斥锁进行加锁后，任何其它企图再次对互斥锁加锁的线程将会阻塞，直到锁被释放。</p>
<p>互斥锁的数据类型是pthread_mutex_t</p>
<p>安装对应帮助手册：</p>
<blockquote>
<p>sudo apt-get install manpages-posix-dev</p>
</blockquote>
<h4 id="1-4-pthread-mutex-init函数"><a href="#1-4-pthread-mutex-init函数" class="headerlink" title="1.4 pthread_mutex_init函数"></a>1.4 pthread_mutex_init函数</h4><p>初始化互斥锁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个互斥锁</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址，类型是 <span class="type">pthread_mutex_t</span></span><br><span class="line">    attr：设置互斥量的属性，通常可采用默认属性，即可将attr设为<span class="literal">NULL</span>。</span><br><span class="line">    可以使用宏PTHREAD_MUTEX_INITIALIZER静态初始化互斥锁，比如：<span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">这种方法等价于使用 <span class="literal">NULL</span> 指定的 attr 参数调用 pthread_mutex_init() 来完成动态初始化，不同之处在</span><br></pre></td></tr></table></figure>

<blockquote>
<p>restrict，C语言中的一种限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外的所有其它直接或间接的方式修改该对象的内容</p>
</blockquote>
<h4 id="1-5-pthread-mutex-destroy函数"><a href="#1-5-pthread-mutex-destroy函数" class="headerlink" title="1.5 pthread_mutex_destroy函数"></a>1.5 pthread_mutex_destroy函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁指定的一个互斥锁，互斥锁在使用完毕后，必须要对互斥锁进行销毁，以释放资源</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="1-6-pthread-mutex-lock函数"><a href="#1-6-pthread-mutex-lock函数" class="headerlink" title="1.6 pthread_mutex_lock函数"></a>1.6 pthread_mutex_lock函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对互斥锁上锁，若互斥锁已经上锁，则调用者阻塞，直到互斥锁解锁后再上锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">调用该函数时，若互斥锁未加锁，则上锁，返回<span class="number">0</span>；</span><br><span class="line">若互斥锁已加锁，则函数直接返回失败，即EBUSY</span><br></pre></td></tr></table></figure>

<h4 id="1-7-pthread-mutex-unlock函数"><a href="#1-7-pthread-mutex-unlock函数" class="headerlink" title="1.7 pthread_mutex_unlock函数"></a>1.7 pthread_mutex_unlock函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对指定的互斥锁解锁</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="1-8-测试程序"><a href="#1-8-测试程序" class="headerlink" title="1.8 测试程序"></a>1.8 测试程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">-1</span>;</span><br><span class="line">    ret = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *((<span class="type">char</span>*)argv + i));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arr1[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr1);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr2);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-9-死锁（DeadLock）"><a href="#1-9-死锁（DeadLock）" class="headerlink" title="1.9 死锁（DeadLock）"></a>1.9 死锁（DeadLock）</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%AD%BB%E9%94%81.png"></p>
<p><strong>1）什么是死锁</strong></p>
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通讯造成的一种阻塞的现象。若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁。</p>
<p><strong>2）死锁引起的原因</strong></p>
<ul>
<li>竞争不可抢占资源引起死锁</li>
</ul>
<p>​	也就是我们说的第一种情况，而这都在等待对方占有的不可抢占的资源</p>
<ul>
<li>竞争可消耗资源引起死锁</li>
</ul>
<p>​	有p1，p2，p3三个进程，p1向p2发送消息并接收p3发送的消息，p2向p3发送消息并接收p1的消息，p3向p1发送消息并接收p2的消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，这就造成了死锁。</p>
<ul>
<li>进程推进顺序不当引起死锁</li>
</ul>
<p>​	有进程p1，p2，都需要资源A，B，本来可以p1运行A—&gt;p1运行B—&gt;p2运行A—&gt;p2运行B，但是顺序换了，p1运行A时p2运行B，容易发生第一种死锁。互相抢占资源。</p>
<p><strong>3）死锁的必要条件</strong></p>
<ul>
<li>互斥条件</li>
</ul>
<p>某资源只能被一个进程使用，其它进程请求该资源时，只能等待，直到资源使用完毕后释放资源</p>
<ul>
<li>请求和保持条件</li>
</ul>
<p>程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其它进程占用，自己占用资源却保持不放。</p>
<ul>
<li>不可抢占条件</li>
</ul>
<p>进程已获得的资源没有使用完，不能被抢占</p>
<ul>
<li>循环等待条件</li>
</ul>
<p>必然存在一个循环链</p>
<p><strong>4）处理死锁的思路</strong></p>
<p>预防死锁</p>
<p>​	破坏死锁的四个必要条件中的一个或多个来预防死锁</p>
<p>避免死锁</p>
<p>​	和预防死锁的区别就是，在资源动态分配过程中，用某种方式防止系统进入不安全的状态</p>
<p>检查死锁</p>
<p>​	运行时出现死锁，能及时发现死锁，把程序解脱出来</p>
<p>解除死锁</p>
<p>​	发生死锁后，解脱进程，通常撤销进程，回收资源，再分配给正处于阻塞状态的进程</p>
<p><strong>5）预防死锁的方法</strong></p>
<p><strong>破坏请求和保持条件</strong></p>
<p>协议1：</p>
<p>所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求了，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在闲置的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生</p>
<p>协议2：</p>
<p>允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来，然后再请求新的资源</p>
<p><strong>破坏不可抢占条件</strong></p>
<p>当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请</p>
<p><strong>破坏循环等待条件</strong></p>
<p>对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放系统和更高序列号的资源后才能申请低序号的资源。多个同类资源必须一起请求</p>
<p>死锁程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义互斥变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex1;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程1请求1号资源成功...\n&quot;</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程1请求2号资源成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程2请求2号资源成功...\n&quot;</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程2请求1号资源成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1 = <span class="number">-1</span>, tid2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//初始化锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, fun1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, fun2, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭进程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//摧毁资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex1);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-读写锁"><a href="#2-读写锁" class="headerlink" title="2.读写锁"></a>2.读写锁</h3><h4 id="2-1-读写锁概述"><a href="#2-1-读写锁概述" class="headerlink" title="2.1 读写锁概述"></a>2.1 读写锁概述</h4><p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取整个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。</p>
<p>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了<strong>读写锁</strong>来实现。</p>
<p>读写锁的特点如下：</p>
<p>1）如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。<br>2）如果有其它线程写数据，则其它线程都不允许读、写操作</p>
<p>读写锁分为读锁和写锁，规则如下：</p>
<p>1）如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁</p>
<p>2）如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁。</p>
<p>POSIX定义的读写锁的数据类型是pthread_rwlock_t</p>
<h4 id="2-2-pthread-rwlock-init函数"><a href="#2-2-pthread-rwlock-init函数" class="headerlink" title="2.2 pthread_rwlock_init函数"></a>2.2 pthread_rwlock_init函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span>* <span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用来初始化rwlock所指向的读写锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock：指向要初始化的读写指针</span><br><span class="line">    attr：读写锁的属性指针。如果attr为<span class="literal">NULL</span>则会使用默认的属性初始化读写锁，否则使用指定的attr初始化读写锁</span><br><span class="line">    可以使用宏PTHREAD_RWLOCK_INITIALIZER静态初始化读写锁，比如：</span><br><span class="line">    <span class="type">pthread_rwlock_t</span> my_rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line">    这种方法等价于使用<span class="literal">NULL</span>指定的attr参数调用pthread_rwlock_init()来完成动态初始化，不同之处在于PTHREAD_RWLOCK_INITIALIZER宏不进行错误检查</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，读写锁的状态将成为已初始化和已解锁</span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="2-3-pthread-rwlock-destroy函数"><a href="#2-3-pthread-rwlock-destroy函数" class="headerlink" title="2.3 pthread_rwlock_destroy函数"></a>2.3 pthread_rwlock_destroy函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用于摧毁一个读写锁，并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init()自动申请的资源）。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="2-4-pthread-rwlock-rdlock函数"><a href="#2-4-pthread-rwlock-rdlock函数" class="headerlink" title="2.4 pthread_rwlock_rdlock函数"></a>2.4 pthread_rwlock_rdlock函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    以阻塞方式在读写锁上获取读锁（读锁定）</span><br><span class="line">    如果没有写者持有该锁，并且写者阻塞在该锁上，则调用线程会获取读锁</span><br><span class="line">    如果调用线程未获取读锁，则它将阻塞直到它获取了该锁。一个线程可以在一个读写锁上多次执行读锁定。</span><br><span class="line">    线程可以成功调用 pthread_rwlock_rdlock()函数n次，但是之后该线程必须调用 pthread_rwlock_unlock() 函数n次才能解除锁定</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">用于尝试以非阻塞的方式来在读写锁上获取读锁</span><br><span class="line">如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则立即失败返回。</span><br></pre></td></tr></table></figure>

<h4 id="2-5-pthread-rwlock-wrlock函数"><a href="#2-5-pthread-rwlock-wrlock函数" class="headerlink" title="2.5 pthread_rwlock_wrlock函数"></a>2.5 pthread_rwlock_wrlock函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    在读写锁上获取写锁（写锁定）</span><br><span class="line">    如果没有写者持有该锁，并且没有写者读者持有该锁，则调用线程会获取写锁</span><br><span class="line">    如果调用线程未获取写锁，则它将阻塞直到它获取了该锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">用于尝试以非阻塞的方式来在读写锁上获取写锁</span><br><span class="line">如果有任何的读者或者写者持有该锁，则立即失败返回</span><br></pre></td></tr></table></figure>

<h4 id="2-6-pthread-rwlock-unlock函数"><a href="#2-6-pthread-rwlock-unlock函数" class="headerlink" title="2.6 pthread_rwlock_unlock函数"></a>2.6 pthread_rwlock_unlock函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    无论是读锁或者写锁，都可以通过此函数解锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="2-7-测试程序"><a href="#2-7-测试程序" class="headerlink" title="2.7 测试程序"></a>2.7 测试程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读写锁对象</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读锁的函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">read_fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//添加读锁</span></span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程%d正在读num:%d\n&quot;</span>, (<span class="type">int</span>)(<span class="type">long</span>)argv, num);</span><br><span class="line">        <span class="comment">//随机休眠1-3秒</span></span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写锁的函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">write_fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程%d正在读num:%d\n&quot;</span>, (<span class="type">int</span>)(<span class="type">long</span>)argv, num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">//随机休眠1-3秒</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">6</span>];</span><br><span class="line">    <span class="comment">//随机数种子</span></span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化读写锁</span></span><br><span class="line">    ret = pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_rwlock_init is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建6个进程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//读数据</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;read_fun, (<span class="type">void</span>*)(<span class="type">long</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;write_fun, (<span class="type">void</span>*)(<span class="type">long</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3.条件变量"></a>3.条件变量</h3><h4 id="3-1-条件变量概述"><a href="#3-1-条件变量概述" class="headerlink" title="3.1 条件变量概述"></a>3.1 条件变量概述</h4><p>在互斥锁不同，条件变量是用来等待而不是用来上锁的，<strong>条件变量本身不是锁！</strong></p>
<p>条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</p>
<p>条件变量的两个动作：</p>
<ul>
<li>条件不满，阻塞线程</li>
<li>当条件满足，通知阻塞的线程开始工作</li>
</ul>
<p>条件变量的类型：pthread_cond_t。</p>
<h4 id="3-2-pthread-cond-init函数"><a href="#3-2-pthread-cond-init函数" class="headerlink" title="3.2 pthread_cond_init函数"></a>3.2 pthread_cond_init函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#Include &lt;pthread.h&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针。</span><br><span class="line">    attr：条件变量属性，通常为默认值，传<span class="literal">NULL</span>即可</span><br><span class="line">        也可以使用静态初始化的方法，初始化条件变量：</span><br><span class="line">        <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h4 id="3-3-pthread-cond-destroy函数"><a href="#3-3-pthread-cond-destroy函数" class="headerlink" title="3.3 pthread_cond_destroy函数"></a>3.3 pthread_cond_destroy函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    摧毁一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h4 id="3-4-pthread-cond-wait函数"><a href="#3-4-pthread-cond-wait函数" class="headerlink" title="3.4 pthread_cond_wait函数"></a>3.4 pthread_cond_wait函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    阻塞等待一个条件变量</span><br><span class="line">    a）阻塞等待条件变量cond（参<span class="number">1</span>）满足</span><br><span class="line">    b）释放已掌握的互斥锁（解锁互斥量）相当于 pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        a）b）两步为一个原子操作</span><br><span class="line">    c）当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁 pthread_mutex_lock(&amp;mutex);</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec* <span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line">功能：</span><br><span class="line">    限时等待一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">    abstime：绝对时间</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<p>abstime补充说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>&#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;<span class="comment">//秒</span></span><br><span class="line">    <span class="type">long</span> tv_nsec;<span class="comment">//纳秒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);<span class="comment">//获取当前的时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span><span class="comment">//定义timespec结构体变量t</span></span><br><span class="line">t.tv_sec = cur + <span class="number">1</span>;<span class="comment">//定义1秒</span></span><br><span class="line">pthread_cond_timedwait(&amp;cond, &amp;t);</span><br></pre></td></tr></table></figure>

<h4 id="3-5-pthread-cond-signal函数"><a href="#3-5-pthread-cond-signal函数" class="headerlink" title="3.5 pthread_cond_signal函数"></a>3.5 pthread_cond_signal函数</h4><p>唤醒至阻塞在条件变量上的线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒全部阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h4 id="3-6-生产者消费者条件变量模型"><a href="#3-6-生产者消费者条件变量模型" class="headerlink" title="3.6 生产者消费者条件变量模型"></a>3.6 生产者消费者条件变量模型</h4><p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法</p>
<p>假设有两个线程，一个模拟生产者的行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">//互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//创建一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pnew</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        <span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc is error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点初始化</span></span><br><span class="line">        pnew-&gt;data = random() % <span class="number">100</span>;</span><br><span class="line">        pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者正在生产%d\n&quot;</span>, pnew-&gt;data);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        <span class="comment">//随机休眠</span></span><br><span class="line">        sleep(random()%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pTemp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pTemp = head;</span><br><span class="line">            head = pTemp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在消费:%d\n&quot;</span>, pTemp-&gt;data);</span><br><span class="line">            <span class="built_in">free</span>(pTemp);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化互斥量</span></span><br><span class="line">    ret = pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_init is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//条件变量初始化</span></span><br><span class="line">    ret = pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_cond_init is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="comment">//摧毁互斥量</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-条件变量的优缺点"><a href="#3-7-条件变量的优缺点" class="headerlink" title="3.7 条件变量的优缺点"></a>3.7 条件变量的优缺点</h4><p>相较于mutex而言，条件变量可以减少竞争。</p>
<p>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。</p>
<p>有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p>
<h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4.信号量"></a>4.信号量</h3><h4 id="4-1-信号量概述"><a href="#4-1-信号量概述" class="headerlink" title="4.1 信号量概述"></a>4.1 信号量概述</h4><p>信号量广泛用于进程或进程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问</p>
<p>编程时可以根据操作信号量的结果判断是否对公共资源具有访问权限，当信号量值大于0时，则可以访问，负责将阻塞</p>
<p>PV原语是对信号量的操作，一次P操作使信号量减1，一次V操作使信号量加1</p>
<p>信号量主要用于进程或线程间的同步和异步两种典型情况</p>
<p>信号量数据类型为：sem_t</p>
<p>信号量用于互斥</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BA%92%E6%96%A5.png"></p>
<p>信号量用于同步：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5.png"></p>
<h4 id="4-2-sem-init函数"><a href="#4-2-sem-init函数" class="headerlink" title="4.2 sem_init函数"></a>4.2 sem_init函数</h4><p>初始化信号量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个信号量并初始化它的值。一个无名信号量在被使用前必须先初始化</span><br><span class="line">参数：</span><br><span class="line">    sem: 信号量的地址</span><br><span class="line">    pshared: 等于<span class="number">0</span>，信号量在线程间同步（常用）；不等于<span class="number">0</span>，信号量在线程间共享。</span><br><span class="line">    value: 信号量的初始值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-sem-destroy函数"><a href="#4-3-sem-destroy函数" class="headerlink" title="4.3 sem_destroy函数"></a>4.3 sem_destroy函数</h4><p>销毁信号量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">功能；</span><br><span class="line">    删除sem标识的信号量</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-4-信号量P操作（减1）"><a href="#4-4-信号量P操作（减1）" class="headerlink" title="4.4 信号量P操作（减1）"></a>4.4 信号量P操作（减1）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值减<span class="number">1</span>，操作前，先检查信号量（sem）的值是否为<span class="number">0</span>，若信号量为<span class="number">0</span>，此函数会阻塞，直到信号量大于<span class="number">0</span>时才进行减<span class="number">1</span>操作</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">以非阻塞的方式来对信号量进行减<span class="number">1</span>操作</span><br><span class="line">若操作前，信号量的值等于<span class="number">0</span>，则对信号量的操作失败，函数立即返回</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">const</span> <span class="keyword">struct</span> timespec* abs_timeout)</span>;</span><br><span class="line">限时尝试将信号量的值减<span class="number">1</span></span><br><span class="line">abs_timeout：绝对时间</span><br></pre></td></tr></table></figure>

<p>abs_timeout补充说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>&#123;</span></span><br><span class="line">  <span class="type">time_t</span> tv_sec;	<span class="comment">//秒</span></span><br><span class="line">  <span class="type">long</span> tv_nsec;		<span class="comment">//纳秒  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);	<span class="comment">//获取当前的时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span>	<span class="comment">//定义timespec结构体变量t</span></span><br><span class="line">t.tv_sec = cur + <span class="number">1</span>;	<span class="comment">//定时1秒</span></span><br><span class="line">sem_timedwait(&amp;cond, &amp;t);</span><br></pre></td></tr></table></figure>

<h4 id="4-5-信号量V操作（加1）"><a href="#4-5-信号量V操作（加1）" class="headerlink" title="4.5 信号量V操作（加1）"></a>4.5 信号量V操作（加1）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值加<span class="number">1</span>并发出信号唤醒等待线程（ sem_wait()）。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-6-获取信号量的值"><a href="#4-6-获取信号量的值" class="headerlink" title="4.6 获取信号量的值"></a>4.6 获取信号量的值</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span>* sval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取sem标识的信号量的值，保存在sval中</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量地址</span><br><span class="line">    sval：保存信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-7-示例程序"><a href="#4-7-示例程序" class="headerlink" title="4.7 示例程序"></a>4.7 示例程序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//占用后P操作</span></span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放后执行V操作</span></span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    sem_init(&amp;sem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//释放线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-消费者模式更改"><a href="#4-8-消费者模式更改" class="headerlink" title="4.8 消费者模式更改"></a>4.8 消费者模式更改</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//创建一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pnew</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        <span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc is error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点初始化</span></span><br><span class="line">        pnew-&gt;data = random() % <span class="number">100</span>;</span><br><span class="line">        pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者正在生产%d\n&quot;</span>, pnew-&gt;data);</span><br><span class="line">        sem_post(&amp;sem_consumer);</span><br><span class="line">        sem_wait(&amp;sem_bearer);</span><br><span class="line">        <span class="comment">//随机休眠</span></span><br><span class="line">        sleep(random()%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pTemp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pTemp = head;</span><br><span class="line">            head = pTemp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在消费:%d\n&quot;</span>, pTemp-&gt;data);</span><br><span class="line">            <span class="built_in">free</span>(pTemp);</span><br><span class="line">            sem_post(&amp;sem_bearer);</span><br><span class="line">            sem_wait(&amp;sem_consumer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    sem_init(&amp;sem_bearer, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    sem_init(&amp;sem_consumer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem_bearer);</span><br><span class="line">    sem_destroy(&amp;sem_consumer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-9-多信号量生产者模式"><a href="#4-9-多信号量生产者模式" class="headerlink" title="4.9 多信号量生产者模式"></a>4.9 多信号量生产者模式</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//创建一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pnew</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        <span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc is error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点初始化</span></span><br><span class="line">        pnew-&gt;data = random() % <span class="number">100</span>;</span><br><span class="line">        pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者正在生产%d\n&quot;</span>, pnew-&gt;data);</span><br><span class="line">        sem_post(&amp;sem_consumer);</span><br><span class="line">        sem_wait(&amp;sem_bearer);</span><br><span class="line">        <span class="comment">//随机休眠</span></span><br><span class="line">        sleep(random()%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pTemp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pTemp = head;</span><br><span class="line">            head = pTemp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在消费:%d\n&quot;</span>, pTemp-&gt;data);</span><br><span class="line">            <span class="built_in">free</span>(pTemp);</span><br><span class="line">            sem_post(&amp;sem_bearer);</span><br><span class="line">            sem_wait(&amp;sem_consumer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">6</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>, i;</span><br><span class="line">    <span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    sem_init(&amp;sem_bearer, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    sem_init(&amp;sem_consumer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem_bearer);</span><br><span class="line">    sem_destroy(&amp;sem_consumer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派开发系列-输入模式和上拉下拉</title>
    <url>/2025/01/17/10bcd339aa70/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面说了一下输出模式，这一章说一下输入模式，学完输入模式后我们就可以用一个软件模拟IIC让OLED0.96寸的显示屏显示内容了。</p>
<h1 id="一、设置输入模式"><a href="#一、设置输入模式" class="headerlink" title="一、设置输入模式"></a>一、设置输入模式</h1><p>前面说过设置<code>gpio</code>的模式的函数是<code>pinMode</code>，这个也可以设置<code>gpio</code>为输入模式。</p>
<p>这里还是使用<code>PC10</code>这个引脚（就是插线比较方便），然后还是和之前的一样的配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以将<code>PC10</code>设置为输入模式了，然后我们就来读一下这个端口的电平。</p>
<h1 id="二、读取端口电平"><a href="#二、读取端口电平" class="headerlink" title="二、读取端口电平"></a>二、读取端口电平</h1><p>这里使用的函数是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">digitalRead</span><span class="params">(<span class="type">int</span> pin)</span></span><br></pre></td></tr></table></figure>

<p>这个函数可以读取指定引脚的电平，通过返回值进行返回。</p>
<p>这里的返回值就是0和1，然后将代码写一下，这里需要一直等待输入，所以这里需要使用一个死循环讲读取放入，这样就可以使其一直在接收状态，而不直接结束，这里如果读取到按键按下后就输出一句话。</p>
<p>在写之前需要分析一下电路，要不然不知道到底读取低电平还是高电平，这里我简单搭建了一个按键电路，按键的另一端接到了地，另一端接到<code>PC10</code>，所以当按键按下后<code>PC10</code>的电平就为低电平了。</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203205928009-1532501103.jpg" alt="img"></p>
<p>知道了接线图就可以开始写代码了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 死循环进行读取内容</span></span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;按键按下了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编译执行一下代码</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231203210158852-1036398294.png" alt="img"></p>
<p>会发现没有按下就会输出这句话，为什么会这样呢？</p>
<p>其实这个本质上和stm32的输入一样。</p>
<h1 id="三、配置上拉下拉电平"><a href="#三、配置上拉下拉电平" class="headerlink" title="三、配置上拉下拉电平"></a>三、配置上拉下拉电平</h1><p>在stm32中，在设置引脚输入的时候会选择一个输入模式，有一个上拉输入还有一个下拉输入然后还有一个无上拉下拉模式，这几个模式在香橙派中也是有的。</p>
<p>我们使用<code>pinMode</code>设置为输入模式的时候会默认讲这个引脚变成无上拉下拉的输入，也就是一个中间态，这个状态非常的不稳定，一点风吹草动都会时输入的状态发生改变，就像上面的那种情况一样，你没有按下按键，但是它波动了就会导致电平变成了低电平。</p>
<p>为了解决这个问题，我们需要设置一下这个引脚为上拉输入还是下拉输入。</p>
<h2 id="1-上拉输入"><a href="#1-上拉输入" class="headerlink" title="1.上拉输入"></a>1.上拉输入</h2><p>上拉输入其实是在内部有一个上拉电阻，也就是有一个接电源的电阻和引脚相连，使得这个引脚一开始就是高电平，我们可以将引脚设置为上拉输入后获取低电平的变化。</p>
<h2 id="2-下拉输入"><a href="#2-下拉输入" class="headerlink" title="2.下拉输入"></a>2.下拉输入</h2><p>下拉输入和上拉是反的，下拉是有一个下拉电阻，其实就是这个引脚有一个接地的电阻和它连接，所以这个引脚一开始就是低电平，我们可以将引脚设置为下拉输入来获取高电平的变化。</p>
<h2 id="3-设置函数"><a href="#3-设置函数" class="headerlink" title="3.设置函数"></a>3.设置函数</h2><p>设置的函数是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pullUpDnControl</span><span class="params">(<span class="type">int</span> pin, <span class="type">int</span> mode)</span></span><br></pre></td></tr></table></figure>

<p>其中mode有下面几种选择</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PUD_OFF</td>
<td>无上拉无下拉</td>
</tr>
<tr>
<td>PUD_UP</td>
<td>上拉输入</td>
</tr>
<tr>
<td>PUD_DOWN</td>
<td>下拉输入</td>
</tr>
</tbody></table>
<p>这里我们需要设置为上拉输入，因为要获取低电平的输入。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);   <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 死循环进行读取内容</span></span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;按键按下了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编译运行一下，然后运行</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231204154759382-2087838547.png" alt="img"></p>
<p>会发现进入了死循环，然后但我们按下后就会有语句输出</p>
<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231204154817885-607915705.png" alt="img"></p>
<p>会发现这个出现了很多语句，怎么样来实现按一下输出一条语句呢？这里可以在循环里面再加上一个循环判断一下这个按键是不是一直为低电平，如果一直为低电平就一直在循环中出不来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);   <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 死循环进行读取内容</span></span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(digitalRead(<span class="number">116</span>) == <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;按键按下了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2023.cnblogs.com/blog/3083010/202312/3083010-20231204155256080-708166452.png" alt="img"></p>
<p>这个就叫做消抖，当然有一些是使用延时函数进行消抖的，这里也说一下，使用<code>delay</code>函数来延时去除抖动即可，一般按键的抖动都在20ms到30ms之间，这个可以进行微调</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);   <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 死循环进行读取内容</span></span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            delay(<span class="number">20</span>);     <span class="comment">// 延时消抖</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;按键按下了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个也不是很精准，一般情况下对按键的消抖是用延时函数配合着循环进行判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    wiringPiSetup();    <span class="comment">// 初始化</span></span><br><span class="line">    pinMode(<span class="number">16</span>, INPUT);  <span class="comment">// 设置为输入模式</span></span><br><span class="line">    pullUpDnControl(<span class="number">16</span>, PUD_UP);   <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 死循环进行读取内容</span></span><br><span class="line">        <span class="keyword">if</span> (digitalRead(<span class="number">16</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            delay(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">while</span>(digitalRead(<span class="number">16</span>) == <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;按键按下了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的消抖要准确一点。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>输入还是非常的简单，大家多多练习即可，后面也会经常使用到这个输入函数的。</p>
<p>大家有什么问题可以私信或者在文章下面留言，我都会看的。</p>
]]></content>
      <categories>
        <category>香橙派</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
</search>
