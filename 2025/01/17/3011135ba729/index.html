<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="referrer" content="no-referrer">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.puill.xin","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"show_result":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="在Linux上编程，直接进一个档次">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程">
<meta property="og:url" content="http://www.puill.xin/2025/01/17/3011135ba729/index.html">
<meta property="og:site_name" content="puill&#39;s Blog">
<meta property="og:description" content="在Linux上编程，直接进一个档次">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8A%8A%E6%89%80%E6%9C%89h%E7%BC%96%E7%A8%8Bo.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B0%86o%E5%85%A8%E9%83%A8%E6%89%93%E5%8C%85%E6%88%90a.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%9D%99%E6%80%81%E5%BA%93.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93o.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%94%9F%E6%88%90so.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8Badd.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E5%BA%93.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%B3%BB%E7%BB%9F%E5%BA%93.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/IO%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%94%99%E8%AF%AF%E7%A0%81.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/stat.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/st_mode%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%99%E6%B3%95.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/stat%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B9%B6%E8%A1%8C.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B9%B6%E5%8F%91.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/MMU.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%80%80%E5%87%BA%E8%BF%9B%E7%A8%8B%E5%87%BD%E6%95%B0.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E4%B8%AD%E9%80%9A%E8%AE%AF%E6%A6%82%E5%BF%B5.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E8%BF%B0.jpg">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%96%E5%8F%B7.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9B%9B%E8%A6%81%E7%B4%A0.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%A6%82%E8%BF%B0.png">
<meta property="og:image" content="http://www.puill.xin/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9B%BE%E7%89%87%5C%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BB%88%E7%AB%AF%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BC%9A%E8%AF%9D.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%AD%BB%E9%94%81.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BA%92%E6%96%A5.png">
<meta property="og:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5.png">
<meta property="article:published_time" content="2025-01-17T13:29:47.000Z">
<meta property="article:modified_time" content="2025-01-17T13:43:19.453Z">
<meta property="article:author" content="puill">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B.png">


<link rel="canonical" href="http://www.puill.xin/2025/01/17/3011135ba729/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.puill.xin/2025/01/17/3011135ba729/","path":"2025/01/17/3011135ba729/","title":"Linux系统编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux系统编程 | puill's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">puill's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-文章"><a href="/articles/" rel="section"><i class="fa fa-file-text fa-fw"></i>文章</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-友链"><a href="/friendchains/" rel="section"><i class="fa fa-paperclip fa-fw"></i>友链</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">Linux系统编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81"><span class="nav-number">1.1.</span> <span class="nav-text">一、静态和动态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.静态链接和动态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1）静态链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">2）动态链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">3）静态、动态编译对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.2.</span> <span class="nav-text">2、静态库和动态库介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.静态库制作和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">3.1 静态库制作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E9%9D%99%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">3.2 静态库使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.4.</span> <span class="nav-text">4.动态库制作和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">4.1 动态库制作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%8A%A8%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">4.2 动态库使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B3%BB%E7%BB%9F%E6%89%BE%E5%88%B0%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">4.3 如何让系统找到动态库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-GDB%E8%B0%83%E8%AF%95%E5%99%A8"><span class="nav-number">1.1.5.</span> <span class="nav-text">5.GDB调试器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-GDB%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">5.1 GDB简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E7%94%9F%E6%88%90%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">5.2 生成调试信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E5%90%AF%E5%8A%A8GDB"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">5.3 启动GDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E6%98%BE%E7%A4%BA%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">5.4 显示源代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-%E6%96%AD%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">5.5 断点操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-1-%E7%AE%80%E5%8D%95%E6%96%AD%E7%82%B9"><span class="nav-number">1.1.5.5.1.</span> <span class="nav-text">5.5.1 简单断点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-2-%E5%A4%9A%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"><span class="nav-number">1.1.5.5.2.</span> <span class="nav-text">5.5.2 多文件设置断点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-3-%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E6%96%AD%E7%82%B9"><span class="nav-number">1.1.5.5.3.</span> <span class="nav-text">5.5.3 查询所有断点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-4-%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="nav-number">1.1.5.5.4.</span> <span class="nav-text">5.5.4 条件断点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-5-%E7%BB%B4%E6%8A%A4%E6%96%AD%E7%82%B9"><span class="nav-number">1.1.5.5.5.</span> <span class="nav-text">5.5.5 维护断点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-6-%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.5.5.6.</span> <span class="nav-text">5.5.6 调试代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-7-%E6%95%B0%E6%8D%AE%E6%9F%A5%E7%9C%8B"><span class="nav-number">1.1.5.5.7.</span> <span class="nav-text">5.5.7 数据查看</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-8-%E8%87%AA%E5%8A%A8%E6%98%BE%E7%A4%BA"><span class="nav-number">1.1.5.5.8.</span> <span class="nav-text">5.5.8 自动显示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-9-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.5.5.9.</span> <span class="nav-text">5.5.9 查看修改变量</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91"><span class="nav-number">1.2.</span> <span class="nav-text">二、自动化编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Makefile"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.Makefile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-Makefile%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">1.1 Makefile简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-Makefile%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">1.2 Makefile语法规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-make%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">1.3 make命令格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-Makefile%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">1.4 Makefile实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-Makefile%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">1.5 Makefile中的变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.1.5.1.</span> <span class="nav-text">1.5.1 自定义变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-2-%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.1.5.2.</span> <span class="nav-text">1.5.2 自动变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-3-%E8%A7%84%E5%88%99%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.1.5.3.</span> <span class="nav-text">1.5.3 规则模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-Makefile%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">1.6 Makefile中的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-Makefile%E4%B8%AD%E7%9A%84%E4%BC%AA%E7%9B%AE%E6%A0%87"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">1.7 Makefile中的伪目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.1.8.</span> <span class="nav-text">1.8 makefile工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E8%B0%83%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">三、系统文件调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E8%B0%83%E7%94%A8%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.系统文件调用简介和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1.1 什么是系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">1.2 系统调用的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">1.3 系统调用和库函数的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-C%E5%BA%93%E4%B8%ADIO%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">1.4 C库中IO函数工作流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.错误处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.虚拟地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">1.3.4.</span> <span class="nav-text">4.文件描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AA%E6%95%B0"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">最大打开的文件个数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6IO%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.5.</span> <span class="nav-text">5.常用文件IO函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-open%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">5.1 open函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-close%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">5.2 close函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-write%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">5.3 write函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-read%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.5.4.</span> <span class="nav-text">5.4 read函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.5.4.1.</span> <span class="nav-text">阻塞和非阻塞的概念</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-lseek%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.5.5.</span> <span class="nav-text">5.5 lseek函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">四、文件操作相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-stat%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.stat函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-stat%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">1.1 stat获得文件类型(第一个版本)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%86%99%E6%B3%95"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">1.2 第二种写法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">1.3 获得文件权限</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-access%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.</span> <span class="nav-text">2.access函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-chmod%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.3.</span> <span class="nav-text">3.chmod函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-chown%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.chown函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-truncate%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.5.</span> <span class="nav-text">5.truncate函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-link%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.6.</span> <span class="nav-text">6.link函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-symlink%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.7.</span> <span class="nav-text">7.symlink函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-readlink%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.8.</span> <span class="nav-text">8.readlink函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-unlink%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.9.</span> <span class="nav-text">9.unlink函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-rename%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.10.</span> <span class="nav-text">10.rename函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%A4%8D%E5%88%B6"><span class="nav-number">1.5.</span> <span class="nav-text">五、文件描述符复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-dup%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.2.</span> <span class="nav-text">2.dup函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-dup2%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.3.</span> <span class="nav-text">3.dup2函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">1.5.4.</span> <span class="nav-text">4.案例分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-fcntl%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.fcntl函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">5.1 获得文件状态表示和设置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%9B%AE%E5%BD%95%E4%B9%A0%E6%83%AF%E6%93%8D%E4%BD%9C"><span class="nav-number">1.5.6.</span> <span class="nav-text">6.目录习惯操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-getcwd%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">6.1 getcwd函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-chdir%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.6.2.</span> <span class="nav-text">6.2 chdir函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-opendir%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.6.3.</span> <span class="nav-text">6.3 opendir函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-closedir%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.6.4.</span> <span class="nav-text">6.4 closedir函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-readdir%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.6.5.</span> <span class="nav-text">6.5 readdir函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">六、进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.进程和程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8D%95%E9%81%93%E3%80%81%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.6.2.</span> <span class="nav-text">2.单道、多道程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%8D%95%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">2.1 单道程序设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">2.2 多道程序设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="nav-number">1.6.3.</span> <span class="nav-text">3.并行和并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-MMU"><span class="nav-number">1.6.4.</span> <span class="nav-text">4.MMU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB"><span class="nav-number">1.6.5.</span> <span class="nav-text">5.进程控制块PCB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.6.6.</span> <span class="nav-text">6.进程的状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-ps"><span class="nav-number">1.6.6.1.</span> <span class="nav-text">6.1 ps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-top"><span class="nav-number">1.6.6.2.</span> <span class="nav-text">6.2 top</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-kill"><span class="nav-number">1.6.6.3.</span> <span class="nav-text">6.3 kill</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-killall"><span class="nav-number">1.6.6.4.</span> <span class="nav-text">6.4 killall</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E8%BF%9B%E7%A8%8B%E5%8F%B7%E5%92%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.7.</span> <span class="nav-text">7.进程号和相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-getpid%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.7.1.</span> <span class="nav-text">7.1 getpid函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-getppid%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.7.2.</span> <span class="nav-text">7.2 getppid函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-getpgid%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.7.3.</span> <span class="nav-text">7.3 getpgid函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.6.7.4.</span> <span class="nav-text">7.4 示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.6.8.</span> <span class="nav-text">8.进程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB"><span class="nav-number">1.6.9.</span> <span class="nav-text">9.父子进程关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%8C%BA%E5%88%86%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.6.10.</span> <span class="nav-text">10.区分父子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.6.11.</span> <span class="nav-text">11.父子进程地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-GDB%E8%B0%83%E8%AF%95%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.6.12.</span> <span class="nav-text">12.GDB调试多进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.13.</span> <span class="nav-text">13.进程退出函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E7%AD%89%E5%BE%85%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.14.</span> <span class="nav-text">14.等待进程退出函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.6.14.1.</span> <span class="nav-text">14.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-wait%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.14.2.</span> <span class="nav-text">14.2 wait函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-3-waitpid%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.14.3.</span> <span class="nav-text">14.3 waitpid函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.6.15.</span> <span class="nav-text">15.孤儿进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.6.16.</span> <span class="nav-text">16.僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2"><span class="nav-number">1.6.17.</span> <span class="nav-text">17.进程替换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF"><span class="nav-number">1.7.</span> <span class="nav-text">七、进程间通讯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">1.7.1.</span> <span class="nav-text">1.无名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">1.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-pipe%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">1.2 pipe函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E7%89%B9%E7%82%B9"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">1.3 管道的读写特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">1.4 设置为非阻塞的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E5%91%BD%E4%BB%A4"><span class="nav-number">1.7.1.5.</span> <span class="nav-text">1.5 查看管道缓冲区命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.1.6.</span> <span class="nav-text">1.6 查看管道缓冲区函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">1.7.2.</span> <span class="nav-text">2.有名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">2.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">2.2 通过命令创建有名管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">2.3 通过函数创建有名管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">2.4 有名管道读写操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.7.2.5.</span> <span class="nav-text">2.5 有名管道注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.7.3.</span> <span class="nav-text">3.消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">3.1 什么是消息队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">3.2 通过命令查看消息队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E5%88%9B%E5%BB%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">3.3 创建消息队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84"><span class="nav-number">1.7.4.</span> <span class="nav-text">4.共享存储映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">4.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">4.2 存储映射函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89mmap%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.2.1.</span> <span class="nav-text">（1）mmap函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89munmap%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.2.2.</span> <span class="nav-text">（2）munmap函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">4.3 注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-%E5%85%B1%E4%BA%AB%E6%98%A0%E5%B0%84%E7%9A%84%E6%96%B9%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="nav-number">1.7.4.4.</span> <span class="nav-text">4.4 共享映射的方式操作文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-%E5%85%B1%E4%BA%AB%E6%98%A0%E5%B0%84%E5%AE%9E%E7%8E%B0%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="nav-number">1.7.4.5.</span> <span class="nav-text">4.5 共享映射实现父子进程通讯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF"><span class="nav-number">1.7.4.6.</span> <span class="nav-text">4.6 不同进程使用存储映射进行进程间通讯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-%E5%8C%BF%E5%90%8D%E6%98%A0%E5%B0%84%E5%AE%9E%E7%8E%B0%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="nav-number">1.7.4.7.</span> <span class="nav-text">4.7 匿名映射实现父子进程通讯</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.8.</span> <span class="nav-text">八、信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-number">1.8.1.</span> <span class="nav-text">1.信号的概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%96%E5%8F%B7"><span class="nav-number">1.8.2.</span> <span class="nav-text">2.信号的编号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BF%A1%E5%8F%B7%E5%9B%9B%E8%A6%81%E7%B4%A0"><span class="nav-number">1.8.3.</span> <span class="nav-text">3.信号四要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.8.4.</span> <span class="nav-text">4.信号的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-number">1.8.5.</span> <span class="nav-text">5.阻塞信号集和未决信号集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86%EF%BC%88%E4%BF%A1%E5%8F%B7%E5%B1%8F%E8%94%BD%E5%AD%97%EF%BC%89"><span class="nav-number">1.8.5.1.</span> <span class="nav-text">5.1 阻塞信号集（信号屏蔽字）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-number">1.8.5.2.</span> <span class="nav-text">5.2 未决信号集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.6.</span> <span class="nav-text">6.信号产生函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-kill%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">6.1 kill函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-raise%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.6.2.</span> <span class="nav-text">6.2 raise函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-abort%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.6.3.</span> <span class="nav-text">6.3 abort函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-alarm%E5%87%BD%E6%95%B0-%E9%97%B9%E9%92%9F"><span class="nav-number">1.8.6.4.</span> <span class="nav-text">6.4 alarm函数(闹钟)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-setitimer%E5%87%BD%E6%95%B0%EF%BC%88%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%89"><span class="nav-number">1.8.6.5.</span> <span class="nav-text">6.5 setitimer函数（定时器）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-number">1.8.7.</span> <span class="nav-text">7.信号集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%A6%82%E8%BF%B0"><span class="nav-number">1.8.7.1.</span> <span class="nav-text">7.1 信号集概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.7.2.</span> <span class="nav-text">7.2 自定义信号集函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-sigprocmask%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.7.3.</span> <span class="nav-text">7.3 sigprocmask函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-sigpending%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.7.4.</span> <span class="nav-text">7.4 sigpending函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="nav-number">1.8.8.</span> <span class="nav-text">8.信号捕捉</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.8.1.</span> <span class="nav-text">8.1 信号处理方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-signal%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.8.2.</span> <span class="nav-text">8.2 signal函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-sigaction%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.8.3.</span> <span class="nav-text">8.3 sigaction函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="nav-number">1.8.9.</span> <span class="nav-text">9.不可重入、可重入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-SIGCHLE%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.8.10.</span> <span class="nav-text">10.SIGCHLE信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-SIGCHLD%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.8.10.1.</span> <span class="nav-text">10.1 SIGCHLD信号产生的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.8.10.2.</span> <span class="nav-text">10.2 如何避免僵尸进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.9.</span> <span class="nav-text">九、守护进程-线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%88%E7%AB%AF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.9.1.</span> <span class="nav-text">1.终端的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%BB%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.9.2.</span> <span class="nav-text">2.进程组概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E7%BB%84%E6%A6%82%E8%BF%B0"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">2.1 进程组概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">2.2 相关函数说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BC%9A%E8%AF%9D"><span class="nav-number">1.9.3.</span> <span class="nav-text">3.会话</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E4%BC%9A%E8%AF%9D%E6%A6%82%E8%BF%B0"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">3.1 会话概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E5%88%9B%E5%BB%BA%E4%BC%9A%E8%AF%9D%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">3.2 创建会话注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-API%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">3.3 API函数介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.9.4.</span> <span class="nav-text">4.守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">4.1 守护进程介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.9.4.2.</span> <span class="nav-text">4.2 守护进程模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="nav-number">1.9.5.</span> <span class="nav-text">5.线程简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">5.1 线程概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8%E5%AE%89%E8%A3%85"><span class="nav-number">1.9.5.2.</span> <span class="nav-text">5.2 线程函数列表安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-NPTL"><span class="nav-number">1.9.5.3.</span> <span class="nav-text">5.3 NPTL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.9.5.4.</span> <span class="nav-text">5.4 线程的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="nav-number">1.9.5.5.</span> <span class="nav-text">5.5 线程共享资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-%E7%BA%BF%E7%A8%8B%E9%9D%9E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="nav-number">1.9.5.6.</span> <span class="nav-text">5.6 线程非共享资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.9.5.7.</span> <span class="nav-text">5.7 线程的优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">1.9.6.</span> <span class="nav-text">6.线程常用操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E7%BA%BF%E7%A8%8B%E5%8F%B7"><span class="nav-number">1.9.6.1.</span> <span class="nav-text">6.1 线程号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.9.6.2.</span> <span class="nav-text">6.2 线程的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="nav-number">1.9.6.3.</span> <span class="nav-text">6.3 线程资源回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-%E7%BA%BF%E7%A8%8B%E8%BF%9E%E5%86%99"><span class="nav-number">1.9.6.4.</span> <span class="nav-text">6.4 线程连写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="nav-number">1.9.6.5.</span> <span class="nav-text">6.5 线程分离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-number">1.9.6.6.</span> <span class="nav-text">6.6 线程退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="nav-number">1.9.6.7.</span> <span class="nav-text">6.7 线程取消</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">1.9.7.</span> <span class="nav-text">7.线程属性（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.9.7.1.</span> <span class="nav-text">7.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81"><span class="nav-number">1.9.7.2.</span> <span class="nav-text">7.2 线程属性初始化和销毁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E7%8A%B6%E6%80%81"><span class="nav-number">1.9.7.3.</span> <span class="nav-text">7.3 线程分离状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%9C%B0%E5%9D%80"><span class="nav-number">1.9.7.4.</span> <span class="nav-text">7.4 线程栈地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.9.7.5.</span> <span class="nav-text">7.5 线程栈大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.9.7.6.</span> <span class="nav-text">7.6 线程使用注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">1.10.</span> <span class="nav-text">十、线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">1.10.1.</span> <span class="nav-text">1.互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E6%A6%82%E8%BF%B0"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">1.1 同步与互斥概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">1.2 为什么需要互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E4%BA%92%E6%96%A5%E9%94%81Mutex%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.10.1.3.</span> <span class="nav-text">1.3 互斥锁Mutex介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-pthread-mutex-init%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.1.4.</span> <span class="nav-text">1.4 pthread_mutex_init函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-pthread-mutex-destroy%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.1.5.</span> <span class="nav-text">1.5 pthread_mutex_destroy函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-pthread-mutex-lock%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.1.6.</span> <span class="nav-text">1.6 pthread_mutex_lock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-pthread-mutex-unlock%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.1.7.</span> <span class="nav-text">1.7 pthread_mutex_unlock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.10.1.8.</span> <span class="nav-text">1.8 测试程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-%E6%AD%BB%E9%94%81%EF%BC%88DeadLock%EF%BC%89"><span class="nav-number">1.10.1.9.</span> <span class="nav-text">1.9 死锁（DeadLock）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">1.10.2.</span> <span class="nav-text">2.读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E8%AF%BB%E5%86%99%E9%94%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">2.1 读写锁概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-pthread-rwlock-init%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">2.2 pthread_rwlock_init函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-pthread-rwlock-destroy%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.2.3.</span> <span class="nav-text">2.3 pthread_rwlock_destroy函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-pthread-rwlock-rdlock%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.2.4.</span> <span class="nav-text">2.4 pthread_rwlock_rdlock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-pthread-rwlock-wrlock%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.2.5.</span> <span class="nav-text">2.5 pthread_rwlock_wrlock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-pthread-rwlock-unlock%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.2.6.</span> <span class="nav-text">2.6 pthread_rwlock_unlock函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.10.2.7.</span> <span class="nav-text">2.7 测试程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">1.10.3.</span> <span class="nav-text">3.条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">3.1 条件变量概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-pthread-cond-init%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">3.2 pthread_cond_init函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-pthread-cond-destroy%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.3.3.</span> <span class="nav-text">3.3 pthread_cond_destroy函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-pthread-cond-wait%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.3.4.</span> <span class="nav-text">3.4 pthread_cond_wait函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-pthread-cond-signal%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.3.5.</span> <span class="nav-text">3.5 pthread_cond_signal函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.10.3.6.</span> <span class="nav-text">3.6 生产者消费者条件变量模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.10.3.7.</span> <span class="nav-text">3.7 条件变量的优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.10.4.</span> <span class="nav-text">4.信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.10.4.1.</span> <span class="nav-text">4.1 信号量概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-sem-init%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.4.2.</span> <span class="nav-text">4.2 sem_init函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-sem-destroy%E5%87%BD%E6%95%B0"><span class="nav-number">1.10.4.3.</span> <span class="nav-text">4.3 sem_destroy函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-%E4%BF%A1%E5%8F%B7%E9%87%8FP%E6%93%8D%E4%BD%9C%EF%BC%88%E5%87%8F1%EF%BC%89"><span class="nav-number">1.10.4.4.</span> <span class="nav-text">4.4 信号量P操作（减1）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-%E4%BF%A1%E5%8F%B7%E9%87%8FV%E6%93%8D%E4%BD%9C%EF%BC%88%E5%8A%A01%EF%BC%89"><span class="nav-number">1.10.4.5.</span> <span class="nav-text">4.5 信号量V操作（加1）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-%E8%8E%B7%E5%8F%96%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%80%BC"><span class="nav-number">1.10.4.6.</span> <span class="nav-text">4.6 获取信号量的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.10.4.7.</span> <span class="nav-text">4.7 示例程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E6%9B%B4%E6%94%B9"><span class="nav-number">1.10.4.8.</span> <span class="nav-text">4.8 消费者模式更改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-%E5%A4%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%9F%E4%BA%A7%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.10.4.9.</span> <span class="nav-text">4.9 多信号量生产者模式</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="puill"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">puill</p>
  <div class="site-description" itemprop="description">puill的博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:2256044190@qq.com" title="E-Mail → mailto:2256044190@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.puill.xin/2025/01/17/3011135ba729/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="puill">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="puill's Blog">
      <meta itemprop="description" content="puill的博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Linux系统编程 | puill's Blog">
      <meta itemprop="description" content="在Linux上编程，直接进一个档次">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux系统编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-01-17 21:29:47 / 修改时间：21:43:19" itemprop="dateCreated datePublished" datetime="2025-01-17T21:29:47+08:00">2025-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">系统编程</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">在Linux上编程，直接进一个档次</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a>Linux系统编程</h1><h2 id="一、静态和动态"><a href="#一、静态和动态" class="headerlink" title="一、静态和动态"></a>一、静态和动态</h2><p>在linux中有两种有静态和动态的方式</p>
<h3 id="1-静态链接和动态链接"><a href="#1-静态链接和动态链接" class="headerlink" title="1.静态链接和动态链接"></a>1.静态链接和动态链接</h3><p>链接分为两种：静态链接、动态链接</p>
<h4 id="1）静态链接"><a href="#1）静态链接" class="headerlink" title="1）静态链接"></a>1）静态链接</h4><p>静态链接：由链接器在链接时将库的内容加入到可执行程序中。</p>
<p>优点：</p>
<ul>
<li>对运行环境的依赖性较小，具有较好的兼容性</li>
</ul>
<p>缺点：</p>
<ul>
<li>生成的程序比较大，需要更多的系统资源，在装入内存时会消耗更多的时间</li>
<li>库函数有了更新，必须重新编译应用程序</li>
</ul>
<h4 id="2）动态链接"><a href="#2）动态链接" class="headerlink" title="2）动态链接"></a>2）动态链接</h4><p>动态链接：连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。</p>
<p>优点：</p>
<ul>
<li>在需要的时候才会调用对应的资源函数</li>
<li>简化程序的升级；有着较小的程序体积</li>
<li>实现进程之间的志愿共享（避免重复拷贝）</li>
</ul>
<p>缺点：</p>
<ul>
<li>依赖动态库，不能独立运行</li>
<li>动态库依赖版本问题严重</li>
</ul>
<h4 id="3）静态、动态编译对比"><a href="#3）静态、动态编译对比" class="headerlink" title="3）静态、动态编译对比"></a>3）静态、动态编译对比</h4><p>在Linux中的gcc是默认使用动态链接来生成代码。</p>
<p>如果想使用静态链接来生成代码，则需要使用下面的指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static</span><br></pre></td></tr></table></figure>

<p>剩下的和动态链接一样</p>
<h3 id="2、静态库和动态库介绍"><a href="#2、静态库和动态库介绍" class="headerlink" title="2、静态库和动态库介绍"></a>2、静态库和动态库介绍</h3><p>所谓”程序库“，简单说，就是包含了数据和执行码的文件。其不能单独执行，可以作为出现都一部分来完成某些功能</p>
<p>库的存在可以使得程序模块化，可以加快程序的再编译，可以实现代码重用，可以使得程序便于升级</p>
<p>程序库可分 <strong>静态库</strong> 和 <strong>共享库</strong></p>
<h3 id="3-静态库制作和使用"><a href="#3-静态库制作和使用" class="headerlink" title="3.静态库制作和使用"></a>3.静态库制作和使用</h3><p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行代码中，成为执行程序的一部分。</p>
<p>按照习惯，一般以 <code>.a</code> 作为文件后缀名。静态库的命名一般分为三个部分：</p>
<ul>
<li>前缀：lib</li>
<li>库名称：自己定义即可</li>
<li>后缀： <code>.a</code></li>
</ul>
<p>所以最终的静态库的名字应该为：<code>libxxx.a</code></p>
<h4 id="3-1-静态库制作"><a href="#3-1-静态库制作" class="headerlink" title="3.1 静态库制作"></a>3.1 静态库制作</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B.png"></p>
<p>步骤1：将C源文件生成对应的<code>.o</code>文件</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%8A%8A%E6%89%80%E6%9C%89h%E7%BC%96%E7%A8%8Bo.png"></p>
<p>步骤2：使用打包工具ar将准备好的.o文件打包为.a文件 libtest.a</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B0%86o%E5%85%A8%E9%83%A8%E6%89%93%E5%8C%85%E6%88%90a.png"></p>
<p>在使用ar工具是需要添加参数：rcs</p>
<ul>
<li>r更新</li>
<li>c创建</li>
<li>s建立索引</li>
</ul>
<h4 id="3-2-静态库使用"><a href="#3-2-静态库使用" class="headerlink" title="3.2 静态库使用"></a>3.2 静态库使用</h4><p>静态库制作完成后，需要将.a文件和头文件一起发布给用户。</p>
<p>假设测试文件为test.c，静态库文件为libtest.a头文件为head.h</p>
<p>编译命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -L. -I. -l test -o test</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>-L：表示要连接的库所在目录</li>
<li>-l（小写L）：指定链接时需要的库，去除前缀和后缀</li>
</ul>
<p>在执行程序的时候，程序1使用到这个静态库，就会在内存中开辟出这块空间来存放静态库，程序2执行的时候也会和程序1的过程一样，会产生大量的空间，导致程序会很大，如果执行多次那空间就会非常大</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%9D%99%E6%80%81%E5%BA%93.png"></p>
<h3 id="4-动态库制作和使用"><a href="#4-动态库制作和使用" class="headerlink" title="4.动态库制作和使用"></a>4.动态库制作和使用</h3><p>共享库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入、不同的应用程序如果调用系统的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。</p>
<p>动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布带来的麻烦。用户只需要更新动态库即可，增量更新。</p>
<p>按照习惯，一般以 <code>.so</code> 作为文件后缀名。共享库的命名一般分为三个部分：</p>
<ul>
<li>前缀：lib</li>
<li>库名称</li>
<li>后缀：.so</li>
</ul>
<p>所以最终的动态库的名字应该为：libxxx.so</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93.png"></p>
<h4 id="4-1-动态库制作"><a href="#4-1-动态库制作" class="headerlink" title="4.1 动态库制作"></a>4.1 动态库制作</h4><p>步骤一：生成目标文件，此时要加编译选项：-fpic</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93o.png"></p>
<p>参数：-fpic创建与地址无关的编译程序，是为了能够在多个应用程序间共享。</p>
<p>步骤二：生成共享库，此时要加链接器选项：-shared（指定生成动态链接库）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared *.o -o libxxx.so</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%94%9F%E6%88%90so.png"></p>
<p>步骤三：通过nm命令查看对应函数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm libtest.so | grep add</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8Badd.png"></p>
<h4 id="4-2-动态库使用"><a href="#4-2-动态库使用" class="headerlink" title="4.2 动态库使用"></a>4.2 动态库使用</h4><p>在使用的时候也是需要对其进行编译</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E5%BA%93.png"></p>
<p>编译完成后运行，会发现报错了</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%8A%A8%E6%80%81%E5%BA%93%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99.png"></p>
<p>原因是因为在链接的时候需要用到连接器才可以使用</p>
<ul>
<li>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器。</li>
<li>对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段-环境变量LD_LIBRARY_PATH-&#x2F;etc&#x2F;ld.so.cache文件列表-&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib目录找到库文件将其载入内存</li>
</ul>
<h4 id="4-3-如何让系统找到动态库"><a href="#4-3-如何让系统找到动态库" class="headerlink" title="4.3 如何让系统找到动态库"></a>4.3 如何让系统找到动态库</h4><ul>
<li><p>将动态库放到 <code>/lib</code> 目录中即可</p>
</li>
<li><p>临时设置LD_LIBRARY_PATH:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>永久设置，把 <code>export LD_LIBRARY_PATH=&amp;LD_LIBRARY_PATH:库路径</code> ，设置到 <code>~/.bashrc</code> 或 <code>/etc/profile</code> 文件中</p>
<p>把 <code>export LD_LIBRARY_PATH=&amp;LD_LIBRARY_PATH:库路径</code> 添加到最后一行即可</p>
<p>执行下面代码让文件生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.bashre</span><br></pre></td></tr></table></figure>
</li>
<li><p>将其添加到 <code>/etc/ld.so.conf</code> 文件中</p>
<p>编辑 <code>/etc/ld.so.conf</code> 文件，加入库文件所在目录的路径</p>
<p>运行 <code>sudo ldconfig -v</code> ，该命令会重建 <code>/etc/ld.so.cache</code> 文件</p>
</li>
<li><p>使用符号链接，但一定要使用绝对1路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /home/deng/test/6share_test/libtest.so /lib/libtest.so</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-GDB调试器"><a href="#5-GDB调试器" class="headerlink" title="5.GDB调试器"></a>5.GDB调试器</h3><h4 id="5-1-GDB简介"><a href="#5-1-GDB简介" class="headerlink" title="5.1 GDB简介"></a>5.1 GDB简介</h4><p>GNU工具集中的调试器是GDB，该程序是一个交互式工具，工作在字符模式。除GDB外，Linux下比较有名的调试器还有xxgdb，ddd，kgdb，ups</p>
<p>GDB主要帮助你完成下面四个方面的功能：</p>
<p>1.启动程序，可以按照你的自定义的要求随心所欲的运行程序。</p>
<p>2.可以被调试的程序在你所指定的调置的断点处停止。</p>
<p>3.当程序被停住时，可以检查此时你的程序中所发生的事</p>
<p>4.动态的改变你的程序的执行环境</p>
<h4 id="5-2-生成调试信息"><a href="#5-2-生成调试信息" class="headerlink" title="5.2 生成调试信息"></a>5.2 生成调试信息</h4><p>一般来说GDB主要调试的是C&#x2F;C++的程序。要调试C&#x2F;C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器(cc&#x2F;gcc&#x2F;g++)的-g参数可以做到这一点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g hello.c -o hello</span><br><span class="line">g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>

<p>如果没有-g，你将看不到程序的函数名、变量名，所替代的全是运行时的内存地址</p>
<h4 id="5-3-启动GDB"><a href="#5-3-启动GDB" class="headerlink" title="5.3 启动GDB"></a>5.3 启动GDB</h4><ul>
<li><p>启动GDB：gdb program</p>
<p>program 也是你的执行文件，一般在当前目录下。</p>
</li>
<li><p>设置运行参数</p>
<p>set args  可指定运行时参数。（如：set args 10 20 30 40 50）</p>
<p>show args 命令可以查看设置好的运行参数。</p>
</li>
<li><p>启动程序</p>
<p>run：程序开始执行，如果有断点，停在第一个断点处</p>
<p>start：程序向下执行一行</p>
</li>
</ul>
<h4 id="5-4-显示源代码"><a href="#5-4-显示源代码" class="headerlink" title="5.4 显示源代码"></a>5.4 显示源代码</h4><p>用list命令来打印程序的源代码。默认打印10行。</p>
<ul>
<li>list linenum：打印第linenm行的上下文内容</li>
<li>list function：显示函数名为function的函数的源程序</li>
<li>list：显示当前行后面的源程序</li>
<li>list -：显示当前行前面的源程序</li>
</ul>
<p>一般是打印当前行的上5行和下5行，如果显示的函数是上2行下8行，默认10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数</p>
<ul>
<li>set listsize count：设置一次显示源代码的行数</li>
<li>show listsize：查看当前listsize的设置。</li>
</ul>
<h4 id="5-5-断点操作"><a href="#5-5-断点操作" class="headerlink" title="5.5 断点操作"></a>5.5 断点操作</h4><h5 id="5-5-1-简单断点"><a href="#5-5-1-简单断点" class="headerlink" title="5.5.1 简单断点"></a>5.5.1 简单断点</h5><p>break设置断点，可以简写为b</p>
<ul>
<li>b 10 设置断点，在源文件第10行</li>
<li>b func 设置断点，在func函数入口处</li>
</ul>
<h5 id="5-5-2-多文件设置断点"><a href="#5-5-2-多文件设置断点" class="headerlink" title="5.5.2 多文件设置断点"></a>5.5.2 多文件设置断点</h5><p>如果有名称空间，可以使用namespace::class::function或者function(type, type) 格式来指定函数名。</p>
<ul>
<li>break filename:linenum –在源文件filename的linenum行处停住</li>
<li>break filename:function – 在源文件filename的function函数的入口处停住</li>
<li>break class::function 或 function(type, type) – 在类class的function函数入口处停住</li>
<li>break namespace::class::function – 在名称空间为namespace的类class的function函数的入口处停住</li>
</ul>
<h5 id="5-5-3-查询所有断点"><a href="#5-5-3-查询所有断点" class="headerlink" title="5.5.3 查询所有断点"></a>5.5.3 查询所有断点</h5><ul>
<li>info b</li>
<li>info break</li>
<li>i break</li>
<li>i b</li>
</ul>
<h5 id="5-5-4-条件断点"><a href="#5-5-4-条件断点" class="headerlink" title="5.5.4 条件断点"></a>5.5.4 条件断点</h5><p>一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。</p>
<p>设置一个条件断点：</p>
<blockquote>
<p>b test.c:8 if Value &#x3D;&#x3D; 5</p>
</blockquote>
<h5 id="5-5-5-维护断点"><a href="#5-5-5-维护断点" class="headerlink" title="5.5.5 维护断点"></a>5.5.5 维护断点</h5><p>1）delete [range…] 输出指定的断点，其简写命令为d。</p>
<ul>
<li>如果不指定断点号，则表示删除所有的断点。range表示断点号的范围*如：3-7）。</li>
<li>比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样</li>
</ul>
<p>2）disable [range…]使指定断点无效，简写命令是dis。</p>
<p>​		如果什么都不指定，表示disable所有的停止点无效</p>
<p>3）enable [range…] 使无效断定失效，缩写命令是ena。</p>
<p>​		如果什么都不指定，表示enable所有的停止点</p>
<h5 id="5-5-6-调试代码"><a href="#5-5-6-调试代码" class="headerlink" title="5.5.6 调试代码"></a>5.5.6 调试代码</h5><ul>
<li>run 运行程序，可简写为r</li>
<li>next 单步跟踪，函数调用当作一条简单语句执行，可简写为n</li>
<li>step 单步跟踪，函数调用进入被调用函数体内，可简写为s</li>
<li>finish 退出进入的函数</li>
<li>until 在一个循环体内单步跟踪时，这个命令可以运行直到退出循环体，可简写为u。</li>
<li>continue 继续运行程序，停在下一个断点的位置，可简写为c</li>
<li>quit 退出gdb，可简写为q</li>
</ul>
<h5 id="5-5-7-数据查看"><a href="#5-5-7-数据查看" class="headerlink" title="5.5.7 数据查看"></a>5.5.7 数据查看</h5><p>1）查看运行时数据</p>
<p>​	print 打印变量、字符串、表达式等的值，可简写为p</p>
<p>​	p count 打印count的值</p>
<h5 id="5-5-8-自动显示"><a href="#5-5-8-自动显示" class="headerlink" title="5.5.8 自动显示"></a>5.5.8 自动显示</h5><p>可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。</p>
<ul>
<li>display 变量名</li>
<li>info display  – 查看设置的自动显示的信息。</li>
<li>undisplay num （info display时显示的编号）</li>
<li>delete display dnums… – 删除自动显示，dnums意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</li>
<li>disable display dnums…</li>
<li>enable display dnums…</li>
<li>disable和enalbe不删除自动显示的设置，而只是让其失效和恢复</li>
</ul>
<h5 id="5-5-9-查看修改变量"><a href="#5-5-9-查看修改变量" class="headerlink" title="5.5.9 查看修改变量"></a>5.5.9 查看修改变量</h5><p>1）ptype width – 查看变量width的类型</p>
<p>​	type &#x3D; double</p>
<p>2）p width – 打印变量width的值</p>
<p>你可以使用set var命令告诉GDB，width不是你GDB的参数，而是程序的变量名，如：</p>
<p>​		set var width&#x3D;47 &#x2F;&#x2F;将变量var值设置为47</p>
<p><strong>在吧改变程序变量取值时，最好都使用set var格式的GDB命令</strong></p>
<h2 id="二、自动化编译"><a href="#二、自动化编译" class="headerlink" title="二、自动化编译"></a>二、自动化编译</h2><h3 id="1-Makefile"><a href="#1-Makefile" class="headerlink" title="1.Makefile"></a>1.Makefile</h3><h4 id="1-1-Makefile简介"><a href="#1-1-Makefile简介" class="headerlink" title="1.1 Makefile简介"></a>1.1 Makefile简介</h4><p>一个工程中的源文件不记其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至进行更复杂的功能操作，因为makefile就像一个shell脚本一样，其中也可以执行操作系统的命令。</p>
<p>Makefile代码来的好处就是–“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令。</p>
<p>make主要解决两个问题：</p>
<p><strong>1）大量代码的关系维护</strong></p>
<p>大项目中源代码比较多，手工维护、编译时间长而且命令复杂，难以记忆及维护</p>
<p>把代码维护命令及编译命令写在makefile文件中，然后再用make工具解析此文件自动执行相应命令，可实现代码的合理编译</p>
<p><strong>2）减少重复编译时间</strong></p>
<p>在改动其中一个文件的时候，能判断哪些文件被修改过，可以只对该文件进行重新编译，然后重新链接所有目标文件，节省编译时间</p>
<p><strong>Makefile文件命名规则</strong></p>
<p>makefile和Makefile都可以</p>
<p><strong>make工具安装</strong></p>
<blockquote>
<p>sudo apt install make</p>
</blockquote>
<h4 id="1-2-Makefile语法规则"><a href="#1-2-Makefile语法规则" class="headerlink" title="1.2 Makefile语法规则"></a>1.2 Makefile语法规则</h4><p>一条规则：</p>
<blockquote>
<p>目标：依赖文件列表</p>
<p><Tab>命令列表</p>
</blockquote>
<p>Makefile基本规则三要素：</p>
<p>1）目标：</p>
<ul>
<li>通常是要产生的文件名称，目标可以是可执行文件或其他obj文件，也可以是一个动作的名称</li>
</ul>
<p>2）依赖文件：</p>
<ul>
<li>用来输入从而产生目标的文件</li>
<li>一个目标通常有几个依赖文件（可以没有）</li>
</ul>
<p>3）命令：</p>
<ul>
<li>make执行的动作，一个规则可以含几个命令（可以没有）</li>
<li>有多个命令时，每个命令占一行</li>
</ul>
<h4 id="1-3-make命令格式"><a href="#1-3-make命令格式" class="headerlink" title="1.3 make命令格式"></a>1.3 make命令格式</h4><p>make是一个命令工具，它解释Makefile中的指令（应该说是规则）。</p>
<p>make命令格式：</p>
<p>make [-f file][options][targets]</p>
<p>1.[-f file]:</p>
<ul>
<li>make默认在工作目录中寻找名为makefile、makefile、Makefile的文件作为makefile输入文件</li>
<li>-f 可以指定以上名字以外的文件作为makefile输入文件</li>
</ul>
<p>2.[options]</p>
<ul>
<li>-v：显示make工具的版本信息</li>
<li>-w：在处理makefile之前和之后显示工作路径</li>
<li>-C dir：读取makefile之前改变工作路径至dir目录</li>
<li>-n：只打印要执行的命令但不执行</li>
<li>-s：执行但不显示执行的命令</li>
</ul>
<p>3.[targets]：</p>
<ul>
<li>若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个目标，然后退出</li>
<li>指定make工具要实现的目标，目标可以是一个或多个（多个目标间用空格隔开）。</li>
</ul>
<h4 id="1-4-Makefile实例"><a href="#1-4-Makefile实例" class="headerlink" title="1.4 Makefile实例"></a>1.4 Makefile实例</h4><p>比如要编译之前写的Add.c Sub.c Div.c Mul.c</p>
<p>在Makefile文件中的写法如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:Add.o Sub.o Div.o Mul.o test.o</span></span><br><span class="line">    gcc Add.o Sub.o Div.o Mul.o test.o -o test</span><br><span class="line"><span class="section">Add.o:Add.c</span></span><br><span class="line">    gcc -c Add.c -o Add.o</span><br><span class="line"><span class="section">Sub.o:Sub.c</span></span><br><span class="line">    gcc -c Sub.c -o Sub.o</span><br><span class="line"><span class="section">Div.o:Div.c</span></span><br><span class="line">    gcc -c Div.c -o Div.o</span><br><span class="line"><span class="section">Mul.o:Mul.c</span></span><br><span class="line">    gcc -c Mul.c -o Mul.o</span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">    gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure>

<p>这种写法后，在如果又修改其他文件话只需要重新编译刚写的文件</p>
<h4 id="1-5-Makefile中的变量"><a href="#1-5-Makefile中的变量" class="headerlink" title="1.5 Makefile中的变量"></a>1.5 Makefile中的变量</h4><p>在Makefile中使用变量有点类似于C语言中的宏定义，使用该变量相当于内存替换，使用变量可以使Makefile易于维护，修改内容变得简单变量定义及使用。</p>
<h5 id="1-5-1-自定义变量"><a href="#1-5-1-自定义变量" class="headerlink" title="1.5.1 自定义变量"></a>1.5.1 自定义变量</h5><p>1）定义变量方法：</p>
<p>​	变量名 &#x3D; 变量值</p>
<p>2）引用变量：</p>
<p>​	$(变量名)或${变量名}</p>
<p>3）makefile的变量名：</p>
<ul>
<li>makefile量名可以以数字开头</li>
<li>变量是大小写敏感的</li>
<li>变量一般都在makefile的头部定义</li>
<li>变量几乎可以在makefile的任何地方使用</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc $&#123;OBJS&#125; -o test</span><br><span class="line"><span class="section">Add.o:Add.c</span></span><br><span class="line">        gcc -c Add.c -o Add.o</span><br><span class="line"><span class="section">Sub.o:Sub.c</span></span><br><span class="line">        gcc -c Sub.c -o Sub.o</span><br><span class="line"><span class="section">Div.o:Div.c</span></span><br><span class="line">        gcc -c Div.c -o Div.o</span><br><span class="line"><span class="section">Mul.o:Mul.c</span></span><br><span class="line">        gcc -c Mul.c -o Mul.o</span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">        gcc -c test.c -o test.o</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户直接使用，我们可以直接对其进行赋值。</p>
<blockquote>
<p>CC&#x3D;gcc #arm-linux-gcc</p>
<p>CPPFLAGS: C预处理器的选择 如：-l</p>
<p>CFLAGS：C编译器的选择 -Wall -g -c</p>
<p>LDFLAGS：链接器选择 -L -l</p>
</blockquote>
<h5 id="1-5-2-自动变量"><a href="#1-5-2-自动变量" class="headerlink" title="1.5.2 自动变量"></a>1.5.2 自动变量</h5><ul>
<li>$@：表示规则中的目标</li>
<li>$&lt;：表示规则中的第一个依赖</li>
<li>$^：表示所有依赖</li>
<li>$?：所有目标依赖中被修改过的文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">Add.o:Add.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">Sub.o:Sub.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">Div.o:Div.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">Mul.o:Mul.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="1-5-3-规则模式"><a href="#1-5-3-规则模式" class="headerlink" title="1.5.3 规则模式"></a>1.5.3 规则模式</h5><p>模式规则示例：</p>
<blockquote>
<p>%.o:%.c</p>
<p>$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o &amp;@</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OBJS = Add.o Sub.o Div.o Mul.o test.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#Add.o:Add.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#Sub.o:Sub.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#Div.o:Div.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#Mul.o:Mul.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="comment">#test.o:test.c</span></span><br><span class="line"><span class="comment">#       gcc -c $&lt; -o $@</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-Makefile中的函数"><a href="#1-6-Makefile中的函数" class="headerlink" title="1.6 Makefile中的函数"></a>1.6 Makefile中的函数</h4><p>makefile中的函数有很多，在这里给大家介绍两个最常用的。</p>
<blockquote>
<p>1.wildcard - 查找指定目录下的指定类型的文件</p>
<p>​	src &#x3D; $(wildcard *.c) &#x2F;&#x2F;找到当前目录下所有后缀为.c的文件，赋值	给src</p>
<p>2.patsubst - 匹配替换</p>
<p>obj &#x3D; $(patsubst %.c, %.o, $(src)) &#x2F;&#x2F;把src变量里所有后缀为.c的文件替换成.o</p>
</blockquote>
<p>在makefile中所有的函数都有返回值的。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取当前目录下所有的.c文件</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将SRC中所有出现的.c的替换成.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-7-Makefile中的伪目标"><a href="#1-7-Makefile中的伪目标" class="headerlink" title="1.7 Makefile中的伪目标"></a>1.7 Makefile中的伪目标</h4><p>clean用途：清除编译生成的中间文件.o文件和最终目标文件</p>
<p>make clean如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：</p>
<ul>
<li><p>伪目标声明：.PHONY:clean</p>
<p>声明目标为伪目标之后，makefile将不会该判断目标是否存在或者该目标是否需要更新</p>
</li>
</ul>
<p>clean命令中的特殊符号：</p>
<ul>
<li><code>-</code> 此条命令出错，make也会继续执行后续的命令。如：“-rm main.o”</li>
<li>“@”不显示命令本身，只显示结果。如：“@echo clean done”</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取当前目录下所有的.c文件</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将SRC中所有出现的.c的替换成.o</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="section">test:$&#123;OBJS&#125;</span></span><br><span class="line">        @gcc <span class="variable">$^</span> -o $&#123;TARGET&#125;</span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">        @gcc -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clear:</span></span><br><span class="line">        -rm -rf $&#123;OBJS&#125; $&#123;TARGET&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-8-makefile工作原理"><a href="#1-8-makefile工作原理" class="headerlink" title="1.8 makefile工作原理"></a>1.8 makefile工作原理</h4><p>1）若想生成目标，检查规则中的依赖条件是否存在，如果不出来，则寻找是否有规则用来生成该依赖文件</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<p>2）检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任一个被更新，则目标必须更新</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p>
<p>总结：</p>
<ul>
<li>分析各个目标和依赖之间的关系</li>
<li>根据依赖关系自底向上执行命令</li>
<li>根据修改事件比目标新，确定更新</li>
<li>如果目标不依赖任何条件，则执行对应命令，以示更新</li>
</ul>
<h2 id="三、系统文件调用"><a href="#三、系统文件调用" class="headerlink" title="三、系统文件调用"></a>三、系统文件调用</h2><h3 id="1-系统文件调用简介和实现"><a href="#1-系统文件调用简介和实现" class="headerlink" title="1.系统文件调用简介和实现"></a>1.系统文件调用简介和实现</h3><h4 id="1-1-什么是系统调用"><a href="#1-1-什么是系统调用" class="headerlink" title="1.1 什么是系统调用"></a>1.1 什么是系统调用</h4><p>操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过区组“特殊“接口来获得操作系统内核提供的服务，比如说用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获取系统时间或设置定时器等。</p>
<p>从逻辑上来说，系统调用可以看成是一个内核与用户空间程序交互的接口——它好比是一个中间人，把用户进程的请求传达给内核，待内核把请求处理完后再将处理结果送回给用户空间。</p>
<h4 id="1-2-系统调用的实现"><a href="#1-2-系统调用的实现" class="headerlink" title="1.2 系统调用的实现"></a>1.2 系统调用的实现</h4><p>系统调用是属于操作系统内核的一部分的，必须以某种方式提供给进程让它们去调用。CPU可以在不同的特权级别下运行，而相应的操作系统也有不同的运行级别，用户态和内核态。运行在内核态的进程可以毫无限制的访问各种资源，而在用户态的用户进程的各种操作都有着权限，比如不能随意的访问内存、不能开闭中断以及切换运行特权。显然，属于内核的系统调用一定是运行在内核态下，但是如何切换到内核态呢？</p>
<p>答案是软件中断。软件中断和我们常说的中断（硬件中断）不同之处在于，它是通过软件指令触发而非外设引发的中断，也就是说，又是编程人员开发出的一种异常（该异常为正常的异常）。<strong>操作系统一般是通过软件中断从用户态切换到内核态。</strong></p>
<h4 id="1-3-系统调用和库函数的区别"><a href="#1-3-系统调用和库函数的区别" class="headerlink" title="1.3 系统调用和库函数的区别"></a>1.3 系统调用和库函数的区别</h4><p>Linux下对文件操作方式有两种方法：<strong>系统调用（system call）</strong> 和 <strong>库函数调用（Library functions）</strong>。</p>
<p>库函数由两类函数组成：</p>
<p>1）不需要调用系统调用</p>
<p>不需要切换到内核空间即可完成函数全部功能，并且将结果反馈给应用程序，如strcpy、bzero 等字符串操作函数</p>
<p>2）需要调用系统调用</p>
<p>需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如printf、fread等</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%B3%BB%E7%BB%9F%E5%BA%93.png"></p>
<p>系统调用是需要时间的，程序中频繁的使用系统调用会降低程序的运行效率。当运行内核代码时，CPU工作在内核态，在系统调用发生前需要保存用户态和内存环境，然后转入内核态工作。系统调用结束后，又要切换回用户态。这种环境的切换会消耗许多时间。</p>
<h4 id="1-4-C库中IO函数工作流程"><a href="#1-4-C库中IO函数工作流程" class="headerlink" title="1.4 C库中IO函数工作流程"></a>1.4 C库中IO函数工作流程</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/IO%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<p>库函数访问文件的时候需要根据需要，设置不同类型的缓冲区，从而减少了直接调用IO系统调用的次数，提高了访问效率</p>
<p>这个过程类似于快递员给某个区域（内核空间）送快递一样，快递员有两种方法送：</p>
<p>1）来一件快递马上送到目的地，来一件送一件，这样导致来回走比较频繁（系统调用）</p>
<p>2）等快递攒着差不多后（缓冲区），才一次性送到目的地（库函数调用）</p>
<h3 id="2-错误处理函数"><a href="#2-错误处理函数" class="headerlink" title="2.错误处理函数"></a>2.错误处理函数</h3><p>errno是记录系统的最后一次错误代码。代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。</p>
<p>当Linux C api函数发生异常时，一般会将errno全局变量赋一个整数值，不同的值表示不同的意义，可以通过查看该值推测出出错原因。</p>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        FILE* fp = fopen(<span class="string">&quot;txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, errno);<span class="comment">//打印错误码</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno)); <span class="comment">//把errno的数字转换成相应的文字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看错误号：</p>
<blockquote>
<p>&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno-base.h</p>
<p>&#x2F;usr&#x2F;include&#x2F;asm-generic&#x2F;errno.h</p>
</blockquote>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%94%99%E8%AF%AF%E7%A0%81.png"></p>
<h3 id="3-虚拟地址空间"><a href="#3-虚拟地址空间" class="headerlink" title="3.虚拟地址空间"></a>3.虚拟地址空间</h3><p>每个进程都会分配虚拟地址，在32位机器上，该地址空间为4G</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png"></p>
<p>在进程里平时说的指针变量，保存的就是虚拟地址。当应用程序使用虚拟地址访问内存时，处理器（CPU）会将其转化成物理地址（MMU）。</p>
<p>MMU：将虚拟的地址转化为物理地址。</p>
<p>这样做的好处在于：</p>
<ul>
<li>进程隔离，更好的保护系统安全运行</li>
<li>屏蔽物理差异带来的麻烦，方便操作系统和编译器安排进程地址</li>
</ul>
<h3 id="4-文件描述符"><a href="#4-文件描述符" class="headerlink" title="4.文件描述符"></a>4.文件描述符</h3><p>在Linux的世界里，一切设备皆为文件。我们可以调用系统中I&#x2F;O的函数（I：input，输入；O：output，输出），对文件进行相应的操作（open()、close()、write()、read()等）。</p>
<p>打开现存文件或新建文件时，系统（内核）会返回一个文件描述符，文件描述符用来指定已经打开的文件。这个文件描述符相当于这个文件已经打开文件的符号，文件描述符是非负整数，是文件的标识，操作这个文件描述符相当于操作这个描述符所指定的文件。</p>
<p>程序运行起来后（每个进程）都有一张文件描述符的表，标准输入、标准输出、标准错误输出设备文件被打开，对应的文件描述符0、1、2记录在表中。程序运行起来后这三个文件描述符是默认打开的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STDIN_FILENO 0 <span class="comment">//标准输入的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDOUT_FILENO 1 <span class="comment">//标准输出的文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDERR_FILENO 2 <span class="comment">//标准错误的文件描述</span></span></span><br></pre></td></tr></table></figure>

<p>在程序运行起来后打开其它文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png"></p>
<h4 id="最大打开的文件个数"><a href="#最大打开的文件个数" class="headerlink" title="最大打开的文件个数"></a>最大打开的文件个数</h4><p>Linux中一个进程最多只能打开 NR_OPEN_DEFAULT （即1024）个文件，故当文件不再使用时应及时调用close()函数关闭文件。</p>
<ul>
<li><p>查看当前系统允许打开最大文件个数：</p>
<blockquote>
<p>cat&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</p>
</blockquote>
</li>
<li><p>当前默认设置最大打开文件个数1024</p>
<blockquote>
<p>ulimit -a</p>
</blockquote>
</li>
<li><p>修改默认设置最大打开文件个数4096</p>
<blockquote>
<p>ulimit -n 4096</p>
</blockquote>
</li>
</ul>
<h3 id="5-常用文件IO函数"><a href="#5-常用文件IO函数" class="headerlink" title="5.常用文件IO函数"></a>5.常用文件IO函数</h3><h4 id="5-1-open函数"><a href="#5-1-open函数" class="headerlink" title="5.1 open函数"></a>5.1 open函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    打开文件，如果文件不存在则可以选择创建。</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件的路径及文件名</span><br><span class="line">    flags：打开文件的行为标志，必选项 O_RDONLY O_WRONLY O_RDWR</span><br><span class="line">    mode：这个参数，只有在文件不存在时有效，指新建文件时指定文件的权限</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回打开的文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>flags详细说明</strong></p>
<p>必选项：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_RDONLY</td>
<td>以只读的方式打开</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>以只写的方式打开</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>以可读、可写的方式打开</td>
</tr>
</tbody></table>
<p>可选项，和必选项按位或起来</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_CREAT</td>
<td>文件不存在则创建文件，使用此选项时需要使用mode说明文件的权限</td>
</tr>
<tr>
<td>O_EXCL</td>
<td>如果同时指定了O_CREAT，则文件已经存在，则会出错</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>如果文件存在，则清空文件内容</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>写文件时，数据添加到文件末尾</td>
</tr>
<tr>
<td>O_NONBLOCK</td>
<td>对于设备文件，以O_NONBLOCK方式打开可以做非阻塞I&#x2F;O</td>
</tr>
</tbody></table>
<p><strong>mode补充说明</strong></p>
<p>1）文件最终权限：mode &amp; ~umask</p>
<p>2）shell进程的umask掩码可以用umask命令查看</p>
<ul>
<li>umask：查看掩码（补码）</li>
<li>umask mode：设置掩码，mode为八进制数</li>
<li>umask -S:查看各组用户的默认操作权限</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>八进制</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>S_IRWXU</td>
<td>00700</td>
<td>文件拿使用者的读、写、可执行权限</td>
</tr>
<tr>
<td>S_IRUSR</td>
<td>00400</td>
<td>文件所有者的读权限</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>00200</td>
<td>文件所有者的写权限</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>00100</td>
<td>文件所有者的可执行权限</td>
</tr>
<tr>
<td>S_IRWXG</td>
<td>00070</td>
<td>文件所有这同组用户的读、写、可执行权限</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>00040</td>
<td>文件所有者同用户组的读权限</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>00020</td>
<td>文件所有者同组用户的写权限</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>00010</td>
<td>文件所有者同组的可执行权限</td>
</tr>
<tr>
<td>S_IRWXO</td>
<td>00007</td>
<td>其它用户的读、写、可执行权限</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>00004</td>
<td>其它用户的读权限</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>00002</td>
<td>其它用户的写权限</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>00001</td>
<td>其它用户的可执行权限</td>
</tr>
</tbody></table>
<h4 id="5-2-close函数"><a href="#5-2-close函数" class="headerlink" title="5.2 close函数"></a>5.2 close函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    关闭已打开的文件</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符，open()的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span>，并设置errno</span><br></pre></td></tr></table></figure>

<p>需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用close关闭，所有即使用用户程序不调用close，在终止时内核也会自动关闭它打开的文件。</p>
<p>但对于一个长年累月运行的程序（比如网络服务器），打开的文件描述符一定要记得关闭，负责随着打开的文件越多，会占用大量文件描述符和系统资源</p>
<h4 id="5-3-write函数"><a href="#5-3-write函数" class="headerlink" title="5.3 write函数"></a>5.3 write函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据写到文件（fd）</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    buf：数据首地址</span><br><span class="line">    count：写入数据的长度（字节）</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际写入数据的字节个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="5-4-read函数"><a href="#5-4-read函数" class="headerlink" title="5.4 read函数"></a>5.4 read函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据到内存（缓冲区）</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    buf：内存首地址</span><br><span class="line">    count：读取的字节个数</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际读取的字节个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h5 id="阻塞和非阻塞的概念"><a href="#阻塞和非阻塞的概念" class="headerlink" title="阻塞和非阻塞的概念"></a>阻塞和非阻塞的概念</h5><p>读常规文件是不会阻塞，不管读多少字节，read一定会在有限的事件内返回。</p>
<p>从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会阻塞，如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于会阻塞多少事件也是不确定的，如果一直没有数据到达就一直阻塞在那里。</p>
<p>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</p>
<p>【注意】阻塞与非阻塞是对于文件而言的，而不是指read、write等的属性。</p>
<h4 id="5-5-lseek函数"><a href="#5-5-lseek函数" class="headerlink" title="5.5 lseek函数"></a>5.5 lseek函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">功能：</span><br><span class="line">    改变文件的偏移量</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    offset：根据whence来移动的位移量（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。</span><br><span class="line">    </span><br><span class="line">    whence：其取值如下：</span><br><span class="line">        SEEK_SET: 从文件开头移动offset个字节数</span><br><span class="line">        SEEK_CUR: 从当前位置移动offset个字节数</span><br><span class="line">        SEEK_END: 从文件末尾移动offset个字节数</span><br><span class="line">返回值：</span><br><span class="line">    若lseek成功执行，则返回新的偏移量</span><br><span class="line">    如果失败，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="四、文件操作相关函数"><a href="#四、文件操作相关函数" class="headerlink" title="四、文件操作相关函数"></a>四、文件操作相关函数</h2><h3 id="1-stat函数"><a href="#1-stat函数" class="headerlink" title="1.stat函数"></a>1.stat函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取文件状态信息</span><br><span class="line">    stat和lstat的区别：</span><br><span class="line">        当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；</span><br><span class="line">        而stat返回的是该链接指向的文件的信息。</span><br><span class="line">参数：</span><br><span class="line">    path：文件名</span><br><span class="line">    buf：保存文件信息的结构体</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>struct stat结构体说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">               <span class="type">dev_t</span>     st_dev;    <span class="comment">//文件的设备编号</span></span><br><span class="line">               <span class="type">ino_t</span>     st_ino;    <span class="comment">//节点</span></span><br><span class="line">               <span class="type">mode_t</span>    st_mode;  <span class="comment">//文件的类型和存储的权限</span></span><br><span class="line">               <span class="type">nlink_t</span>   st_nlink; <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">               <span class="type">uid_t</span>     st_uid; <span class="comment">//用户ID</span></span><br><span class="line">               <span class="type">gid_t</span>     st_gid;<span class="comment">//组ID</span></span><br><span class="line">               <span class="type">dev_t</span>     st_rdev; <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">               <span class="type">off_t</span>     st_size; <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line">               <span class="type">blksize_t</span> st_blksize; <span class="comment">//块大小(文件系统I/O缓冲区大小)</span></span><br><span class="line">               <span class="type">blkcnt_t</span>  st_blocks;   <span class="comment">//块数</span></span><br><span class="line"></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">           <span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-stat获得文件类型-第一个版本"><a href="#1-1-stat获得文件类型-第一个版本" class="headerlink" title="1.1 stat获得文件类型(第一个版本)"></a>1.1 stat获得文件类型(第一个版本)</h4><p>之前说stat中有一个获取文件类型和存储权限中的st_mode，其实可以通过这个类型来获取文件的类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">show_file_type</span><span class="params">(<span class="keyword">struct</span> stat* s)</span>&#123;</span><br><span class="line">     <span class="keyword">switch</span>(s-&gt;st_mode &amp; S_IFMT)&#123;</span><br><span class="line">         <span class="keyword">case</span> S_IFREG:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;普通文件\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;目录\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;字符设备\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;块文件\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;套接字\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;管道\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;符号链接\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;未知的文件类型\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//容错判断</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ./a.out filename\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的很多内容都可以在官方手册上看到</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/stat.png"></p>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;st_mode &amp; S_IFMT</span><br></pre></td></tr></table></figure>

<p>是官方手册上规定的写法</p>
<p>运行时只需要执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out filename</span><br></pre></td></tr></table></figure>

<p>这里采用的是默认的编译</p>
<p>如果你使用了自定义文件名的话，只需要把 a.out 改成你自定义的文件名就可以了。</p>
<h4 id="1-2-第二种写法"><a href="#1-2-第二种写法" class="headerlink" title="1.2 第二种写法"></a>1.2 第二种写法</h4><p>在官方手册上还提供了第二种写法，比第一种要简单</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/st_mode%E7%9A%84%E7%AE%80%E5%8D%95%E5%86%99%E6%B3%95.png"></p>
<p>直接写代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">show_file_type</span><span class="params">(<span class="keyword">struct</span> stat* s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;普通文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目录\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISCHR(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符设备\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISBLK(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;块文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISSOCK(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;套接字\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(s-&gt;st_mode))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;符号链接\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知文件类型\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//容错判断</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out filename\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = stat(argv[<span class="number">1</span>], &amp;s);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    show_file_type(&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-获得文件权限"><a href="#1-3-获得文件权限" class="headerlink" title="1.3 获得文件权限"></a>1.3 获得文件权限</h4><p>在stat中st_mode中提供了查看文件权限的宏定义</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/stat%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">4</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="number">5</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"> <span class="number">6</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span> <span class="type">int</span> <span class="title function_">show_file_type</span><span class="params">(<span class="keyword">struct</span> stat* s)</span>&#123;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">if</span> (s-&gt;st_mode &amp; S_IRUSR)&#123;</span><br><span class="line"><span class="number">10</span>         <span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="number">13</span>         <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span>     <span class="keyword">if</span> (s-&gt;st_mode &amp; S_IWUSR)&#123;</span><br><span class="line"><span class="number">16</span>         <span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="number">19</span>         <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="number">20</span>     &#125;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">if</span> (s-&gt;st_mode &amp; S_IXUSR)&#123;</span><br><span class="line"><span class="number">22</span>         <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span>     <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="number">25</span>         <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span>     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="number">28</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">29</span> &#125;</span><br><span class="line"><span class="number">30</span> </span><br><span class="line"><span class="number">31</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line"><span class="number">32</span>     <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="number">33</span>     <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line"><span class="number">34</span> </span><br><span class="line"><span class="number">35</span>     <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="number">36</span>         <span class="built_in">printf</span>(<span class="string">&quot;./file_3 filename\n&quot;</span>);</span><br><span class="line"><span class="number">37</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">38</span>     &#125;</span><br><span class="line"><span class="number">39</span> </span><br><span class="line"><span class="number">40</span>     ret = stat(argv[<span class="number">1</span>], &amp;s);</span><br><span class="line"><span class="number">41</span>     <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="number">42</span>         perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line"><span class="number">43</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">44</span>     &#125;</span><br><span class="line"><span class="number">45</span>     show_file_type(&amp;s);</span><br><span class="line"><span class="number">46</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">47</span> &#125;                                    </span><br></pre></td></tr></table></figure>

<h3 id="2-access函数"><a href="#2-access函数" class="headerlink" title="2.access函数"></a>2.access函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> mode)</span>;</span><br><span class="line">功能：测试指定文件是否具有某种属性</span><br><span class="line">参数：</span><br><span class="line">    pathname:文件名</span><br><span class="line">    mode:文件权限，<span class="number">4</span>种权限</span><br><span class="line">        R_OK:	是否有读写权限</span><br><span class="line">        W_OK:	是否有写权限</span><br><span class="line">        X_OK:	是否有执行权限</span><br><span class="line">        F_OK:	测试文件是否存在</span><br><span class="line">返回值：</span><br><span class="line">    <span class="number">0</span>：有某种权限，或文件存在</span><br><span class="line">    <span class="number">-1</span>：没有，或文件不存在</span><br></pre></td></tr></table></figure>

<h3 id="3-chmod函数"><a href="#3-chmod函数" class="headerlink" title="3.chmod函数"></a>3.chmod函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：修改文件权限</span><br><span class="line">参数：</span><br><span class="line">    filename:文件名</span><br><span class="line">    mode:权限(<span class="number">8</span>进制数)</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-chown函数"><a href="#4-chown函数" class="headerlink" title="4.chown函数"></a>4.chown函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">uid_t</span> owner, <span class="type">git_t</span> group)</span>;</span><br><span class="line">功能：</span><br><span class="line">    修改文件所有者和所属组</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件或目录名</span><br><span class="line">    owner：文件所有者id，通过查看 /etc/passwd 得到所有者id</span><br><span class="line">    group:文件所属组id，通过 /etc/group 得到用户组id</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="5-truncate函数"><a href="#5-truncate函数" class="headerlink" title="5.truncate函数"></a>5.truncate函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">off_t</span> length)</span>;</span><br><span class="line">功能：修改文件大小</span><br><span class="line">参数：</span><br><span class="line">    path：文件名字</span><br><span class="line">    length：指定的文件大小</span><br><span class="line">        a)比用来小，删除后边的部分</span><br><span class="line">        b)比原来大，向后拓展</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="6-link函数"><a href="#6-link函数" class="headerlink" title="6.link函数"></a>6.link函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* oldpath, <span class="type">const</span> <span class="type">char</span>* newpath)</span>;</span><br><span class="line">功能：创建一个硬链接</span><br><span class="line">参数：</span><br><span class="line">    oldpath：源文件名字</span><br><span class="line">    newpath：硬链接名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="7-symlink函数"><a href="#7-symlink函数" class="headerlink" title="7.symlink函数"></a>7.symlink函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* target, <span class="type">const</span> <span class="type">char</span>* linkpath)</span>;</span><br><span class="line">功能：创建一个软链接</span><br><span class="line">参数：</span><br><span class="line">    target：源文件名字</span><br><span class="line">    linkpath：软链接名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="8-readlink函数"><a href="#8-readlink函数" class="headerlink" title="8.readlink函数"></a>8.readlink函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">char</span>* buf, <span class="type">size_t</span> bufsize)</span>;</span><br><span class="line">功能：读软连接对应的文件名，不是读内容(该函数只能读软链接文件)</span><br><span class="line">参数：</span><br><span class="line">    pathname：软连接名</span><br><span class="line">    buf：存放软链接对呀的文件名</span><br><span class="line">    bufsize：缓冲区大小(第二个参数存放的最大字节数)</span><br><span class="line">返回值：</span><br><span class="line">    成功：&gt;<span class="number">0</span>，读到buf中的字符个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="9-unlink函数"><a href="#9-unlink函数" class="headerlink" title="9.unlink函数"></a>9.unlink函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname)</span>;</span><br><span class="line">功能：删除一个文件(软硬链接文件)</span><br><span class="line">参数：</span><br><span class="line">    pathname：删除的文件名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="10-rename函数"><a href="#10-rename函数" class="headerlink" title="10.rename函数"></a>10.rename函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* oldpath, <span class="type">const</span> <span class="type">char</span>* newpath)</span>;</span><br><span class="line">功能：把oldpath的文件名改成newpath</span><br><span class="line">参数：</span><br><span class="line">    oldpath：旧文件名</span><br><span class="line">    newpath：新文件名</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="五、文件描述符复制"><a href="#五、文件描述符复制" class="headerlink" title="五、文件描述符复制"></a>五、文件描述符复制</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>dup() 和dup2() 是两个非常有用的系统调用，都是用来复制一个文件的描述符，使新的文件描述符也标识旧的文件描述符所标识的文件。</p>
<p>对于dup() dup2() 也一样，通过原来的文件描述符复制出一个新的文件描述符，这样的话，原来的我加你描述符和新的文件描述符都指向同一个文件，我们操作这两个文件描述符的任何一个，都能操作它所对应的文件。</p>
<h3 id="2-dup函数"><a href="#2-dup函数" class="headerlink" title="2.dup函数"></a>2.dup函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    通过 oldfd 复制出一个新的文件描述符，新的文件描述符表中最小可用的文件描述符，最终 oldfd 和新的文件描述符都指向同一个文件</span><br><span class="line">参数：</span><br><span class="line">    oldfd：需要复制的文件描述符 oldfd</span><br><span class="line">返回值：</span><br><span class="line">    成功：新文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%BB%93%E6%9E%84.png"></p>
<h3 id="3-dup2函数"><a href="#3-dup2函数" class="headerlink" title="3.dup2函数"></a>3.dup2函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    通过 oldfd 复制出一个新的文件描述符 newfd，如果成功，newfd 和函数返回值是同一个返回值，最终 oldfd 和新的文件描述符 newfd 都指向同一个文件。</span><br><span class="line">    oldfd：需要复制的文件描述符</span><br><span class="line">    newfd：新的文件描述符，这个描述符可以人为指定一个合法数字(<span class="number">0</span><span class="number">-1023</span>)，如果指定的数字已经被占用（和某个文件有关联），此函数会自动关闭close()断开这个数字和某个文件的关联，再来使用这个合法数字。</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回 newfd</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-案例分析"><a href="#4-案例分析" class="headerlink" title="4.案例分析"></a>4.案例分析</h3><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.png"></p>
<h3 id="5-fcntl函数"><a href="#5-fcntl函数" class="headerlink" title="5.fcntl函数"></a>5.fcntl函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line">功能：改变已打开的文件性质，fcntl针对描述符提供控制。</span><br><span class="line">参数：</span><br><span class="line">    fd：操作的文件操作符</span><br><span class="line">    cmd：操作方式</span><br><span class="line">    arg：针对cmd的值，fcntl能够接受第三个参数<span class="type">int</span> arg</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回某个其他值</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>fcntl函数有5种功能：</p>
<p>1）复制一个现有的描述符（cmd &#x3D; F_DUPFD）</p>
<p>2）获得 &#x2F; 设置文件描述符标记（cmd&#x3D;F_GETFD或F_SETFD）</p>
<p>3）获得 &#x2F; 设置文件状态标记（cmd&#x3D;F_GETFL或F_SETFL）</p>
<p>4）获得 &#x2F; 设置异步I&#x2F;O所有权（cmd&#x3D;F_GETOWN或F_SETOWN）</p>
<p>5）获得 &#x2F; 设置记录锁（cmd&#x3D;F_GETLK，F_SETLK或F_SETLKW）</p>
</blockquote>
<p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fcntl复制文件描述符功能</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> newfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="comment">//第三个参数0 表示返回第一个最小的可用的文件描述符，并且大于或等于0</span></span><br><span class="line">    newfd = fcntl(fd, F_DUPFD, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (newfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写文件</span></span><br><span class="line">    write(fd, <span class="string">&quot;123456789&quot;</span>, <span class="number">9</span>);</span><br><span class="line">    write(newfd, <span class="string">&quot;ABCDEFG&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    close(newfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-获得文件状态表示和设置"><a href="#5-1-获得文件状态表示和设置" class="headerlink" title="5.1 获得文件状态表示和设置"></a>5.1 获得文件状态表示和设置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fcntl复制文件描述符功能</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> newfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件状态标记</span></span><br><span class="line">    ret = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &amp; O_APPEND)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before not append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置文件状态标记</span></span><br><span class="line">    ret = ret | O_APPEND;</span><br><span class="line">    ret = fcntl(fd, F_SETFL, ret);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件状态标记</span></span><br><span class="line">    ret = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &amp; O_APPEND)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before not append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-目录习惯操作"><a href="#6-目录习惯操作" class="headerlink" title="6.目录习惯操作"></a>6.目录习惯操作</h3><h4 id="6-1-getcwd函数"><a href="#6-1-getcwd函数" class="headerlink" title="6.1 getcwd函数"></a>6.1 getcwd函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getcwd</span><span class="params">(<span class="type">char</span>* buf, <span class="type">sie_t</span> size)</span>;</span><br><span class="line">功能：获取当前进程的工作目录</span><br><span class="line">参数：</span><br><span class="line">    buf：缓冲区，存储当前的工作目录</span><br><span class="line">    size：缓冲区大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：buf中保存当前进程工作目录位置</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-chdir函数"><a href="#6-2-chdir函数" class="headerlink" title="6.2 chdir函数"></a>6.2 chdir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span>;</span><br><span class="line">功能：修改当前进程(应用程序)的路径</span><br><span class="line">参数：</span><br><span class="line">    path：切换的路径</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-opendir函数"><a href="#6-3-opendir函数" class="headerlink" title="6.3 opendir函数"></a>6.3 opendir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR* <span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br><span class="line">功能：打开一个目录</span><br><span class="line">参数：</span><br><span class="line">    name：目录名</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回指向该目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="6-4-closedir函数"><a href="#6-4-closedir函数" class="headerlink" title="6.4 closedir函数"></a>6.4 closedir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR* dirp)</span>;</span><br><span class="line">功能：关闭目录</span><br><span class="line">参数：</span><br><span class="line">    dirp：opendir返回的指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="6-5-readdir函数"><a href="#6-5-readdir函数" class="headerlink" title="6.5 readdir函数"></a>6.5 readdir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent* <span class="title function_">readdir</span><span class="params">(DIR* dirp)</span>;</span><br><span class="line">功能：读取目录</span><br><span class="line">参数：</span><br><span class="line">    dirp：opendir的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p>相关结构体说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>&#123;</span></span><br><span class="line">    <span class="type">ino_t</span> d_ino;	<span class="comment">//此目录进入点的inode</span></span><br><span class="line">    <span class="type">off_t</span> d_off;	<span class="comment">//目录文件开头至目录进入点的位移</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">short</span> <span class="type">int</span> d_reclen;	<span class="comment">//d_name的长度，不包含NULL字符</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> d_type;	<span class="comment">//d_type所指的文件类型</span></span><br><span class="line">    <span class="type">char</span> d_name[<span class="number">256</span>];	<span class="comment">//文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>d_type文件类型说明</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DT_BLK</td>
<td>块设备</td>
</tr>
<tr>
<td>DT_CHR</td>
<td>字符设备</td>
</tr>
<tr>
<td>DT_DIR</td>
<td>目录</td>
</tr>
<tr>
<td>DT_LNK</td>
<td>软链接</td>
</tr>
<tr>
<td>DT_FIFO</td>
<td>管道</td>
</tr>
<tr>
<td>DT_REG</td>
<td>普通文件</td>
</tr>
<tr>
<td>DT_SOCK</td>
<td>套接字</td>
</tr>
<tr>
<td>DT_UNKNOWN</td>
<td>未知</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//目录打开和关闭</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    DIR* dir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">d</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//打开目录</span></span><br><span class="line">    dir = opendir(<span class="string">&quot;/home/pi/student/student03&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;dir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开目录成功...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//循读取目录中的内容</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        d = readdir(dir);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file_type:%hu\tfile_name:%s\n&quot;</span>, d-&gt;d_type, d-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="六、进程"><a href="#六、进程" class="headerlink" title="六、进程"></a>六、进程</h2><h3 id="1-进程和程序"><a href="#1-进程和程序" class="headerlink" title="1.进程和程序"></a>1.进程和程序</h3><p>程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。程序是静态的，进程是动态的。</p>
<p>在linux系统中，操作系统是通过进程去完成一个一个的任务，进程是管理事务的基本单元。</p>
<p>进程拥有自己独立的处理环境（如：当前需要用到哪些环境变量，程序运行的目录在哪是，当前是哪个用户在运行此程序等）和系统资源（如：处理器CPU占用率、存储器、I&#x2F;O设备、数据、程序）。</p>
<h3 id="2-单道、多道程序设计"><a href="#2-单道、多道程序设计" class="headerlink" title="2.单道、多道程序设计"></a>2.单道、多道程序设计</h3><h4 id="2-1-单道程序设计"><a href="#2-1-单道程序设计" class="headerlink" title="2.1 单道程序设计"></a>2.1 单道程序设计</h4><p>所有进程一个一个排队执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现是必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p>
<h4 id="2-2-多道程序设计"><a href="#2-2-多道程序设计" class="headerlink" title="2.2 多道程序设计"></a>2.2 多道程序设计</h4><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p>
<p>在计算机中时钟中断即为多道程序设计模型的理论基础。并发时，任意进程在执行期间都不希望放弃CPU。因此系统需要一种强制让进程让出CPU资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。操作系统中的中断处理函数来负责调度程序执行。</p>
<p>在多道程序设计模型中，多个进程轮流使用CPU（（分时复用CPU资源）。而当下常用CPU为纳秒级，1秒可执行大约10亿条指令。由于人眼的反应是毫秒级的，所以看似同时进行。</p>
<blockquote>
<p>1s &#x3D; 1000ms</p>
<p>1ms &#x3D; 1000um</p>
<p>1um &#x3D; 1000ns</p>
<p>1s &#x3D; 1000000000ns</p>
</blockquote>
<h3 id="3-并行和并发"><a href="#3-并行和并发" class="headerlink" title="3.并行和并发"></a>3.并行和并发</h3><p>**并行(parallel):**指同一时刻，有多条指令在多个处理器上同时执行</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B9%B6%E8%A1%8C.png"></p>
<p>**并发(concurrency):**指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使得进程快速交替的执行</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%B9%B6%E5%8F%91.png"></p>
<h3 id="4-MMU"><a href="#4-MMU" class="headerlink" title="4.MMU"></a>4.MMU</h3><p>MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中原来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/MMU.png"></p>
<h3 id="5-进程控制块PCB"><a href="#5-进程控制块PCB" class="headerlink" title="5.进程控制块PCB"></a>5.进程控制块PCB</h3><p>进程运行时，内核为进程每个进程分配一个PCB（进程控制块），维护相关信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>其内部成员有很多，掌握以下部分即可</p>
<ul>
<li>进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</li>
<li>进程的状态，有就绪、运行、挂起、停止等状态</li>
<li>进程切换时需要保存和恢复的一些CPU存储器</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息。</li>
<li>当前工作目录（Current Working Directory）。</li>
<li>umask掩码</li>
<li>文件描述符，包含很多指向file结构体的指针。</li>
<li>和信号相关的信息</li>
<li>用户id和组id</li>
<li>会话（Session）和进程组</li>
<li>进程可以使用的资源上限（Resource Limit）。</li>
</ul>
<h3 id="6-进程的状态"><a href="#6-进程的状态" class="headerlink" title="6.进程的状态"></a>6.进程的状态</h3><p>进程状态反应进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。</p>
<p>在三态模型中，进程状态分为三个基本状态，即<strong>运行态、就绪态、阻塞态。</strong></p>
<p>在五态模型中，进程分为<strong>新建态、终止态、运行态、就绪态、阻塞态。</strong></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png"></p>
<p>查看进程的方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>

<h4 id="6-1-ps"><a href="#6-1-ps" class="headerlink" title="6.1 ps"></a>6.1 ps</h4><p>进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。</p>
<p>ps命令可以查看进程的详细情况，常用选项(选项可以不加”-“)如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示终端上的所有进程，包括其它用户的进程</td>
</tr>
<tr>
<td>-u</td>
<td>显示进程的详细状态</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
<tr>
<td>-w</td>
<td>显示加宽，以便显示更多的信息</td>
</tr>
<tr>
<td>-r</td>
<td>只显示正在运行的进程</td>
</tr>
</tbody></table>
<h4 id="6-2-top"><a href="#6-2-top" class="headerlink" title="6.2 top"></a>6.2 top</h4><p>top命令用来动态显示运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。可以在top命令时加上-d来指定显示信息更新的时间间隔。</p>
<p>在top命令执行后，可以按下按键得到对显示的结果进行排序：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>M</td>
<td>根据内存使用量来排序</td>
</tr>
<tr>
<td>P</td>
<td>根据CPU占有率来排序</td>
</tr>
<tr>
<td>T</td>
<td>根据进程运行时间的长短来排序</td>
</tr>
<tr>
<td>U</td>
<td>可以根据后面输入的用户名筛选进程</td>
</tr>
<tr>
<td>K</td>
<td>可以根据后面输入的PID来杀死进程</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>h</td>
<td>获得帮助</td>
</tr>
</tbody></table>
<h4 id="6-3-kill"><a href="#6-3-kill" class="headerlink" title="6.3 kill"></a>6.3 kill</h4><p>kill命令指定进程号的进程，需要配合ps使用</p>
<p>使用格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-signal] pid</span><br></pre></td></tr></table></figure>

<p>信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。</p>
<p>有些进程没办法直接杀死，需要添加 <code>-9</code> 参数强制杀死</p>
<h4 id="6-4-killall"><a href="#6-4-killall" class="headerlink" title="6.4 killall"></a>6.4 killall</h4><p>通过名字杀死进程</p>
<h3 id="7-进程号和相关函数"><a href="#7-进程号和相关函数" class="headerlink" title="7.进程号和相关函数"></a>7.进程号和相关函数</h3><p>每个进程都由一个进程号标识，其类型为pid_t（整形），进程号的范围：0~32767.进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用。</p>
<p><strong>进程号（PID）：</strong></p>
<p>标识进程的一个非负整形数</p>
<p><strong>父进程号（PPID）：</strong></p>
<p>任何进程（除init进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。如，A进程创建了B进程，A的进程号就是B进程的父进程号。</p>
<p><strong>进程组号（PGID）：</strong></p>
<p>进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。这个过程有点类似于QQ群，各个进程相当于各个好友，把各个好友都拉入这个QQ群里，主要是方便管理，特别是通知某些事时，只要在群里吼一声，所有人都收到，简单粗暴。但是，这个进程组号和QQ群号是有区别的，默认的情况下，当前的进程号会当作当前的进程号。</p>
<h4 id="7-1-getpid函数"><a href="#7-1-getpid函数" class="headerlink" title="7.1 getpid函数"></a>7.1 getpid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取本进程号（PID）</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    本进程号</span><br></pre></td></tr></table></figure>

<h4 id="7-2-getppid函数"><a href="#7-2-getppid函数" class="headerlink" title="7.2 getppid函数"></a>7.2 getppid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：获取调用此函数的进程的父进程号</span><br><span class="line">参数：无</span><br><span class="line">返回值：调用此函数的进程的父进程号（PPID）</span><br></pre></td></tr></table></figure>

<h4 id="7-3-getpgid函数"><a href="#7-3-getpgid函数" class="headerlink" title="7.3 getpgid函数"></a>7.3 getpgid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取进程组号（PGID）</span><br><span class="line">参数：</span><br><span class="line">    查询进程的进程号</span><br><span class="line">返回值：</span><br><span class="line">    进程组号（PGID）</span><br></pre></td></tr></table></figure>

<h4 id="7-4-示例"><a href="#7-4-示例" class="headerlink" title="7.4 示例"></a>7.4 示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取进程号 父进程号 进程组号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//获取当前进程的进程号</span></span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程号:%d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前进程的父进程号</span></span><br><span class="line">    pid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父进程号:%d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前进程组号</span></span><br><span class="line">    pid = getpgid(getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程组号:%d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-进程的创建"><a href="#8-进程的创建" class="headerlink" title="8.进程的创建"></a>8.进程的创建</h3><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程呢个，形成进程树结构模型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：用于从一个已经存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程。</span><br><span class="line">参数：无</span><br><span class="line">返回值：</span><br><span class="line">    成功：子进程中返回<span class="number">0</span>，父进程中返回子进程ID。<span class="type">pid_t</span>为整形</span><br><span class="line">    失败：返回<span class="number">-1</span></span><br><span class="line">    失败的两个原因：</span><br><span class="line">        <span class="number">1</span>）当前的进程数已经达到了系统规定的上限，这时errno的值为EAGAIN。</span><br><span class="line">        <span class="number">2</span>）系统内存不足，这时errno的值被设置为ENOMEM。</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,word\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,word</span><br><span class="line">hello,word</span><br></pre></td></tr></table></figure>

<h3 id="9-父子进程关系"><a href="#9-父子进程关系" class="headerlink" title="9.父子进程关系"></a>9.父子进程关系</h3><p>使用fork()函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。</p>
<p>子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用fork()函数的代价是很大的。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png"></p>
<p>简单来说，一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p>
<p>实际上，更准确来说，Linux的fork()使用是通过写时拷贝（copy-on-write）实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只要在需要写入的社会才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</p>
<p>注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件文件偏移指针。</p>
<h3 id="10-区分父子进程"><a href="#10-区分父子进程" class="headerlink" title="10.区分父子进程"></a>10.区分父子进程</h3><p>子进程是父进程的一个复制品，可以简单认为父子进程的代码一样。父进程做了什么事，子进程也做什么事，如果我们需要实现多任务的要求该如何实现呢？答案是通过fork()的返回值。</p>
<p>fork()函数被调用一次，但返回两次。两次返回的区别是：子进程的返回值是0，而父进程的返回值则是子进程的ID。</p>
<p>测试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> child_id;</span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程创建失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id: %d  pid: %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id: %d  child_id: %d\n&quot;</span>, getpid(), child_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-父子进程地址空间"><a href="#11-父子进程地址空间" class="headerlink" title="11.父子进程地址空间"></a>11.父子进程地址空间</h3><p>父进程的值是在单独的空间，子进程的值是在单独空间，两者修改不会互相影响。</p>
<p>如果是在堆区开辟的空间也不会相互受到影响，但是记住一定要释放一下开辟出来的空间，比如下面的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> child_id;</span><br><span class="line">    <span class="type">int</span>* num = <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *num = <span class="number">200</span>;</span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程创建失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_id == <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程:%d\n&quot;</span>, *num);</span><br><span class="line">        <span class="built_in">free</span>(num);</span><br><span class="line">        num = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程前:%d\n&quot;</span>, *num);</span><br><span class="line">        (*num)++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程后:%d\n&quot;</span>, *num);</span><br><span class="line">        <span class="built_in">free</span>(num);</span><br><span class="line">        num = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不两次释放会导致内存溢出</p>
<h3 id="12-GDB调试多进程"><a href="#12-GDB调试多进程" class="headerlink" title="12.GDB调试多进程"></a>12.GDB调试多进程</h3><p>使用GDB调试的时候，GDB只能跟踪一个进程。可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者各种子进程。默认跟踪父进程。</p>
<ul>
<li>set follow-fork-mode child	设置GDB在fork之后跟踪子进程。</li>
<li>set follow-fork-mode parent  设置跟踪父进程（默认）</li>
</ul>
<p>注意，一定要在fork函数调用之前设置才有效</p>
<h3 id="13-进程退出函数"><a href="#13-进程退出函数" class="headerlink" title="13.进程退出函数"></a>13.进程退出函数</h3><p>相关函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line">功能：</span><br><span class="line">    结束调用此函数的进程。</span><br><span class="line">参数：</span><br><span class="line">    status：返回值给父进程的参数（低<span class="number">8</span>位有效），至于这个参数是多少根据需求来写。</span><br><span class="line">返回值：</span><br><span class="line">    无</span><br></pre></td></tr></table></figure>

<p>exit() 和 _exit() 函数功能和用法是一样的，无非是所包含的头文件不一样，exit() 属于标准库函数， _exit() 属于系统调用函数。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%80%80%E5%87%BA%E8%BF%9B%E7%A8%8B%E5%87%BD%E6%95%B0.png"></p>
<h3 id="14-等待进程退出函数"><a href="#14-等待进程退出函数" class="headerlink" title="14.等待进程退出函数"></a>14.等待进程退出函数</h3><h4 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h4><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号、退出状态、允许时间等）。</p>
<p>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除这个进程。</p>
<p>wait() 和 waitpid() 函数的功能一样，区别在于， wait() 函数会阻塞， waitpid() 可以设置不阻塞， waitpid() 还可以指定等待哪个子进程结束。</p>
<p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
<h4 id="14-2-wait函数"><a href="#14-2-wait函数" class="headerlink" title="14.2 wait函数"></a>14.2 wait函数</h4><p>函数说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>* status)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    status：进程结束时的状态信息</span><br><span class="line">返回值：</span><br><span class="line">    成功：已经结束子进程的进程号</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>调用 wait() 函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号才被唤醒（相当于继续往下执行）。</p>
<p>若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。</p>
<p>所以，wait()函数的主要功能为回收已经结束子进程的资源。</p>
<p>如果参数status的值不是NULL，wait() 就会把子进程退出时的状态取出并存入其中，这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的。</p>
<p>这个退出信息在一个int中包含了多个字段，直接使用这个值是没有意义的，我们需要用宏定义取出其中的每个字段。</p>
<p><strong>宏函数可以分为如下三组：</strong></p>
<p>1）WIFEXITED(status)</p>
<p>​	为非0 进程正常结束</p>
<p>WEXITSTATUS(status)</p>
<p>​	如果宏为真，使用此宏 获取进程退出状态（exit的参数）</p>
<p>2）WIFSIGNALED(status)</p>
<p>​	为非0 进程异常终止</p>
<p>WTERMSIG(status)</p>
<p>​	如上宏为真，使用此宏 取得进程终止的那个信号的编号</p>
<p>3）WIFSTOPPED(status)</p>
<p>​	为非0 进程处于暂停状态</p>
<p>WSTOPSIG(status)</p>
<p>​	如上宏为真，使用此宏 取得使进程暂停的那个信号的编号</p>
<p>WIFCONTINUED(status)</p>
<p>​	为真 进程暂停后已经继续运行</p>
<h4 id="14-3-waitpid函数"><a href="#14-3-waitpid函数" class="headerlink" title="14.3 waitpid函数"></a>14.3 waitpid函数</h4><p>函数说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">pid_d <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* status, <span class="type">int</span> options)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    pid：参数 pid 的值有以下几种类型：</span><br><span class="line">    pid &gt; <span class="number">0</span> 等待进程 ID 等于 pid 的子进程</span><br><span class="line">    pid = <span class="number">0</span> 等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid 不会等待它。</span><br><span class="line">    pid = <span class="number">-1</span> 等待任意子进程，此时 waitpid 和 wait 作用一样。</span><br><span class="line">    pid &lt; <span class="number">-1</span> 等待指定进程组中的任何子进程，这个进程组的 ID 等于 pid 的绝对值。</span><br><span class="line">    </span><br><span class="line">    status：进程退出时的状态信息。和 wait() 用法一样。</span><br><span class="line">    </span><br><span class="line">    options：options 提供了一些额外的选项来控制 waitpid()。</span><br><span class="line">        <span class="number">0</span>：同 wait(),阻塞父进程，等待子进程退出。</span><br><span class="line">        WNOHANG:没有任何已经结束的子进程，则立刻返回</span><br><span class="line">        WUNTRACED:如果子进程暂停了则此函数马上返回，并且不予理会子进程的结束状态。（由于涉及到一些调试方面的知识，加之极少用到）</span><br><span class="line">返回值：</span><br><span class="line">    waitpid() 的返回值比 wait() 稍微复杂一些，一共有 <span class="number">3</span> 种情况：</span><br><span class="line">        <span class="number">1</span>) 当正常返回的时候，waitpid() 返回收集到的已经回收子进程的进程号；</span><br><span class="line">        <span class="number">2</span>) 如果设置了选项 WNOHANG，而调用中 waitpid() 发现没有已退出的子进程可等待，则返回 <span class="number">0</span>；</span><br><span class="line">        <span class="number">3</span>) 如果调用中出错，则返回<span class="number">-1</span>，这时 errno 会被设置成相应的值以指示错误所在，如：当 pid 所对应的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid() 就会出错返回，这时 errno 被设置为 ECHILD；</span><br></pre></td></tr></table></figure>

<h3 id="15-孤儿进程"><a href="#15-孤儿进程" class="headerlink" title="15.孤儿进程"></a>15.孤儿进程</h3><p>父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程（Orphan Process）。</p>
<p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。</p>
<p>因此孤儿进程并不会有什么危害。</p>
<h3 id="16-僵尸进程"><a href="#16-僵尸进程" class="headerlink" title="16.僵尸进程"></a>16.僵尸进程</h3><p>进程终止，父进程尚未回收子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</p>
<p>这样就会导致一个问题，如果进程不调用wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有进程号而导致系统不能产生新的进程，这就是僵尸进程的危害，应当避免。</p>
<h3 id="17-进程替换"><a href="#17-进程替换" class="headerlink" title="17.进程替换"></a>17.进程替换</h3><p><strong>概述</strong></p>
<p>在Windows平台下，我们可以通过双击运行可执行程序成为一个进程；而在Linux平台，我们可以通过 <code>./</code> 运行，让一个可执行程序成为一个进程。</p>
<p>但是，如果我们本来就运行着一个程序（进程），我们如何在这个进程内部启动一个外部程序，由内核将这个程序读入内存，使其执行起来成为一个进程呢？这里我们通过 exec 函数族实现。</p>
<p>exec 函数族，顾名思义，就是一簇函数，在Linux中，并不存在 exec() 函数，exec 指的是一组函数，一共有6个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...<span class="comment">/*(char*)NULL */</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* arg, ...<span class="comment">/*(char*)NULL */</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...<span class="comment">/*(char*)NULL char* const envp[]*/</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<p>其中只有 execve() 是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</p>
<p>exec函数族的作用是根据指定的文件名或目录名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p>
<p>进程调用一种exec函数时，该进程完全由新程序交替，而新程序则从其main函数开始执行。因为调用exec并吧创建新进程，所以前后的进程 ID （当然还有父进程号、进程组号、当前工作目录……）并未改变。exec 只是用另一个新程序替换了当前进程的正文、数据、堆和栈段（进程替换）。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2.png"></p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/home&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、进程间通讯"><a href="#七、进程间通讯" class="headerlink" title="七、进程间通讯"></a>七、进程间通讯</h2><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p>
<p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信（IPC：Inter Processes Communication）。</p>
<p>进程间通讯的目的：</p>
<ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li>
<li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li>
</ul>
<p><strong>Linux 操作系统支持的主要进程间通信的通信机制：</strong></p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E8%BF%9B%E7%A8%8B%E4%B8%AD%E9%80%9A%E8%AE%AF%E6%A6%82%E5%BF%B5.png"></p>
<h3 id="1-无名管道"><a href="#1-无名管道" class="headerlink" title="1.无名管道"></a>1.无名管道</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>管道也叫无名管道，它是UNIX系统IPC（进程间通信）的最古老形式，所有的UNIX系统都支持这种通信机制。</p>
<p><strong>管道有如下特点：</strong></p>
<p>1）半双工，数据在同一时刻只能在一个方向上流动。</p>
<p>2）数据只能从管道的一端写入，从另一端读出。</p>
<p>3）写入管道中的数据遵循先入后出的规则。</p>
<p>4）管道所传送的数据是无格式的，这要求管道的读出方必须事先约定好数据的格式，如多少字节算一个消息等。</p>
<p>5）管道不是普通的文件，不属于某个文件系统，其只存放于内存中。</p>
<p>6）管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。</p>
<p>7）从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据。</p>
<p>8）管道没有名字，只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</p>
<p>对于管道特点的理解，我们可以类比实现生活中管子，管子的一端塞东西，管子的另一端取东西。</p>
<p>管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93.png"></p>
<h4 id="1-2-pipe函数"><a href="#1-2-pipe函数" class="headerlink" title="1.2 pipe函数"></a>1.2 pipe函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line">功能：创建无名管道。</span><br><span class="line">    </span><br><span class="line">参数：</span><br><span class="line">    pipefd：为 <span class="type">int</span> 型数组的首地址，其存放了管道的文件描述符 pipefd[<span class="number">0</span>]、pipefd[<span class="number">1</span>]。</span><br><span class="line">    </span><br><span class="line">    当一个管道建立时，它会创建两个文件描述符 fd[<span class="number">0</span>] 和 fd[<span class="number">1</span>]。其中 fd[<span class="number">0</span>] 固定用于读管道，而 fd[<span class="number">1</span>] 固定用于写管道。一般文件 I/O的函数都可以用来操作管道(lseek() 除外)。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>例子：父子进程通过无名管道进行通讯</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父子进程通讯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> read_string[SIZE];</span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>, child_id = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> read_bool = <span class="number">-1</span>, write_bool = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建无名管道</span></span><br><span class="line">    ret = pipe(pd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子进程 读内容</span></span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//禁用写端</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取管道中的内容</span></span><br><span class="line">        read_bool = read(pd[<span class="number">0</span>], read_string, SIZE);</span><br><span class="line">        <span class="keyword">if</span> (read_bool &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child read: %s\n&quot;</span>, read_string);</span><br><span class="line">        <span class="comment">//禁用读端</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父进程 写内容</span></span><br><span class="line">    <span class="comment">//关闭读管道</span></span><br><span class="line">    close(pd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    write_bool = write(pd[<span class="number">1</span>], <span class="string">&quot;ABCDEFGHIJK&quot;</span>, SIZE);</span><br><span class="line">    <span class="keyword">if</span>(write_bool &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent process write len: %d\n&quot;</span>, write_bool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭写管道</span></span><br><span class="line">    close(pd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意一下，创建匿名管道的时候需要在创建进程前创建，如果按照下面的代码创建匿名管道：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>], ret, i;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">            ret = read(fd[<span class="number">0</span>], buf, <span class="number">20</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, ret, buf);</span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">            ret = write(fd[<span class="number">1</span>], <span class="string">&quot;abcd&quot;</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            close(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样会导致子进程读不出父进程向管道传入的数据，原因是因为在创建好子进程后，子进程后父进程分别创建了一个管道，子进程使用的管道是子进程自己创建的管道，而父进程使用的管道是父进程创建的管道，父进程向管道中传入内容，其实是向它自己创建的管道中传入内容，而子进程读取管道中的内容是读取自己管道中的内容，所以子进程读不出来内容。 </p>
<h4 id="1-3-管道的读写特点"><a href="#1-3-管道的读写特点" class="headerlink" title="1.3 管道的读写特点"></a>1.3 管道的读写特点</h4><p>使用管道需要注意一下4种特殊情况（假设都是阻塞I&#x2F;O操作，没有设置O_NONBLOCK标志）：</p>
<p>1）如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</p>
<p>2）如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</p>
<p>3）如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。</p>
<p>4）如果有指向管道读端的文件描述符没关闭（管道读端引用计数器大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p>
<p><strong>总结：</strong></p>
<p><strong>读管道：</strong></p>
<ul>
<li>管道中有数据，read返回实际读到的字节数。</li>
<li>管道中无数据：<ul>
<li>管道写端被全部关闭，read返回0（相当于读到文件结尾）</li>
<li>写端没有全部被关闭，read阻塞等待（不久的将来可能有数据递达，此时会让出CPU）</li>
</ul>
</li>
</ul>
<p><strong>写管道：</strong></p>
<ul>
<li>管道读端全部被关闭，进程异常终止（也可使用捕捉SIGPIPE信号，使进程终止）</li>
<li>管道读端没有全部关闭：<ul>
<li>管道已满，write阻塞。</li>
<li>管道未满，writr将数据写入，并返回实际写入的字节数</li>
</ul>
</li>
</ul>
<h4 id="1-4-设置为非阻塞的方法"><a href="#1-4-设置为非阻塞的方法" class="headerlink" title="1.4 设置为非阻塞的方法"></a>1.4 设置为非阻塞的方法</h4><p>设置方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取原来的flags</span></span><br><span class="line"><span class="type">int</span> flage = fcntl(fd[<span class="number">0</span>], F_GETFL);</span><br><span class="line"><span class="comment">//设置新的flags</span></span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line"><span class="comment">//flags = flags | O_NONBLOCK;</span></span><br><span class="line">fcntl(fd[<span class="number">0</span>], F_SETFL, flags);</span><br></pre></td></tr></table></figure>

<p>结论：如果写端没有关闭，读端设置为非阻塞，直接返回-1。</p>
<h4 id="1-5-查看管道缓冲区命令"><a href="#1-5-查看管道缓冲区命令" class="headerlink" title="1.5 查看管道缓冲区命令"></a>1.5 查看管道缓冲区命令</h4><p>可以使用ulimit-a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小</p>
<h4 id="1-6-查看管道缓冲区函数"><a href="#1-6-查看管道缓冲区函数" class="headerlink" title="1.6 查看管道缓冲区函数"></a>1.6 查看管道缓冲区函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line">功能：该函数可以通过name参数查看不同的属性值</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    name：</span><br><span class="line">        _PC_PIPE_BUF,查看管道缓冲区大小</span><br><span class="line">        _PC_NAME_MAX,文件名字字节数的上限</span><br><span class="line">返回值：</span><br><span class="line">    成功：根据name返回的值的意义也不同。</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>], ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建无名管道</span></span><br><span class="line">    ret = pipe(pd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看管道缓冲区函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, fpathconf(pd[<span class="number">0</span>], _PC_PIPE_BUF));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, fpathconf(pd[<span class="number">0</span>], _PC_NAME_MAX));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-有名管道"><a href="#2-有名管道" class="headerlink" title="2.有名管道"></a>2.有名管道</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>无名管道由于没有名字，只能用于亲缘关系的进程间通讯。为了克服这个缺点，提出了明名管道（FIFO），也叫有民管道、FIFO文件。</p>
<p>命名管道（FIFO）不同于无名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通讯，因此，通过FIFO不相关的进程也能交换数据。</p>
<p>命名管道（FIFO）和无名管道（pipe）有一些特点是相同的，不一样的地方在于：</p>
<p>1）FIFO在文件系统中作为一个特殊的文件而存在，但FIFO中的内容却存放在内存中。</p>
<p>2）当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。</p>
<p>3）FIFO有名字，不相关的进程可以通过打开命名管道进行通讯。</p>
<h4 id="2-2-通过命令创建有名管道"><a href="#2-2-通过命令创建有名管道" class="headerlink" title="2.2 通过命令创建有名管道"></a>2.2 通过命令创建有名管道</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93.png"></p>
<h4 id="2-3-通过函数创建有名管道"><a href="#2-3-通过函数创建有名管道" class="headerlink" title="2.3 通过函数创建有名管道"></a>2.3 通过函数创建有名管道</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：</span><br><span class="line">    命名管道的创建。</span><br><span class="line">参数：</span><br><span class="line">    pathname : 普通的路径名，也就是创建后 FIFO 的名字。</span><br><span class="line">    mode : 文件的权限，与打开普通文件的 open() 函数中的 mode 参数相同。（<span class="number">0666</span>）</span><br><span class="line">返回值：</span><br><span class="line">    成功: <span class="number">0</span>	状态码</span><br><span class="line">    失败：如果文件已经存在，则会出错且返回<span class="number">-1</span>。    </span><br></pre></td></tr></table></figure>

<h4 id="2-4-有名管道读写操作"><a href="#2-4-有名管道读写操作" class="headerlink" title="2.4 有名管道读写操作"></a>2.4 有名管道读写操作</h4><p>一旦使用mkfifo创建一个FIFO，就可以使用open打开它，常见的文件I&#x2F;O函数都可用于fifo。如：close、read、write、unlink等。</p>
<p>FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始到处返回数据，对它们的写则把数据添加到末尾。<strong>它们不支持诸如lseek()等文件定位操作。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*write.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fp = <span class="number">-1</span>, ret = <span class="number">-1</span>, i = <span class="number">14</span>;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="comment">//打开有名管道</span></span><br><span class="line">    fp = open(<span class="string">&quot;fifo&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写内容</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, SIZE);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello itcast:%d&quot;</span>, i);</span><br><span class="line">        ret = write(fp, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write fifo : %d\n&quot;</span>, ret);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭管道</span></span><br><span class="line">    close(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*read.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd =<span class="number">-1</span>, ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;fifo&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read....\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ret = read(fd, buf, SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-有名管道注意事项"><a href="#2-5-有名管道注意事项" class="headerlink" title="2.5 有名管道注意事项"></a>2.5 有名管道注意事项</h4><p>1）一个为只读而打开一个管道的进程会阻塞直到另一个进程为只写打开该管道</p>
<p>2）一个为只写而打开一个管道的进程会阻塞直到另一个进程为只读打开管道</p>
<p><strong>读管道：</strong></p>
<ul>
<li>管道中有数据，read返回实际读到的字节数。</li>
<li>管道中无数据：<ul>
<li>管道写端被全部关闭，read返回0（相当于读到文件结尾）</li>
<li>写端没有全部被关闭，read阻塞等待</li>
</ul>
</li>
</ul>
<p><strong>写管道：</strong></p>
<ul>
<li>管道读端全部被关闭，进程异常终止（也可使用捕捉SIGPIPE信号，使进程终止）</li>
<li>管道读端没有全部关闭：<ul>
<li>管道已满，write阻塞。</li>
<li>管道未满，write将数据写入，并返回实际写入的字节数。</li>
</ul>
</li>
</ul>
<h3 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3.消息队列"></a>3.消息队列</h3><p>在上面说了一下管道，学习完管道后发现管道是一端发送什么，另一端就只能接收什么，而且只能传递一种类型，但在实际的项目中，有些时候需要选择性的接收另一端传递过来的数据，为了解决这个问题，Linux中出现了一个叫做消息队列的东西。</p>
<h4 id="3-1-什么是消息队列"><a href="#3-1-什么是消息队列" class="headerlink" title="3.1 什么是消息队列"></a>3.1 什么是消息队列</h4><p>消息队列其实是一个在内核地址空间中的内部链表，每一个链表的内容是一个数据块，数据块中能存放的内容有很多的类型，这些可以自己去定义，而且还能选择性的进行接收数据。</p>
<h4 id="3-2-通过命令查看消息队列"><a href="#3-2-通过命令查看消息队列" class="headerlink" title="3.2 通过命令查看消息队列"></a>3.2 通过命令查看消息队列</h4><p>在Linux中可以使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcs -q</span><br></pre></td></tr></table></figure>

<p>来查看一下当前系统中的消息队列的个数和每个消息队列的大小</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png"></p>
<h4 id="3-3-创建消息队列"><a href="#3-3-创建消息队列" class="headerlink" title="3.3 创建消息队列"></a>3.3 创建消息队列</h4><p>可以使用<code>msgget</code>函数创建出一个消息队列，函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgfig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    功能：创建接口队列</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        key:消息队列中的键值，通常使用ftok()函数进行创建</span></span><br><span class="line"><span class="comment">        msgfig:权限标志</span></span><br><span class="line"><span class="comment">            IPC_CREATE:如果key值所对应的消息队列不存在，那么就创建一个</span></span><br><span class="line"><span class="comment">            IPC_EXCL:</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="4-共享存储映射"><a href="#4-共享存储映射" class="headerlink" title="4.共享存储映射"></a>4.共享存储映射</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>存储映射I&#x2F;O(Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84.png"></p>
<p>于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I&#x2F;O操作。</p>
<p>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式，因为进程可以直接读写内存，而不需要任何数据的拷贝。</p>
<h4 id="4-2-存储映射函数"><a href="#4-2-存储映射函数" class="headerlink" title="4.2 存储映射函数"></a>4.2 存储映射函数</h4><h5 id="（1）mmap函数"><a href="#（1）mmap函数" class="headerlink" title="（1）mmap函数"></a>（1）mmap函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    一个文件或者其它对象映射进内存</span><br><span class="line">参数：</span><br><span class="line">    addr ： 指定映射的起始地址，通常设为<span class="literal">NULL</span>，由系统指定</span><br><span class="line">    length ： 映射到内存的文件长度</span><br><span class="line">    prot ： 映射区的保护方式，最常用的：</span><br><span class="line">        a) 读：PROT_READ</span><br><span class="line">        b) 写：PROT_WRITE</span><br><span class="line">        c) 读写：PROT_READ | PROT_WRITE</span><br><span class="line">    flags: 映射区的特性，可以是</span><br><span class="line">        a) MAP_SHARED : 写入映射区的数据会复制回文件，且允许其它映射该文件的进程共享。</span><br><span class="line">        b) MAP_PRIVATE : 对映射区的写入操作会产生一个映射区的复制(copy - on - write)，对此区域所做的修改不会写回原文件。</span><br><span class="line">    fd: 由open返回的文件描述符，代表要映射的文件。</span><br><span class="line">    offset: 以文件开始处的偏移量，必须是<span class="number">4</span>k的整数倍，通常为<span class="number">0</span>，表示从文件头开始映射</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回创建的映射区首地址</span><br><span class="line">    失败：MAP_FAILED宏</span><br></pre></td></tr></table></figure>

<p>关于mmap函数的使用总结：</p>
<p>1）第一个参数写成NULL</p>
<p>2）第二个参数要映射的文件大小 &gt;0</p>
<p>3）第三个参数：PROT_READ、PROT_WRITE</p>
<p>4）第四个参数：MAP_SHARED 或者 MAP_PRIVATE</p>
<p>5）第五个参数：打开的文件对应的文件描述符</p>
<p>6）第六个参数：4k的整数倍，通常为0</p>
<h5 id="（2）munmap函数"><a href="#（2）munmap函数" class="headerlink" title="（2）munmap函数"></a>（2）munmap函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line">功能：</span><br><span class="line">    释放内存映射区</span><br><span class="line">参数：</span><br><span class="line">    addr: 使用mmap函数创建的映射区的首地址</span><br><span class="line">    length: 映射区的大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3 注意事项"></a>4.3 注意事项</h4><p>1）创建映射区的过程中，隐含着一次对映射文件的读操作。</p>
<p>2）当MAP_SHARED时，要求映射区的权限应 &lt;&#x3D;文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</p>
<p>3）映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。</p>
<p>4）特别注意，当映射文件大小为0时，不能创建映射区。所以，用于映射的文件必须要有实际大小。mmap使用时常常会出现总线程错误，通常是由于共享文件存储空间大小引起的。</p>
<p>5）munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。</p>
<p>6）如果文件偏移量必须为4K的整数倍。</p>
<p>7）mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</p>
<h4 id="4-4-共享映射的方式操作文件"><a href="#4-4-共享映射的方式操作文件" class="headerlink" title="4.4 共享映射的方式操作文件"></a>4.4 共享映射的方式操作文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取文件成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建映射</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建映射成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;关闭文件描述符成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向映射区写内容</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr, <span class="string">&quot;123456789&quot;</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存区</span></span><br><span class="line">    ret = munmap(addr, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;释放内存成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-共享映射实现父子进程通讯"><a href="#4-5-共享映射实现父子进程通讯" class="headerlink" title="4.5 共享映射实现父子进程通讯"></a>4.5 共享映射实现父子进程通讯</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* mp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">pid_t</span> child_id = <span class="number">-1</span>; </span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建映射</span></span><br><span class="line">    mp = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mp == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    child_id = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_id == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_id == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">memcpy</span>(mp, <span class="string">&quot;abcdefg&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mp:%s\n&quot;</span>, (<span class="type">char</span>*)mp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放内存映射</span></span><br><span class="line">    munmap(mp, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-不同进程使用存储映射进行进程间通讯"><a href="#4-6-不同进程使用存储映射进行进程间通讯" class="headerlink" title="4.6 不同进程使用存储映射进行进程间通讯"></a>4.6 不同进程使用存储映射进行进程间通讯</h4><p>write.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加映射</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存映射添加成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">//写文件</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr, <span class="string">&quot;qwertyuiop&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放映射内存</span></span><br><span class="line">    ret = munmap(addr, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;释放映射内存成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加映射</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存映射添加成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">//读文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">void</span>*)addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放映射内存</span></span><br><span class="line">    ret = munmap(addr, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;释放映射内存成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-7-匿名映射实现父子进程通讯"><a href="#4-7-匿名映射实现父子进程通讯" class="headerlink" title="4.7 匿名映射实现父子进程通讯"></a>4.7 匿名映射实现父子进程通讯</h4><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程通讯间也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。</p>
<p>通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。可以直接使用匿名映射来代替。</p>
<p>其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定</p>
<p>使用<strong>MAO_ANONYMOUS(或MAP_ANON)</strong>。</p>
<p><code>int* p - mmap(NULL, 4, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</code></p>
<ul>
<li>4“随意举例，该位置表示映射区大小，可依实际需要填写”。</li>
<li>MAP_ANONYMOUS 和 MAP_ANON 这两个宏是Linux操作系统特有的宏。推荐使用 <strong>MAP_ANONYMOUS</strong>。</li>
</ul>
<p>程序实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* arrd = <span class="literal">NULL</span>;</span><br><span class="line">    arrd = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (arrd == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    pd = fork();</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向文件中写内容</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(arrd, <span class="string">&quot;hello,word&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读文件中的内容</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arrd:%s\n&quot;</span>, (<span class="type">char</span>*)arrd);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭映射</span></span><br><span class="line">    munmap(arrd, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、信号"><a href="#八、信号" class="headerlink" title="八、信号"></a>八、信号</h2><h3 id="1-信号的概述"><a href="#1-信号的概述" class="headerlink" title="1.信号的概述"></a>1.信号的概述</h3><p>信号是Linux进程通讯的最古老的方式。信号是软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
<p><strong>信号的特点</strong></p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特设条件才发送</li>
</ul>
<p>信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。</p>
<p>一个完整的信号周期包括三个部分：信号的产生，信号在进程中的注册，信号在进程中的注销，执行信号处理函数。如下图所示：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E8%BF%B0.jpg"></p>
<p>注意：这里信号的产生，注册，注销时信号的内部机制，而不是信号的函数实现。</p>
<h3 id="2-信号的编号"><a href="#2-信号的编号" class="headerlink" title="2.信号的编号"></a>2.信号的编号</h3><p>1）信号编号：</p>
<p>Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了修改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p>
<p>Linux 可使用命令：kill -l，查看相应的信号</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%96%E5%8F%B7.png"></p>
<p>不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。</p>
<p>2）Linux常规信号一览表</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>信号</th>
<th>对应事件</th>
<th>默认动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>用户推出shell时，由该shell启动的所有进程将收到这个信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>当用户按下了**&lt;Ctrl+C&gt;**组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>用户按下了**&lt;ctrl+\&gt;**组合键时产生了该信号，用户终端向正在运行中的由该终端启动的程序发出些信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>CPU检测到某进程执行了非法指令</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>该信号由断点指令或其他trap指令产生</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>调用abort函数时产生该信号</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS</td>
<td>非法访问内存地址，包括内存对齐出错</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的运算时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止进程。本信号不能被忽略，处理和阻塞</td>
<td>终止进程，可以杀死任何进程</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSE1</td>
<td>用户定义的信号。即程序员可以在程序中定义并使用该信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>指示进程进行了无效内存访问（段错误）</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>另外一个用户自定义信号，程序员可以在程序中定义并使用该型号</td>
<td>终止进程</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>Broken pipe向一个没有读端的管道写数据</td>
<td>终止进程</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>定时器超时，超时的时间由系统调用alarm设置</td>
<td>终止进程</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令kill时，缺省产生这个信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>16</td>
<td>SIGSTKFLT</td>
<td>Linux早期版本出现的信号，现仍保留向后兼容</td>
<td>终止进程</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>子进程结束时，父进程会收到这个信号</td>
<td>忽略这个信号</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>如果进程已停止，则使其继续运行</td>
<td>继续&#x2F;忽略</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>停止进程的执行。信号不能被忽略，处理和阻塞</td>
<td>为终止进程</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号</td>
<td>暂停进程</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>后台进程读终端控制台</td>
<td>暂停进程</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生</td>
<td>暂停进程</td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程</td>
<td>终止进程</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>超过文件的最大长度设置</td>
<td>终止进程</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTLRM</td>
<td>虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用s’j</td>
<td>终止进程</td>
</tr>
<tr>
<td>27</td>
<td>SGIPROF</td>
<td>类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间</td>
<td>终止进程</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>窗口变化大小时发出</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO</td>
<td>此信号向进程指示发出了一个异步IO事件</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>关机</td>
<td>终止进程</td>
</tr>
<tr>
<td>31</td>
<td>SIGSYS</td>
<td>无效的系统调用</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>34~64</td>
<td>SIGRTMIN~</td>
<td>Linux的实时信号，它们没有固定的含义（可以自定义）</td>
<td>终止进程</td>
</tr>
</tbody></table>
<h3 id="3-信号四要素"><a href="#3-信号四要素" class="headerlink" title="3.信号四要素"></a>3.信号四要素</h3><p>每个信号必备4要素，分别是：</p>
<p>1）编号 2）名称 3）事件 4）默认处理动作</p>
<p>可通过 <strong>man 7 signal</strong> 查看帮助文档获取：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9B%9B%E8%A6%81%E7%B4%A0.png"></p>
<p>我这个是 arm 架构的，和教程上的不一样。</p>
<p>在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他框架，最后一个应用于mips架构。一个’-‘表示在对应架构上尚未定义该信号。</p>
<p>不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号。</p>
<p>Action为默认动作：</p>
<ul>
<li>Term：终止进程</li>
<li>lgn：忽略信号（默认即使对该种信号忽略操作）</li>
<li>Core：终止进程，生成Core文件。（查验死亡原因，用于gdb调试）</li>
<li>Stop：停止（暂停）进程</li>
<li>Cont：继续运行进程</li>
</ul>
<p>注意通过 man 7 signal 命令查看帮助文档，其中可看到：The signals <strong>SIGKILL</strong> and <strong>SIGSTOP</strong> cannot be caught，blocked，or ignored。</p>
<p>这里特别强调了 <strong>SIGKILL 和 SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></p>
<p>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送（但不一定递达），不应乱发信号！！！</p>
<h3 id="4-信号的状态"><a href="#4-信号的状态" class="headerlink" title="4.信号的状态"></a>4.信号的状态</h3><p><strong>1）产生</strong></p>
<p>a）当用户按某些终端键时，将产生信号。</p>
<p>​	终端上按“ctrl+c”组合键通常产生中断信号 SIGINT</p>
<p>​	终端上按“ctrl+\”键通常产生中断信号 SIGQUIT</p>
<p>​	终端上按“ctrl+z”键通常产生中断信号 SIGSTOP等。</p>
<p>b）硬件异常将产生信号。</p>
<p>除数为0，无效的内存访问等。这些情况通常由硬件检测到，并通知内核，然后内核产生适当的信号发送给相应的进程。</p>
<p>c）软件异常将产生信号。</p>
<p>当检测到某种软件条件已发生（如：定时器alarm），并将其通知有关进程时，产生信号。</p>
<p>d）调用系统函数（如：kill、raise、abort）将发送信号。</p>
<p>注意：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。</p>
<p>e）运行 kill &#x2F; killall命令将发送信号。</p>
<p>此程序实际上是使用 kill 函数来发送信号。也常用此命令终止一个失控的后台进程。 </p>
<p><strong>2）未决状态：没有被处理</strong></p>
<p><strong>3）递达状态：信号被处理了</strong></p>
<h3 id="5-阻塞信号集和未决信号集"><a href="#5-阻塞信号集和未决信号集" class="headerlink" title="5.阻塞信号集和未决信号集"></a>5.阻塞信号集和未决信号集</h3><p>信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。</p>
<p>Linux内核的进程控制块PCB是一个结构体，task_struct，除了包含进程id、状态、工作目录、用户id、组id、文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集。</strong></p>
<h4 id="5-1-阻塞信号集（信号屏蔽字）"><a href="#5-1-阻塞信号集（信号屏蔽字）" class="headerlink" title="5.1 阻塞信号集（信号屏蔽字）"></a>5.1 阻塞信号集（信号屏蔽字）</h4><p>将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，该信号的处理将推后（处理发送在解除屏蔽后）。</p>
<h4 id="5-2-未决信号集"><a href="#5-2-未决信号集" class="headerlink" title="5.2 未决信号集"></a>5.2 未决信号集</h4><p>信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位反转回为0.这一时刻往往非常短暂。</p>
<p>信号产生后由于某些原因（主要是阻塞）不能抵达。这类信号的集合称为未决信号集。在屏蔽解除前，信号一直处于未决状态。</p>
<h3 id="6-信号产生函数"><a href="#6-信号产生函数" class="headerlink" title="6.信号产生函数"></a>6.信号产生函数</h3><h4 id="6-1-kill函数"><a href="#6-1-kill函数" class="headerlink" title="6.1 kill函数"></a>6.1 kill函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#Include &lt;sys/types.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给指定进程发送指定信息（不一定杀死）</span><br><span class="line">    </span><br><span class="line">参数：</span><br><span class="line">    pid ： 取值有<span class="number">4</span>种情况：</span><br><span class="line">        pid &gt; <span class="number">0</span>:将信号传送给进程 ID 为pid的进程</span><br><span class="line">        pid = <span class="number">0</span>:将信号传送给当前进程所在进程组中的所有进程。</span><br><span class="line">        pid = <span class="number">-1</span>:将信号传送给系统内所有的进程。</span><br><span class="line">        pid &lt; <span class="number">-1</span>:将信号传送给指定进程组的所有进程。这个进程组号等于 pid 的绝对值。</span><br><span class="line">    sig：信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill -l 进行查看。不推荐直接使用数字，应该使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</span><br><span class="line">    返回值：</span><br><span class="line">            成功： <span class="number">0</span></span><br><span class="line">            失败： <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>super用户（root）可以发送信号给容易用户，普通用户是不能向系统用户发送信号的。</p>
<p>kill -9（root用户的pid）是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号。</p>
<p>普通用户基本规则是：发送者实际或有效用户ID &#x3D;&#x3D; 接收者实际或有效用户ID</p>
<p>程序示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    pd = fork();</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pd == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child is run\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child is not good\n&quot;</span>);</span><br><span class="line">        kill(pd, SIGTERM);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-raise函数"><a href="#6-2-raise函数" class="headerlink" title="6.2 raise函数"></a>6.2 raise函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给当前进程发送指定信号（自己给自己发），等价于 kill(getpid(), sig)</span><br><span class="line">参数：</span><br><span class="line">    sig：信号编号</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>值</span><br></pre></td></tr></table></figure>

<p>程序示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;run:%d\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">4</span>)&#123;</span><br><span class="line">            raise(SIGALRM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-abort函数"><a href="#6-3-abort函数" class="headerlink" title="6.3 abort函数"></a>6.3 abort函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：给自己发送异常终止信号 SIGABRT，并产生core文件，等价于 kill(getpid(), SIGABRT);</span><br><span class="line">参数：无</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<h4 id="6-4-alarm函数-闹钟"><a href="#6-4-alarm函数-闹钟" class="headerlink" title="6.4 alarm函数(闹钟)"></a>6.4 alarm函数(闹钟)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line">功能:</span><br><span class="line">    设置定时器(闹钟)。在指定的seconds后，内核会给当前进程发送 SIGALRM 信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。</span><br><span class="line">     取消定时器alarm(<span class="number">0</span>)，返回旧闹钟余下秒数。</span><br><span class="line">参数:</span><br><span class="line">    seconds: 指定的时间，以秒为单位</span><br><span class="line">返回值:</span><br><span class="line">    返回<span class="number">0</span>或剩余的秒数</span><br></pre></td></tr></table></figure>

<p>定时，与进程状态无关（自然定时法）！就绪、运行、挂起（阻塞、暂停）、终止、僵尸….无论进程处于何种状态，alarm都计时。</p>
<p>测试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在运行程序\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    ret = alarm(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;之前的闹钟无效了，之前还剩 %d 秒\n&quot;</span>, ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按任意键退出...&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-5-setitimer函数（定时器）"><a href="#6-5-setitimer函数（定时器）" class="headerlink" title="6.5 setitimer函数（定时器）"></a>6.5 setitimer函数（定时器）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval* new_value, <span class="keyword">struct</span> itimerval* old_value)</span>;</span><br><span class="line">功能:</span><br><span class="line">    设置定时器(闹钟)。可代替alarm函数。精度微秒us，可以实现周期定时。</span><br><span class="line">参数:</span><br><span class="line">    which: 指定定时方法</span><br><span class="line">         a) 自然定时: ITIMER_REAL → SUGALR计算自然时间</span><br><span class="line">         b) 虚拟空间计时(用户空间): ITIMER_VIRTUAL → SIGPROF计算进程占用cpu的时间</span><br><span class="line">         c) 运行时计时(用户 + 内核): ITIMER_PROF → SIGPROF计算占用cpu及执行系统调用的时间</span><br><span class="line">    new_value: </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>&#123;</span></span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_interval</span>;</span> <span class="comment">//闹钟触发周期</span></span><br><span class="line">             <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_value</span>;</span>   <span class="comment">//闹钟触发时间</span></span><br><span class="line">         &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">            <span class="type">long</span> tv_sec;	<span class="comment">//秒</span></span><br><span class="line">            <span class="type">long</span> tv_user;	<span class="comment">//毫秒</span></span><br><span class="line">        &#125;;</span><br><span class="line">        itimerval.it_vale: 设定一次执行function所延迟的秒数</span><br><span class="line">        itimerval.it_interval: 设定以后每几秒执行function</span><br><span class="line">    old_value: 存放旧的timeout值，一般指定为<span class="literal">NULL</span></span><br><span class="line">返回值:</span><br><span class="line">    成功: <span class="number">0</span></span><br><span class="line">    失败: <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>程序示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">iti</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//第一次触发时间</span></span><br><span class="line">    iti.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    iti.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//触发周期</span></span><br><span class="line">    iti.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    iti.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    ret = setitimer(ITIMER_REAL, &amp;iti, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setitmer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键退出...\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-信号集"><a href="#7-信号集" class="headerlink" title="7.信号集"></a>7.信号集</h3><h4 id="7-1-信号集概述"><a href="#7-1-信号集概述" class="headerlink" title="7.1 信号集概述"></a>7.1 信号集概述</h4><p>在PCB中有两个非常重要的信号集。一个称为“阻塞信号集”，另一个称为“未决信号集”。</p>
<p>这两个信号集都是内核使用<strong>位图机制</strong>来实现的。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数对PCB中的这两个信号集进行修改。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%A6%82%E8%BF%B0.png"></p>
<h4 id="7-2-自定义信号集函数"><a href="#7-2-自定义信号集函数" class="headerlink" title="7.2 自定义信号集函数"></a>7.2 自定义信号集函数</h4><p>为了方便对多个信号进行处理，一个用户进程常常需要对多个信号做出处理，在Linux系统中引入了信号集（信号的集合）。</p>
<p>这个信号集有点类似于我们的QQ群，一个个的信号相当于QQ群里的一个个好友。</p>
<p>信号集是一个能表示多个信号的数据类型，sigset_t set，set即一个信号集。既然是一个集合，就需要对集合进行添加&#x2F;删除等操作。</p>
<p>相关函数说明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;	<span class="comment">//将set集合置空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(sigset* <span class="built_in">set</span>)</span>;	<span class="comment">//将所有信号加入set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(sigset* <span class="built_in">set</span>, <span class="type">int</span> signo)</span>;	<span class="comment">//将signo信号加入到set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signo)</span>; <span class="comment">//从set集合中移除signo信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">int</span> signo)</span>; <span class="comment">//判断信号是否存在</span></span><br></pre></td></tr></table></figure>

<p>除sigismember外，其余操作函数中的set均为传出参数。sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</p>
<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印信号集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_sigset</span><span class="params">(<span class="type">sigset_t</span>* s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sigismember(s, i))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">//清空信号集</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有信号加入set集中</span></span><br><span class="line">    sigfillset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将signo信号移除</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGHUP);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将signo信号重新加入到set集合中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGHUP);</span><br><span class="line">    print_sigset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-sigprocmask函数"><a href="#7-3-sigprocmask函数" class="headerlink" title="7.3 sigprocmask函数"></a>7.3 sigprocmask函数</h4><p>信号阻塞也称信号屏蔽集、信号掩码。每个进程都有应该阻塞集，创建进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。</p>
<p>所谓阻塞并不是禁止传送信号，而是暂缓信号的传送。若将阻塞的信号从信号阻塞集中删除，且对应的信号在阻塞时发生了，进程将会收到相应的信号。</p>
<p>我们可以通过 sigprocmask() 修改当前的信号掩码来改变信号的阻塞情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>, <span class="type">sigset_t</span>* oldset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改信号阻塞集，根据 how 指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由 <span class="built_in">set</span> 指定，而原先的信号阻塞集合由 oldset 保存。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    how：信号阻塞集合的修改方法，有<span class="number">3</span>种情况：</span><br><span class="line">        SIG_BLOCK:向信号阻塞集合中添加 <span class="built_in">set</span> 信号集，新的信号掩码是<span class="built_in">set</span>和旧信号掩码的并集。相当于 mask = mask|<span class="built_in">set</span>。</span><br><span class="line">        SIG_UNBLOCK:从信号阻塞集合中删除 <span class="built_in">set</span> 信号集，从当前信号掩码中去除 <span class="built_in">set</span> 中的信号。相当于 mask = mask &amp; ~ <span class="built_in">set</span>。</span><br><span class="line">        SIG_SETMASK:将信号阻塞集合设为 <span class="built_in">set</span> 信号集，相当于原来信号阻塞集的内容清空，然后按照 <span class="built_in">set</span> 中的信号重新设置信号阻塞集，相当于 mask = <span class="built_in">set</span>。</span><br><span class="line">    <span class="built_in">set</span>：要操作的信号集地址。</span><br><span class="line">            若 <span class="built_in">set</span> 为 <span class="literal">NULL</span>，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到 oldset 中。</span><br><span class="line">    oldset：保存原来信号阻塞地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span>，失败时错误代码只可能是 EINVAL，表示参数 how不合法。</span><br></pre></td></tr></table></figure>

<h4 id="7-4-sigpending函数"><a href="#7-4-sigpending函数" class="headerlink" title="7.4 sigpending函数"></a>7.4 sigpending函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;</span><br><span class="line">功能：读取当前进程的未决信号集</span><br><span class="line">参数：</span><br><span class="line">    <span class="built_in">set</span>：未决信号集</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="8-信号捕捉"><a href="#8-信号捕捉" class="headerlink" title="8.信号捕捉"></a>8.信号捕捉</h3><h4 id="8-1-信号处理方式"><a href="#8-1-信号处理方式" class="headerlink" title="8.1 信号处理方式"></a>8.1 信号处理方式</h4><p>一个进程收到一个信号的时候，可以用如下方式进行处理：</p>
<p>1）执行系统默认动作</p>
<p>对于大多数信号来说，系统默认动作是用来终止该进程。</p>
<p>2）忽略此信号（丢弃）</p>
<p>接收到此信号后没有任何动作。</p>
<p>3）执行自定义信号处理函数（捕捉）</p>
<p>用用户定义的信号处理函数处理该信号。</p>
<p>【注意】：SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。</p>
<p>内核实现信号捕捉过程：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9B%BE%E7%89%87%5C%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89.png"></p>
<h4 id="8-2-signal函数"><a href="#8-2-signal函数" class="headerlink" title="8.2 signal函数"></a>8.2 signal函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line">功能：</span><br><span class="line">    注册信号处理函数（不可用于 SIGKILL、SIGSTOP 信号），即确定收到信号后处理函数的入口地址。此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    signum：信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill -l进行相应查看。</span><br><span class="line">    handler：取值有 <span class="number">3</span> 种情况：</span><br><span class="line">        SIG_IGN:忽略该信号</span><br><span class="line">        SIG_DFL:执行系统默认动作</span><br><span class="line">        信号处理函数名：自定义信号处理函数，如：func</span><br><span class="line">        回调函数的定义如下：</span><br><span class="line">            <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">                <span class="comment">//signo 为触发的信号，为signal() 第一个参数的值</span></span><br><span class="line">            &#125;</span><br><span class="line">返回值：</span><br><span class="line">    成功：第一次返回 <span class="literal">NULL</span>，下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面先声明此函数指针的类型。</span><br><span class="line">    失败：返回 SIG_ERR</span><br></pre></td></tr></table></figure>

<p>该函数由ANSI定义，因为Unix和Linux版本的原因不推荐使用这个函数，取而代之的是sigaction函数</p>
<h4 id="8-3-sigaction函数"><a href="#8-3-sigaction函数" class="headerlink" title="8.3 sigaction函数"></a>8.3 sigaction函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oldact)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改指定信号的设置（或同时执行这两种操作）。</span><br><span class="line">参数：</span><br><span class="line">    signum：要操作的信号。</span><br><span class="line">    act：要设置的对信号的新处理方式（传入参数）。</span><br><span class="line">    oldact：原来对信号的处理方式（传入参数）。</span><br><span class="line">    如果 act 指针非空，则要改变指定信号的处理方式（设置），如果 oldact 指针非空，则系统将此前指定信号的处理方式存入 oldact。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>struct sigaction结构体：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">    <span class="type">void</span>(*sa_handler)(<span class="type">int</span>); <span class="comment">//旧的信号处理函数指针</span></span><br><span class="line">    <span class="type">void</span>(*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span>*, <span class="type">void</span>* ); <span class="comment">//新的信号处理函数指针</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;	<span class="comment">//信号阻塞集</span></span><br><span class="line">    <span class="type">int</span> sa_flags;	<span class="comment">//信号处理的方式</span></span><br><span class="line">    <span class="type">void</span>(*sa_restorer)(<span class="type">void</span>); <span class="comment">//已弃用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1）sa_handler、sa_sigaction：信号处理函数指针，如signal()里的函数指针用法一样，应根据情况给 sa_sigaction、sa_handler 两者之一赋值，其取值如下：</p>
<p>a）SIG_IGN：忽略该信号</p>
<p>b）SIG_DFL:执行系统默认动作</p>
<p>c）处理函数名：自定义信号处理函数</p>
<p>2）sa_mask：信号阻塞集，在信号处理函数执行过程中，临时屏蔽指定的信号。</p>
<p>3）sa_flags：用于指定信号处理的行为，通常设置为0，表使用默认属性。它可以是一下值的”按位或“组合：</p>
<ul>
<li>SA_RESTART：使被信号打断的系统调用自动重新发起（已经废弃）</li>
<li>SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到SIGCHLD信号。</li>
<li>SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到SIGCHLD信号，这时子进程如果退出也不会成为僵尸进程。</li>
<li>SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。</li>
<li>SA_RESETHAND：信号处理之后重新设置为默认的处理方式。</li>
<li>SA_SIGINFO：使用sa_sigaction成员而不是sa_handler作为信号处理函数。</li>
</ul>
<p><strong>信号处理函数：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*sa_sigaction)(<span class="type">int</span> signum, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* context);</span><br><span class="line">参数说明：</span><br><span class="line">    signum：信号的编号。</span><br><span class="line">    info：记录信号发送进程信号的结构体。</span><br><span class="line">    context：可以赋给指向 <span class="type">ucontext_t</span> 类型的一个对象的指针，以引用在传递信号时被中断的接收进程或线程的上下文。</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signum, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* context)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号:%d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_sigaction = fun1;</span><br><span class="line">    <span class="comment">//标志指定使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按回车退出...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-不可重入、可重入"><a href="#9-不可重入、可重入" class="headerlink" title="9.不可重入、可重入"></a>9.不可重入、可重入</h3><p>如果一个函数不幸被设计成为这样：那么不同任务调用这个函数时可能修改其它任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数。</p>
<p>满足下列条件的函数是不可重入（不安全）的：</p>
<ul>
<li>函数体内使用了静态的数据结构</li>
<li>函数体内调用了malloc() 或者 free() 函数（谨慎使用堆）</li>
<li>函数体内调用了标准 I&#x2F;O 函数</li>
</ul>
<p>相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？所谓可重入函数是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。</p>
<p>保证函数的可重入性的方法：</p>
<ul>
<li>在写函数时尽量使用局部变量（例如寄存器、栈中的变量）</li>
<li>对于要使用的全局变量要加以保护（如采取关中断、信号量等互斥方法），这样构成的函数就一定是一个可重入的函数</li>
</ul>
<p><strong>注意：信号处理函数是可重入函数</strong></p>
<h3 id="10-SIGCHLE信号"><a href="#10-SIGCHLE信号" class="headerlink" title="10.SIGCHLE信号"></a>10.SIGCHLE信号</h3><h4 id="10-1-SIGCHLD信号产生的条件"><a href="#10-1-SIGCHLD信号产生的条件" class="headerlink" title="10.1 SIGCHLD信号产生的条件"></a>10.1 SIGCHLD信号产生的条件</h4><p>1）子进程终止时</p>
<p>2）子进程接收到SIGSTOP信号停止时</p>
<p>3）子进程处在停止态，接受到SIGCONT后唤醒时</p>
<h4 id="10-2-如何避免僵尸进程"><a href="#10-2-如何避免僵尸进程" class="headerlink" title="10.2 如何避免僵尸进程"></a>10.2 如何避免僵尸进程</h4><p>1）最简单的方式，父进程通过wait()和waitpid()等待子进程结束，但是，这会导致父进程挂起。</p>
<p>2）如果父进程要处理的事情很多，不能够挂起，通过 signal() 函数人为处理信号 SIGCHLD，只要子进程退出自动调用指定好的回调函数，因为子进程结束后，父进程会收到该信号 SIGCHLD，可以在其回调函数里调用wait() 或 waitpid() 回收</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signum, <span class="type">siginfo_t</span>* info, <span class="type">void</span>* context)</span>&#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程结束了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_sigaction = fun1;</span><br><span class="line">    <span class="comment">//标志指定使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    ret = sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3）如果父进程不关心子进程什么时候结束，那么可以用signal(SIGCHLD, SIG_IGN) 通知内核，自己对子进程的结束不感兴趣，父进程忽略此信号，那么子进程结束后，内核回收，并不再给父进程发送信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程结束了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="九、守护进程-线程"><a href="#九、守护进程-线程" class="headerlink" title="九、守护进程-线程"></a>九、守护进程-线程</h2><h3 id="1-终端的概念"><a href="#1-终端的概念" class="headerlink" title="1.终端的概念"></a>1.终端的概念</h3><p>在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端（Controlling Terminal），进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。</p>
<p>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是用户的键盘输入，进程往标准输出或标准错误输出也写到显示器上。</p>
<p>信号中还讲过，在控制终端输入有些特殊的控制按键可以给前台进程发信号，例如Ctrl+C表示SIGINT，Ctrl+\表示SIGQUIT。</p>
<p>函数说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">ttyname</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line">功能：由文件描述符查出对应的文件名</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">返回值：</span><br><span class="line">    成功：终端名</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h3 id="2-进程组概念"><a href="#2-进程组概念" class="headerlink" title="2.进程组概念"></a>2.进程组概念</h3><h4 id="2-1-进程组概述"><a href="#2-1-进程组概述" class="headerlink" title="2.1 进程组概述"></a>2.1 进程组概述</h4><p>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。<strong>代表一个或多个进程的集合。</strong></p>
<p>每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。</p>
<p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID为第一个进程ID（组长进程）。所以，组长进程标识：其进程组ID为其进程ID。</p>
<p>可以使用<strong>kill -SIGKILL -进程组ID</strong>（负的）来将整个进程组内的进程全部杀死：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BB%88%E7%AB%AF%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5.png"></p>
<p>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</p>
<p>进程组生存期：进程组创建的最后一个进程离开（终止或转移到另一个进程组）。</p>
<p>一个进程可以为自己或子进程设置进程组ID。</p>
<h4 id="2-2-相关函数说明"><a href="#2-2-相关函数说明" class="headerlink" title="2.2 相关函数说明"></a>2.2 相关函数说明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能:获取当前进程组的进程ID;</span><br><span class="line">参数:无;</span><br><span class="line">返回值:总是返回调用者的进程组ID;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能:获取指定进程的进程组ID;</span><br><span class="line">参数:</span><br><span class="line">    pid:进程号，如果pid = <span class="number">0</span>，那么该函数作用和getpgrp一样</span><br><span class="line">返回值:</span><br><span class="line">    成功：进程组ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> setpgid(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid);</span><br><span class="line">功能：</span><br><span class="line">    改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。</span><br><span class="line">参数：</span><br><span class="line">    将参<span class="number">1</span>对应的进程，加入参<span class="number">2</span>对应的进程组中</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-会话"><a href="#3-会话" class="headerlink" title="3.会话"></a>3.会话</h3><h4 id="3-1-会话概述"><a href="#3-1-会话概述" class="headerlink" title="3.1 会话概述"></a>3.1 会话概述</h4><p>会话是一个或多个进程组的集合。</p>
<ul>
<li>一个会话可以有一个控制终端。这通常是终端设备或伪终端设备；</li>
<li>建立与控制终端连接的会话首进程被称为控制进程</li>
<li>一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，其它进程组为后台进程组</li>
<li>如果终端接口检测到断开连接，则将挂断信号发送至控制进程（会话首进程）。</li>
</ul>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BC%9A%E8%AF%9D.png"></p>
<h4 id="3-2-创建会话注意事项"><a href="#3-2-创建会话注意事项" class="headerlink" title="3.2 创建会话注意事项"></a>3.2 创建会话注意事项</h4><p>1）调用进程不能是进程组组长，该进程变成新会话首进程(session header)</p>
<p>2）该调用进程是组长进程，则出错返回</p>
<p>3）该进程成为一个新进程组的组长进程</p>
<p>4）需要root权限(ubuntu不需要)</p>
<p>5）新会话丢弃原有的控制终端，该会话没有控制终端</p>
<p>6）建立新会话时，先调用fork，父进程终止，子进程调用setsid</p>
<h4 id="3-3-API函数介绍"><a href="#3-3-API函数介绍" class="headerlink" title="3.3 API函数介绍"></a>3.3 API函数介绍</h4><p>getsid函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能: 获取进程所属的会话ID</span><br><span class="line">参数: </span><br><span class="line">    pid: 进程号，pid为<span class="number">0</span>表示查看当前进程session ID</span><br><span class="line">返回值：</span><br><span class="line">    返回值：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</p>
<p>setsid函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能:</span><br><span class="line">    创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。调用了setsid函数的进程，既是新的会长，也是新的组长。</span><br><span class="line">参数: 无</span><br><span class="line">返回值: </span><br><span class="line">    成功：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-守护进程"><a href="#4-守护进程" class="headerlink" title="4.守护进程"></a>4.守护进程</h3><h4 id="4-1-守护进程介绍"><a href="#4-1-守护进程介绍" class="headerlink" title="4.1 守护进程介绍"></a>4.1 守护进程介绍</h4><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立控制终端并且周期性地执行某种任务或等待处理某些发生的时间。一般采用以d结尾的名字。</p>
<p>守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离终端是为了避免进程被任何终端产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在Linux中，每一个系统用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个字段，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。</p>
<p>Linux的大多数服务器就是用守护进程实现的。比如，Internet服务器，web服务器，http等。</p>
<h4 id="4-2-守护进程模型"><a href="#4-2-守护进程模型" class="headerlink" title="4.2 守护进程模型"></a>4.2 守护进程模型</h4><p>1）创建子进程，父进程退出（必须）</p>
<ul>
<li>所有工作在子进程中进行形式上脱离了控制终端</li>
</ul>
<p>2）在子进程中创建新会话（必须）</p>
<ul>
<li>setsid()函数</li>
<li>使子进程完全独立出来，脱离控制</li>
</ul>
<p>3）改变当前目录为根目录（不是必须）</p>
<ul>
<li>chdir()函数</li>
<li>防止占用可卸载的文件系统</li>
<li>也可以换成其它路径</li>
</ul>
<p>4）重设文件权限掩码（不是必须）</p>
<ul>
<li>umask() 函数</li>
<li>防止继承的文件创建屏蔽字拒绝某些权限</li>
<li>增加守护进程灵活性</li>
</ul>
<p>5）关闭文件描述符（不是必须）</p>
<ul>
<li>继承的打开文件不会用到，浪费系统资源，无法卸载</li>
</ul>
<p>6）开始执行守护进程核心工作（必须）</p>
<ul>
<li>守护进程退出处理程序模型</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//1.创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在子进程中创建新会话</span></span><br><span class="line">    pid = setsid();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.改变当前工作目录</span></span><br><span class="line">    ret = chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.重设文件权限掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.关闭文件描述符</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.开始执行进程核心工作</span></span><br><span class="line">    <span class="comment">//要求每隔一秒种向txt文件插入时间</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        system(<span class="string">&quot;date &gt;&gt; /home/pi/time.txt&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-线程简介"><a href="#5-线程简介" class="headerlink" title="5.线程简介"></a>5.线程简介</h3><h4 id="5-1-线程概念"><a href="#5-1-线程概念" class="headerlink" title="5.1 线程概念"></a>5.1 线程概念</h4><p>在许多经典的操作系统教科书中，总是把进程定义为程序的执行实例，它并不执行什么，只是维护引用程序所需的各种资源，而线程则是真正的执行实体。</p>
<p>所以，线程是轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。</p>
<p>为了让进程完成一定的工作，进程必须至少包含一个线程。</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0.png"></p>
<p>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统，操作系统会以进程为单位，分配系统资源，所以我们也说：<strong>进程是CPU分配资源的最小单位。</strong></p>
<p>线程存在与进程当中（进程可以认为是线程的容器），是操作系统调度执行的最小单位。说通俗点，线程就是干活的。</p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运动活动，进程是系统进程资源分配和调度的一个独立单位。</p>
<p>线程是进程的一个实体，是CPU调度和分配的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其它的线程共享进程所拥有的全部资源。</p>
<p>如果说进程是一个资源管家，负责从主人哪里要资源的话，那么线程就是干活的苦力。一个管家必须完成一项工作，就需要最少一个苦力，也就是说，一个进程最少包含一个线程，也可以包含多个线程。苦力要干活，就需要依托于管家，所以说一个线程，必须属于某个进程。</p>
<p>进程有自己的地址空间，线程使用进程的地址空间，也就是说，进程里的资源，线程都是有权访问的，比如说堆，栈，静态存储区。</p>
<blockquote>
<p>进程是操作系统分配资源的最小单位</p>
<p>线程是操作系统调度的最小单位</p>
</blockquote>
<h4 id="5-2-线程函数列表安装"><a href="#5-2-线程函数列表安装" class="headerlink" title="5.2 线程函数列表安装"></a>5.2 线程函数列表安装</h4><p>命令：</p>
<blockquote>
<p>sudo apt-get install manpages-posix-posix-dev</p>
</blockquote>
<p>【说明】manpages-posix-posix-dev 包含POSIX的header files 和calls的用法</p>
<p>查看：</p>
<blockquote>
<p>man -k pthread</p>
</blockquote>
<h4 id="5-3-NPTL"><a href="#5-3-NPTL" class="headerlink" title="5.3 NPTL"></a>5.3 NPTL</h4><p>当linux最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调用度的实体。这个调用创建了调用进程（calling process）的一个拷贝，这个拷贝与调用进程共享系统的地址空间。LinuxThreads 项目使用这个调用来完全在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程同步原语方面都存在问题。另外，这个线程模式也不符合POSIX的要求。</p>
<p>要改进LinuxThreads，非常明显我们需要内核的支持，并且需要重写线程库。有两个相互竞争的项目开始来满足这些要求。一个包括IBM的开发人员的团队开展了NGPT项目。同时，Red Hat 的一些开发人员开展了NPTL项目。NGPT在2003年中期被放弃了，把这个领域完全留给了NPTL。</p>
<p>NPTL或称为Native POSIX Thread Library，是Linux线程的一个新实现，它克服了LinuxThreads的缺陷，同时也符合POSIX的需求。与LinuxThreads相比，它在性能和稳定性方面都提供了重大的改进。</p>
<p>查看当前pthread库版本：getconf GNU_LIBPTHREAD_VERSION</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC.png"></p>
<h4 id="5-4-线程的特点"><a href="#5-4-线程的特点" class="headerlink" title="5.4 线程的特点"></a>5.4 线程的特点</h4><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进制机制实现出了线程的概念。</p>
<p>因此在这类系统中，进程和线程关系密切：</p>
<p>1）线程是轻量级进程（light-weight process），也有PCB，创建线程使用的底层函数和进程一样，都是clone。</p>
<p>2）从内核里看进程和线程是一样的，都有各自不同的PCB。</p>
<p>3）进程可以蜕变成线程</p>
<p>4）在Linux下，线程是最小的执行单位；进程是最小的分配资源单位</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9.png"></p>
<p>查看指定进程的LWP号：</p>
<blockquote>
<p>ps -Lf pid</p>
</blockquote>
<p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone。</p>
<ul>
<li>如果复制对方的地址空间，那么就产出一个“线程”。</li>
<li>如果共享对方的地址空间，就会产生一个“线程”</li>
</ul>
<p>Linux内核是不区分进程和线程的，只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p>
<h4 id="5-5-线程共享资源"><a href="#5-5-线程共享资源" class="headerlink" title="5.5 线程共享资源"></a>5.5 线程共享资源</h4><p>1）文件描述符表</p>
<p>2）每种信号的处理方式</p>
<p>3）当前工作目录</p>
<p>4）用户ID和组ID</p>
<p>内存地址空间（.test&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库）</p>
<h4 id="5-6-线程非共享资源"><a href="#5-6-线程非共享资源" class="headerlink" title="5.6 线程非共享资源"></a>5.6 线程非共享资源</h4><p>1）线程id</p>
<p>2）处理器现场和栈指针（内核栈）</p>
<p>3）独立的栈空间（用户空间栈）</p>
<p>4）errno变量</p>
<p>5）信号屏蔽字</p>
<p>6）调用优先级</p>
<h4 id="5-7-线程的优缺点"><a href="#5-7-线程的优缺点" class="headerlink" title="5.7 线程的优缺点"></a>5.7 线程的优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>提高程序并发性</li>
<li>开销小</li>
<li>数据通讯、共享数据方便</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>库函数，不稳定</li>
<li>调试、编写困难、gdb不支持</li>
<li>对信号支持不好</li>
</ul>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p>
<h3 id="6-线程常用操作"><a href="#6-线程常用操作" class="headerlink" title="6.线程常用操作"></a>6.线程常用操作</h3><h4 id="6-1-线程号"><a href="#6-1-线程号" class="headerlink" title="6.1 线程号"></a>6.1 线程号</h4><p>就像每个进程都有一个进程号一样，每个线程也有一个线程号。进程号在整个系统中是唯一的，但线程号不同，线程号只在它所属的进程环境中有效。</p>
<p>进程号用 pid_t 数据类型表示，是一个非负整数。线程号则用 pthread_t 数据类型来表示，Linux 使用无符号长整型表示。</p>
<p>有的系统在实现pthread_t 的时候，用一个结构体来表示，所以在可移植的操作系统实现不能把它做为整数处理。</p>
<p>pthread_self函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取线程号。</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    调用线程的线程ID。</span><br></pre></td></tr></table></figure>

<p>因为pthread_self这个函数是一个第三方库，所以在编译的时候需要链接一下外部的动态库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-pthread</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pt;</span><br><span class="line">    pt = pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, pt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pthread_equal函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line">功能:</span><br><span class="line">    判断线程号t1和t2是否相等。为了方便移植，尽量使用函数来比较</span><br><span class="line">参数:</span><br><span class="line">    t1，t2:待判断的线程号。</span><br><span class="line">返回值：</span><br><span class="line">     相等：非<span class="number">0</span></span><br><span class="line">     不相等：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pt;</span><br><span class="line">    pt = pthread_self();</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(pt, pthread_self()))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个线程号相等\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个线程号不相等\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-线程的创建"><a href="#6-2-线程的创建" class="headerlink" title="6.2 线程的创建"></a>6.2 线程的创建</h4><p>pthread_create函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthred_create</span><span class="params">(<span class="type">pthread_t</span>* thread, <span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* (*start_routine)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个线程</span><br><span class="line">参数：</span><br><span class="line">    thread：线程标识符地址。</span><br><span class="line">    attr：线程属性结构体地址，通常设置为<span class="literal">NULL</span>。</span><br><span class="line">    start_routine：线程函数的入口地址。</span><br><span class="line">    arg：传入线程函数的参数。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p> 在一个线程中调用pthread_create()创建新的线程后，当前进程从pthread_create()返回继续在下执行，而新的线程所执行的代码由我们传给pthread_create()的函数指针start_routine决定。</p>
<p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以先用strerror()把错误码转换成错误信息再打印。</p>
<p>实例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* agv)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新的线程执行任务 tid: %lu\n 传入的参数为:%d\n&quot;</span>, pthread_self(), (<span class="type">int</span>)(<span class="type">long</span>)agv); <span class="comment">//这里因为是void*类型，直接转换为int长度不够，先让它变成long，然后再转换为int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//打印错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread... tid:%lu\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按任意键结束\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-3-线程资源回收"><a href="#6-3-线程资源回收" class="headerlink" title="6.3 线程资源回收"></a>6.3 线程资源回收</h4><p>pthread_join函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span>** retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待线程结束（此函数会阻塞），并回收线程资源，类似于进程的 wait() 函数，如果线程已经结束，那么该函数会立刻返回。</span><br><span class="line">参数：</span><br><span class="line">    thread：被等待的线程号。</span><br><span class="line">    retval：用来储存线程退出状态的指针地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0x03</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span>* retp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, &amp;retp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;retp:%p\n&quot;</span>, retp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;man thread exit...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程不同的方式终止，通过pthread_join得到的终止状态是不同的，总结如下：</p>
<p>1）如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</p>
<p>2）如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED</p>
<p>3）如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</p>
<h4 id="6-4-线程连写"><a href="#6-4-线程连写" class="headerlink" title="6.4 线程连写"></a>6.4 线程连写</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现线程的连写</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1执行的函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);	<span class="comment">//刷新缓冲区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ((<span class="type">char</span>*)arg)[i]);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret1 = <span class="number">-1</span>, ret2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1 = <span class="number">-1</span>, tid2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arr1[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">//创建两个进程</span></span><br><span class="line">    ret1 = pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun, (<span class="type">void</span>*)arr1);</span><br><span class="line">    <span class="keyword">if</span> (ret1 != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程1创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret2 = pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun, (<span class="type">void</span>*)arr2);</span><br><span class="line">    <span class="keyword">if</span> (ret2 != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程2创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-5-线程分离"><a href="#6-5-线程分离" class="headerlink" title="6.5 线程分离"></a>6.5 线程分离</h4><p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获得它的状态为止。但是线程也可以被置为detach（分离）状态，这样的线程一旦终止就立刻回收它所有资源，而不保留终止状态。</p>
<p>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
<p>pthread_detach函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    使调用线程与当前进程分离，分离后不代表此线程不依赖于当前进程，线程分离的目的是将线程资源的回收工作交给系统自动来完成，也就是说当被分离的线程结束之后，系统会自动回收它的资源。所以，此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    thread：线程号</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="6-6-线程退出"><a href="#6-6-线程退出" class="headerlink" title="6.6 线程退出"></a>6.6 线程退出</h4><p>在进程中我们可以调用exit函数或_exit函数来结束进程，在一个线程中我们可以通过以下三种在不中断整个进程的情况下停止它的控制流。</p>
<ul>
<li>线程从执行函数中返回</li>
<li>线程调用pthread_exit退出线程</li>
<li>线程可以被同一进程中的其它线程取消。</li>
</ul>
<p>pthread_exit函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    退出调用线程。一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源不会释放。</span><br><span class="line">参数：</span><br><span class="line">    retval：存储线程退出状态的指针</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread:%d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分离进程失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按任意键继续...&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-7-线程取消"><a href="#6-7-线程取消" class="headerlink" title="6.7 线程取消"></a>6.7 线程取消</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">thread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    杀死(取消)线程</span><br><span class="line">参数：</span><br><span class="line">    thread：目标线程ID</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：出错编号</span><br></pre></td></tr></table></figure>

<p>注意：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某一个取消点（检查点）。</p>
<p>类似于玩游戏存档，必须到达指定的场所（存档点）才能存储进度</p>
<p>杀死线程也不是立刻就能完成，必须要到达取消点。</p>
<p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write…执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。</p>
<p>可粗略认为一个系统调用（进入内核）即为一个取消点</p>
<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_detach is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    ret = pthread_cancel(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_cancel is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子线程被取消\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-线程属性（了解）"><a href="#7-线程属性（了解）" class="headerlink" title="7.线程属性（了解）"></a>7.线程属性（了解）</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><p>Linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。</p>
<p>如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> etachstate;	<span class="comment">//线程分离状态</span></span><br><span class="line">    <span class="type">int</span> schedpolicy; <span class="comment">//线程调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">schedparam</span>;</span> <span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched; <span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="type">int</span> scope; <span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="type">size_t</span> guardsize; <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="type">int</span> stackadd_set; <span class="comment">//线程的栈设置</span></span><br><span class="line">    <span class="type">void</span>* stackaddr;  <span class="comment">//线程栈的位置</span></span><br><span class="line">    <span class="type">size_t</span> stacksize; <span class="comment">//线程栈的大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>

<p>主要结构体成员：</p>
<p>1）线程分离状态</p>
<p>2）线程栈大小（默认平均分配）</p>
<p>3）线程栈警戒缓冲区大小（位于栈末尾）</p>
<p>4）线程栈最低地址</p>
<p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。之后须用pthread_attr_destroy函数来释放资源。</p>
<p>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and paraneters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p>
<h4 id="7-2-线程属性初始化和销毁"><a href="#7-2-线程属性初始化和销毁" class="headerlink" title="7.2 线程属性初始化和销毁"></a>7.2 线程属性初始化和销毁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span>* attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化线程属性函数，注意：应先初始化线程属性，再pthread_create创建线程</span><br><span class="line">参数：</span><br><span class="line">    attr：线程属性结构体</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span>* attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁线程属性所占用的资源函数</span><br><span class="line">参数：</span><br><span class="line">    attr：线程属性结构体</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br></pre></td></tr></table></figure>

<h4 id="7-3-线程分离状态"><a href="#7-3-线程分离状态" class="headerlink" title="7.3 线程分离状态"></a>7.3 线程分离状态</h4><p>线程的分离状态决定一个线程以什么样的方式来终止自己。</p>
<ul>
<li>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</li>
<li>分离状态：分离状态没有被其它的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</li>
</ul>
<p>相关函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line">功能：设置线程分离状态</span><br><span class="line">参数：</span><br><span class="line">    attr：已初始化的线程属性</span><br><span class="line">    detachstate：分离状态</span><br><span class="line">        PTHREAD_CREATE_DETACHED（分离状态）</span><br><span class="line">        PTHREAD_CREATE_JOINABLE（非分离状态）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">int</span>* detachstate)</span>;</span><br><span class="line">功能：获得线程分离状态</span><br><span class="line">参数：</span><br><span class="line">    attr：已初始化的线程属性</span><br><span class="line">    detachstate：分离状态</span><br><span class="line">        PTHREAD_CREATE_DETACHED（分离状态）</span><br><span class="line">        PTHREAD _CREATE_JOINABLE（非分离状态）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其它的线程使用，这样调用pthread_create的线程就得到了错误的线程号。</p>
<p>要避免这种情况可以采用一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会，留出足够的时间让函数pthread_create返回。</p>
<p>设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p>
<h4 id="7-4-线程栈地址"><a href="#7-4-线程栈地址" class="headerlink" title="7.4 线程栈地址"></a>7.4 线程栈地址</h4><p>POSIX.1定义了两个常量来检查系统是否支持栈属性：</p>
<ul>
<li>_POSIX_THREAD_ATTR_STACKADDR</li>
<li>_POSIX_THREAD_ATTR_STACKSIZE</li>
</ul>
<p>也可以给sysconf函数传递来进行检测：</p>
<ul>
<li>_SC_THREAD_ATTR_STACKADDR</li>
<li>_SC_THREAD_ATTR_STACKSIZE</li>
</ul>
<p>当进程栈地址空间不够时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过pthread_attr_setstack和pthread_attr_getstack两个函数分配设置和获取线程的栈地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* stackaddr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line">功能：设置线程的栈地址</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stackaddr：内存首地址</span><br><span class="line">    stacksize：返回线程的堆栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstack</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>** stackaddr, <span class="type">size_t</span>* stacksize)</span>;</span><br><span class="line">功能：获取线程的栈地址</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stackaddr：返回获取的栈地址</span><br><span class="line">    stacksize：返回获取的栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br></pre></td></tr></table></figure>

<h4 id="7-5-线程栈大小"><a href="#7-5-线程栈大小" class="headerlink" title="7.5 线程栈大小"></a>7.5 线程栈大小</h4><p>当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用，但线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line">功能：设置线程的大小</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stacksize：线程的堆栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">size_t</span>* stacksize)</span>;</span><br><span class="line">功能：获取线程的栈大小</span><br><span class="line">参数：</span><br><span class="line">    attr：指向一个线程属性的指针</span><br><span class="line">    stacksize：返回线程的堆栈大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：错误号</span><br></pre></td></tr></table></figure>

<h4 id="7-6-线程使用注意事项"><a href="#7-6-线程使用注意事项" class="headerlink" title="7.6 线程使用注意事项"></a>7.6 线程使用注意事项</h4><p>1）主线程退出其它线程不退出，主线程应该调用pthread_exit</p>
<p>2）避免僵尸线程</p>
<p>​	a）pthread_join</p>
<p>​	b）pthread_detach</p>
<p>​	c）pthread_create指定分离属性</p>
<p>​	被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值；</p>
<p>3）malloc和mmap申请的内存可以被其它线程释放</p>
<p>4）应避免在多线程模型中调用fork，除非马上exec，子进程中只有调用fork的线程存在，其它线程在子进程中均pthread_exit</p>
<p>5）信号的复杂语义很难和多线程共享，应避免在多线程中引用信号机制。</p>
<h2 id="十、线程同步"><a href="#十、线程同步" class="headerlink" title="十、线程同步"></a>十、线程同步</h2><h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1.互斥锁"></a>1.互斥锁</h3><h4 id="1-1-同步与互斥概述"><a href="#1-1-同步与互斥概述" class="headerlink" title="1.1 同步与互斥概述"></a>1.1 同步与互斥概述</h4><p>现代操作系统基本上都是多任务操作系统，即同时有大量可调度实体在运行。在多任务操作系统中，同时运行的多个任务可能：</p>
<ul>
<li>都需要访问&#x2F;使用同一种资源</li>
<li>多任务之间有依赖关系，某个任务的运行依赖于另一个任务</li>
</ul>
<p>这两种情形是多任务编程中遇到的最基本问题，也是多任务编程中的核心问题，同步和互斥就是用于解决这两个问题的。</p>
<p>**互斥：**是指散步在不同任务之间的若干程序片段，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之间的任意程序片段，只能等到该任务完成这个程序片段后才可以运行。最基本的场景就是：一个公共资源同一时间只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</p>
<p>**同步：**是指散步在不同任务之间的若干程序片段，它们的运行必须严格按照规定的某种先后顺序来运行，这种先后顺序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后顺序运行。比如A任务的运行依赖于B任务产生的数据。</p>
<p>虽然，同步是一种更为复杂的互斥锁，互斥是两个任务之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但它是必须要按照某种次序来运行相应的线程（也是一种互斥），因此互斥具有唯一性和排它性，但互斥并不限制任务的运行顺序，即任务是无序的，而同步任务之间则有顺序关系</p>
<h4 id="1-2-为什么需要互斥锁"><a href="#1-2-为什么需要互斥锁" class="headerlink" title="1.2 为什么需要互斥锁"></a>1.2 为什么需要互斥锁</h4><p>在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。这个过程有点类似于公司部门里，使用打印机打印东西的同时（还没打印完），别人刚好也在此时此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。</p>
<p>下面用程序来模拟一下这个过程，线程一需要打印“hello”，线程二需要答应“word：，不加任何处理的话，打印出来的内容会混乱</p>
<p>测试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *((<span class="type">char</span>*)argv + i));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arr1[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr1);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr2);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，打印机是有做处理的，我在打印着的时候别人是不允许打印的，只有等待我打印结束后别人才允许打印。这个过程有点类似于，把打印机放在一个房间里，给这个房间安把锁，这个锁默认是打开的。当A需要打印时，它先过来检查这把锁有没有锁着，没有的话就进去，同时上锁在房间里打印，而这时B也需要打印，B同时先检查锁，发现锁是锁住的，它就在门口等，当A打印结束后，他会开锁出来，这时B才进去上锁打印。</p>
<h4 id="1-3-互斥锁Mutex介绍"><a href="#1-3-互斥锁Mutex介绍" class="headerlink" title="1.3 互斥锁Mutex介绍"></a>1.3 互斥锁Mutex介绍</h4><p>在线程里也有这么一把锁：互斥锁（mutex），也叫互斥量，互斥锁是一种简单的加锁方式来控制对共享资源的访问，互斥锁只有两种状态，即<strong>加锁</strong>（lock）和<strong>解锁</strong>（unlock）。</p>
<p>互斥锁的操作流程如下：</p>
<p>1）在访问共享资源后临界区域前，对互斥锁进行加锁。</p>
<p>2）在访问完成后释放互斥锁导上的锁</p>
<p>3）对互斥锁进行加锁后，任何其它企图再次对互斥锁加锁的线程将会阻塞，直到锁被释放。</p>
<p>互斥锁的数据类型是pthread_mutex_t</p>
<p>安装对应帮助手册：</p>
<blockquote>
<p>sudo apt-get install manpages-posix-dev</p>
</blockquote>
<h4 id="1-4-pthread-mutex-init函数"><a href="#1-4-pthread-mutex-init函数" class="headerlink" title="1.4 pthread_mutex_init函数"></a>1.4 pthread_mutex_init函数</h4><p>初始化互斥锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个互斥锁</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址，类型是 <span class="type">pthread_mutex_t</span></span><br><span class="line">    attr：设置互斥量的属性，通常可采用默认属性，即可将attr设为<span class="literal">NULL</span>。</span><br><span class="line">    可以使用宏PTHREAD_MUTEX_INITIALIZER静态初始化互斥锁，比如：<span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">这种方法等价于使用 <span class="literal">NULL</span> 指定的 attr 参数调用 pthread_mutex_init() 来完成动态初始化，不同之处在</span><br></pre></td></tr></table></figure>

<blockquote>
<p>restrict，C语言中的一种限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外的所有其它直接或间接的方式修改该对象的内容</p>
</blockquote>
<h4 id="1-5-pthread-mutex-destroy函数"><a href="#1-5-pthread-mutex-destroy函数" class="headerlink" title="1.5 pthread_mutex_destroy函数"></a>1.5 pthread_mutex_destroy函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁指定的一个互斥锁，互斥锁在使用完毕后，必须要对互斥锁进行销毁，以释放资源</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="1-6-pthread-mutex-lock函数"><a href="#1-6-pthread-mutex-lock函数" class="headerlink" title="1.6 pthread_mutex_lock函数"></a>1.6 pthread_mutex_lock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对互斥锁上锁，若互斥锁已经上锁，则调用者阻塞，直到互斥锁解锁后再上锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">调用该函数时，若互斥锁未加锁，则上锁，返回<span class="number">0</span>；</span><br><span class="line">若互斥锁已加锁，则函数直接返回失败，即EBUSY</span><br></pre></td></tr></table></figure>

<h4 id="1-7-pthread-mutex-unlock函数"><a href="#1-7-pthread-mutex-unlock函数" class="headerlink" title="1.7 pthread_mutex_unlock函数"></a>1.7 pthread_mutex_unlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对指定的互斥锁解锁</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="1-8-测试程序"><a href="#1-8-测试程序" class="headerlink" title="1.8 测试程序"></a>1.8 测试程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">-1</span>;</span><br><span class="line">    ret = pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *((<span class="type">char</span>*)argv + i));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> arr1[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr1);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, fun, (<span class="type">void</span>*)arr2);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-9-死锁（DeadLock）"><a href="#1-9-死锁（DeadLock）" class="headerlink" title="1.9 死锁（DeadLock）"></a>1.9 死锁（DeadLock）</h4><p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E6%AD%BB%E9%94%81.png"></p>
<p><strong>1）什么是死锁</strong></p>
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通讯造成的一种阻塞的现象。若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁。</p>
<p><strong>2）死锁引起的原因</strong></p>
<ul>
<li>竞争不可抢占资源引起死锁</li>
</ul>
<p>​	也就是我们说的第一种情况，而这都在等待对方占有的不可抢占的资源</p>
<ul>
<li>竞争可消耗资源引起死锁</li>
</ul>
<p>​	有p1，p2，p3三个进程，p1向p2发送消息并接收p3发送的消息，p2向p3发送消息并接收p1的消息，p3向p1发送消息并接收p2的消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，这就造成了死锁。</p>
<ul>
<li>进程推进顺序不当引起死锁</li>
</ul>
<p>​	有进程p1，p2，都需要资源A，B，本来可以p1运行A—&gt;p1运行B—&gt;p2运行A—&gt;p2运行B，但是顺序换了，p1运行A时p2运行B，容易发生第一种死锁。互相抢占资源。</p>
<p><strong>3）死锁的必要条件</strong></p>
<ul>
<li>互斥条件</li>
</ul>
<p>某资源只能被一个进程使用，其它进程请求该资源时，只能等待，直到资源使用完毕后释放资源</p>
<ul>
<li>请求和保持条件</li>
</ul>
<p>程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其它进程占用，自己占用资源却保持不放。</p>
<ul>
<li>不可抢占条件</li>
</ul>
<p>进程已获得的资源没有使用完，不能被抢占</p>
<ul>
<li>循环等待条件</li>
</ul>
<p>必然存在一个循环链</p>
<p><strong>4）处理死锁的思路</strong></p>
<p>预防死锁</p>
<p>​	破坏死锁的四个必要条件中的一个或多个来预防死锁</p>
<p>避免死锁</p>
<p>​	和预防死锁的区别就是，在资源动态分配过程中，用某种方式防止系统进入不安全的状态</p>
<p>检查死锁</p>
<p>​	运行时出现死锁，能及时发现死锁，把程序解脱出来</p>
<p>解除死锁</p>
<p>​	发生死锁后，解脱进程，通常撤销进程，回收资源，再分配给正处于阻塞状态的进程</p>
<p><strong>5）预防死锁的方法</strong></p>
<p><strong>破坏请求和保持条件</strong></p>
<p>协议1：</p>
<p>所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求了，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在闲置的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生</p>
<p>协议2：</p>
<p>允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来，然后再请求新的资源</p>
<p><strong>破坏不可抢占条件</strong></p>
<p>当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请</p>
<p><strong>破坏循环等待条件</strong></p>
<p>对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放系统和更高序列号的资源后才能申请低序号的资源。多个同类资源必须一起请求</p>
<p>死锁程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义互斥变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex1;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程1请求1号资源成功...\n&quot;</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程1请求2号资源成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程2请求2号资源成功...\n&quot;</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程2请求1号资源成功...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1 = <span class="number">-1</span>, tid2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//初始化锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, fun1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, fun2, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭进程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//摧毁资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex1);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-读写锁"><a href="#2-读写锁" class="headerlink" title="2.读写锁"></a>2.读写锁</h3><h4 id="2-1-读写锁概述"><a href="#2-1-读写锁概述" class="headerlink" title="2.1 读写锁概述"></a>2.1 读写锁概述</h4><p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取整个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。</p>
<p>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了<strong>读写锁</strong>来实现。</p>
<p>读写锁的特点如下：</p>
<p>1）如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。<br>2）如果有其它线程写数据，则其它线程都不允许读、写操作</p>
<p>读写锁分为读锁和写锁，规则如下：</p>
<p>1）如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁</p>
<p>2）如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁。</p>
<p>POSIX定义的读写锁的数据类型是pthread_rwlock_t</p>
<h4 id="2-2-pthread-rwlock-init函数"><a href="#2-2-pthread-rwlock-init函数" class="headerlink" title="2.2 pthread_rwlock_init函数"></a>2.2 pthread_rwlock_init函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span>* <span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用来初始化rwlock所指向的读写锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock：指向要初始化的读写指针</span><br><span class="line">    attr：读写锁的属性指针。如果attr为<span class="literal">NULL</span>则会使用默认的属性初始化读写锁，否则使用指定的attr初始化读写锁</span><br><span class="line">    可以使用宏PTHREAD_RWLOCK_INITIALIZER静态初始化读写锁，比如：</span><br><span class="line">    <span class="type">pthread_rwlock_t</span> my_rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line">    这种方法等价于使用<span class="literal">NULL</span>指定的attr参数调用pthread_rwlock_init()来完成动态初始化，不同之处在于PTHREAD_RWLOCK_INITIALIZER宏不进行错误检查</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，读写锁的状态将成为已初始化和已解锁</span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="2-3-pthread-rwlock-destroy函数"><a href="#2-3-pthread-rwlock-destroy函数" class="headerlink" title="2.3 pthread_rwlock_destroy函数"></a>2.3 pthread_rwlock_destroy函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用于摧毁一个读写锁，并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init()自动申请的资源）。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="2-4-pthread-rwlock-rdlock函数"><a href="#2-4-pthread-rwlock-rdlock函数" class="headerlink" title="2.4 pthread_rwlock_rdlock函数"></a>2.4 pthread_rwlock_rdlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    以阻塞方式在读写锁上获取读锁（读锁定）</span><br><span class="line">    如果没有写者持有该锁，并且写者阻塞在该锁上，则调用线程会获取读锁</span><br><span class="line">    如果调用线程未获取读锁，则它将阻塞直到它获取了该锁。一个线程可以在一个读写锁上多次执行读锁定。</span><br><span class="line">    线程可以成功调用 pthread_rwlock_rdlock()函数n次，但是之后该线程必须调用 pthread_rwlock_unlock() 函数n次才能解除锁定</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">用于尝试以非阻塞的方式来在读写锁上获取读锁</span><br><span class="line">如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则立即失败返回。</span><br></pre></td></tr></table></figure>

<h4 id="2-5-pthread-rwlock-wrlock函数"><a href="#2-5-pthread-rwlock-wrlock函数" class="headerlink" title="2.5 pthread_rwlock_wrlock函数"></a>2.5 pthread_rwlock_wrlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    在读写锁上获取写锁（写锁定）</span><br><span class="line">    如果没有写者持有该锁，并且没有写者读者持有该锁，则调用线程会获取写锁</span><br><span class="line">    如果调用线程未获取写锁，则它将阻塞直到它获取了该锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">用于尝试以非阻塞的方式来在读写锁上获取写锁</span><br><span class="line">如果有任何的读者或者写者持有该锁，则立即失败返回</span><br></pre></td></tr></table></figure>

<h4 id="2-6-pthread-rwlock-unlock函数"><a href="#2-6-pthread-rwlock-unlock函数" class="headerlink" title="2.6 pthread_rwlock_unlock函数"></a>2.6 pthread_rwlock_unlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    无论是读锁或者写锁，都可以通过此函数解锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="2-7-测试程序"><a href="#2-7-测试程序" class="headerlink" title="2.7 测试程序"></a>2.7 测试程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读写锁对象</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读锁的函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">read_fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//添加读锁</span></span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程%d正在读num:%d\n&quot;</span>, (<span class="type">int</span>)(<span class="type">long</span>)argv, num);</span><br><span class="line">        <span class="comment">//随机休眠1-3秒</span></span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写锁的函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">write_fun</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程%d正在读num:%d\n&quot;</span>, (<span class="type">int</span>)(<span class="type">long</span>)argv, num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">//随机休眠1-3秒</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">6</span>];</span><br><span class="line">    <span class="comment">//随机数种子</span></span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化读写锁</span></span><br><span class="line">    ret = pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_rwlock_init is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建6个进程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//读数据</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;read_fun, (<span class="type">void</span>*)(<span class="type">long</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;write_fun, (<span class="type">void</span>*)(<span class="type">long</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3.条件变量"></a>3.条件变量</h3><h4 id="3-1-条件变量概述"><a href="#3-1-条件变量概述" class="headerlink" title="3.1 条件变量概述"></a>3.1 条件变量概述</h4><p>在互斥锁不同，条件变量是用来等待而不是用来上锁的，<strong>条件变量本身不是锁！</strong></p>
<p>条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</p>
<p>条件变量的两个动作：</p>
<ul>
<li>条件不满，阻塞线程</li>
<li>当条件满足，通知阻塞的线程开始工作</li>
</ul>
<p>条件变量的类型：pthread_cond_t。</p>
<h4 id="3-2-pthread-cond-init函数"><a href="#3-2-pthread-cond-init函数" class="headerlink" title="3.2 pthread_cond_init函数"></a>3.2 pthread_cond_init函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#Include &lt;pthread.h&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* <span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针。</span><br><span class="line">    attr：条件变量属性，通常为默认值，传<span class="literal">NULL</span>即可</span><br><span class="line">        也可以使用静态初始化的方法，初始化条件变量：</span><br><span class="line">        <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h4 id="3-3-pthread-cond-destroy函数"><a href="#3-3-pthread-cond-destroy函数" class="headerlink" title="3.3 pthread_cond_destroy函数"></a>3.3 pthread_cond_destroy函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    摧毁一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h4 id="3-4-pthread-cond-wait函数"><a href="#3-4-pthread-cond-wait函数" class="headerlink" title="3.4 pthread_cond_wait函数"></a>3.4 pthread_cond_wait函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    阻塞等待一个条件变量</span><br><span class="line">    a）阻塞等待条件变量cond（参<span class="number">1</span>）满足</span><br><span class="line">    b）释放已掌握的互斥锁（解锁互斥量）相当于 pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        a）b）两步为一个原子操作</span><br><span class="line">    c）当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁 pthread_mutex_lock(&amp;mutex);</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec* <span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line">功能：</span><br><span class="line">    限时等待一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">    abstime：绝对时间</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<p>abstime补充说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>&#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;<span class="comment">//秒</span></span><br><span class="line">    <span class="type">long</span> tv_nsec;<span class="comment">//纳秒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);<span class="comment">//获取当前的时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span><span class="comment">//定义timespec结构体变量t</span></span><br><span class="line">t.tv_sec = cur + <span class="number">1</span>;<span class="comment">//定义1秒</span></span><br><span class="line">pthread_cond_timedwait(&amp;cond, &amp;t);</span><br></pre></td></tr></table></figure>

<h4 id="3-5-pthread-cond-signal函数"><a href="#3-5-pthread-cond-signal函数" class="headerlink" title="3.5 pthread_cond_signal函数"></a>3.5 pthread_cond_signal函数</h4><p>唤醒至阻塞在条件变量上的线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒全部阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<h4 id="3-6-生产者消费者条件变量模型"><a href="#3-6-生产者消费者条件变量模型" class="headerlink" title="3.6 生产者消费者条件变量模型"></a>3.6 生产者消费者条件变量模型</h4><p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法</p>
<p>假设有两个线程，一个模拟生产者的行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">//互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//创建一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pnew</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        <span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc is error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点初始化</span></span><br><span class="line">        pnew-&gt;data = random() % <span class="number">100</span>;</span><br><span class="line">        pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者正在生产%d\n&quot;</span>, pnew-&gt;data);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        <span class="comment">//随机休眠</span></span><br><span class="line">        sleep(random()%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pTemp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pTemp = head;</span><br><span class="line">            head = pTemp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在消费:%d\n&quot;</span>, pTemp-&gt;data);</span><br><span class="line">            <span class="built_in">free</span>(pTemp);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化互斥量</span></span><br><span class="line">    ret = pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_init is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//条件变量初始化</span></span><br><span class="line">    ret = pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_cond_init is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="comment">//摧毁互斥量</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-条件变量的优缺点"><a href="#3-7-条件变量的优缺点" class="headerlink" title="3.7 条件变量的优缺点"></a>3.7 条件变量的优缺点</h4><p>相较于mutex而言，条件变量可以减少竞争。</p>
<p>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。</p>
<p>有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p>
<h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4.信号量"></a>4.信号量</h3><h4 id="4-1-信号量概述"><a href="#4-1-信号量概述" class="headerlink" title="4.1 信号量概述"></a>4.1 信号量概述</h4><p>信号量广泛用于进程或进程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问</p>
<p>编程时可以根据操作信号量的结果判断是否对公共资源具有访问权限，当信号量值大于0时，则可以访问，负责将阻塞</p>
<p>PV原语是对信号量的操作，一次P操作使信号量减1，一次V操作使信号量加1</p>
<p>信号量主要用于进程或线程间的同步和异步两种典型情况</p>
<p>信号量数据类型为：sem_t</p>
<p>信号量用于互斥</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BA%92%E6%96%A5.png"></p>
<p>信号量用于同步：</p>
<p><img src="https://gitee.com/Mr_zhang_yu_ge/puillimage/raw/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5.png"></p>
<h4 id="4-2-sem-init函数"><a href="#4-2-sem-init函数" class="headerlink" title="4.2 sem_init函数"></a>4.2 sem_init函数</h4><p>初始化信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个信号量并初始化它的值。一个无名信号量在被使用前必须先初始化</span><br><span class="line">参数：</span><br><span class="line">    sem: 信号量的地址</span><br><span class="line">    pshared: 等于<span class="number">0</span>，信号量在线程间同步（常用）；不等于<span class="number">0</span>，信号量在线程间共享。</span><br><span class="line">    value: 信号量的初始值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-sem-destroy函数"><a href="#4-3-sem-destroy函数" class="headerlink" title="4.3 sem_destroy函数"></a>4.3 sem_destroy函数</h4><p>销毁信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">功能；</span><br><span class="line">    删除sem标识的信号量</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-4-信号量P操作（减1）"><a href="#4-4-信号量P操作（减1）" class="headerlink" title="4.4 信号量P操作（减1）"></a>4.4 信号量P操作（减1）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值减<span class="number">1</span>，操作前，先检查信号量（sem）的值是否为<span class="number">0</span>，若信号量为<span class="number">0</span>，此函数会阻塞，直到信号量大于<span class="number">0</span>时才进行减<span class="number">1</span>操作</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">以非阻塞的方式来对信号量进行减<span class="number">1</span>操作</span><br><span class="line">若操作前，信号量的值等于<span class="number">0</span>，则对信号量的操作失败，函数立即返回</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">const</span> <span class="keyword">struct</span> timespec* abs_timeout)</span>;</span><br><span class="line">限时尝试将信号量的值减<span class="number">1</span></span><br><span class="line">abs_timeout：绝对时间</span><br></pre></td></tr></table></figure>

<p>abs_timeout补充说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>&#123;</span></span><br><span class="line">  <span class="type">time_t</span> tv_sec;	<span class="comment">//秒</span></span><br><span class="line">  <span class="type">long</span> tv_nsec;		<span class="comment">//纳秒  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);	<span class="comment">//获取当前的时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span>	<span class="comment">//定义timespec结构体变量t</span></span><br><span class="line">t.tv_sec = cur + <span class="number">1</span>;	<span class="comment">//定时1秒</span></span><br><span class="line">sem_timedwait(&amp;cond, &amp;t);</span><br></pre></td></tr></table></figure>

<h4 id="4-5-信号量V操作（加1）"><a href="#4-5-信号量V操作（加1）" class="headerlink" title="4.5 信号量V操作（加1）"></a>4.5 信号量V操作（加1）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span>* sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值加<span class="number">1</span>并发出信号唤醒等待线程（ sem_wait()）。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-6-获取信号量的值"><a href="#4-6-获取信号量的值" class="headerlink" title="4.6 获取信号量的值"></a>4.6 获取信号量的值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span>* sval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取sem标识的信号量的值，保存在sval中</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量地址</span><br><span class="line">    sval：保存信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="4-7-示例程序"><a href="#4-7-示例程序" class="headerlink" title="4.7 示例程序"></a>4.7 示例程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//占用后P操作</span></span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放后执行V操作</span></span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    sem_init(&amp;sem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//释放线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-消费者模式更改"><a href="#4-8-消费者模式更改" class="headerlink" title="4.8 消费者模式更改"></a>4.8 消费者模式更改</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//创建一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pnew</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        <span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc is error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点初始化</span></span><br><span class="line">        pnew-&gt;data = random() % <span class="number">100</span>;</span><br><span class="line">        pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者正在生产%d\n&quot;</span>, pnew-&gt;data);</span><br><span class="line">        sem_post(&amp;sem_consumer);</span><br><span class="line">        sem_wait(&amp;sem_bearer);</span><br><span class="line">        <span class="comment">//随机休眠</span></span><br><span class="line">        sleep(random()%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pTemp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pTemp = head;</span><br><span class="line">            head = pTemp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在消费:%d\n&quot;</span>, pTemp-&gt;data);</span><br><span class="line">            <span class="built_in">free</span>(pTemp);</span><br><span class="line">            sem_post(&amp;sem_bearer);</span><br><span class="line">            sem_wait(&amp;sem_consumer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    sem_init(&amp;sem_bearer, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    sem_init(&amp;sem_consumer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem_bearer);</span><br><span class="line">    sem_destroy(&amp;sem_consumer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-9-多信号量生产者模式"><a href="#4-9-多信号量生产者模式" class="headerlink" title="4.9 多信号量生产者模式"></a>4.9 多信号量生产者模式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//创建一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pnew</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        <span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc is error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点初始化</span></span><br><span class="line">        pnew-&gt;data = random() % <span class="number">100</span>;</span><br><span class="line">        pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者正在生产%d\n&quot;</span>, pnew-&gt;data);</span><br><span class="line">        sem_post(&amp;sem_consumer);</span><br><span class="line">        sem_wait(&amp;sem_bearer);</span><br><span class="line">        <span class="comment">//随机休眠</span></span><br><span class="line">        sleep(random()%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>* argv)</span>&#123;</span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pTemp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pTemp = head;</span><br><span class="line">            head = pTemp-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在消费:%d\n&quot;</span>, pTemp-&gt;data);</span><br><span class="line">            <span class="built_in">free</span>(pTemp);</span><br><span class="line">            sem_post(&amp;sem_bearer);</span><br><span class="line">            sem_wait(&amp;sem_consumer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">6</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>, i;</span><br><span class="line">    <span class="type">sem_t</span> sem_bearer, sem_consumer;</span><br><span class="line">    srand(getpid());</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    sem_init(&amp;sem_bearer, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    sem_init(&amp;sem_consumer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建子线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pthread_create is error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem_bearer);</span><br><span class="line">    sem_destroy(&amp;sem_consumer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>puill
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://www.puill.xin/2025/01/17/3011135ba729/" title="Linux系统编程">http://www.puill.xin/2025/01/17/3011135ba729/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/01/16/9db92f684b04/" rel="prev" title="C语言进阶">
                  <i class="fa fa-angle-left"></i> C语言进阶
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/01/17/5f463418ae32/" rel="next" title="Linux网络编程">
                  Linux网络编程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">puill</span>
  </div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
--><div>
<!--添加网站运行时间-->
<span>小破站已经在风雨中度过了</span>
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    function createtime() {
        const startTime = '01/10/2025 00:00:00',
            start = new Date(startTime)
        let mill = new Date() - start,
            seconds = Math.floor(mill / 1000),
            mins = Math.floor(seconds / 60),
            hours = Math.floor(mins / 60),
            days = Math.floor(hours / 24)
        const time = {
            seconds: seconds - mins * 60,
            mins: mins - hours * 60,
            hours: hours - days * 24,
        }
        for (const k in time) {
            time[k] = `${time[k]}`.padStart(2, '0')
        }
        document.getElementById("timeDate").innerHTML = ` ${days} 天`
        document.getElementById("times").innerHTML = ` ${time.hours} 小时 ${time.mins} 分 ${time.seconds} 秒`
    }
    setInterval(createtime, 500)
</script>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
